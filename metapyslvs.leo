<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="http://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20231202195600.1"><vh>@settings</vh>
<v t="leo.20231202195600.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="leo.20231202195600.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="leo.20231205082558.1"><vh>About</vh>
<v t="leo.20231205091145.1"><vh>qtpy</vh></v>
<v t="leo.20231205092018.1"><vh>PMKS, plus and MotionGen</vh></v>
<v t="leo.20231205092846.1"><vh>MeKin2D</vh></v>
</v>
<v t="leo.20231202195533.2"><vh>py importer</vh></v>
<v t="leo.20231205083732.1"><vh>pyx importer</vh></v>
<v t="leo.20231205084737.1"><vh>py</vh>
<v t="leo.20231205084737.2"><vh>@path Y:/tmp/metapyslvs/</vh>
<v t="leo.20231205084737.3"><vh>@path Pyslvs-UI</vh>
<v t="leo.20231205084738.1"><vh>@path pyslvs_ui</vh>
<v t="leo.20231205084738.2"><vh>@@clean qt_patch.py</vh>
<v t="leo.20231205084738.3"><vh>class QABCMeta</vh></v>
</v>
<v t="leo.20231205084738.4"><vh>@@clean __init__.py</vh></v>
<v t="leo.20231205084738.5"><vh>@@clean __main__.py</vh>
<v t="leo.20231205084738.6"><vh>main</vh></v>
</v>
<v t="leo.20231205084738.7"><vh>@path entities</vh>
<v t="leo.20231205084738.8"><vh>@@clean edit_link.py</vh>
<v t="leo.20231205084738.9"><vh>class EditLinkDialog</vh>
<v t="leo.20231205084738.10"><vh>EditLinkDialog.__init__</vh></v>
<v t="leo.20231205084738.11"><vh>EditLinkDialog.__is_ok</vh></v>
<v t="leo.20231205084738.12"><vh>EditLinkDialog.__legal_name</vh></v>
<v t="leo.20231205084738.13"><vh>EditLinkDialog.__point_item</vh></v>
<v t="leo.20231205084738.14"><vh>EditLinkDialog.__set_name</vh></v>
<v t="leo.20231205084738.15"><vh>EditLinkDialog.__set_color</vh></v>
<v t="leo.20231205084738.16"><vh>EditLinkDialog.__set_rgb</vh></v>
<v t="leo.20231205084738.17"><vh>EditLinkDialog.__add_selected</vh></v>
<v t="leo.20231205084738.18"><vh>EditLinkDialog.__add_no_selected</vh></v>
</v>
</v>
<v t="leo.20231205084738.19"><vh>@@clean edit_link_ui.py</vh>
<v t="leo.20231205084738.20"><vh>class Ui_Dialog</vh>
<v t="leo.20231205084738.21"><vh>Ui_Dialog.setupUi</vh></v>
<v t="leo.20231205084738.22"><vh>Ui_Dialog.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084738.23"><vh>@@clean edit_point.py</vh>
<v t="leo.20231205084738.24"><vh>class EditPointDialog</vh>
<v t="leo.20231205084738.25"><vh>EditPointDialog.__init__</vh></v>
<v t="leo.20231205084738.26"><vh>EditPointDialog.__link_item</vh></v>
<v t="leo.20231205084738.27"><vh>EditPointDialog.__set_name</vh></v>
<v t="leo.20231205084738.28"><vh>EditPointDialog.__set_color</vh></v>
<v t="leo.20231205084738.29"><vh>EditPointDialog.__set_rgb</vh></v>
<v t="leo.20231205084738.30"><vh>EditPointDialog.__check_angle</vh></v>
<v t="leo.20231205084738.31"><vh>EditPointDialog.__add_selected</vh></v>
<v t="leo.20231205084738.32"><vh>EditPointDialog.__add_no_selected</vh></v>
<v t="leo.20231205084738.33"><vh>EditPointDialog.__relocate</vh></v>
</v>
</v>
<v t="leo.20231205084738.34"><vh>@@clean edit_point_ui.py</vh>
<v t="leo.20231205084738.35"><vh>class Ui_Dialog</vh>
<v t="leo.20231205084738.36"><vh>Ui_Dialog.setupUi</vh></v>
<v t="leo.20231205084738.37"><vh>Ui_Dialog.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084738.38"><vh>@@clean relocate_point.py</vh>
<v t="leo.20231205084738.39"><vh>class RelocateDialog</vh>
<v t="leo.20231205084738.40"><vh>RelocateDialog.__init__</vh></v>
<v t="leo.20231205084738.41"><vh>RelocateDialog.__set_pos</vh></v>
<v t="leo.20231205084738.42"><vh>RelocateDialog.__is_ok</vh></v>
<v t="leo.20231205084738.43"><vh>RelocateDialog.get_x</vh></v>
<v t="leo.20231205084738.44"><vh>RelocateDialog.get_y</vh></v>
</v>
</v>
<v t="leo.20231205084738.45"><vh>@@clean relocate_point_ui.py</vh>
<v t="leo.20231205084738.46"><vh>class Ui_Dialog</vh>
<v t="leo.20231205084738.47"><vh>Ui_Dialog.setupUi</vh></v>
<v t="leo.20231205084738.48"><vh>Ui_Dialog.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084738.49"><vh>@@clean utility.py</vh>
<v t="leo.20231205084738.50"><vh>set_custom_color</vh></v>
<v t="leo.20231205084738.51"><vh>add_custom_color</vh></v>
</v>
<v t="leo.20231205084738.52"><vh>@@clean __init__.py</vh></v>
</v>
<v t="leo.20231205084738.53"><vh>@path graphics</vh>
<v t="leo.20231205084738.54"><vh>@@clean canvas.py</vh>
<v t="leo.20231205084738.55"><vh>convex_hull</vh></v>
<v t="leo.20231205084738.56"><vh>convex_hull</vh></v>
<v t="leo.20231205084738.57"><vh>convex_hull</vh>
<v t="leo.20231205084738.58"><vh>cmp</vh></v>
<v t="leo.20231205084738.59"><vh>turn</vh></v>
<v t="leo.20231205084738.60"><vh>keep_left</vh></v>
</v>
<v t="leo.20231205084738.61"><vh>class RangeDetector</vh>
<v t="leo.20231205084738.62"><vh>RangeDetector.__call__</vh></v>
</v>
<v t="leo.20231205084738.63"><vh>class _PathOption</vh></v>
<v t="leo.20231205084738.64"><vh>class _TickMark</vh></v>
<v t="leo.20231205084738.65"><vh>class BaseCanvas</vh>
<v t="leo.20231205084738.66"><vh>BaseCanvas.__init__</vh></v>
<v t="leo.20231205084738.67"><vh>BaseCanvas.switch_grab</vh></v>
<v t="leo.20231205084738.68"><vh>BaseCanvas.zoom_factor</vh></v>
<v t="leo.20231205084738.69"><vh>BaseCanvas.paintEvent</vh></v>
<v t="leo.20231205084738.70"><vh>BaseCanvas.draw_circle</vh></v>
<v t="leo.20231205084738.71"><vh>BaseCanvas.draw_point</vh></v>
<v t="leo.20231205084738.72"><vh>BaseCanvas.draw_ranges</vh></v>
<v t="leo.20231205084738.73"><vh>BaseCanvas.draw_target_path</vh></v>
<v t="leo.20231205084738.74"><vh>BaseCanvas.draw_arrow</vh></v>
<v t="leo.20231205084738.75"><vh>BaseCanvas.draw_curve</vh></v>
<v t="leo.20231205084738.76"><vh>BaseCanvas.draw_dot</vh></v>
<v t="leo.20231205084738.77"><vh>BaseCanvas.solution_polygon</vh></v>
<v t="leo.20231205084738.78"><vh>BaseCanvas.draw_solution</vh></v>
<v t="leo.20231205084738.79"><vh>BaseCanvas.set_show_ticks</vh></v>
<v t="leo.20231205084738.80"><vh>BaseCanvas.set_monochrome_mode</vh></v>
</v>
<v t="leo.20231205084738.81"><vh>class AnimationCanvas</vh>
<v t="leo.20231205084738.82"><vh>AnimationCanvas.__init__</vh></v>
<v t="leo.20231205084738.83"><vh>AnimationCanvas.__zoom_to_fit_size</vh></v>
<v t="leo.20231205084738.84"><vh>AnimationCanvas.paintEvent</vh></v>
<v t="leo.20231205084738.85"><vh>AnimationCanvas.mouseMoveEvent</vh></v>
</v>
<v t="leo.20231205084738.86"><vh>class PreviewCanvas</vh>
<v t="leo.20231205084738.87"><vh>PreviewCanvas.__init__</vh></v>
<v t="leo.20231205084738.88"><vh>PreviewCanvas.clear</vh></v>
<v t="leo.20231205084738.89"><vh>PreviewCanvas.paintEvent</vh></v>
<v t="leo.20231205084738.90"><vh>PreviewCanvas.__zoom_to_fit_limit</vh></v>
<v t="leo.20231205084738.91"><vh>PreviewCanvas.set_graph</vh></v>
<v t="leo.20231205084738.92"><vh>PreviewCanvas.set_grounded</vh></v>
<v t="leo.20231205084738.93"><vh>PreviewCanvas.set_driver</vh></v>
<v t="leo.20231205084738.94"><vh>PreviewCanvas.set_target</vh></v>
<v t="leo.20231205084738.95"><vh>PreviewCanvas.set_status</vh></v>
<v t="leo.20231205084738.96"><vh>PreviewCanvas.get_status</vh></v>
<v t="leo.20231205084738.97"><vh>PreviewCanvas.grounded_detect</vh></v>
<v t="leo.20231205084738.98"><vh>PreviewCanvas.from_profile</vh></v>
<v t="leo.20231205084738.99"><vh>PreviewCanvas.is_all_lock</vh></v>
<v t="leo.20231205084738.100"><vh>PreviewCanvas.distance</vh></v>
</v>
</v>
<v t="leo.20231205084738.101"><vh>@@clean chart.py</vh>
<v t="leo.20231205084738.102"><vh>class DataChart</vh>
<v t="leo.20231205084738.103"><vh>DataChart.__init__</vh></v>
<v t="leo.20231205084738.104"><vh>DataChart.ax</vh></v>
</v>
<v t="leo.20231205084738.105"><vh>class DataChartDialog</vh>
<v t="leo.20231205084738.106"><vh>DataChartDialog.__init__</vh></v>
<v t="leo.20231205084738.107"><vh>DataChartDialog.ax</vh></v>
<v t="leo.20231205084738.108"><vh>DataChartDialog.set_margin</vh></v>
</v>
</v>
<v t="leo.20231205084738.109"><vh>@@clean color.py</vh>
<v t="leo.20231205084738.110"><vh>color_qt</vh></v>
<v t="leo.20231205084738.111"><vh>color_num</vh></v>
<v t="leo.20231205084738.112"><vh>color_icon</vh></v>
<v t="leo.20231205084738.113"><vh>Target path color: (line, dot)</vh></v>
<v t="leo.20231205084738.114"><vh>target_path_style</vh></v>
</v>
<v t="leo.20231205084738.115"><vh>@@clean nx_layout.py</vh>
<v t="leo.20231205084738.116"><vh>engine_picker</vh></v>
<v t="leo.20231205084738.117"><vh>graph2icon</vh></v>
</v>
<v t="leo.20231205084738.118"><vh>@@clean path_parser.py</vh>
<v t="leo.20231205084738.119"><vh>class _Transformer</vh>
<v t="leo.20231205084738.120"><vh>_Transformer.number</vh></v>
<v t="leo.20231205084738.121"><vh>_Transformer.complex</vh></v>
<v t="leo.20231205084738.122"><vh>_Transformer.coord</vh></v>
<v t="leo.20231205084738.123"><vh>_Transformer.line</vh></v>
</v>
<v t="leo.20231205084738.124"><vh>_translator = _Transformer()</vh></v>
<v t="leo.20231205084738.125"><vh>parse_path</vh></v>
</v>
<v t="leo.20231205084738.126"><vh>@@clean __init__.py</vh></v>
</v>
<v t="leo.20231205084738.128"><vh>@path info</vh>
<v t="leo.20231205084738.129"><vh>@@clean about.py</vh>
<v t="leo.20231205084738.130"><vh>html</vh></v>
<v t="leo.20231205084738.131"><vh>_title</vh></v>
<v t="leo.20231205084738.132"><vh>_content</vh></v>
<v t="leo.20231205084738.133"><vh>_order_list</vh></v>
<v t="leo.20231205084738.134"><vh>class PyslvsAbout</vh>
<v t="leo.20231205084738.135"><vh>PyslvsAbout.__init__</vh></v>
</v>
<v t="leo.20231205084738.136"><vh>check_update</vh></v>
</v>
<v t="leo.20231205084738.137"><vh>@@clean about_ui.py</vh>
<v t="leo.20231205084738.138"><vh>class Ui_Dialog</vh>
<v t="leo.20231205084738.139"><vh>Ui_Dialog.setupUi</vh></v>
<v t="leo.20231205084738.140"><vh>Ui_Dialog.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084738.141"><vh>@@clean info.py</vh>
<v t="leo.20231205084738.142"><vh>has_module</vh></v>
<v t="leo.20231205084738.143"><vh>HAS_SLVS = has_module('python_solvespace')</vh></v>
<v t="leo.20231205084738.144"><vh>class Kernel</vh>
<v t="leo.20231205084738.145"><vh>Kernel.title</vh></v>
</v>
<v t="leo.20231205084738.146"><vh>class Arguments</vh></v>
<v t="leo.20231205084738.147"><vh>parse_args</vh></v>
</v>
<v t="leo.20231205084738.148"><vh>@@clean logging_handler.py</vh>
<v t="leo.20231205084738.149"><vh>sign_in_logger</vh></v>
<v t="leo.20231205084738.150"><vh>class _QtHandler</vh>
<v t="leo.20231205084738.151"><vh>_QtHandler.__init__</vh></v>
<v t="leo.20231205084738.152"><vh>_QtHandler.emit</vh></v>
<v t="leo.20231205084738.153"><vh>_QtHandler.close</vh></v>
</v>
<v t="leo.20231205084738.154"><vh>class XStream</vh>
<v t="leo.20231205084738.155"><vh>XStream.write</vh></v>
<v t="leo.20231205084738.156"><vh>XStream.replaced</vh></v>
<v t="leo.20231205084738.157"><vh>XStream.stdout</vh></v>
<v t="leo.20231205084738.158"><vh>XStream.back</vh></v>
</v>
</v>
<v t="leo.20231205084738.159"><vh>@@clean __init__.py</vh>
<v t="leo.20231205084738.160"><vh>size_format</vh></v>
</v>
</v>
<v t="leo.20231205084738.161"><vh>@path io</vh>
<v t="leo.20231205084738.162"><vh>@@clean dxf.py</vh>
<v t="leo.20231205084738.163"><vh>dxf_frame</vh></v>
<v t="leo.20231205084738.164"><vh>dxf_boundary</vh></v>
</v>
<v t="leo.20231205084738.165"><vh>@@clean format_editor.py</vh>
<v t="leo.20231205084738.166"><vh>class ProjectFormat</vh>
<v t="leo.20231205084738.167"><vh>ProjectFormat.format_name</vh></v>
</v>
<v t="leo.20231205084738.168"><vh>class FormatEditor</vh>
<v t="leo.20231205084738.169"><vh>FormatEditor.__init__</vh></v>
<v t="leo.20231205084738.170"><vh>FormatEditor.save_data</vh></v>
<v t="leo.20231205084738.171"><vh>FormatEditor.load_data</vh></v>
<v t="leo.20231205084738.172"><vh>FormatEditor.__process</vh></v>
<v t="leo.20231205084738.173"><vh>FormatEditor.__load_mech</vh></v>
<v t="leo.20231205084738.174"><vh>FormatEditor.__load_input</vh></v>
<v t="leo.20231205084738.175"><vh>FormatEditor.__load_storage</vh></v>
<v t="leo.20231205084738.176"><vh>FormatEditor.__load_path</vh></v>
<v t="leo.20231205084738.177"><vh>FormatEditor.__load_collection</vh></v>
<v t="leo.20231205084738.178"><vh>FormatEditor.__load_config</vh></v>
<v t="leo.20231205084738.179"><vh>FormatEditor.__load_algorithm</vh></v>
<v t="leo.20231205084738.180"><vh>FormatEditor.__load_background</vh></v>
<v t="leo.20231205084738.181"><vh>FormatEditor.__set_group</vh></v>
<v t="leo.20231205084738.182"><vh>FormatEditor.__end_group</vh></v>
<v t="leo.20231205084738.183"><vh>FormatEditor.test</vh></v>
<v t="leo.20231205084738.184"><vh>FormatEditor.save</vh></v>
<v t="leo.20231205084738.185"><vh>FormatEditor.load</vh></v>
</v>
</v>
<v t="leo.20231205084738.186"><vh>@@clean output_option.py</vh>
<v t="leo.20231205084738.187"><vh>_get_name</vh></v>
<v t="leo.20231205084738.188"><vh>class OutputDialog</vh>
<v t="leo.20231205084738.189"><vh>OutputDialog.__init__</vh></v>
<v t="leo.20231205084738.190"><vh>OutputDialog.__set_dir</vh></v>
<v t="leo.20231205084738.191"><vh>OutputDialog.__accepted</vh></v>
<v t="leo.20231205084738.192"><vh>OutputDialog.do</vh></v>
<v t="leo.20231205084738.193"><vh>OutputDialog.exist_warning</vh></v>
</v>
<v t="leo.20231205084738.194"><vh>class SlvsOutputDialog</vh>
<v t="leo.20231205084738.195"><vh>SlvsOutputDialog.__init__</vh></v>
<v t="leo.20231205084738.196"><vh>SlvsOutputDialog.do</vh></v>
</v>
<v t="leo.20231205084738.197"><vh>class DxfOutputDialog</vh>
<v t="leo.20231205084738.198"><vh>DxfOutputDialog.__init__</vh></v>
<v t="leo.20231205084738.199"><vh>DxfOutputDialog.do</vh></v>
</v>
</v>
<v t="leo.20231205084738.200"><vh>@@clean output_option_ui.py</vh>
<v t="leo.20231205084738.201"><vh>class Ui_Dialog</vh>
<v t="leo.20231205084738.202"><vh>Ui_Dialog.setupUi</vh></v>
<v t="leo.20231205084738.203"><vh>Ui_Dialog.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084738.204"><vh>@@clean overview.py</vh>
<v t="leo.20231205084738.205"><vh>class OverviewDialog</vh>
<v t="leo.20231205084738.206"><vh>OverviewDialog.__init__</vh></v>
<v t="leo.20231205084738.207"><vh>OverviewDialog.__set_item_text</vh></v>
</v>
</v>
<v t="leo.20231205084738.208"><vh>@@clean overview_ui.py</vh>
<v t="leo.20231205084738.209"><vh>class Ui_Dialog</vh>
<v t="leo.20231205084738.210"><vh>Ui_Dialog.setupUi</vh></v>
<v t="leo.20231205084738.211"><vh>Ui_Dialog.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084738.212"><vh>@@clean preferences.py</vh>
<v t="leo.20231205084738.213"><vh>class PreferencesDialog</vh>
<v t="leo.20231205084738.214"><vh>PreferencesDialog.__init__</vh></v>
<v t="leo.20231205084738.215"><vh>PreferencesDialog.__reset</vh></v>
<v t="leo.20231205084738.216"><vh>PreferencesDialog.__load_settings</vh></v>
<v t="leo.20231205084738.217"><vh>PreferencesDialog.__get_settings</vh></v>
<v t="leo.20231205084738.218"><vh>PreferencesDialog.__cancel</vh></v>
<v t="leo.20231205084738.219"><vh>PreferencesDialog.closeEvent</vh></v>
<v t="leo.20231205084738.220"><vh>PreferencesDialog.__cancel_check</vh></v>
</v>
</v>
<v t="leo.20231205084738.221"><vh>@@clean preference_ui.py</vh>
<v t="leo.20231205084738.222"><vh>class Ui_Dialog</vh>
<v t="leo.20231205084738.223"><vh>Ui_Dialog.setupUi</vh></v>
<v t="leo.20231205084738.224"><vh>Ui_Dialog.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084738.225"><vh>@@clean project.py</vh>
<v t="leo.20231205084738.226"><vh>class ProjectWidget</vh>
<v t="leo.20231205084738.227"><vh>ProjectWidget.__init__</vh></v>
<v t="leo.20231205084738.228"><vh>ProjectWidget.reset</vh></v>
<v t="leo.20231205084738.229"><vh>ProjectWidget.set_file_name</vh></v>
<v t="leo.20231205084738.230"><vh>ProjectWidget.file_name</vh></v>
<v t="leo.20231205084738.231"><vh>ProjectWidget.file_path</vh></v>
<v t="leo.20231205084738.232"><vh>ProjectWidget.base_file_name</vh></v>
<v t="leo.20231205084738.233"><vh>ProjectWidget.file_suffix</vh></v>
<v t="leo.20231205084738.234"><vh>ProjectWidget.file_exist</vh></v>
<v t="leo.20231205084738.235"><vh>ProjectWidget.set_changed</vh></v>
<v t="leo.20231205084738.236"><vh>ProjectWidget.changed</vh></v>
<v t="leo.20231205084738.237"><vh>ProjectWidget.save</vh></v>
<v t="leo.20231205084738.238"><vh>ProjectWidget.read</vh></v>
<v t="leo.20231205084738.239"><vh>ProjectWidget.load_example</vh></v>
<v t="leo.20231205084738.240"><vh>ProjectWidget.__background_choose_dir</vh></v>
<v t="leo.20231205084738.241"><vh>ProjectWidget.background_config</vh></v>
<v t="leo.20231205084738.242"><vh>ProjectWidget.set_background_config</vh></v>
<v t="leo.20231205084738.243"><vh>ProjectWidget.get_background_path</vh></v>
</v>
</v>
<v t="leo.20231205084738.244"><vh>@@clean project_pickle.py</vh>
<v t="leo.20231205084738.245"><vh>class PickleEditor</vh>
<v t="leo.20231205084738.246"><vh>PickleEditor.__init__</vh></v>
<v t="leo.20231205084738.247"><vh>PickleEditor.test</vh></v>
<v t="leo.20231205084738.248"><vh>PickleEditor.save</vh></v>
<v t="leo.20231205084738.249"><vh>PickleEditor.load</vh></v>
</v>
</v>
<v t="leo.20231205084738.250"><vh>@@clean project_ui.py</vh>
<v t="leo.20231205084738.251"><vh>class Ui_Form</vh>
<v t="leo.20231205084738.252"><vh>Ui_Form.setupUi</vh></v>
<v t="leo.20231205084738.253"><vh>Ui_Form.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084738.254"><vh>@@clean project_yaml.py</vh>
<v t="leo.20231205084738.255"><vh>class YamlEditor</vh>
<v t="leo.20231205084738.256"><vh>YamlEditor.__init__</vh></v>
<v t="leo.20231205084738.257"><vh>YamlEditor.test</vh></v>
<v t="leo.20231205084738.258"><vh>YamlEditor.save</vh></v>
<v t="leo.20231205084738.259"><vh>YamlEditor.load</vh></v>
</v>
</v>
<v t="leo.20231205084739.1"><vh>@@clean script.py</vh>
<v t="leo.20231205084739.2"><vh>class _NpImage</vh>
<v t="leo.20231205084739.3"><vh>_NpImage.__init__</vh></v>
<v t="leo.20231205084739.4"><vh>_NpImage.new_image</vh></v>
<v t="leo.20231205084739.5"><vh>_NpImage.drawrect</vh></v>
<v t="leo.20231205084739.6"><vh>_NpImage.get_qimage</vh></v>
<v t="leo.20231205084739.7"><vh>_NpImage.save</vh></v>
</v>
<v t="leo.20231205084739.8"><vh>slvs_process_script</vh></v>
<v t="leo.20231205084739.9"><vh>_expr_to_script</vh></v>
<v t="leo.20231205084739.10"><vh>class _ScriptBrowser</vh>
<v t="leo.20231205084739.11"><vh>_ScriptBrowser.__init__</vh></v>
<v t="leo.20231205084739.12"><vh>_ScriptBrowser.wheelEvent</vh></v>
</v>
<v t="leo.20231205084739.13"><vh>class ScriptDialog</vh>
<v t="leo.20231205084739.14"><vh>ScriptDialog.__init__</vh></v>
<v t="leo.20231205084739.15"><vh>ScriptDialog.__save</vh></v>
<v t="leo.20231205084739.16"><vh>ScriptDialog.__copy</vh></v>
<v t="leo.20231205084739.17"><vh>ScriptDialog.__show_qrcode</vh></v>
</v>
</v>
<v t="leo.20231205084739.18"><vh>@@clean script_ui.py</vh>
<v t="leo.20231205084739.19"><vh>class Ui_Dialog</vh>
<v t="leo.20231205084739.20"><vh>Ui_Dialog.setupUi</vh></v>
<v t="leo.20231205084739.21"><vh>Ui_Dialog.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084739.22"><vh>@@clean __init__.py</vh>
<v t="leo.20231205084739.23"><vh>str_between</vh></v>
<v t="leo.20231205084739.24"><vh>str_before</vh></v>
</v>
<v t="leo.20231205084739.25"><vh>@path slvs</vh>
<v t="leo.20231205084739.26"><vh>@@clean frame.py</vh>
<v t="leo.20231205084739.27"><vh>slvs2_frame</vh></v>
</v>
<v t="leo.20231205084739.28"><vh>@@clean part.py</vh>
<v t="leo.20231205084739.29"><vh>_by_frame</vh></v>
<v t="leo.20231205084739.30"><vh>_by_boundary</vh></v>
<v t="leo.20231205084739.31"><vh>boundary_loop</vh></v>
<v t="leo.20231205084739.32"><vh>slvs2_part</vh>
<v t="leo.20231205084739.33"><vh>add_param</vh></v>
<v t="leo.20231205084739.34"><vh>arc_coords</vh></v>
<v t="leo.20231205084739.35"><vh>add_param(frame)</vh></v>
<v t="leo.20231205084739.36"><vh>segment_processing</vh></v>
<v t="leo.20231205084739.37"><vh>segment_processing(frame, is_frame=True)</vh></v>
<v t="leo.20231205084739.38"><vh>add_circle</vh></v>
<v t="leo.20231205084739.39"><vh>add_arc</vh></v>
</v>
</v>
<v t="leo.20231205084739.40"><vh>@@clean read.py</vh>
<v t="leo.20231205084739.41"><vh>class SlvsParser</vh>
<v t="leo.20231205084739.42"><vh>SlvsParser.__init__</vh></v>
<v t="leo.20231205084739.43"><vh>SlvsParser.is_valid</vh></v>
<v t="leo.20231205084739.44"><vh>SlvsParser.get_groups</vh></v>
<v t="leo.20231205084739.45"><vh>SlvsParser.parse</vh></v>
</v>
</v>
<v t="leo.20231205084739.46"><vh>@@clean write.py</vh>
<v t="leo.20231205084739.47"><vh>_shift16</vh></v>
<v t="leo.20231205084739.48"><vh>class SlvsWriter2</vh>
<v t="leo.20231205084739.49"><vh>SlvsWriter2.__init__</vh></v>
<v t="leo.20231205084739.50"><vh>SlvsWriter2.set_group</vh></v>
<v t="leo.20231205084739.51"><vh>SlvsWriter2.set_comment_group</vh></v>
<v t="leo.20231205084739.52"><vh>SlvsWriter2.set_workplane</vh></v>
<v t="leo.20231205084739.53"><vh>SlvsWriter2.param_shift16</vh></v>
<v t="leo.20231205084739.54"><vh>SlvsWriter2.entity_shift16</vh></v>
<v t="leo.20231205084739.55"><vh>SlvsWriter2.group_origin</vh></v>
<v t="leo.20231205084739.56"><vh>SlvsWriter2.group_normal</vh></v>
<v t="leo.20231205084739.57"><vh>SlvsWriter2.param</vh></v>
<v t="leo.20231205084739.58"><vh>SlvsWriter2.param_val</vh></v>
<v t="leo.20231205084739.59"><vh>SlvsWriter2.request</vh></v>
<v t="leo.20231205084739.60"><vh>SlvsWriter2.request_workplane</vh></v>
<v t="leo.20231205084739.61"><vh>SlvsWriter2.request_line</vh></v>
<v t="leo.20231205084739.62"><vh>SlvsWriter2.request_arc</vh></v>
<v t="leo.20231205084739.63"><vh>SlvsWriter2.request_circle</vh></v>
<v t="leo.20231205084739.64"><vh>SlvsWriter2.entity_plane</vh></v>
<v t="leo.20231205084739.65"><vh>SlvsWriter2.entity_point</vh></v>
<v t="leo.20231205084739.66"><vh>SlvsWriter2.entity_normal</vh></v>
<v t="leo.20231205084739.67"><vh>SlvsWriter2.entity_normal_3d</vh></v>
<v t="leo.20231205084739.68"><vh>SlvsWriter2.entity_normal_3d_wxyz</vh></v>
<v t="leo.20231205084739.69"><vh>SlvsWriter2.entity_normal_2d</vh></v>
<v t="leo.20231205084739.70"><vh>SlvsWriter2.entity_normal_copy</vh></v>
<v t="leo.20231205084739.71"><vh>SlvsWriter2.__2d_point_line</vh></v>
<v t="leo.20231205084739.72"><vh>SlvsWriter2.entity_point_2d</vh></v>
<v t="leo.20231205084739.73"><vh>SlvsWriter2.entity_line</vh></v>
<v t="leo.20231205084739.74"><vh>SlvsWriter2.entity_arc</vh></v>
<v t="leo.20231205084739.75"><vh>SlvsWriter2.entity_circle</vh></v>
<v t="leo.20231205084739.76"><vh>SlvsWriter2.entity_distance</vh></v>
<v t="leo.20231205084739.77"><vh>SlvsWriter2.__cons_point_radius</vh></v>
<v t="leo.20231205084739.78"><vh>SlvsWriter2.constraint_point</vh></v>
<v t="leo.20231205084739.79"><vh>SlvsWriter2.constraint_equal_radius</vh></v>
<v t="leo.20231205084739.80"><vh>SlvsWriter2.constraint_grounded</vh></v>
<v t="leo.20231205084739.81"><vh>SlvsWriter2.__cons_val</vh></v>
<v t="leo.20231205084739.82"><vh>SlvsWriter2.constraint_distance</vh></v>
<v t="leo.20231205084739.83"><vh>SlvsWriter2.constraint_angle</vh></v>
<v t="leo.20231205084739.84"><vh>SlvsWriter2.constraint_diameter</vh></v>
<v t="leo.20231205084739.85"><vh>SlvsWriter2.constraint_arc_line_tangent</vh></v>
<v t="leo.20231205084739.86"><vh>SlvsWriter2.constraint_comment</vh></v>
<v t="leo.20231205084739.87"><vh>SlvsWriter2.save</vh></v>
</v>
</v>
<v t="leo.20231205084739.88"><vh>@@clean __init__.py</vh></v>
</v>
</v>
<v t="leo.20231205084739.89"><vh>@path main_window</vh>
<v t="leo.20231205084739.90"><vh>@@clean actions.py</vh>
<v t="leo.20231205084739.91"><vh>_copy_table_data</vh></v>
<v t="leo.20231205084739.92"><vh>class ActionMethodInterface</vh>
<v t="leo.20231205084739.93"><vh>ActionMethodInterface.__enable_point_context</vh>
<v t="leo.20231205084739.94"><vh>ActionMethodInterface.func</vh></v>
</v>
<v t="leo.20231205084739.95"><vh>ActionMethodInterface.__enable_link_context</vh>
<v t="leo.20231205084739.96"><vh>ActionMethodInterface.func</vh></v>
</v>
<v t="leo.20231205084739.97"><vh>ActionMethodInterface.__merge_joint</vh></v>
<v t="leo.20231205084739.98"><vh>ActionMethodInterface.__merge_link</vh></v>
<v t="leo.20231205084739.99"><vh>ActionMethodInterface.set_mouse_pos</vh></v>
<v t="leo.20231205084739.100"><vh>ActionMethodInterface.point_context_menu</vh></v>
<v t="leo.20231205084739.101"><vh>ActionMethodInterface.link_context_menu</vh></v>
<v t="leo.20231205084739.102"><vh>ActionMethodInterface.canvas_context_menu</vh></v>
<v t="leo.20231205084739.103"><vh>ActionMethodInterface.enable_mechanism_actions</vh></v>
<v t="leo.20231205084739.104"><vh>ActionMethodInterface.copy_points_table</vh></v>
<v t="leo.20231205084739.105"><vh>ActionMethodInterface.copy_links_table</vh></v>
<v t="leo.20231205084739.106"><vh>ActionMethodInterface.copy_coord</vh></v>
<v t="leo.20231205084739.107"><vh>ActionMethodInterface.__set_preference</vh></v>
<v t="leo.20231205084739.108"><vh>ActionMethodInterface.apply_preferences</vh></v>
<v t="leo.20231205084739.109"><vh>ActionMethodInterface.__set_nav_toolbar_pos</vh></v>
<v t="leo.20231205084739.110"><vh>ActionMethodInterface.__set_grid_mode</vh></v>
</v>
</v>
<v t="leo.20231205084739.111"><vh>@@clean entities.py</vh>
<v t="leo.20231205084739.112"><vh>class _ScaleDialog</vh>
<v t="leo.20231205084739.113"><vh>_ScaleDialog.__init__</vh></v>
<v t="leo.20231205084739.114"><vh>_ScaleDialog.__add_option</vh></v>
<v t="leo.20231205084739.115"><vh>_ScaleDialog.factor</vh></v>
</v>
<v t="leo.20231205084739.116"><vh>class _LinkLengthDialog</vh>
<v t="leo.20231205084739.117"><vh>_LinkLengthDialog.__init__</vh></v>
<v t="leo.20231205084739.118"><vh>_LinkLengthDialog.__set_follower</vh></v>
<v t="leo.20231205084739.119"><vh>_LinkLengthDialog.__set_length</vh></v>
<v t="leo.20231205084739.120"><vh>_LinkLengthDialog.get_leader</vh></v>
<v t="leo.20231205084739.121"><vh>_LinkLengthDialog.get_follower</vh></v>
<v t="leo.20231205084739.122"><vh>_LinkLengthDialog.get_length</vh></v>
</v>
<v t="leo.20231205084739.123"><vh>class _FourBarDialog</vh>
<v t="leo.20231205084739.124"><vh>_FourBarDialog.__init__</vh></v>
</v>
<v t="leo.20231205084739.125"><vh>class EntitiesMethodInterface</vh>
<v t="leo.20231205084739.126"><vh>EntitiesMethodInterface.__init__</vh></v>
<v t="leo.20231205084739.127"><vh>EntitiesMethodInterface.__edit_point</vh></v>
<v t="leo.20231205084739.128"><vh>EntitiesMethodInterface.__edit_link</vh></v>
<v t="leo.20231205084739.129"><vh>EntitiesMethodInterface.__get_link_serial_number</vh></v>
<v t="leo.20231205084739.130"><vh>EntitiesMethodInterface.delete_point</vh></v>
<v t="leo.20231205084739.131"><vh>EntitiesMethodInterface.delete_link</vh></v>
<v t="leo.20231205084739.132"><vh>EntitiesMethodInterface.delete_points</vh></v>
<v t="leo.20231205084739.133"><vh>EntitiesMethodInterface.delete_links</vh></v>
<v t="leo.20231205084739.134"><vh>EntitiesMethodInterface.add_point_by_pos</vh></v>
<v t="leo.20231205084739.135"><vh>EntitiesMethodInterface.add_normal_point</vh></v>
<v t="leo.20231205084739.136"><vh>EntitiesMethodInterface.add_fixed_point</vh></v>
<v t="leo.20231205084739.137"><vh>EntitiesMethodInterface.add_point</vh></v>
<v t="leo.20231205084739.138"><vh>EntitiesMethodInterface.add_points</vh></v>
<v t="leo.20231205084739.139"><vh>EntitiesMethodInterface.add_points_by_graph</vh></v>
<v t="leo.20231205084739.140"><vh>EntitiesMethodInterface.add_normal_link</vh></v>
<v t="leo.20231205084739.141"><vh>EntitiesMethodInterface.add_link</vh></v>
<v t="leo.20231205084739.142"><vh>EntitiesMethodInterface.new_point</vh></v>
<v t="leo.20231205084739.143"><vh>EntitiesMethodInterface.edit_point</vh></v>
<v t="leo.20231205084739.144"><vh>EntitiesMethodInterface.lock_points</vh></v>
<v t="leo.20231205084739.145"><vh>EntitiesMethodInterface.clone_point</vh></v>
<v t="leo.20231205084739.146"><vh>EntitiesMethodInterface.__new_fourbar</vh></v>
<v t="leo.20231205084739.147"><vh>EntitiesMethodInterface.__set_scale</vh></v>
<v t="leo.20231205084739.148"><vh>EntitiesMethodInterface.__set_link_length</vh></v>
<v t="leo.20231205084739.149"><vh>EntitiesMethodInterface.set_free_move</vh></v>
<v t="leo.20231205084739.150"><vh>EntitiesMethodInterface.new_link</vh></v>
<v t="leo.20231205084739.151"><vh>EntitiesMethodInterface.edit_link</vh></v>
<v t="leo.20231205084739.152"><vh>EntitiesMethodInterface.release_ground</vh></v>
<v t="leo.20231205084739.153"><vh>EntitiesMethodInterface.constrain_link</vh></v>
<v t="leo.20231205084739.154"><vh>EntitiesMethodInterface.delete_selected_points</vh></v>
<v t="leo.20231205084739.155"><vh>EntitiesMethodInterface.delete_selected_links</vh></v>
<v t="leo.20231205084739.156"><vh>EntitiesMethodInterface.deduce_links</vh></v>
<v t="leo.20231205084739.157"><vh>EntitiesMethodInterface.set_coords_as_current</vh></v>
<v t="leo.20231205084739.158"><vh>EntitiesMethodInterface.point_alignment</vh></v>
</v>
</v>
<v t="leo.20231205084739.159"><vh>@@clean io.py</vh>
<v t="leo.20231205084739.160"><vh>class IOMethodInterface</vh>
<v t="leo.20231205084739.161"><vh>IOMethodInterface.__v_to_slvs</vh></v>
<v t="leo.20231205084739.162"><vh>IOMethodInterface.__read_slvs</vh></v>
<v t="leo.20231205084739.163"><vh>IOMethodInterface.dragEnterEvent</vh></v>
<v t="leo.20231205084739.164"><vh>IOMethodInterface.dropEvent</vh></v>
<v t="leo.20231205084739.165"><vh>IOMethodInterface.project_no_save</vh></v>
<v t="leo.20231205084739.166"><vh>IOMethodInterface.project_saved</vh></v>
<v t="leo.20231205084739.167"><vh>IOMethodInterface.set_window_title_full_path</vh></v>
<v t="leo.20231205084739.168"><vh>IOMethodInterface.__open_url</vh></v>
<v t="leo.20231205084739.169"><vh>IOMethodInterface.__show_help</vh></v>
<v t="leo.20231205084739.170"><vh>IOMethodInterface.__show_pyslvs_com</vh></v>
<v t="leo.20231205084739.171"><vh>IOMethodInterface.__show_github</vh></v>
<v t="leo.20231205084739.172"><vh>IOMethodInterface.__show_doc</vh></v>
<v t="leo.20231205084739.173"><vh>IOMethodInterface.__about</vh></v>
<v t="leo.20231205084739.174"><vh>IOMethodInterface.__load_example</vh></v>
<v t="leo.20231205084739.175"><vh>IOMethodInterface.__new_project</vh></v>
<v t="leo.20231205084739.176"><vh>IOMethodInterface.clear</vh></v>
<v t="leo.20231205084739.177"><vh>IOMethodInterface.import_pmks_url</vh></v>
<v t="leo.20231205084739.178"><vh>IOMethodInterface.parse_expression</vh></v>
<v t="leo.20231205084739.179"><vh>IOMethodInterface.add_empty_links</vh></v>
<v t="leo.20231205084739.180"><vh>IOMethodInterface.__load_file</vh></v>
<v t="leo.20231205084739.181"><vh>IOMethodInterface.save</vh></v>
<v t="leo.20231205084739.182"><vh>IOMethodInterface.__save_as</vh></v>
<v t="leo.20231205084739.183"><vh>IOMethodInterface.__cad_export</vh></v>
<v t="leo.20231205084739.184"><vh>IOMethodInterface.export_slvs</vh></v>
<v t="leo.20231205084739.185"><vh>IOMethodInterface.export_dxf</vh></v>
<v t="leo.20231205084739.186"><vh>IOMethodInterface.export_image</vh></v>
<v t="leo.20231205084739.187"><vh>IOMethodInterface.output_to</vh></v>
<v t="leo.20231205084739.188"><vh>IOMethodInterface.input_from</vh></v>
<v t="leo.20231205084739.189"><vh>IOMethodInterface.input_from_multiple</vh></v>
<v t="leo.20231205084739.190"><vh>IOMethodInterface.save_reply_box</vh></v>
<v t="leo.20231205084739.191"><vh>IOMethodInterface.save_pmks</vh></v>
<v t="leo.20231205084739.192"><vh>IOMethodInterface.save_picture_clipboard</vh></v>
<v t="leo.20231205084739.193"><vh>IOMethodInterface.show_expr</vh></v>
<v t="leo.20231205084739.194"><vh>IOMethodInterface.py_script</vh></v>
<v t="leo.20231205084739.195"><vh>IOMethodInterface.__check_update</vh></v>
<v t="leo.20231205084739.196"><vh>IOMethodInterface.__report_issue</vh></v>
<v t="leo.20231205084739.197"><vh>IOMethodInterface.check_file_changed</vh></v>
<v t="leo.20231205084739.198"><vh>IOMethodInterface.restore_settings</vh></v>
<v t="leo.20231205084739.199"><vh>IOMethodInterface.save_settings</vh></v>
<v t="leo.20231205084739.200"><vh>IOMethodInterface.load_from_args</vh></v>
<v t="leo.20231205084739.201"><vh>IOMethodInterface.command_reload</vh></v>
<v t="leo.20231205084739.202"><vh>IOMethodInterface.show_overview</vh></v>
</v>
</v>
<v t="leo.20231205084739.203"><vh>@@clean solver.py</vh>
<v t="leo.20231205084739.204"><vh>_offset</vh></v>
<v t="leo.20231205084739.205"><vh>_slvs_solve</vh>
<v t="leo.20231205084739.206"><vh>pick_slider</vh></v>
<v t="leo.20231205084739.207"><vh>for vlink in vlinks.values():</vh></v>
<v t="leo.20231205084739.208"><vh>get_friend</vh></v>
</v>
<v t="leo.20231205084739.209"><vh>class SolverMethodInterface</vh>
<v t="leo.20231205084739.210"><vh>SolverMethodInterface.__init__</vh></v>
<v t="leo.20231205084739.211"><vh>SolverMethodInterface.get_back_position</vh></v>
<v t="leo.20231205084739.212"><vh>SolverMethodInterface.solve</vh></v>
<v t="leo.20231205084739.213"><vh>SolverMethodInterface.resolve</vh></v>
<v t="leo.20231205084739.214"><vh>SolverMethodInterface.preview_path</vh></v>
<v t="leo.20231205084739.215"><vh>SolverMethodInterface.get_graph</vh></v>
<v t="leo.20231205084739.216"><vh>SolverMethodInterface.get_configure</vh></v>
<v t="leo.20231205084739.217"><vh>SolverMethodInterface.get_triangle</vh></v>
<v t="leo.20231205084739.218"><vh>SolverMethodInterface.right_input</vh></v>
<v t="leo.20231205084739.219"><vh>SolverMethodInterface.reload_canvas</vh></v>
<v t="leo.20231205084739.220"><vh>SolverMethodInterface.dof</vh></v>
</v>
</v>
<v t="leo.20231205084739.221"><vh>@@clean storage.py</vh>
<v t="leo.20231205084739.222"><vh>class StorageMethodInterface</vh>
<v t="leo.20231205084739.223"><vh>StorageMethodInterface.__add_storage</vh></v>
<v t="leo.20231205084739.224"><vh>StorageMethodInterface.__add_current_storage</vh></v>
<v t="leo.20231205084739.225"><vh>StorageMethodInterface.__copy_storage</vh></v>
<v t="leo.20231205084739.226"><vh>StorageMethodInterface.__paste_storage</vh></v>
<v t="leo.20231205084739.227"><vh>StorageMethodInterface.ask_add_storage</vh></v>
<v t="leo.20231205084739.228"><vh>StorageMethodInterface.__delete_storage</vh></v>
<v t="leo.20231205084739.229"><vh>StorageMethodInterface.__restore_storage</vh></v>
<v t="leo.20231205084739.230"><vh>StorageMethodInterface.get_storage</vh></v>
<v t="leo.20231205084739.231"><vh>StorageMethodInterface.add_multiple_storage</vh></v>
<v t="leo.20231205084739.232"><vh>StorageMethodInterface.get_expression</vh></v>
</v>
</v>
<v t="leo.20231205084739.233"><vh>@@clean __init__.py</vh>
<v t="leo.20231205084739.234"><vh>class MainWindow</vh>
<v t="leo.20231205084739.235"><vh>MainWindow.__init__</vh></v>
<v t="leo.20231205084739.236"><vh>MainWindow.new</vh></v>
<v t="leo.20231205084739.237"><vh>MainWindow.closeEvent</vh></v>
<v t="leo.20231205084739.238"><vh>MainWindow.__set_zoom</vh></v>
<v t="leo.20231205084739.239"><vh>MainWindow.__customize_zoom</vh></v>
<v t="leo.20231205084739.240"><vh>MainWindow.__reset_zoom</vh></v>
<v t="leo.20231205084739.241"><vh>MainWindow.__set_show_dimensions</vh></v>
<v t="leo.20231205084739.242"><vh>MainWindow.__set_show_point_mark</vh></v>
<v t="leo.20231205084739.243"><vh>MainWindow.__set_curve_mode</vh></v>
<v t="leo.20231205084739.244"><vh>MainWindow.__set_show_target_path</vh></v>
<v t="leo.20231205084739.245"><vh>MainWindow.add_target_point</vh></v>
<v t="leo.20231205084739.246"><vh>MainWindow.merge_result</vh></v>
<v t="leo.20231205084739.247"><vh>MainWindow.console_connect</vh></v>
<v t="leo.20231205084739.248"><vh>MainWindow.console_disconnect</vh></v>
<v t="leo.20231205084739.249"><vh>MainWindow.__append_to_console</vh></v>
<v t="leo.20231205084739.250"><vh>MainWindow.__full_screen</vh></v>
<v t="leo.20231205084739.251"><vh>MainWindow.__about_qt</vh></v>
</v>
</v>
</v>
<v t="leo.20231205084739.252"><vh>@path synthesis</vh>
<v t="leo.20231205084739.253"><vh>@@clean thread.py</vh>
<v t="leo.20231205084739.254"><vh>class BaseThread</vh>
<v t="leo.20231205084739.255"><vh>BaseThread.__init__</vh></v>
<v t="leo.20231205084739.256"><vh>BaseThread.stop</vh></v>
</v>
</v>
<v t="leo.20231205084739.257"><vh>@@clean __init__.py</vh></v>
<v t="leo.20231205084739.258"><vh>@path collections</vh>
<v t="leo.20231205084739.259"><vh>@@clean configure_widget.py</vh>
<v t="leo.20231205084739.260"><vh>class _ConfigureCanvas</vh>
<v t="leo.20231205084739.261"><vh>_ConfigureCanvas.__init__</vh></v>
<v t="leo.20231205084739.262"><vh>_ConfigureCanvas.mousePressEvent</vh></v>
<v t="leo.20231205084739.263"><vh>_ConfigureCanvas.mouseReleaseEvent</vh></v>
<v t="leo.20231205084739.264"><vh>_ConfigureCanvas.mouseMoveEvent</vh></v>
</v>
<v t="leo.20231205084739.265"><vh>_set_warning</vh></v>
<v t="leo.20231205084739.266"><vh>class ConfigureWidget</vh>
<v t="leo.20231205084739.267"><vh>ConfigureWidget.__init__</vh></v>
<v t="leo.20231205084739.268"><vh>ConfigureWidget.add_collections</vh></v>
<v t="leo.20231205084739.269"><vh>ConfigureWidget.clear</vh></v>
<v t="leo.20231205084739.270"><vh>ConfigureWidget.__clear_panel</vh></v>
<v t="leo.20231205084739.271"><vh>ConfigureWidget.__user_clear</vh></v>
<v t="leo.20231205084739.272"><vh>ConfigureWidget.__add_collection</vh></v>
<v t="leo.20231205084739.273"><vh>ConfigureWidget.set_graph</vh></v>
<v t="leo.20231205084739.274"><vh>ConfigureWidget.__set_grounded</vh></v>
<v t="leo.20231205084739.275"><vh>ConfigureWidget.__set_driver_base</vh></v>
<v t="leo.20231205084739.276"><vh>ConfigureWidget.__add_driver</vh></v>
<v t="leo.20231205084739.277"><vh>ConfigureWidget.__del_driver</vh></v>
<v t="leo.20231205084739.278"><vh>ConfigureWidget.__update_driver</vh></v>
<v t="leo.20231205084739.279"><vh>ConfigureWidget.__set_cus_same</vh></v>
<v t="leo.20231205084739.280"><vh>ConfigureWidget.__get_current_mech</vh></v>
<v t="leo.20231205084739.281"><vh>ConfigureWidget.__from_profile</vh></v>
<v t="leo.20231205084739.282"><vh>ConfigureWidget.__set_target</vh></v>
<v t="leo.20231205084739.283"><vh>ConfigureWidget.__set_parm_bind</vh></v>
<v t="leo.20231205084739.284"><vh>ConfigureWidget.__save</vh></v>
<v t="leo.20231205084739.285"><vh>ConfigureWidget.__copy</vh></v>
</v>
</v>
<v t="leo.20231205084739.286"><vh>@@clean configure_widget_ui.py</vh>
<v t="leo.20231205084739.287"><vh>class Ui_Form</vh>
<v t="leo.20231205084739.288"><vh>Ui_Form.setupUi</vh></v>
<v t="leo.20231205084739.289"><vh>Ui_Form.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084739.290"><vh>@@clean structure_widget.py</vh>
<v t="leo.20231205084739.291"><vh>class StructureWidget</vh>
<v t="leo.20231205084739.292"><vh>StructureWidget.__init__</vh></v>
<v t="leo.20231205084739.293"><vh>StructureWidget.clear</vh></v>
<v t="leo.20231205084739.294"><vh>StructureWidget.__user_clear</vh></v>
<v t="leo.20231205084739.295"><vh>StructureWidget.__reload_atlas</vh></v>
<v t="leo.20231205084739.296"><vh>StructureWidget.__is_valid_graph</vh></v>
<v t="leo.20231205084739.297"><vh>StructureWidget.add_collection</vh></v>
<v t="leo.20231205084739.298"><vh>StructureWidget.add_collections</vh></v>
<v t="leo.20231205084739.299"><vh>StructureWidget.__add_from_edges</vh></v>
<v t="leo.20231205084739.300"><vh>StructureWidget.__add_from_files</vh></v>
<v t="leo.20231205084739.301"><vh>StructureWidget.__save_graph</vh></v>
<v t="leo.20231205084739.302"><vh>StructureWidget.__save_atlas</vh></v>
<v t="leo.20231205084739.303"><vh>StructureWidget.__save_edges</vh></v>
<v t="leo.20231205084739.304"><vh>StructureWidget.__set_selection</vh></v>
<v t="leo.20231205084739.305"><vh>StructureWidget.__clear_selection</vh></v>
<v t="leo.20231205084739.306"><vh>StructureWidget.__copy_expr</vh></v>
<v t="leo.20231205084739.307"><vh>StructureWidget.__delete_collection</vh></v>
<v t="leo.20231205084739.308"><vh>StructureWidget.__make_duplicate</vh></v>
<v t="leo.20231205084739.309"><vh>StructureWidget.__configuration</vh></v>
<v t="leo.20231205084739.310"><vh>StructureWidget.__grounded</vh></v>
<v t="leo.20231205084739.311"><vh>StructureWidget.__grounded_merge</vh></v>
</v>
</v>
<v t="leo.20231205084739.312"><vh>@@clean structure_widget_ui.py</vh>
<v t="leo.20231205084739.313"><vh>class Ui_Form</vh>
<v t="leo.20231205084739.314"><vh>Ui_Form.setupUi</vh></v>
<v t="leo.20231205084739.315"><vh>Ui_Form.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084739.316"><vh>@@clean __init__.py</vh>
<v t="leo.20231205084739.317"><vh>class Collections</vh>
<v t="leo.20231205084739.318"><vh>Collections.__init__</vh></v>
<v t="leo.20231205084739.319"><vh>Collections.clear</vh></v>
<v t="leo.20231205084739.320"><vh>Collections.collect_data</vh></v>
<v t="leo.20231205084739.321"><vh>Collections.config_data</vh></v>
</v>
</v>
<v t="leo.20231205084739.322"><vh>@path dialogs</vh>
<v t="leo.20231205084739.323"><vh>@@clean collections.py</vh>
<v t="leo.20231205084739.324"><vh>class CollectionsDialog</vh>
<v t="leo.20231205084739.325"><vh>CollectionsDialog.__init__</vh></v>
<v t="leo.20231205084739.326"><vh>CollectionsDialog.__can_open</vh></v>
<v t="leo.20231205084739.327"><vh>CollectionsDialog.__has_collection</vh></v>
<v t="leo.20231205084739.328"><vh>CollectionsDialog.__rename</vh></v>
<v t="leo.20231205084739.329"><vh>CollectionsDialog.__copy</vh></v>
<v t="leo.20231205084739.330"><vh>CollectionsDialog.__delete</vh></v>
<v t="leo.20231205084739.331"><vh>CollectionsDialog.__choose_common</vh></v>
<v t="leo.20231205084739.332"><vh>CollectionsDialog.__choose_collections</vh></v>
<v t="leo.20231205084739.333"><vh>CollectionsDialog.__from_canvas</vh></v>
<v t="leo.20231205084739.334"><vh>CollectionsDialog.__load_common</vh></v>
<v t="leo.20231205084739.335"><vh>CollectionsDialog.__load_collections</vh></v>
</v>
</v>
<v t="leo.20231205084739.336"><vh>@@clean collections_ui.py</vh>
<v t="leo.20231205084739.337"><vh>class Ui_Dialog</vh>
<v t="leo.20231205084739.338"><vh>Ui_Dialog.setupUi</vh></v>
<v t="leo.20231205084739.339"><vh>Ui_Dialog.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084739.340"><vh>@@clean customs.py</vh>
<v t="leo.20231205084739.341"><vh>class CustomsDialog</vh>
<v t="leo.20231205084739.342"><vh>CustomsDialog.__init__</vh></v>
<v t="leo.20231205084739.343"><vh>CustomsDialog.__reload_quote_choose</vh></v>
<v t="leo.20231205084739.344"><vh>CustomsDialog.__add_cus</vh></v>
<v t="leo.20231205084739.345"><vh>CustomsDialog.__delete_cus</vh></v>
<v t="leo.20231205084739.346"><vh>CustomsDialog.__set_quote</vh></v>
<v t="leo.20231205084739.347"><vh>CustomsDialog.__set_quote_link</vh></v>
<v t="leo.20231205084739.348"><vh>CustomsDialog.__add_multi_joint</vh></v>
<v t="leo.20231205084739.349"><vh>CustomsDialog.__delete_multi_joint</vh></v>
</v>
</v>
<v t="leo.20231205084739.350"><vh>@@clean customs_ui.py</vh>
<v t="leo.20231205084739.351"><vh>class Ui_Dialog</vh>
<v t="leo.20231205084739.352"><vh>Ui_Dialog.setupUi</vh></v>
<v t="leo.20231205084739.353"><vh>Ui_Dialog.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084739.354"><vh>@@clean targets.py</vh>
<v t="leo.20231205084739.355"><vh>list_texts</vh></v>
<v t="leo.20231205084739.356"><vh>class TargetsDialog</vh>
<v t="leo.20231205084739.357"><vh>TargetsDialog.__init__</vh></v>
<v t="leo.20231205084739.358"><vh>TargetsDialog.__add</vh></v>
<v t="leo.20231205084739.359"><vh>TargetsDialog.__remove</vh></v>
<v t="leo.20231205084739.360"><vh>TargetsDialog.targets</vh></v>
</v>
</v>
<v t="leo.20231205084739.361"><vh>@@clean targets_ui.py</vh>
<v t="leo.20231205084739.362"><vh>class Ui_Dialog</vh>
<v t="leo.20231205084739.363"><vh>Ui_Dialog.setupUi</vh></v>
<v t="leo.20231205084739.364"><vh>Ui_Dialog.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084739.365"><vh>@@clean __init__.py</vh></v>
</v>
</v>
<v t="leo.20231205084739.366"><vh>@path dimensional_synthesis</vh>
<v t="leo.20231205084739.367"><vh>@@clean dimension_widget_ui.py</vh>
<v t="leo.20231205084740.1"><vh>class Ui_Form</vh>
<v t="leo.20231205084740.2"><vh>Ui_Form.setupUi</vh></v>
<v t="leo.20231205084740.3"><vh>Ui_Form.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084740.4"><vh>@@clean __init__.py</vh>
<v t="leo.20231205084740.5"><vh>class Optimizer</vh>
<v t="leo.20231205084740.6"><vh>Optimizer.__init__</vh></v>
<v t="leo.20231205084740.7"><vh>Optimizer.clear</vh></v>
<v t="leo.20231205084740.8"><vh>Optimizer.__clear_settings</vh></v>
<v t="leo.20231205084740.9"><vh>Optimizer.has_target</vh></v>
<v t="leo.20231205084740.10"><vh>Optimizer.__user_clear</vh></v>
<v t="leo.20231205084740.11"><vh>Optimizer.load_results</vh></v>
<v t="leo.20231205084740.12"><vh>Optimizer.__current_path_changed</vh></v>
<v t="leo.20231205084740.13"><vh>Optimizer.current_path</vh></v>
<v t="leo.20231205084740.14"><vh>Optimizer.__set_target</vh></v>
<v t="leo.20231205084740.15"><vh>Optimizer.clear_path</vh></v>
<v t="leo.20231205084740.16"><vh>Optimizer.__copy_path</vh></v>
<v t="leo.20231205084740.17"><vh>Optimizer.__paste_path</vh></v>
<v t="leo.20231205084740.18"><vh>Optimizer.__import_csv</vh></v>
<v t="leo.20231205084740.19"><vh>Optimizer.__read_path_from_csv</vh></v>
<v t="leo.20231205084740.20"><vh>Optimizer.__append_path</vh></v>
<v t="leo.20231205084740.21"><vh>Optimizer.__save_path</vh></v>
<v t="leo.20231205084740.22"><vh>Optimizer.__import_xlsx</vh></v>
<v t="leo.20231205084740.23"><vh>Optimizer.__adjust_path</vh></v>
<v t="leo.20231205084740.24"><vh>Optimizer.__norm_path</vh></v>
<v t="leo.20231205084740.25"><vh>Optimizer.add_point</vh></v>
<v t="leo.20231205084740.26"><vh>Optimizer.set_path</vh></v>
<v t="leo.20231205084740.27"><vh>Optimizer.set_point</vh></v>
<v t="leo.20231205084740.28"><vh>Optimizer.__move_up_point</vh></v>
<v t="leo.20231205084740.29"><vh>Optimizer.__move_down_point</vh></v>
<v t="leo.20231205084740.30"><vh>Optimizer.__delete_point</vh></v>
<v t="leo.20231205084740.31"><vh>Optimizer.__able_to_generate</vh></v>
<v t="leo.20231205084740.32"><vh>Optimizer.__synthesis</vh></v>
<v t="leo.20231205084740.33"><vh>Optimizer.__set_time</vh></v>
<v t="leo.20231205084740.34"><vh>Optimizer.__add_result</vh></v>
<v t="leo.20231205084740.35"><vh>Optimizer.__delete_result</vh></v>
<v t="leo.20231205084740.36"><vh>Optimizer.__has_result</vh></v>
<v t="leo.20231205084740.37"><vh>Optimizer.__show_result</vh></v>
<v t="leo.20231205084740.38"><vh>Optimizer.__merge_result</vh></v>
<v t="leo.20231205084740.39"><vh>Optimizer.__get_path</vh></v>
<v t="leo.20231205084740.40"><vh>Optimizer.__copy_result_text</vh></v>
<v t="leo.20231205084740.41"><vh>Optimizer.__save_profile</vh></v>
<v t="leo.20231205084740.42"><vh>Optimizer.__load_profile</vh></v>
<v t="leo.20231205084740.43"><vh>Optimizer.__set_profile</vh>
<v t="leo.20231205084740.44"><vh>Optimizer.func</vh></v>
<v t="leo.20231205084740.45"><vh>Optimizer.return func</vh></v>
<v t="leo.20231205084740.46"><vh>Optimizer.func</vh></v>
</v>
<v t="leo.20231205084740.47"><vh>Optimizer.__load_result_settings</vh></v>
<v t="leo.20231205084740.48"><vh>Optimizer.__set_algorithm_default</vh></v>
<v t="leo.20231205084740.49"><vh>Optimizer.__show_advance</vh></v>
<v t="leo.20231205084740.50"><vh>Optimizer.update_range</vh></v>
<v t="leo.20231205084740.51"><vh>Optimizer.__copy_expr</vh></v>
</v>
</v>
<v t="leo.20231205084740.52"><vh>@path dialogs</vh>
<v t="leo.20231205084740.53"><vh>@@clean chart.py</vh>
<v t="leo.20231205084740.54"><vh>class ChartDialog</vh>
<v t="leo.20231205084740.55"><vh>ChartDialog.__init__</vh></v>
<v t="leo.20231205084740.56"><vh>ChartDialog.__set_chart</vh></v>
</v>
</v>
<v t="leo.20231205084740.57"><vh>@@clean edit_path.py</vh>
<v t="leo.20231205084740.58"><vh>class EditPathDialog</vh>
<v t="leo.20231205084740.59"><vh>EditPathDialog.__init__</vh></v>
<v t="leo.20231205084740.60"><vh>EditPathDialog.__gen_fitting</vh></v>
<v t="leo.20231205084740.61"><vh>EditPathDialog.__fitting_preview</vh></v>
<v t="leo.20231205084740.62"><vh>EditPathDialog.__fitting</vh></v>
<v t="leo.20231205084740.63"><vh>EditPathDialog.__move</vh></v>
<v t="leo.20231205084740.64"><vh>EditPathDialog.__rotate</vh></v>
<v t="leo.20231205084740.65"><vh>EditPathDialog.__scale</vh></v>
</v>
</v>
<v t="leo.20231205084740.66"><vh>@@clean edit_path_ui.py</vh>
<v t="leo.20231205084740.67"><vh>class Ui_Dialog</vh>
<v t="leo.20231205084740.68"><vh>Ui_Dialog.setupUi</vh></v>
<v t="leo.20231205084740.69"><vh>Ui_Dialog.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084740.70"><vh>@@clean options.py</vh>
<v t="leo.20231205084740.71"><vh>class AlgorithmOptionDialog</vh>
<v t="leo.20231205084740.72"><vh>AlgorithmOptionDialog.__init__</vh></v>
<v t="leo.20231205084740.73"><vh>AlgorithmOptionDialog.__init_alg_table</vh></v>
<v t="leo.20231205084740.74"><vh>AlgorithmOptionDialog.__set_args</vh></v>
<v t="leo.20231205084740.75"><vh>AlgorithmOptionDialog.__reset</vh></v>
</v>
</v>
<v t="leo.20231205084740.76"><vh>@@clean options_ui.py</vh>
<v t="leo.20231205084740.77"><vh>class Ui_Dialog</vh>
<v t="leo.20231205084740.78"><vh>Ui_Dialog.setupUi</vh></v>
<v t="leo.20231205084740.79"><vh>Ui_Dialog.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084740.80"><vh>@@clean preview.py</vh>
<v t="leo.20231205084740.81"><vh>class _DynamicCanvas</vh>
<v t="leo.20231205084740.82"><vh>_DynamicCanvas.__init__</vh></v>
<v t="leo.20231205084740.83"><vh>_DynamicCanvas.paintEvent</vh></v>
<v t="leo.20231205084740.84"><vh>_DynamicCanvas.__draw_point</vh></v>
<v t="leo.20231205084740.85"><vh>_DynamicCanvas.__draw_link</vh></v>
<v t="leo.20231205084740.86"><vh>_DynamicCanvas.__draw_path</vh></v>
<v t="leo.20231205084740.87"><vh>_DynamicCanvas.__change_index</vh></v>
<v t="leo.20231205084740.88"><vh>_DynamicCanvas.get_target</vh></v>
<v t="leo.20231205084740.89"><vh>_DynamicCanvas.get_path</vh></v>
</v>
<v t="leo.20231205084740.90"><vh>class PreviewDialog</vh>
<v t="leo.20231205084740.91"><vh>PreviewDialog.__init__</vh></v>
<v t="leo.20231205084740.92"><vh>PreviewDialog.__set_mouse_pos</vh></v>
<v t="leo.20231205084740.93"><vh>PreviewDialog.__cc_plot</vh></v>
</v>
</v>
<v t="leo.20231205084740.94"><vh>@@clean preview_ui.py</vh>
<v t="leo.20231205084740.95"><vh>class Ui_Dialog</vh>
<v t="leo.20231205084740.96"><vh>Ui_Dialog.setupUi</vh></v>
<v t="leo.20231205084740.97"><vh>Ui_Dialog.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084740.98"><vh>@@clean progress.py</vh>
<v t="leo.20231205084740.99"><vh>class ProgressDialog</vh>
<v t="leo.20231205084740.100"><vh>ProgressDialog.__init__</vh></v>
<v t="leo.20231205084740.101"><vh>ProgressDialog.__set_progress</vh></v>
<v t="leo.20231205084740.102"><vh>ProgressDialog.__set_time</vh></v>
<v t="leo.20231205084740.103"><vh>ProgressDialog.__start</vh></v>
<v t="leo.20231205084740.104"><vh>ProgressDialog.__get_result</vh></v>
<v t="leo.20231205084740.105"><vh>ProgressDialog.__finish</vh></v>
<v t="leo.20231205084740.106"><vh>ProgressDialog.__interrupt</vh></v>
<v t="leo.20231205084740.107"><vh>ProgressDialog.__close_work</vh></v>
</v>
</v>
<v t="leo.20231205084740.108"><vh>@@clean progress_ui.py</vh>
<v t="leo.20231205084740.109"><vh>class Ui_Dialog</vh>
<v t="leo.20231205084740.110"><vh>Ui_Dialog.setupUi</vh></v>
<v t="leo.20231205084740.111"><vh>Ui_Dialog.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084740.112"><vh>@@clean thread.py</vh>
<v t="leo.20231205084740.113"><vh>class DimensionalThread</vh>
<v t="leo.20231205084740.114"><vh>DimensionalThread.__init__</vh></v>
<v t="leo.20231205084740.115"><vh>DimensionalThread.set_loop</vh></v>
<v t="leo.20231205084740.116"><vh>DimensionalThread.run</vh></v>
<v t="leo.20231205084740.117"><vh>DimensionalThread.__task</vh></v>
</v>
</v>
<v t="leo.20231205084740.118"><vh>@@clean __init__.py</vh></v>
</v>
</v>
<v t="leo.20231205084740.119"><vh>@path structure_synthesis</vh>
<v t="leo.20231205084740.120"><vh>@@clean structure_widget_ui.py</vh>
<v t="leo.20231205084740.121"><vh>class Ui_Form</vh>
<v t="leo.20231205084740.122"><vh>Ui_Form.setupUi</vh></v>
<v t="leo.20231205084740.123"><vh>Ui_Form.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084740.124"><vh>@@clean thread.py</vh>
<v t="leo.20231205084740.125"><vh>assortment_eval</vh></v>
<v t="leo.20231205084740.126"><vh>class LinkThread</vh>
<v t="leo.20231205084740.127"><vh>LinkThread.__init__</vh></v>
<v t="leo.20231205084740.128"><vh>LinkThread.run</vh></v>
</v>
<v t="leo.20231205084740.129"><vh>class GraphThread</vh>
<v t="leo.20231205084740.130"><vh>GraphThread.__init__</vh></v>
<v t="leo.20231205084740.131"><vh>GraphThread.run</vh></v>
</v>
</v>
<v t="leo.20231205084740.132"><vh>@@clean __init__.py</vh>
<v t="leo.20231205084740.133"><vh>class SynthesisProgressDialog</vh>
<v t="leo.20231205084740.134"><vh>SynthesisProgressDialog.__init__</vh></v>
<v t="leo.20231205084740.135"><vh>SynthesisProgressDialog.stop_func</vh></v>
</v>
<v t="leo.20231205084740.136"><vh>class StructureSynthesis</vh>
<v t="leo.20231205084740.137"><vh>StructureSynthesis.__init__</vh></v>
<v t="leo.20231205084740.138"><vh>StructureSynthesis.clear</vh></v>
<v t="leo.20231205084740.139"><vh>StructureSynthesis.__clear_assortment</vh></v>
<v t="leo.20231205084740.140"><vh>StructureSynthesis.__clear_structure_list</vh></v>
<v t="leo.20231205084740.141"><vh>StructureSynthesis.__from_mechanism</vh></v>
<v t="leo.20231205084740.142"><vh>StructureSynthesis.__adjust_structure_data</vh>
<v t="leo.20231205084740.143"><vh>StructureSynthesis.nl_func</vh></v>
<v t="leo.20231205084740.144"><vh>StructureSynthesis.is_above = n2 &gt; self.nj_input_old_value</vh></v>
<v t="leo.20231205084740.145"><vh>StructureSynthesis.nl_func</vh></v>
</v>
<v t="leo.20231205084740.146"><vh>StructureSynthesis.__number_synthesis</vh></v>
<v t="leo.20231205084740.147"><vh>StructureSynthesis.__set_time_count</vh></v>
<v t="leo.20231205084740.148"><vh>StructureSynthesis.__set_paint_time</vh></v>
<v t="leo.20231205084740.149"><vh>StructureSynthesis.__structure_synthesis</vh></v>
<v t="leo.20231205084740.150"><vh>StructureSynthesis.__structure_synthesis_all</vh></v>
<v t="leo.20231205084740.151"><vh>StructureSynthesis.__structural_combine</vh></v>
<v t="leo.20231205084740.152"><vh>StructureSynthesis.__reload_atlas</vh></v>
<v t="leo.20231205084740.153"><vh>StructureSynthesis.__draw_atlas</vh></v>
<v t="leo.20231205084740.154"><vh>StructureSynthesis.__atlas_image</vh></v>
<v t="leo.20231205084740.155"><vh>StructureSynthesis.__structure_list_context_menu</vh></v>
<v t="leo.20231205084740.156"><vh>StructureSynthesis.__copy_expr</vh></v>
<v t="leo.20231205084740.157"><vh>StructureSynthesis.__add_collection</vh></v>
<v t="leo.20231205084740.158"><vh>StructureSynthesis.__save_atlas</vh></v>
<v t="leo.20231205084740.159"><vh>StructureSynthesis.__save_atlas_ask</vh></v>
<v t="leo.20231205084740.160"><vh>StructureSynthesis.__save_edges</vh></v>
<v t="leo.20231205084740.161"><vh>StructureSynthesis.__edges2atlas</vh></v>
</v>
</v>
</v>
</v>
<v t="leo.20231205084740.162"><vh>@path widgets</vh>
<v t="leo.20231205084740.163"><vh>@@clean canvas.py</vh>
<v t="leo.20231205084740.164"><vh>class MainCanvas</vh>
<v t="leo.20231205084740.165"><vh>MainCanvas.__init__</vh></v>
<v t="leo.20231205084740.166"><vh>MainCanvas.update_canvas</vh></v>
<v t="leo.20231205084740.167"><vh>MainCanvas.set_link_width</vh></v>
<v t="leo.20231205084740.168"><vh>MainCanvas.set_path_width</vh></v>
<v t="leo.20231205084740.169"><vh>MainCanvas.set_point_mark</vh></v>
<v t="leo.20231205084740.170"><vh>MainCanvas.set_show_dimension</vh></v>
<v t="leo.20231205084740.171"><vh>MainCanvas.set_curve_mode</vh></v>
<v t="leo.20231205084740.172"><vh>MainCanvas.set_font_size</vh></v>
<v t="leo.20231205084740.173"><vh>MainCanvas.set_zoom</vh></v>
<v t="leo.20231205084740.174"><vh>MainCanvas.get_zoom</vh></v>
<v t="leo.20231205084740.175"><vh>MainCanvas.set_default_zoom</vh></v>
<v t="leo.20231205084740.176"><vh>MainCanvas.set_show_target_path</vh></v>
<v t="leo.20231205084740.177"><vh>MainCanvas.set_free_move</vh></v>
<v t="leo.20231205084740.178"><vh>MainCanvas.set_selection_radius</vh></v>
<v t="leo.20231205084740.179"><vh>MainCanvas.set_transparency</vh></v>
<v t="leo.20231205084740.180"><vh>MainCanvas.set_margin_factor</vh></v>
<v t="leo.20231205084740.181"><vh>MainCanvas.set_joint_size</vh></v>
<v t="leo.20231205084740.182"><vh>MainCanvas.set_zoom_by</vh></v>
<v t="leo.20231205084740.183"><vh>MainCanvas.set_snap</vh></v>
<v t="leo.20231205084740.184"><vh>MainCanvas.set_background</vh></v>
<v t="leo.20231205084740.185"><vh>MainCanvas.set_background_opacity</vh></v>
<v t="leo.20231205084740.186"><vh>MainCanvas.set_background_scale</vh></v>
<v t="leo.20231205084740.187"><vh>MainCanvas.set_background_offset_x</vh></v>
<v t="leo.20231205084740.188"><vh>MainCanvas.set_background_offset_y</vh></v>
<v t="leo.20231205084740.189"><vh>MainCanvas.set_selection_mode</vh></v>
<v t="leo.20231205084740.190"><vh>MainCanvas.set_selection</vh></v>
<v t="leo.20231205084740.191"><vh>MainCanvas.set_solving_path</vh></v>
<v t="leo.20231205084740.192"><vh>MainCanvas.set_path_show</vh></v>
<v t="leo.20231205084740.193"><vh>MainCanvas.update_ranges</vh></v>
<v t="leo.20231205084740.194"><vh>MainCanvas.record_start</vh></v>
<v t="leo.20231205084740.195"><vh>MainCanvas.record_path</vh></v>
<v t="leo.20231205084740.196"><vh>MainCanvas.get_record_path</vh></v>
<v t="leo.20231205084740.197"><vh>MainCanvas.adjust_link</vh></v>
<v t="leo.20231205084740.198"><vh>MainCanvas.wheelEvent</vh></v>
<v t="leo.20231205084740.199"><vh>MainCanvas.grab_no_background</vh></v>
</v>
</v>
<v t="leo.20231205084740.200"><vh>@@clean canvas_base.py</vh>
<v t="leo.20231205084740.201"><vh>class _Selector</vh>
<v t="leo.20231205084740.202"><vh>_Selector.release</vh></v>
<v t="leo.20231205084740.203"><vh>_Selector.is_close</vh></v>
<v t="leo.20231205084740.204"><vh>_Selector.in_rect</vh></v>
<v t="leo.20231205084740.205"><vh>_Selector.to_rect</vh></v>
<v t="leo.20231205084740.206"><vh>_Selector.current_selection</vh></v>
</v>
<v t="leo.20231205084740.207"><vh>class FreeMode</vh></v>
<v t="leo.20231205084740.208"><vh>class SelectMode</vh></v>
<v t="leo.20231205084740.209"><vh>class ZoomBy</vh></v>
<v t="leo.20231205084740.210"><vh>_selection_unit = {</vh></v>
<v t="leo.20231205084740.211"><vh>class MainCanvasBase</vh>
<v t="leo.20231205084740.212"><vh>MainCanvasBase.__init__</vh></v>
<v t="leo.20231205084740.213"><vh>MainCanvasBase.__draw_frame</vh></v>
<v t="leo.20231205084740.214"><vh>MainCanvasBase.__draw_point</vh></v>
<v t="leo.20231205084740.215"><vh>MainCanvasBase.__draw_link</vh></v>
<v t="leo.20231205084740.216"><vh>MainCanvasBase.__draw_path</vh></v>
<v t="leo.20231205084740.217"><vh>MainCanvasBase.__emit_free_move</vh></v>
<v t="leo.20231205084740.218"><vh>MainCanvasBase.__select_func</vh>
<v t="leo.20231205084740.219"><vh>MainCanvasBase.catch_p</vh></v>
<v t="leo.20231205084740.220"><vh>MainCanvasBase.for i, vpoint in enumerate(self.vpoints):</vh></v>
<v t="leo.20231205084740.221"><vh>MainCanvasBase.catch_l</vh></v>
<v t="leo.20231205084740.222"><vh>MainCanvasBase.for i, vl in enumerate(self.vlinks):</vh></v>
<v t="leo.20231205084740.223"><vh>MainCanvasBase.catch</vh></v>
</v>
<v t="leo.20231205084740.224"><vh>MainCanvasBase.__snap</vh></v>
<v t="leo.20231205084740.225"><vh>MainCanvasBase.__zoom_to_fit_size</vh></v>
<v t="leo.20231205084740.226"><vh>MainCanvasBase.emit_free_move_all</vh></v>
<v t="leo.20231205084740.227"><vh>MainCanvasBase.paintEvent</vh></v>
<v t="leo.20231205084740.228"><vh>MainCanvasBase.__mouse_pos</vh></v>
<v t="leo.20231205084740.229"><vh>MainCanvasBase.mousePressEvent</vh></v>
<v t="leo.20231205084740.230"><vh>MainCanvasBase.mouseDoubleClickEvent</vh></v>
<v t="leo.20231205084740.231"><vh>MainCanvasBase.mouseReleaseEvent</vh></v>
<v t="leo.20231205084740.232"><vh>MainCanvasBase.mouseMoveEvent</vh></v>
<v t="leo.20231205084740.233"><vh>MainCanvasBase.zoom_to_fit</vh></v>
<v t="leo.20231205084740.234"><vh>MainCanvasBase.update_preview_path</vh></v>
</v>
</v>
<v t="leo.20231205084740.235"><vh>@@clean main_abc.py</vh>
<v t="leo.20231205084740.236"><vh>class MainWindowABC</vh>
<v t="leo.20231205084740.237"><vh>MainWindowABC.__init__</vh></v>
<v t="leo.20231205084740.238"><vh>MainWindowABC.command_reload</vh></v>
<v t="leo.20231205084740.239"><vh>MainWindowABC.new_point</vh></v>
<v t="leo.20231205084740.240"><vh>MainWindowABC.add_normal_point</vh></v>
<v t="leo.20231205084740.241"><vh>MainWindowABC.add_fixed_point</vh></v>
<v t="leo.20231205084740.242"><vh>MainWindowABC.edit_point</vh></v>
<v t="leo.20231205084740.243"><vh>MainWindowABC.delete_selected_points</vh></v>
<v t="leo.20231205084740.244"><vh>MainWindowABC.lock_points</vh></v>
<v t="leo.20231205084740.245"><vh>MainWindowABC.new_link</vh></v>
<v t="leo.20231205084740.246"><vh>MainWindowABC.edit_link</vh></v>
<v t="leo.20231205084740.247"><vh>MainWindowABC.delete_selected_links</vh></v>
<v t="leo.20231205084740.248"><vh>MainWindowABC.deduce_links</vh></v>
<v t="leo.20231205084740.249"><vh>MainWindowABC.constrain_link</vh></v>
<v t="leo.20231205084740.250"><vh>MainWindowABC.release_ground</vh></v>
<v t="leo.20231205084740.251"><vh>MainWindowABC.add_target_point</vh></v>
<v t="leo.20231205084740.252"><vh>MainWindowABC.set_free_move</vh></v>
<v t="leo.20231205084740.253"><vh>MainWindowABC.add_point_by_pos</vh></v>
<v t="leo.20231205084740.254"><vh>MainWindowABC.set_mouse_pos</vh></v>
<v t="leo.20231205084740.255"><vh>MainWindowABC.get_back_position</vh></v>
<v t="leo.20231205084740.256"><vh>MainWindowABC.solve</vh></v>
<v t="leo.20231205084740.257"><vh>MainWindowABC.resolve</vh></v>
<v t="leo.20231205084740.258"><vh>MainWindowABC.enable_mechanism_actions</vh></v>
<v t="leo.20231205084740.259"><vh>MainWindowABC.clone_point</vh></v>
<v t="leo.20231205084740.260"><vh>MainWindowABC.copy_coord</vh></v>
<v t="leo.20231205084740.261"><vh>MainWindowABC.copy_points_table</vh></v>
<v t="leo.20231205084740.262"><vh>MainWindowABC.copy_links_table</vh></v>
<v t="leo.20231205084740.263"><vh>MainWindowABC.canvas_context_menu</vh></v>
<v t="leo.20231205084740.264"><vh>MainWindowABC.point_context_menu</vh></v>
<v t="leo.20231205084740.265"><vh>MainWindowABC.link_context_menu</vh></v>
<v t="leo.20231205084740.266"><vh>MainWindowABC.preview_path</vh></v>
<v t="leo.20231205084740.267"><vh>MainWindowABC.reload_canvas</vh></v>
<v t="leo.20231205084740.268"><vh>MainWindowABC.output_to</vh></v>
<v t="leo.20231205084740.269"><vh>MainWindowABC.right_input</vh></v>
<v t="leo.20231205084740.270"><vh>MainWindowABC.set_coords_as_current</vh></v>
<v t="leo.20231205084740.271"><vh>MainWindowABC.dof</vh></v>
<v t="leo.20231205084740.272"><vh>MainWindowABC.save_reply_box</vh></v>
<v t="leo.20231205084740.273"><vh>MainWindowABC.input_from</vh></v>
<v t="leo.20231205084740.274"><vh>MainWindowABC.input_from_multiple</vh></v>
<v t="leo.20231205084740.275"><vh>MainWindowABC.get_graph</vh></v>
<v t="leo.20231205084740.276"><vh>MainWindowABC.get_configure</vh></v>
<v t="leo.20231205084740.277"><vh>MainWindowABC.project_no_save</vh></v>
<v t="leo.20231205084740.278"><vh>MainWindowABC.project_saved</vh></v>
<v t="leo.20231205084740.279"><vh>MainWindowABC.merge_result</vh></v>
<v t="leo.20231205084740.280"><vh>MainWindowABC.check_file_changed</vh></v>
<v t="leo.20231205084740.281"><vh>MainWindowABC.get_storage</vh></v>
<v t="leo.20231205084740.282"><vh>MainWindowABC.add_empty_links</vh></v>
<v t="leo.20231205084740.283"><vh>MainWindowABC.parse_expression</vh></v>
<v t="leo.20231205084740.284"><vh>MainWindowABC.add_multiple_storage</vh></v>
<v t="leo.20231205084740.285"><vh>MainWindowABC.clear</vh></v>
<v t="leo.20231205084740.286"><vh>MainWindowABC.add_points</vh></v>
<v t="leo.20231205084740.287"><vh>MainWindowABC.add_points_by_graph</vh></v>
<v t="leo.20231205084740.288"><vh>MainWindowABC.set_window_title_full_path</vh></v>
<v t="leo.20231205084740.289"><vh>MainWindowABC.import_pmks_url</vh></v>
<v t="leo.20231205084740.290"><vh>MainWindowABC.save_picture_clipboard</vh></v>
<v t="leo.20231205084740.291"><vh>MainWindowABC.show_expr</vh></v>
<v t="leo.20231205084740.292"><vh>MainWindowABC.py_script</vh></v>
<v t="leo.20231205084740.293"><vh>MainWindowABC.export_dxf</vh></v>
<v t="leo.20231205084740.294"><vh>MainWindowABC.export_slvs</vh></v>
<v t="leo.20231205084740.295"><vh>MainWindowABC.save_pmks</vh></v>
<v t="leo.20231205084740.296"><vh>MainWindowABC.export_image</vh></v>
<v t="leo.20231205084740.297"><vh>MainWindowABC.show_overview</vh></v>
<v t="leo.20231205084740.298"><vh>MainWindowABC.new</vh></v>
<v t="leo.20231205084740.299"><vh>MainWindowABC.point_alignment</vh></v>
<v t="leo.20231205084740.300"><vh>MainWindowABC.get_expression</vh></v>
</v>
</v>
<v t="leo.20231205084740.301"><vh>@@clean main_base.py</vh>
<v t="leo.20231205084740.302"><vh>_set_actions</vh></v>
<v t="leo.20231205084740.303"><vh>class _Enable</vh></v>
<v t="leo.20231205084740.304"><vh>class _Context</vh>
<v t="leo.20231205084740.305"><vh>_Context.point_enable</vh></v>
<v t="leo.20231205084740.306"><vh>_Context.link_enable</vh></v>
<v t="leo.20231205084740.307"><vh>_Context.__getitem__</vh></v>
<v t="leo.20231205084740.308"><vh>_Context.__setitem__</vh></v>
</v>
<v t="leo.20231205084740.309"><vh>class Preferences</vh>
<v t="leo.20231205084740.310"><vh>Preferences.diff</vh></v>
<v t="leo.20231205084740.311"><vh>Preferences.reset</vh></v>
<v t="leo.20231205084740.312"><vh>Preferences.copy</vh></v>
</v>
<v t="leo.20231205084740.313"><vh>class MainWindowBase</vh>
<v t="leo.20231205084740.314"><vh>MainWindowBase.__init__</vh></v>
<v t="leo.20231205084740.315"><vh>MainWindowBase.env_path</vh></v>
<v t="leo.20231205084740.316"><vh>MainWindowBase.set_locate</vh></v>
<v t="leo.20231205084740.317"><vh>MainWindowBase.__undo_redo</vh></v>
<v t="leo.20231205084740.318"><vh>MainWindowBase.__appearance</vh></v>
<v t="leo.20231205084740.319"><vh>MainWindowBase.__alignment</vh>
<v t="leo.20231205084740.320"><vh>MainWindowBase.func</vh></v>
</v>
<v t="leo.20231205084740.321"><vh>MainWindowBase.__free_move</vh>
<v t="leo.20231205084740.322"><vh>MainWindowBase.func</vh></v>
</v>
<v t="leo.20231205084740.323"><vh>MainWindowBase.__options</vh></v>
<v t="leo.20231205084740.324"><vh>MainWindowBase.__action</vh></v>
<v t="leo.20231205084740.325"><vh>MainWindowBase.__context_menu</vh></v>
<v t="leo.20231205084740.326"><vh>MainWindowBase.__set_selection_mode</vh></v>
</v>
</v>
<v t="leo.20231205084740.327"><vh>@@clean main_ui.py</vh>
<v t="leo.20231205084740.328"><vh>class Ui_MainWindow</vh>
<v t="leo.20231205084740.329"><vh>Ui_MainWindow.setupUi</vh></v>
<v t="leo.20231205084740.330"><vh>Ui_MainWindow.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084740.331"><vh>@@clean tables.py</vh>
<v t="leo.20231205084740.332"><vh>class BaseTableWidget</vh>
<v t="leo.20231205084740.333"><vh>BaseTableWidget.__init__</vh></v>
<v t="leo.20231205084740.334"><vh>BaseTableWidget.row_text</vh></v>
<v t="leo.20231205084740.335"><vh>BaseTableWidget.effective_range</vh></v>
<v t="leo.20231205084740.336"><vh>BaseTableWidget.selected_rows</vh></v>
<v t="leo.20231205084740.337"><vh>BaseTableWidget.selectAll</vh></v>
<v t="leo.20231205084740.338"><vh>BaseTableWidget.set_selections</vh></v>
<v t="leo.20231205084740.339"><vh>BaseTableWidget.__set_selected_ranges</vh></v>
<v t="leo.20231205084740.340"><vh>BaseTableWidget.keyPressEvent</vh></v>
<v t="leo.20231205084740.341"><vh>BaseTableWidget.clear</vh></v>
<v t="leo.20231205084740.342"><vh>BaseTableWidget.clearSelection</vh></v>
</v>
<v t="leo.20231205084740.343"><vh>class PointTableWidget</vh>
<v t="leo.20231205084740.344"><vh>PointTableWidget.__init__</vh></v>
<v t="leo.20231205084740.345"><vh>PointTableWidget.edit_point</vh></v>
<v t="leo.20231205084740.346"><vh>PointTableWidget.row_data</vh></v>
<v t="leo.20231205084740.347"><vh>PointTableWidget.rename</vh></v>
<v t="leo.20231205084740.348"><vh>PointTableWidget.current_position</vh></v>
<v t="leo.20231205084740.349"><vh>PointTableWidget.update_current_position</vh></v>
<v t="leo.20231205084740.350"><vh>PointTableWidget.get_back_position</vh></v>
<v t="leo.20231205084740.351"><vh>PointTableWidget.get_links</vh></v>
<v t="leo.20231205084740.352"><vh>PointTableWidget.set_selections</vh></v>
<v t="leo.20231205084740.353"><vh>PointTableWidget.effective_range</vh></v>
<v t="leo.20231205084740.354"><vh>PointTableWidget.clearSelection</vh></v>
</v>
<v t="leo.20231205084740.355"><vh>class LinkTableWidget</vh>
<v t="leo.20231205084740.356"><vh>LinkTableWidget.__init__</vh></v>
<v t="leo.20231205084740.357"><vh>LinkTableWidget.edit_link</vh></v>
<v t="leo.20231205084740.358"><vh>LinkTableWidget.row_data</vh></v>
<v t="leo.20231205084740.359"><vh>LinkTableWidget.find_name</vh></v>
<v t="leo.20231205084740.360"><vh>LinkTableWidget.get_points</vh></v>
<v t="leo.20231205084740.361"><vh>LinkTableWidget.effective_range</vh></v>
<v t="leo.20231205084740.362"><vh>LinkTableWidget.clear</vh></v>
</v>
<v t="leo.20231205084740.363"><vh>class ExprTableWidget</vh>
<v t="leo.20231205084740.364"><vh>ExprTableWidget.__init__</vh></v>
<v t="leo.20231205084740.365"><vh>ExprTableWidget.set_expr</vh></v>
<v t="leo.20231205084740.366"><vh>ExprTableWidget.effective_range</vh></v>
<v t="leo.20231205084740.367"><vh>ExprTableWidget.clear</vh></v>
</v>
<v t="leo.20231205084740.368"><vh>class SelectionLabel</vh>
<v t="leo.20231205084740.369"><vh>SelectionLabel.__init__</vh></v>
<v t="leo.20231205084740.370"><vh>SelectionLabel.update_select_point</vh></v>
<v t="leo.20231205084740.371"><vh>SelectionLabel.update_mouse_position</vh></v>
</v>
<v t="leo.20231205084740.372"><vh>class FPSLabel</vh>
<v t="leo.20231205084740.373"><vh>FPSLabel.__init__</vh></v>
<v t="leo.20231205084740.374"><vh>FPSLabel.__update_text</vh></v>
<v t="leo.20231205084740.375"><vh>FPSLabel.update_text</vh></v>
</v>
</v>
<v t="leo.20231205084740.376"><vh>@@clean undo_redo.py</vh>
<v t="leo.20231205084740.377"><vh>_no_empty</vh></v>
<v t="leo.20231205084740.378"><vh>_args2vpoint</vh></v>
<v t="leo.20231205084740.379"><vh>_args2vlink</vh></v>
<v t="leo.20231205084740.380"><vh>class _FusedTable</vh>
<v t="leo.20231205084740.381"><vh>_FusedTable.__init__</vh></v>
</v>
<v t="leo.20231205084740.382"><vh>class AddTable</vh>
<v t="leo.20231205084740.383"><vh>AddTable.__init__</vh></v>
<v t="leo.20231205084740.384"><vh>AddTable.redo</vh></v>
<v t="leo.20231205084740.385"><vh>AddTable.undo</vh></v>
</v>
<v t="leo.20231205084740.386"><vh>class DeleteTable</vh>
<v t="leo.20231205084740.387"><vh>DeleteTable.__init__</vh></v>
<v t="leo.20231205084740.388"><vh>DeleteTable.redo</vh></v>
<v t="leo.20231205084740.389"><vh>DeleteTable.undo</vh></v>
</v>
<v t="leo.20231205084740.390"><vh>class FixSequenceNumber</vh>
<v t="leo.20231205084740.391"><vh>FixSequenceNumber.__init__</vh></v>
<v t="leo.20231205084740.392"><vh>FixSequenceNumber.redo</vh></v>
<v t="leo.20231205084740.393"><vh>FixSequenceNumber.undo</vh></v>
<v t="leo.20231205084740.394"><vh>FixSequenceNumber.__sorting</vh></v>
</v>
<v t="leo.20231205084740.395"><vh>class _EditFusedTable</vh>
<v t="leo.20231205084740.396"><vh>_EditFusedTable.__init__</vh></v>
</v>
<v t="leo.20231205084740.397"><vh>class EditPointTable</vh>
<v t="leo.20231205084740.398"><vh>EditPointTable.__init__</vh></v>
<v t="leo.20231205084740.399"><vh>EditPointTable.redo</vh></v>
<v t="leo.20231205084740.400"><vh>EditPointTable.undo</vh></v>
<v t="leo.20231205084740.401"><vh>EditPointTable.__write_links</vh></v>
<v t="leo.20231205084740.402"><vh>EditPointTable.__set_cell</vh></v>
</v>
<v t="leo.20231205084740.403"><vh>class EditLinkTable</vh>
<v t="leo.20231205084740.404"><vh>EditLinkTable.__init__</vh></v>
<v t="leo.20231205084740.405"><vh>EditLinkTable.redo</vh></v>
<v t="leo.20231205084740.406"><vh>EditLinkTable.undo</vh></v>
<v t="leo.20231205084740.407"><vh>EditLinkTable.__rename</vh></v>
<v t="leo.20231205084740.408"><vh>EditLinkTable.__write_points</vh></v>
<v t="leo.20231205084740.409"><vh>EditLinkTable.__set_cell</vh></v>
</v>
<v t="leo.20231205084740.410"><vh>class AddPath</vh>
<v t="leo.20231205084740.411"><vh>AddPath.__init__</vh></v>
<v t="leo.20231205084740.412"><vh>AddPath.redo</vh></v>
<v t="leo.20231205084740.413"><vh>AddPath.undo</vh></v>
</v>
<v t="leo.20231205084740.414"><vh>class DeletePath</vh>
<v t="leo.20231205084740.415"><vh>DeletePath.__init__</vh></v>
<v t="leo.20231205084740.416"><vh>DeletePath.redo</vh></v>
<v t="leo.20231205084740.417"><vh>DeletePath.undo</vh></v>
</v>
<v t="leo.20231205084740.418"><vh>class AddStorage</vh>
<v t="leo.20231205084740.419"><vh>AddStorage.__init__</vh></v>
<v t="leo.20231205084740.420"><vh>AddStorage.redo</vh></v>
<v t="leo.20231205084740.421"><vh>AddStorage.undo</vh></v>
</v>
<v t="leo.20231205084740.422"><vh>class DeleteStorage</vh>
<v t="leo.20231205084740.423"><vh>DeleteStorage.__init__</vh></v>
<v t="leo.20231205084740.424"><vh>DeleteStorage.redo</vh></v>
<v t="leo.20231205084740.425"><vh>DeleteStorage.undo</vh></v>
</v>
<v t="leo.20231205084740.426"><vh>class AddStorageName</vh>
<v t="leo.20231205084740.427"><vh>AddStorageName.__init__</vh></v>
<v t="leo.20231205084740.428"><vh>AddStorageName.redo</vh></v>
<v t="leo.20231205084740.429"><vh>AddStorageName.undo</vh></v>
</v>
<v t="leo.20231205084740.430"><vh>class ClearStorageName</vh>
<v t="leo.20231205084740.431"><vh>ClearStorageName.__init__</vh></v>
<v t="leo.20231205084740.432"><vh>ClearStorageName.redo</vh></v>
<v t="leo.20231205084740.433"><vh>ClearStorageName.undo</vh></v>
</v>
<v t="leo.20231205084740.434"><vh>class AddInput</vh>
<v t="leo.20231205084740.435"><vh>AddInput.__init__</vh></v>
<v t="leo.20231205084740.436"><vh>AddInput.redo</vh></v>
<v t="leo.20231205084740.437"><vh>AddInput.undo</vh></v>
</v>
<v t="leo.20231205084740.438"><vh>class DeleteInput</vh>
<v t="leo.20231205084740.439"><vh>DeleteInput.__init__</vh></v>
<v t="leo.20231205084740.440"><vh>DeleteInput.redo</vh></v>
<v t="leo.20231205084740.441"><vh>DeleteInput.undo</vh></v>
</v>
</v>
<v t="leo.20231205084740.442"><vh>@@clean __init__.py</vh></v>
<v t="leo.20231205084741.1"><vh>@path inputs</vh>
<v t="leo.20231205084741.2"><vh>@@clean animation.py</vh>
<v t="leo.20231205084741.3"><vh>class _DynamicCanvas</vh>
<v t="leo.20231205084741.4"><vh>_DynamicCanvas.__init__</vh></v>
<v t="leo.20231205084741.5"><vh>_DynamicCanvas.set_index</vh></v>
<v t="leo.20231205084741.6"><vh>_DynamicCanvas.set_factor</vh></v>
<v t="leo.20231205084741.7"><vh>_DynamicCanvas.get_vel</vh></v>
<v t="leo.20231205084741.8"><vh>_DynamicCanvas.get_acc</vh></v>
<v t="leo.20231205084741.9"><vh>_DynamicCanvas.paintEvent</vh></v>
</v>
<v t="leo.20231205084741.10"><vh>class AnimateDialog</vh>
<v t="leo.20231205084741.11"><vh>AnimateDialog.__init__</vh></v>
<v t="leo.20231205084741.12"><vh>AnimateDialog.__move_ind</vh></v>
<v t="leo.20231205084741.13"><vh>AnimateDialog.__set_pos</vh></v>
<v t="leo.20231205084741.14"><vh>AnimateDialog.__play</vh></v>
</v>
</v>
<v t="leo.20231205084741.15"><vh>@@clean inputs_ui.py</vh>
<v t="leo.20231205084741.16"><vh>class Ui_Form</vh>
<v t="leo.20231205084741.17"><vh>Ui_Form.setupUi</vh></v>
<v t="leo.20231205084741.18"><vh>Ui_Form.retranslateUi</vh></v>
</v>
</v>
<v t="leo.20231205084741.19"><vh>@@clean rotatable.py</vh>
<v t="leo.20231205084741.20"><vh>class QRotatableView</vh>
<v t="leo.20231205084741.21"><vh>QRotatableView.__init__</vh></v>
<v t="leo.20231205084741.22"><vh>QRotatableView.__value_changed</vh></v>
<v t="leo.20231205084741.23"><vh>QRotatableView.value</vh></v>
<v t="leo.20231205084741.24"><vh>QRotatableView.set_value</vh></v>
<v t="leo.20231205084741.25"><vh>QRotatableView.minimum</vh></v>
<v t="leo.20231205084741.26"><vh>QRotatableView.set_minimum</vh></v>
<v t="leo.20231205084741.27"><vh>QRotatableView.maximum</vh></v>
<v t="leo.20231205084741.28"><vh>QRotatableView.set_maximum</vh></v>
<v t="leo.20231205084741.29"><vh>QRotatableView.setEnabled</vh></v>
</v>
</v>
<v t="leo.20231205084741.30"><vh>@@clean __init__.py</vh>
<v t="leo.20231205084741.31"><vh>_no_auto_path</vh></v>
<v t="leo.20231205084741.32"><vh>_variable_int</vh></v>
<v t="leo.20231205084741.33"><vh>_fourier</vh></v>
<v t="leo.20231205084741.34"><vh>class InputsWidget</vh>
<v t="leo.20231205084741.35"><vh>InputsWidget.__init__</vh>
<v t="leo.20231205084741.36"><vh>InputsWidget.func</vh></v>
</v>
<v t="leo.20231205084741.37"><vh>InputsWidget.clear</vh></v>
<v t="leo.20231205084741.38"><vh>InputsWidget.__set_angle_mode</vh></v>
<v t="leo.20231205084741.39"><vh>InputsWidget.__set_unit_mode</vh></v>
<v t="leo.20231205084741.40"><vh>InputsWidget.paths</vh></v>
<v t="leo.20231205084741.41"><vh>InputsWidget.slider_paths</vh></v>
<v t="leo.20231205084741.42"><vh>InputsWidget.set_selection</vh></v>
<v t="leo.20231205084741.43"><vh>InputsWidget.clear_selection</vh></v>
<v t="leo.20231205084741.44"><vh>InputsWidget.__update_relate_points</vh></v>
<v t="leo.20231205084741.45"><vh>InputsWidget.__set_add_var_enabled</vh></v>
<v t="leo.20231205084741.46"><vh>InputsWidget.__add_inputs_variable</vh></v>
<v t="leo.20231205084741.47"><vh>InputsWidget.add_inputs_variables</vh></v>
<v t="leo.20231205084741.48"><vh>InputsWidget.__dial_ok</vh></v>
<v t="leo.20231205084741.49"><vh>InputsWidget.variable_excluding</vh></v>
<v t="leo.20231205084741.50"><vh>InputsWidget.remove_var</vh></v>
<v t="leo.20231205084741.51"><vh>InputsWidget.interval</vh></v>
<v t="leo.20231205084741.52"><vh>InputsWidget.input_count</vh></v>
<v t="leo.20231205084741.53"><vh>InputsWidget.input_pairs</vh></v>
<v t="leo.20231205084741.54"><vh>InputsWidget.variable_reload</vh></v>
<v t="leo.20231205084741.55"><vh>InputsWidget.__set_var</vh></v>
<v t="leo.20231205084741.56"><vh>InputsWidget.__update_var</vh></v>
<v t="leo.20231205084741.57"><vh>InputsWidget.variable_value_reset</vh></v>
<v t="leo.20231205084741.58"><vh>InputsWidget.__play</vh></v>
<v t="leo.20231205084741.59"><vh>InputsWidget.__change_index</vh></v>
<v t="leo.20231205084741.60"><vh>InputsWidget.__start_record</vh></v>
<v t="leo.20231205084741.61"><vh>InputsWidget.add_path</vh></v>
<v t="leo.20231205084741.62"><vh>InputsWidget.load_paths</vh></v>
<v t="leo.20231205084741.63"><vh>InputsWidget.__remove_path</vh></v>
<v t="leo.20231205084741.64"><vh>InputsWidget.__path_dlg</vh></v>
<v t="leo.20231205084741.65"><vh>InputsWidget.__current_path_name</vh></v>
<v t="leo.20231205084741.66"><vh>InputsWidget.__copy_path</vh></v>
<v t="leo.20231205084741.67"><vh>InputsWidget.__copy_path_data</vh></v>
<v t="leo.20231205084741.68"><vh>InputsWidget.__show_path</vh></v>
<v t="leo.20231205084741.69"><vh>InputsWidget.__show_all_path</vh></v>
<v t="leo.20231205084741.70"><vh>InputsWidget.__set_path_show</vh></v>
<v t="leo.20231205084741.71"><vh>InputsWidget.__set_path</vh></v>
<v t="leo.20231205084741.72"><vh>InputsWidget.current_path</vh></v>
<v t="leo.20231205084741.73"><vh>InputsWidget.__set_variable_priority</vh></v>
<v t="leo.20231205084741.74"><vh>InputsWidget.__animate</vh></v>
<v t="leo.20231205084741.75"><vh>InputsWidget.__plot</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="leo.20231205084741.76"><vh>@path scripts</vh>
<v t="leo.20231205084741.77"><vh>@@clean entry.py</vh></v>
<v t="leo.20231205084741.78"><vh>@@clean hook-pyslvs_ui.py</vh></v>
<v t="leo.20231205084741.79"><vh>@@clean uic.py</vh>
<v t="leo.20231205084741.80"><vh>gen_ui</vh></v>
</v>
</v>
</v>
<v t="leo.20231205084741.81"><vh>@path metaheuristics</vh>
<v t="leo.20231205084741.82"><vh>@@clean config_types.py</vh>
<v t="leo.20231205084741.83"><vh>class Setting</vh></v>
<v t="leo.20231205084741.84"><vh>class DESetting</vh></v>
<v t="leo.20231205084741.85"><vh>class RGASetting</vh></v>
<v t="leo.20231205084741.86"><vh>class PSOSetting</vh></v>
<v t="leo.20231205084741.87"><vh>class FASetting</vh></v>
<v t="leo.20231205084741.88"><vh>class TOBLSetting</vh></v>
</v>
<v t="leo.20231205084741.89"><vh>@@clean __init__.py</vh>
<v t="leo.20231205084741.90"><vh>class AlgorithmType</vh></v>
<v t="leo.20231205084741.91"><vh>_ALGORITHM: Mapping[AlgorithmType, Type[Algorithm]] = {</vh></v>
<v t="leo.20231205084741.92"><vh>algorithm</vh></v>
<v t="leo.20231205084741.93"><vh>default</vh></v>
</v>
</v>
<v t="leo.20231205084741.94"><vh>@path pyslvs</vh>
<v t="leo.20231205084741.95"><vh>@@clean setup.py</vh>
<v t="leo.20231205084741.96"><vh>class Build</vh>
<v t="leo.20231205084741.97"><vh>Build.build_extensions</vh></v>
</v>
</v>
<v t="leo.20231205084741.99"><vh>@path pyslvs</vh>
<v t="leo.20231205084741.100"><vh>@@clean collection.py</vh>
<v t="leo.20231205084741.101"><vh>class Collection</vh></v>
<v t="leo.20231205084741.102"><vh>_collection_list: Dict[str, Collection] = {</vh></v>
<v t="leo.20231205084741.103"><vh>collection_list</vh></v>
<v t="leo.20231205084741.104"><vh>all_collections</vh></v>
</v>
<v t="leo.20231205084741.105"><vh>@@clean efd.py</vh>
<v t="leo.20231205084741.106"><vh>efd_fitting</vh></v>
<v t="leo.20231205084741.107"><vh>normalize_efd</vh></v>
<v t="leo.20231205084741.108"><vh>locus</vh></v>
<v t="leo.20231205084741.109"><vh>calculate_efd</vh></v>
<v t="leo.20231205084741.110"><vh>inverse_transform</vh></v>
<v t="leo.20231205084741.111"><vh>_nyquist</vh></v>
<v t="leo.20231205084741.112"><vh>fourier_power</vh></v>
<v t="leo.20231205084741.113"><vh>rotate_contour</vh></v>
</v>
<v t="leo.20231205084741.114"><vh>@@clean example.py</vh>
<v t="leo.20231205084741.115"><vh>example_list</vh></v>
<v t="leo.20231205084741.116"><vh>all_examples</vh></v>
</v>
<v t="leo.20231205084741.117"><vh>@@clean expression_parser.py</vh>
<v t="leo.20231205084741.118"><vh>color_rgb</vh></v>
<v t="leo.20231205084741.119"><vh>class PointArgs</vh></v>
<v t="leo.20231205084741.120"><vh>class LinkArgs</vh></v>
<v t="leo.20231205084741.121"><vh>_GRAMMAR = Lark(r"""</vh></v>
<v t="leo.20231205084741.122"><vh>class _Transformer</vh>
<v t="leo.20231205084741.123"><vh>_Transformer.type</vh></v>
<v t="leo.20231205084741.124"><vh>_Transformer.name</vh></v>
<v t="leo.20231205084741.125"><vh>_Transformer.color</vh></v>
<v t="leo.20231205084741.126"><vh>_Transformer.color_value</vh></v>
<v t="leo.20231205084741.127"><vh>_Transformer.number</vh></v>
<v t="leo.20231205084741.128"><vh>_Transformer.angle = number</vh></v>
<v t="leo.20231205084741.129"><vh>_Transformer.point</vh></v>
<v t="leo.20231205084741.130"><vh>_Transformer.link</vh></v>
<v t="leo.20231205084741.131"><vh>_Transformer.joint</vh></v>
<v t="leo.20231205084741.132"><vh>_Transformer.mechanism</vh></v>
</v>
<v t="leo.20231205084741.133"><vh>class _ParamsTrans</vh>
<v t="leo.20231205084741.134"><vh>_ParamsTrans.type</vh></v>
<v t="leo.20231205084741.135"><vh>_ParamsTrans.joint</vh></v>
</v>
<v t="leo.20231205084741.136"><vh>class _PositionTrans</vh>
<v t="leo.20231205084741.137"><vh>_PositionTrans.type</vh></v>
<v t="leo.20231205084741.138"><vh>_PositionTrans.joint</vh></v>
</v>
<v t="leo.20231205084741.139"><vh>class _VPointsTrans</vh>
<v t="leo.20231205084741.140"><vh>_VPointsTrans.type</vh></v>
<v t="leo.20231205084741.141"><vh>_VPointsTrans.joint</vh></v>
</v>
<v t="leo.20231205084741.142"><vh>_params_translator = _ParamsTrans()</vh></v>
<v t="leo.20231205084741.143"><vh>parse_params</vh></v>
<v t="leo.20231205084741.144"><vh>parse_pos</vh></v>
<v t="leo.20231205084741.145"><vh>parse_vpoints</vh></v>
<v t="leo.20231205084741.146"><vh>parse_vlinks</vh></v>
<v t="leo.20231205084741.147"><vh>_sorted_pair</vh></v>
<v t="leo.20231205084741.148"><vh>edges_view</vh></v>
<v t="leo.20231205084741.149"><vh>graph2vpoints</vh></v>
</v>
<v t="leo.20231205084741.150"><vh>@@clean __init__.py</vh>
<v t="leo.20231205084741.151"><vh>get_include</vh></v>
</v>
<v t="leo.20231205084741.153"><vh>@path graph</vh>
<v t="leo.20231205084741.154"><vh>@@clean __init__.py</vh></v>
</v>
<v t="leo.20231205084741.155"><vh>@path optimization</vh>
<v t="leo.20231205084741.156"><vh>@@clean utility.py</vh>
<v t="leo.20231205084741.157"><vh>class FConfig</vh></v>
<v t="leo.20231205084741.158"><vh>class NConfig</vh></v>
</v>
<v t="leo.20231205084741.159"><vh>@@clean __init__.py</vh></v>
</v>
</v>
<v t="leo.20231205084741.161"><vh>@path test</vh>
<v t="leo.20231205084741.162"><vh>@@clean test_core.py</vh>
<v t="leo.20231205084741.163"><vh>class CoreTest</vh>
<v t="leo.20231205084741.164"><vh>CoreTest.test_pxy</vh></v>
<v t="leo.20231205084741.165"><vh>CoreTest.test_ppp</vh></v>
<v t="leo.20231205084741.166"><vh>CoreTest.test_plap</vh></v>
<v t="leo.20231205084741.167"><vh>CoreTest.test_pllp</vh></v>
<v t="leo.20231205084741.168"><vh>CoreTest.test_plpp</vh></v>
<v t="leo.20231205084741.169"><vh>CoreTest.test_palp</vh></v>
<v t="leo.20231205084741.170"><vh>CoreTest.test_solving</vh></v>
<v t="leo.20231205084741.171"><vh>CoreTest.test_solving_bfgs</vh></v>
</v>
</v>
<v t="leo.20231205084741.172"><vh>@@clean test_efd.py</vh>
<v t="leo.20231205084741.173"><vh>class EFDTest</vh></v>
</v>
<v t="leo.20231205084741.174"><vh>@@clean test_graph.py</vh>
<v t="leo.20231205084741.175"><vh>class GraphTest</vh>
<v t="leo.20231205084741.176"><vh>GraphTest.test_graph_basic</vh></v>
<v t="leo.20231205084741.177"><vh>GraphTest.test_graph_isomorphic</vh></v>
<v t="leo.20231205084741.178"><vh>GraphTest.test_graph_planar</vh></v>
<v t="leo.20231205084741.179"><vh>GraphTest.test_graph_degenerate</vh></v>
<v t="leo.20231205084741.180"><vh>GraphTest.test_graph_duplicate</vh></v>
<v t="leo.20231205084741.181"><vh>GraphTest.test_graph_loop</vh></v>
<v t="leo.20231205084741.182"><vh>GraphTest.test_graph_degree_code</vh></v>
<v t="leo.20231205084741.183"><vh>GraphTest.test_atlas</vh></v>
<v t="leo.20231205084741.184"><vh>GraphTest.test_number_synthesis</vh></v>
</v>
</v>
<v t="leo.20231205084741.185"><vh>@@clean test_metaheuristics.py</vh>
<v t="leo.20231205084741.186"><vh>class AlgorithmTest</vh>
<v t="leo.20231205084741.187"><vh>AlgorithmTest.case</vh></v>
<v t="leo.20231205084741.188"><vh>AlgorithmTest.test_rga</vh></v>
<v t="leo.20231205084741.189"><vh>AlgorithmTest.test_de</vh></v>
<v t="leo.20231205084741.190"><vh>AlgorithmTest.test_pso</vh></v>
<v t="leo.20231205084741.191"><vh>AlgorithmTest.test_fa</vh></v>
<v t="leo.20231205084741.192"><vh>AlgorithmTest.test_tlbo</vh></v>
</v>
</v>
<v t="leo.20231205084741.193"><vh>@@clean test_planar_linkage.py</vh>
<v t="leo.20231205084741.194"><vh>class PlanarTest</vh>
<v t="leo.20231205084741.195"><vh>PlanarTest.test_norm</vh></v>
<v t="leo.20231205084741.196"><vh>PlanarTest.planar</vh></v>
<v t="leo.20231205084741.197"><vh>PlanarTest.test_case</vh></v>
<v t="leo.20231205084741.198"><vh>PlanarTest.test_rga</vh></v>
<v t="leo.20231205084741.199"><vh>PlanarTest.test_de</vh></v>
<v t="leo.20231205084741.200"><vh>PlanarTest.test_pso</vh></v>
<v t="leo.20231205084741.201"><vh>PlanarTest.test_fa</vh></v>
<v t="leo.20231205084741.202"><vh>PlanarTest.test_tlbo</vh></v>
</v>
</v>
<v t="leo.20231205084741.203"><vh>@@clean __init__.py</vh>
<v t="leo.20231205084741.204"><vh>class TestBase</vh></v>
</v>
</v>
</v>
<v t="leo.20231205084741.205"><vh>@path solvespace</vh>
<v t="leo.20231205084742.2"><vh>@path cmake</vh></v>
<v t="leo.20231205084742.4"><vh>@path cython</vh>
<v t="leo.20231205084742.5"><vh>@@clean setup.py</vh>
<v t="leo.20231205084742.6"><vh>copy_source</vh></v>
<v t="leo.20231205084742.7"><vh>class Build</vh>
<v t="leo.20231205084742.8"><vh>Build.build_extensions</vh></v>
</v>
<v t="leo.20231205084742.9"><vh>class PackSource</vh>
<v t="leo.20231205084742.10"><vh>PackSource.run</vh></v>
</v>
</v>
<v t="leo.20231205084742.12"><vh>@path python_solvespace</vh>
<v t="leo.20231205084742.13"><vh>@@clean __init__.py</vh></v>
</v>
<v t="leo.20231205084742.14"><vh>@path test</vh>
<v t="leo.20231205084742.15"><vh>@@clean test_slvs.py</vh>
<v t="leo.20231205084742.16"><vh>class CoreTest</vh>
<v t="leo.20231205084742.17"><vh>CoreTest.test_crank_rocker</vh></v>
<v t="leo.20231205084742.18"><vh>CoreTest.test_involute</vh></v>
<v t="leo.20231205084742.19"><vh>CoreTest.test_jansen_linkage</vh></v>
<v t="leo.20231205084742.20"><vh>CoreTest.test_nut_cracker</vh></v>
<v t="leo.20231205084742.21"><vh>CoreTest.test_pydemo</vh></v>
</v>
</v>
<v t="leo.20231205084742.22"><vh>@@clean __init__.py</vh></v>
<v t="leo.20231205084742.23"><vh>@@clean __main__.py</vh></v>
</v>
</v>
<v t="leo.20231205084742.26"><vh>@path extlib</vh></v>
<v t="leo.20231205084742.29"><vh>@path pkg</vh>
<v t="leo.20231205084742.31"><vh>@path snap</vh></v>
</v>
<v t="leo.20231205084742.33"><vh>@path res</vh>
<v t="leo.20231205084742.34"><vh>@path cocoa</vh></v>
<v t="leo.20231205084742.36"><vh>@path fonts</vh></v>
<v t="leo.20231205084742.39"><vh>@path icons</vh></v>
</v>
<v t="leo.20231205084743.4"><vh>@path src</vh>
<v t="leo.20231205084743.5"><vh>@path platform</vh></v>
</v>
<v t="leo.20231205084743.9"><vh>@path test</vh>
<v t="leo.20231205084743.10"><vh>@path analysis</vh></v>
<v t="leo.20231205084743.12"><vh>@path constraint</vh></v>
<v t="leo.20231205084744.9"><vh>@path core</vh></v>
<v t="leo.20231205084744.13"><vh>@path group</vh></v>
<v t="leo.20231205084744.17"><vh>@path request</vh></v>
</v>
</v>
</v>
</v>
<v t="leo.20231205084803.1"><vh>pyx</vh>
<v t="leo.20231205084803.2"><vh>@path Y:/tmp/metapyslvs/</vh>
<v t="leo.20231205084804.20"><vh>@path metaheuristics</vh>
<v t="leo.20231205084804.21"><vh>@@clean de.pyx</vh>
<v t="leo.20231205084804.22"><vh>cpdef enum Strategy</vh></v>
<v t="leo.20231205084804.23"><vh>cdef class DE</vh>
<v t="leo.20231205084804.24"><vh>cdef Strategy strategy</vh></v>
<v t="leo.20231205084804.25"><vh>cdef double f, cr</vh></v>
<v t="leo.20231205084804.26"><vh>cdef uint[</vh></v>
<v t="leo.20231205084804.27"><vh>cdef double[</vh></v>
<v t="leo.20231205084804.28"><vh>cdef (double (*)(DE, uint) nogil) formula</vh></v>
<v t="leo.20231205084804.29"><vh>__cinit__</vh></v>
<v t="leo.20231205084804.30"><vh>):</vh></v>
<v t="leo.20231205084804.31"><vh>cdef uint num</vh></v>
<v t="leo.20231205084804.32"><vh>if self.strategy in {S1, S3, S6, S8}:</vh></v>
<v t="leo.20231205084804.33"><vh>cdef inline void init</vh></v>
<v t="leo.20231205084804.34"><vh>cdef inline void vector</vh>
<v t="leo.20231205084804.35"><vh>cdef uint j</vh></v>
</v>
<v t="leo.20231205084804.36"><vh>cdef double f1</vh></v>
<v t="leo.20231205084804.37"><vh>cdef double f2</vh></v>
<v t="leo.20231205084804.38"><vh>cdef double f3</vh></v>
<v t="leo.20231205084804.39"><vh>cdef double f4</vh></v>
<v t="leo.20231205084804.40"><vh>cdef double f5</vh></v>
<v t="leo.20231205084804.41"><vh>cdef void s1</vh></v>
<v t="leo.20231205084804.42"><vh>cdef void s2</vh></v>
<v t="leo.20231205084804.43"><vh>cdef inline void recombination</vh></v>
<v t="leo.20231205084804.44"><vh>cdef inline void generation</vh>
<v t="leo.20231205084804.45"><vh>cdef uint i, s</vh></v>
<v t="leo.20231205084804.46"><vh>cdef double tmp_f</vh></v>
</v>
</v>
</v>
<v t="leo.20231205084804.47"><vh>@@clean fa.pyx</vh>
<v t="leo.20231205084804.48"><vh>cdef double _distance</vh>
<v t="leo.20231205084804.49"><vh>cdef double dist = 0</vh></v>
<v t="leo.20231205084804.50"><vh>cdef uint i</vh></v>
<v t="leo.20231205084804.51"><vh>cdef double diff</vh></v>
</v>
<v t="leo.20231205084804.52"><vh>cdef class FA</vh>
<v t="leo.20231205084804.53"><vh>cdef double alpha, beta_min, gamma</vh></v>
<v t="leo.20231205084804.54"><vh>__cinit__</vh></v>
<v t="leo.20231205084804.55"><vh>):</vh></v>
<v t="leo.20231205084804.56"><vh>cdef inline void move_fireflies</vh></v>
<v t="leo.20231205084804.57"><vh>cdef inline void move_firefly</vh>
<v t="leo.20231205084804.58"><vh>cdef double[</vh></v>
<v t="leo.20231205084804.59"><vh>with gil:</vh></v>
<v t="leo.20231205084804.60"><vh>cdef double r = _distance</vh></v>
<v t="leo.20231205084804.61"><vh>cdef double beta = self.beta_min * exp</vh></v>
<v t="leo.20231205084804.62"><vh>cdef uint s</vh></v>
<v t="leo.20231205084804.63"><vh>cdef double step, surround</vh></v>
<v t="leo.20231205084804.64"><vh>for s in range(self.dim):</vh></v>
<v t="leo.20231205084804.65"><vh>cdef double f = self.func.fitness</vh></v>
</v>
<v t="leo.20231205084804.66"><vh>cdef inline void generation</vh></v>
</v>
</v>
<v t="leo.20231205084804.67"><vh>@@clean pso.pyx</vh>
<v t="leo.20231205084804.68"><vh>cdef class PSO</vh>
<v t="leo.20231205084804.69"><vh>cdef double cognition, social, velocity</vh></v>
<v t="leo.20231205084804.70"><vh>cdef double[</vh></v>
<v t="leo.20231205084804.71"><vh>cdef double[</vh></v>
<v t="leo.20231205084804.72"><vh>__cinit__</vh></v>
<v t="leo.20231205084804.73"><vh>):</vh></v>
<v t="leo.20231205084804.74"><vh>cdef inline void init</vh></v>
<v t="leo.20231205084804.75"><vh>cdef inline void generation</vh>
<v t="leo.20231205084804.76"><vh>cdef double alpha</vh></v>
<v t="leo.20231205084804.77"><vh>cdef double beta</vh></v>
<v t="leo.20231205084804.78"><vh>cdef uint i, s</vh></v>
</v>
</v>
</v>
<v t="leo.20231205084804.79"><vh>@@clean rga.pyx</vh>
<v t="leo.20231205084804.80"><vh>cdef class RGA</vh>
<v t="leo.20231205084804.81"><vh>cdef double cross, mutate_f, win, delta</vh></v>
<v t="leo.20231205084804.82"><vh>cdef double[</vh></v>
<v t="leo.20231205084804.83"><vh>cdef double[</vh></v>
<v t="leo.20231205084804.84"><vh>__cinit__</vh></v>
<v t="leo.20231205084804.85"><vh>):</vh></v>
<v t="leo.20231205084804.86"><vh>cdef inline double bound</vh></v>
<v t="leo.20231205084804.87"><vh>cdef inline void crossover</vh>
<v t="leo.20231205084804.88"><vh>cdef uint i, s</vh></v>
</v>
<v t="leo.20231205084804.89"><vh>cdef inline double get_delta</vh></v>
<v t="leo.20231205084804.90"><vh>cdef inline void mutate</vh>
<v t="leo.20231205084804.91"><vh>cdef uint i, s</vh></v>
</v>
<v t="leo.20231205084804.92"><vh>cdef inline void select</vh>
<v t="leo.20231205084804.93"><vh>cdef uint i, j, k</vh></v>
</v>
<v t="leo.20231205084804.94"><vh>cdef inline void generation</vh></v>
</v>
</v>
<v t="leo.20231205084804.95"><vh>@@clean test.pyx</vh>
<v t="leo.20231205084804.96"><vh>cdef class TestObj</vh>
<v t="leo.20231205084804.97"><vh>__cinit__</vh></v>
<v t="leo.20231205084804.98"><vh>cdef double target</vh></v>
<v t="leo.20231205084804.99"><vh>cdef double fitness</vh></v>
<v t="leo.20231205084804.100"><vh>cpdef object result</vh></v>
</v>
</v>
<v t="leo.20231205084804.101"><vh>@@clean tlbo.pyx</vh>
<v t="leo.20231205084804.102"><vh>cdef class TLBO</vh>
<v t="leo.20231205084804.103"><vh>cdef double[</vh></v>
<v t="leo.20231205084804.104"><vh>__cinit__</vh></v>
<v t="leo.20231205084804.105"><vh>):</vh></v>
<v t="leo.20231205084804.106"><vh>cdef inline void bounding</vh></v>
<v t="leo.20231205084804.107"><vh>cdef inline void register</vh></v>
<v t="leo.20231205084804.108"><vh>cdef inline void teaching</vh>
<v t="leo.20231205084804.109"><vh>cdef double tf = round</vh></v>
<v t="leo.20231205084804.110"><vh>cdef uint s, j</vh></v>
<v t="leo.20231205084804.111"><vh>cdef double mean</vh></v>
</v>
<v t="leo.20231205084804.112"><vh>cdef inline void learning</vh>
<v t="leo.20231205084804.113"><vh>cdef uint j = rand_i</vh></v>
<v t="leo.20231205084804.114"><vh>if j &gt;= i:</vh></v>
<v t="leo.20231205084804.115"><vh>cdef uint s</vh></v>
<v t="leo.20231205084804.116"><vh>cdef double diff</vh></v>
</v>
<v t="leo.20231205084804.117"><vh>cdef inline void generation</vh></v>
</v>
</v>
<v t="leo.20231205084804.118"><vh>@@clean utility.pyx</vh>
<v t="leo.20231205084804.119"><vh>cdef inline double rand_v</vh></v>
<v t="leo.20231205084804.120"><vh>cdef inline uint rand_i</vh></v>
<v t="leo.20231205084804.121"><vh>cdef class ObjFunc</vh>
<v t="leo.20231205084804.122"><vh>cdef double fitness</vh></v>
<v t="leo.20231205084804.123"><vh>cpdef object result</vh></v>
</v>
<v t="leo.20231205084804.124"><vh>cdef class Algorithm</vh>
<v t="leo.20231205084804.125"><vh>__cinit__</vh></v>
<v t="leo.20231205084804.126"><vh>):</vh></v>
<v t="leo.20231205084804.127"><vh>cdef void assign</vh></v>
<v t="leo.20231205084804.128"><vh>cdef void assign_from</vh></v>
<v t="leo.20231205084804.129"><vh>cdef void set_best</vh></v>
<v t="leo.20231205084804.130"><vh>cdef void find_best</vh>
<v t="leo.20231205084804.131"><vh>cdef uint best = 0</vh></v>
<v t="leo.20231205084804.132"><vh>cdef uint i</vh></v>
</v>
<v t="leo.20231205084804.133"><vh>cdef void init_pop</vh>
<v t="leo.20231205084804.134"><vh>cdef uint best = 0</vh></v>
<v t="leo.20231205084804.135"><vh>cdef uint i, s</vh></v>
</v>
<v t="leo.20231205084804.136"><vh>cdef void init</vh></v>
<v t="leo.20231205084804.137"><vh>cdef void generation</vh></v>
<v t="leo.20231205084804.138"><vh>cdef double check</vh></v>
<v t="leo.20231205084804.139"><vh>cdef inline void report</vh></v>
<v t="leo.20231205084804.140"><vh>cpdef double[</vh></v>
<v t="leo.20231205084804.141"><vh>cpdef tuple result</vh></v>
<v t="leo.20231205084804.142"><vh>cpdef object run</vh>
<v t="leo.20231205084804.143"><vh>cdef double diff, best_f</vh></v>
<v t="leo.20231205084804.144"><vh>cdef double last_diff = 0</vh></v>
</v>
</v>
</v>
</v>
<v t="leo.20231205084804.145"><vh>@path pyslvs</vh>
<v t="leo.20231205084804.147"><vh>@path pyslvs</vh>
<v t="leo.20231205084804.148"><vh>@@clean bfgs.pyx</vh>
<v t="leo.20231205084804.149"><vh>cdef inline double *de_refer_post_inc</vh></v>
<v t="leo.20231205084804.150"><vh>cdef inline void _sort_pairs</vh></v>
<v t="leo.20231205084804.151"><vh>cdef inline double _radians</vh></v>
<v t="leo.20231205084804.152"><vh>cdef class SolverSystem</vh>
<v t="leo.20231205084804.153"><vh>__cinit__</vh></v>
<v t="leo.20231205084804.154"><vh>cpdef bint same_points</vh>
<v t="leo.20231205084804.155"><vh>cdef int i</vh></v>
<v t="leo.20231205084804.156"><vh>cdef VPoint p1, p2</vh></v>
</v>
<v t="leo.20231205084804.157"><vh>cpdef frozenset show_inputs</vh></v>
<v t="leo.20231205084804.158"><vh>cpdef frozenset show_data</vh></v>
<v t="leo.20231205084804.159"><vh>cdef Point *point_ptr</vh></v>
<v t="leo.20231205084804.160"><vh>cdef void build_expression</vh>
<v t="leo.20231205084804.161"><vh>cdef int i</vh></v>
<v t="leo.20231205084804.162"><vh>cdef double x, y</vh></v>
<v t="leo.20231205084804.163"><vh>cdef double *tmp_ptr</vh></v>
<v t="leo.20231205084804.164"><vh>cdef VPoint vpoint</vh></v>
<v t="leo.20231205084804.165"><vh>cdef Coord coord</vh></v>
<v t="leo.20231205084804.166"><vh>for i, vpoint in enumerate(self.vpoints):</vh></v>
<v t="leo.20231205084804.167"><vh>cdef int a, b, c, d</vh></v>
<v t="leo.20231205084804.168"><vh>cdef VPoint vp1, vp2</vh></v>
<v t="leo.20231205084804.169"><vh>cdef Point *p1</vh></v>
<v t="leo.20231205084804.170"><vh>cdef Point *p2</vh></v>
<v t="leo.20231205084804.171"><vh>cdef VLink vlink</vh></v>
<v t="leo.20231205084804.172"><vh>for vlink in self.vlinks.values():</vh></v>
<v t="leo.20231205084804.173"><vh>cdef Line *slider_slot</vh></v>
<v t="leo.20231205084804.174"><vh>cdef pair[int, int] slider</vh></v>
<v t="leo.20231205084804.175"><vh>for slider in self.sliders:</vh></v>
<v t="leo.20231205084804.176"><vh>cdef double angle</vh></v>
</v>
<v t="leo.20231205084804.177"><vh>cdef bint check_known</vh></v>
<v t="leo.20231205084804.178"><vh>cpdef void set_inputs</vh>
<v t="leo.20231205084804.179"><vh>cdef int b, d</vh></v>
<v t="leo.20231205084804.180"><vh>cdef double angle</vh></v>
<v t="leo.20231205084804.181"><vh>cdef double *handle</vh></v>
<v t="leo.20231205084804.182"><vh>cdef clist[double].iterator it = self.inputs_angle.begin</vh></v>
</v>
<v t="leo.20231205084804.183"><vh>cpdef void set_data</vh>
<v t="leo.20231205084804.184"><vh>cdef size_t n = 0</vh></v>
<v t="leo.20231205084804.185"><vh>cdef int i</vh></v>
<v t="leo.20231205084804.186"><vh>cdef double *handle</vh></v>
<v t="leo.20231205084804.187"><vh>cdef VPoint vpoint</vh></v>
<v t="leo.20231205084804.188"><vh>cdef Coord coord</vh></v>
<v t="leo.20231205084804.189"><vh>cdef clist[double].iterator it = self.data_values.begin</vh></v>
<v t="leo.20231205084804.190"><vh>for i, vpoint in enumerate(self.vpoints):</vh></v>
<v t="leo.20231205084804.191"><vh>cdef int a, b, c, d</vh></v>
<v t="leo.20231205084804.192"><vh>cdef VLink vlink</vh></v>
</v>
<v t="leo.20231205084804.193"><vh>cpdef list solve</vh>
<v t="leo.20231205084804.194"><vh>cdef size_t params_count = &lt;int&gt;self.params.size</vh></v>
<v t="leo.20231205084804.195"><vh>cdef double **params_ptr = &lt;double **&gt;PyMem_Malloc</vh></v>
<v t="leo.20231205084804.196"><vh>cdef clist[double].iterator it = self.params.begin</vh></v>
<v t="leo.20231205084804.197"><vh>cdef size_t i</vh></v>
<v t="leo.20231205084804.198"><vh>for i in range(params_count):</vh></v>
<v t="leo.20231205084804.199"><vh>cdef size_t cons_count = &lt;int&gt;self.cons_list.size</vh></v>
<v t="leo.20231205084804.200"><vh>cdef Constraint *cons = &lt;Constraint *&gt;PyMem_Malloc</vh></v>
<v t="leo.20231205084804.201"><vh>i = 0</vh></v>
<v t="leo.20231205084804.202"><vh>cdef Constraint con</vh></v>
<v t="leo.20231205084804.203"><vh>for con in self.cons_list:</vh></v>
<v t="leo.20231205084804.204"><vh>cdef bint flag = solve</vh></v>
<v t="leo.20231205084804.205"><vh>cdef VPoint vp</vh></v>
<v t="leo.20231205084804.206"><vh>cdef Coord c</vh></v>
<v t="leo.20231205084804.207"><vh>cdef Point p1, p2</vh></v>
</v>
</v>
</v>
<v t="leo.20231205084805.1"><vh>@@clean expression.pyx</vh>
<v t="leo.20231205084805.2"><vh>cdef double distance</vh></v>
<v t="leo.20231205084805.3"><vh>cdef double slope_angle</vh></v>
<v t="leo.20231205084805.4"><vh>cpdef list get_vlinks</vh>
<v t="leo.20231205084805.5"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.6"><vh>cdef VPoint vpoint</vh></v>
</v>
<v t="leo.20231205084805.7"><vh>cdef class Coord</vh>
<v t="leo.20231205084805.8"><vh>__cinit__</vh></v>
<v t="leo.20231205084805.9"><vh>cpdef double distance</vh></v>
<v t="leo.20231205084805.10"><vh>cpdef double slope_angle</vh></v>
<v t="leo.20231205084805.11"><vh>cpdef bint is_nan</vh></v>
<v t="leo.20231205084805.12"><vh>__repr__</vh></v>
</v>
<v t="leo.20231205084805.13"><vh>cdef class VPoint</vh>
<v t="leo.20231205084805.14"><vh>__cinit__</vh></v>
<v t="leo.20231205084805.15"><vh>):</vh></v>
<v t="leo.20231205084805.16"><vh>r_joint</vh></v>
<v t="leo.20231205084805.17"><vh>cdef VPoint c_r_joint</vh></v>
<v t="leo.20231205084805.18"><vh>slider_joint</vh></v>
<v t="leo.20231205084805.19"><vh>cdef VPoint c_slider_joint</vh></v>
<v t="leo.20231205084805.20"><vh>cpdef VPoint copy</vh></v>
<v t="leo.20231205084805.21"><vh>sx</vh></v>
<v t="leo.20231205084805.22"><vh>sy</vh></v>
<v t="leo.20231205084805.23"><vh>cx</vh></v>
<v t="leo.20231205084805.24"><vh>cy</vh></v>
<v t="leo.20231205084805.25"><vh>cpdef void set_links</vh></v>
<v t="leo.20231205084805.26"><vh>cpdef void replace_link</vh></v>
<v t="leo.20231205084805.27"><vh>cpdef void move</vh>
<v t="leo.20231205084805.28"><vh>cdef double x, y</vh></v>
</v>
<v t="leo.20231205084805.29"><vh>cpdef void locate</vh></v>
<v t="leo.20231205084805.30"><vh>cpdef void rotate</vh></v>
<v t="leo.20231205084805.31"><vh>cpdef void set_offset</vh></v>
<v t="leo.20231205084805.32"><vh>cpdef void disable_offset</vh></v>
<v t="leo.20231205084805.33"><vh>cpdef bint is_slider</vh></v>
<v t="leo.20231205084805.34"><vh>cpdef double distance</vh>
<v t="leo.20231205084805.35"><vh>cdef double m_x = 0</vh></v>
<v t="leo.20231205084805.36"><vh>cdef double m_y = 0</vh></v>
<v t="leo.20231205084805.37"><vh>cdef double p_x = 0</vh></v>
<v t="leo.20231205084805.38"><vh>cdef double p_y = 0</vh></v>
</v>
<v t="leo.20231205084805.39"><vh>cpdef bint has_offset</vh></v>
<v t="leo.20231205084805.40"><vh>cpdef double offset</vh></v>
<v t="leo.20231205084805.41"><vh>cpdef double true_offset</vh></v>
<v t="leo.20231205084805.42"><vh>cpdef double slope_angle</vh>
<v t="leo.20231205084805.43"><vh>cdef double x1, y1, x2, y2</vh></v>
</v>
<v t="leo.20231205084805.44"><vh>cpdef Coord link_pos</vh></v>
<v t="leo.20231205084805.45"><vh>cpdef bint grounded</vh></v>
<v t="leo.20231205084805.46"><vh>cpdef bint pin_grounded</vh></v>
<v t="leo.20231205084805.47"><vh>cpdef bint same_link</vh></v>
<v t="leo.20231205084805.48"><vh>cpdef bint no_link</vh></v>
<v t="leo.20231205084805.49"><vh>cpdef bint is_slot_link</vh></v>
<v t="leo.20231205084805.50"><vh>cpdef str expr</vh></v>
<v t="leo.20231205084805.51"><vh>cpdef Coord to_coord</vh></v>
<v t="leo.20231205084805.52"><vh>__copy__</vh>
<v t="leo.20231205084805.53"><vh>cdef VPoint vpoint = VPoint.__new__</vh></v>
</v>
<v t="leo.20231205084805.54"><vh>__richcmp__</vh>
<v t="leo.20231205084805.55"><vh>cdef VPoint other = rhs</vh></v>
<v t="leo.20231205084805.56"><vh>cdef bint different =</vh></v>
</v>
<v t="leo.20231205084805.57"><vh>__getitem__</vh></v>
<v t="leo.20231205084805.58"><vh>__repr__</vh></v>
</v>
<v t="leo.20231205084805.59"><vh>cdef class VLink</vh>
<v t="leo.20231205084805.60"><vh>__cinit__</vh></v>
<v t="leo.20231205084805.61"><vh>):</vh></v>
<v t="leo.20231205084805.62"><vh>cpdef void set_points</vh></v>
<v t="leo.20231205084805.63"><vh>cpdef Coord[</vh>
<v t="leo.20231205084805.64"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.65"><vh>cdef Coord c</vh></v>
<v t="leo.20231205084805.66"><vh>cdef VPoint vpoint</vh></v>
</v>
<v t="leo.20231205084805.67"><vh>__contains__</vh></v>
<v t="leo.20231205084805.68"><vh>__repr__</vh></v>
</v>
</v>
<v t="leo.20231205084805.69"><vh>@@clean tinycadlib.pyx</vh>
<v t="leo.20231205084805.70"><vh>pxy</vh>
<v t="leo.20231205084805.71"><vh>cdef CCoord c = cpxy</vh></v>
</v>
<v t="leo.20231205084805.72"><vh>ppp</vh>
<v t="leo.20231205084805.73"><vh>cdef CCoord c = cppp</vh></v>
</v>
<v t="leo.20231205084805.74"><vh>plap</vh></v>
<v t="leo.20231205084805.75"><vh>):</vh></v>
<v t="leo.20231205084805.76"><vh>cdef CCoord c = cplap</vh></v>
<v t="leo.20231205084805.77"><vh>return Coord.__new__(Coord, c.x, c.y)</vh></v>
<v t="leo.20231205084805.78"><vh>pllp</vh></v>
<v t="leo.20231205084805.79"><vh>):</vh></v>
<v t="leo.20231205084805.80"><vh>cdef CCoord c = cpllp</vh></v>
<v t="leo.20231205084805.81"><vh>return Coord.__new__(Coord, c.x, c.y)</vh></v>
<v t="leo.20231205084805.82"><vh>plpp</vh></v>
<v t="leo.20231205084805.83"><vh>):</vh></v>
<v t="leo.20231205084805.84"><vh>cdef CCoord c = cplpp</vh></v>
<v t="leo.20231205084805.85"><vh>return Coord.__new__(Coord, c.x, c.y)</vh></v>
<v t="leo.20231205084805.86"><vh>palp</vh></v>
<v t="leo.20231205084805.87"><vh>):</vh></v>
<v t="leo.20231205084805.88"><vh>cdef CCoord c = cpalp</vh></v>
<v t="leo.20231205084805.89"><vh>return Coord.__new__(Coord, c.x, c.y)</vh></v>
<v t="leo.20231205084805.90"><vh>cpdef int vpoint_dof</vh>
<v t="leo.20231205084805.91"><vh>cdef int j1 = 0</vh></v>
<v t="leo.20231205084805.92"><vh>cdef int j2 = 0</vh></v>
<v t="leo.20231205084805.93"><vh>First link is frame</vh></v>
<v t="leo.20231205084805.94"><vh>cdef int link_count</vh></v>
<v t="leo.20231205084805.95"><vh>cdef VPoint vp</vh></v>
</v>
<v t="leo.20231205084805.96"><vh>cdef inline int base_friend</vh>
<v t="leo.20231205084805.97"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.98"><vh>cdef VPoint vpoint</vh></v>
</v>
<v t="leo.20231205084805.99"><vh>cdef bint preprocessing</vh></v>
<v t="leo.20231205084805.100"><vh>vpoints = list(vpoints)</vh></v>
<v t="leo.20231205084805.101"><vh>cdef int vp_dof = vpoint_dof</vh></v>
<v t="leo.20231205084805.102"><vh>cdef int node, base</vh></v>
<v t="leo.20231205084805.103"><vh>cdef VPoint vp, vp2</vh></v>
<v t="leo.20231205084805.104"><vh>vlinks = {}</vh></v>
<v t="leo.20231205084805.105"><vh>cdef double x, y, angle</vh></v>
<v t="leo.20231205084805.106"><vh>for base in range(len(vpoints)):</vh></v>
<v t="leo.20231205084805.107"><vh>cdef int dof = 0</vh></v>
<v t="leo.20231205084805.108"><vh>cdef Expr e</vh></v>
<v t="leo.20231205084805.109"><vh>cdef SwappablePair pair1, pair2</vh></v>
<v t="leo.20231205084805.110"><vh>for e in exprs.stack:</vh></v>
<v t="leo.20231205084805.111"><vh>cpdef list expr_solving</vh></v>
<v t="leo.20231205084805.112"><vh>):</vh></v>
<v t="leo.20231205084805.113"><vh>cdef map[Sym, CCoord] joint_pos</vh></v>
<v t="leo.20231205084805.114"><vh>cdef map[SwappablePair, double] link_len</vh></v>
<v t="leo.20231205084805.115"><vh>cdef map[Sym, double] param</vh></v>
<v t="leo.20231205084805.116"><vh>if not preprocessing(exprs, vpoints, inputs, joint_pos, link_len, param):</vh></v>
<v t="leo.20231205084805.117"><vh>cdef Expr e</vh></v>
<v t="leo.20231205084805.118"><vh>for e in exprs.stack:</vh></v>
<v t="leo.20231205084805.119"><vh>cdef bint bfgs_mode = not all</vh></v>
<v t="leo.20231205084805.120"><vh>cdef ExprSolver solver = ExprSolver</vh></v>
<v t="leo.20231205084805.121"><vh>if not solver.solve():</vh></v>
<v t="leo.20231205084805.122"><vh>cdef pair[Sym, CCoord] jp</vh></v>
<v t="leo.20231205084805.123"><vh>if bfgs_mode:</vh></v>
<v t="leo.20231205084805.124"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.125"><vh>cdef CCoord c</vh></v>
<v t="leo.20231205084805.126"><vh>cdef VPoint vp</vh></v>
<v t="leo.20231205084805.127"><vh>for i, vp in enumerate(vpoints):</vh></v>
<v t="leo.20231205084805.128"><vh>cdef ExprSolver s = ExprSolver</vh></v>
<v t="leo.20231205084805.129"><vh>cdef bint ok = s.solve</vh></v>
<v t="leo.20231205084805.130"><vh>return ok, s.joint_pos</vh></v>
<v t="leo.20231205084805.131"><vh>uniform_four_bar</vh></v>
<v t="leo.20231205084805.132"><vh>cdef double[</vh>
<v t="leo.20231205084805.133"><vh>cdef double[</vh></v>
<v t="leo.20231205084805.134"><vh>cdef int i</vh></v>
</v>
<v t="leo.20231205084805.135"><vh>uniform_path</vh></v>
<v t="leo.20231205084805.136"><vh>cdef (vector[Expr], map[Sym, CCoord], map[Sym, double]) ueb(double[:] v) nogil:</vh></v>
<v t="leo.20231205084805.137"><vh>cdef vector[Expr] stack</vh></v>
<v t="leo.20231205084805.138"><vh>stack.push_back(Expr(False, PLA, Sym(L_LABEL, 1), Sym(I_LABEL, 0),</vh></v>
<v t="leo.20231205084805.139"><vh>cdef map[Sym, CCoord] joint_pos</vh></v>
<v t="leo.20231205084805.140"><vh>joint_pos[Sym(P_LABEL, 0)] = CCoord(0, 0)</vh></v>
<v t="leo.20231205084805.141"><vh>cdef map[Sym, double] param</vh></v>
<v t="leo.20231205084805.142"><vh>param[Sym(L_LABEL, 1)] = 1.</vh></v>
<v t="leo.20231205084805.143"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.144"><vh>for i in range(1, 4):</vh></v>
<v t="leo.20231205084805.145"><vh>cdef double[</vh>
<v t="leo.20231205084805.146"><vh>cdef double[</vh></v>
<v t="leo.20231205084805.147"><vh>with gil:</vh></v>
<v t="leo.20231205084805.148"><vh>cdef vector[Expr] stack</vh></v>
<v t="leo.20231205084805.149"><vh>cdef map[Sym, CCoord] joint_pos</vh></v>
<v t="leo.20231205084805.150"><vh>cdef map[Sym, double] param</vh></v>
<v t="leo.20231205084805.151"><vh>cdef bint ok</vh></v>
<v t="leo.20231205084805.152"><vh>cdef int i, j</vh></v>
<v t="leo.20231205084805.153"><vh>cdef double a</vh></v>
<v t="leo.20231205084805.154"><vh>cdef CCoord c</vh></v>
<v t="leo.20231205084805.155"><vh>cdef map[Sym, CCoord] ans</vh></v>
</v>
<v t="leo.20231205084805.156"><vh>cpdef object uniform_expr</vh>
<v t="leo.20231205084805.157"><vh>cdef vector[Expr] stack</vh></v>
<v t="leo.20231205084805.158"><vh>cdef map[Sym, CCoord] joint_pos</vh></v>
<v t="leo.20231205084805.159"><vh>cdef map[Sym, double] param</vh></v>
<v t="leo.20231205084805.160"><vh>stack, joint_pos, param = ueb(v)</vh></v>
<v t="leo.20231205084805.161"><vh>cdef vector[CCoord] coords = vector[CCoord]</vh></v>
<v t="leo.20231205084805.162"><vh>cdef bint ok = False</vh></v>
<v t="leo.20231205084805.163"><vh>cdef double a = 0</vh></v>
<v t="leo.20231205084805.164"><vh>cdef map[Sym, CCoord] ans</vh></v>
</v>
</v>
<v t="leo.20231205084805.165"><vh>@@clean topo_config.pyx</vh>
<v t="leo.20231205084805.166"><vh>cdef str symbol_str</vh></v>
<v t="leo.20231205084805.167"><vh>cdef class EStack</vh>
<v t="leo.20231205084805.168"><vh>cdef void add_pxy</vh>
<v t="leo.20231205084805.169"><vh>cdef Expr e</vh></v>
</v>
<v t="leo.20231205084805.170"><vh>cdef void add_ppp</vh></v>
<v t="leo.20231205084805.171"><vh>cdef void add_pla</vh>
<v t="leo.20231205084805.172"><vh>cdef Expr e</vh></v>
</v>
<v t="leo.20231205084805.173"><vh>cdef void add_plap</vh>
<v t="leo.20231205084805.174"><vh>cdef Expr e</vh></v>
</v>
<v t="leo.20231205084805.175"><vh>cdef void add_pllp</vh>
<v t="leo.20231205084805.176"><vh>cdef Expr e</vh></v>
</v>
<v t="leo.20231205084805.177"><vh>cdef void add_plpp</vh>
<v t="leo.20231205084805.178"><vh>cdef Expr e</vh></v>
</v>
<v t="leo.20231205084805.179"><vh>cdef void add_palp</vh>
<v t="leo.20231205084805.180"><vh>cdef Expr e</vh></v>
</v>
<v t="leo.20231205084805.181"><vh>cpdef list as_list</vh>
<v t="leo.20231205084805.182"><vh>cdef Expr expr</vh></v>
</v>
<v t="leo.20231205084805.183"><vh>__repr__</vh></v>
</v>
<v t="leo.20231205084805.184"><vh>cdef bint _is_all_lock</vh></v>
<v t="leo.20231205084805.185"><vh>cdef bint _is_parallel</vh></v>
<v t="leo.20231205084805.186"><vh>cdef bint _clockwise</vh></v>
<v t="leo.20231205084805.187"><vh>cdef (bint, int, int) _get_reliable_friends(</vh></v>
<v t="leo.20231205084805.188"><vh>cdef int fa = -1</vh></v>
<v t="leo.20231205084805.189"><vh>cdef int fb = -1</vh></v>
<v t="leo.20231205084805.190"><vh>cdef int f</vh></v>
<v t="leo.20231205084805.191"><vh>for link in vpoint.links:</vh></v>
<v t="leo.20231205084805.192"><vh>cdef int _get_intersection</vh></v>
<v t="leo.20231205084805.193"><vh>):</vh></v>
<v t="leo.20231205084805.194"><vh>cdef int node</vh></v>
<v t="leo.20231205084805.195"><vh>cdef VPoint vp</vh></v>
<v t="leo.20231205084805.196"><vh>for node, vp in enumerate(vpoints):</vh></v>
<v t="leo.20231205084805.197"><vh>cdef int _get_not_base_friend</vh>
<v t="leo.20231205084805.198"><vh>cdef int f</vh></v>
</v>
<v t="leo.20231205084805.199"><vh>cdef (bint, int, int) _get_base_friend(VPoint vpoint, object vlinks):</vh></v>
<v t="leo.20231205084805.200"><vh>cdef int fa = -1</vh></v>
<v t="leo.20231205084805.201"><vh>cdef int f</vh></v>
<v t="leo.20231205084805.202"><vh>for f in vlinks[vpoint.links[0]]:</vh></v>
<v t="leo.20231205084805.203"><vh>cdef int _get_input_base</vh></v>
<v t="leo.20231205084805.204"><vh>cpdef EStack t_config</vh></v>
<v t="leo.20231205084805.205"><vh>):</vh></v>
<v t="leo.20231205084805.206"><vh>cdef bint has_input = True</vh></v>
<v t="leo.20231205084805.207"><vh>cdef bint has_status = True</vh></v>
<v t="leo.20231205084805.208"><vh>if inputs_ is None or not inputs_:</vh></v>
<v t="leo.20231205084805.209"><vh>cdef EStack exprs = EStack.__new__</vh></v>
<v t="leo.20231205084805.210"><vh>if not vpoints_ or not has_input:</vh></v>
<v t="leo.20231205084805.211"><vh>cdef Inputs inputs</vh></v>
<v t="leo.20231205084805.212"><vh>cdef Status status</vh></v>
<v t="leo.20231205084805.213"><vh>cdef bint ok</vh></v>
<v t="leo.20231205084805.214"><vh>cdef int node, base</vh></v>
<v t="leo.20231205084805.215"><vh>if has_input:</vh></v>
<v t="leo.20231205084805.216"><vh>cdef VPoint vp1, vp2, vp3</vh></v>
<v t="leo.20231205084805.217"><vh>vlinks = {}</vh></v>
<v t="leo.20231205084805.218"><vh>cdef double[</vh></v>
<v t="leo.20231205084805.219"><vh>for base, vp1 in enumerate(vpoints):</vh></v>
<v t="leo.20231205084805.220"><vh>cdef int link_symbol = 0</vh></v>
<v t="leo.20231205084805.221"><vh>cdef int input_symbol = 0</vh></v>
<v t="leo.20231205084805.222"><vh>cdef int angle_symbol = 0</vh></v>
<v t="leo.20231205084805.223"><vh>Input joints (R) that was connect with ground</vh></v>
<v t="leo.20231205084805.224"><vh>cdef int skip_times = 0</vh></v>
<v t="leo.20231205084805.225"><vh>cdef int around = len</vh></v>
<v t="leo.20231205084805.226"><vh>cdef int fa, fb, fc, fd</vh></v>
<v t="leo.20231205084805.227"><vh>cdef double angle</vh></v>
<v t="leo.20231205084805.228"><vh>cdef double[</vh></v>
</v>
<v t="leo.20231205084805.230"><vh>@path graph</vh>
<v t="leo.20231205084805.231"><vh>@@clean graph.pyx</vh>
<v t="leo.20231205084805.232"><vh>cpdef list link_assortment</vh>
<v t="leo.20231205084805.233"><vh>cdef int d, n</vh></v>
</v>
<v t="leo.20231205084805.234"><vh>cpdef list contracted_link_assortment</vh>
<v t="leo.20231205084805.235"><vh>cdef int n, d</vh></v>
</v>
<v t="leo.20231205084805.236"><vh>cdef list _multi_contracted_links</vh>
<v t="leo.20231205084805.237"><vh>cdef int n1, n2, index, neighbor</vh></v>
</v>
<v t="leo.20231205084805.238"><vh>cpdef list labeled_enumerate</vh>
<v t="leo.20231205084805.239"><vh>cdef int n1, n2</vh></v>
<v t="leo.20231205084805.240"><vh>cdef Graph g1, g2</vh></v>
</v>
<v t="leo.20231205084805.241"><vh>cdef class Graph</vh>
<v t="leo.20231205084805.242"><vh>__cinit__</vh>
<v t="leo.20231205084805.243"><vh>cdef int p1, p2</vh></v>
</v>
<v t="leo.20231205084805.244"><vh>cpdef void add_vertices</vh></v>
<v t="leo.20231205084805.245"><vh>cpdef void add_edge</vh></v>
<v t="leo.20231205084805.246"><vh>cpdef void add_path</vh>
<v t="leo.20231205084805.247"><vh>cdef int n1 = -1</vh></v>
<v t="leo.20231205084805.248"><vh>cdef int n2</vh></v>
</v>
<v t="leo.20231205084805.249"><vh>cpdef void remove_edge</vh>
<v t="leo.20231205084805.250"><vh>cdef bint once = False</vh></v>
<v t="leo.20231205084805.251"><vh>for edge in self.edges:</vh></v>
<v t="leo.20231205084805.252"><vh>cdef int n</vh></v>
</v>
<v t="leo.20231205084805.253"><vh>cpdef int dof</vh></v>
<v t="leo.20231205084805.254"><vh>cpdef inline tuple neighbors</vh>
<v t="leo.20231205084805.255"><vh>cdef int l1, l2</vh></v>
</v>
<v t="leo.20231205084805.256"><vh>cpdef dict degrees</vh></v>
<v t="leo.20231205084805.257"><vh>cpdef ullong degree_code</vh>
<v t="leo.20231205084805.258"><vh>cdef int i, n1, n2</vh></v>
<v t="leo.20231205084805.259"><vh>cdef ullong code, sub_code</vh></v>
</v>
<v t="leo.20231205084805.260"><vh>cpdef double[</vh>
<v t="leo.20231205084805.261"><vh>cdef int n = len</vh></v>
<v t="leo.20231205084805.262"><vh>cdef double[</vh></v>
<v t="leo.20231205084805.263"><vh>cdef int n1, n2</vh></v>
</v>
<v t="leo.20231205084805.264"><vh>cpdef bint is_connected</vh>
<v t="leo.20231205084805.265"><vh>cdef int neighbors</vh></v>
<v t="leo.20231205084805.266"><vh>cdef int index = 0</vh></v>
</v>
<v t="leo.20231205084805.267"><vh>cpdef bint has_cut_link</vh>
<v t="leo.20231205084805.268"><vh>cdef int n, d</vh></v>
</v>
<v t="leo.20231205084805.269"><vh>cpdef bint is_degenerate</vh>
<v t="leo.20231205084805.270"><vh>cdef int n1, n2</vh></v>
<v t="leo.20231205084805.271"><vh>cdef Graph g = self.copy</vh></v>
</v>
<v t="leo.20231205084805.272"><vh>cpdef bint has_triangle</vh>
<v t="leo.20231205084805.273"><vh>cdef int n1, n2</vh></v>
</v>
<v t="leo.20231205084805.274"><vh>cpdef bint is_isomorphic</vh></v>
<v t="leo.20231205084805.275"><vh>cpdef bint is_isomorphic_vf2</vh></v>
<v t="leo.20231205084805.276"><vh>cpdef bint is_isomorphic_degree_code</vh></v>
<v t="leo.20231205084805.277"><vh>cpdef Graph duplicate</vh>
<v t="leo.20231205084805.278"><vh>cdef int max_num = max</vh></v>
<v t="leo.20231205084805.279"><vh>mapping = {}</vh></v>
<v t="leo.20231205084805.280"><vh>cdef int i, n1, n2</vh></v>
</v>
<v t="leo.20231205084805.281"><vh>cpdef Graph copy</vh></v>
<v t="leo.20231205084805.282"><vh>__repr__</vh></v>
</v>
<v t="leo.20231205084805.283"><vh>cdef bint _is_adjacent</vh></v>
<v t="leo.20231205084805.284"><vh>cdef class GraphMatcher</vh>
<v t="leo.20231205084805.285"><vh>cdef Graph g1, g2</vh></v>
<v t="leo.20231205084805.286"><vh>cdef set g1_nodes, g2_nodes</vh></v>
<v t="leo.20231205084805.287"><vh>cdef dict core_1, core_2, inout_1, inout_2, mapping</vh></v>
<v t="leo.20231205084805.288"><vh>cdef GMState state</vh></v>
<v t="leo.20231205084805.289"><vh>__cinit__</vh>
<v t="leo.20231205084805.290"><vh>cdef int old_recursion_limit = sys.getrecursionlimit</vh></v>
<v t="leo.20231205084805.291"><vh>cdef int expected_max_recursion_level = len</vh></v>
</v>
<v t="leo.20231205084805.292"><vh>cdef inline void initialize</vh></v>
<v t="leo.20231205084805.293"><vh>candidate_pairs_iter</vh>
<v t="leo.20231205084805.294"><vh>cdef int node</vh></v>
</v>
<v t="leo.20231205084805.295"><vh>cdef bint is_isomorphic</vh></v>
<v t="leo.20231205084805.296"><vh>match</vh>
<v t="leo.20231205084805.297"><vh>cdef int g1_node, g2_node</vh></v>
<v t="leo.20231205084805.298"><vh>cdef GMState new_state</vh></v>
</v>
<v t="leo.20231205084805.299"><vh>cdef inline bint syntactic_feasibility</vh>
<v t="leo.20231205084805.300"><vh>cdef int neighbor</vh></v>
<v t="leo.20231205084805.301"><vh>for neighbor in self.g1.adj[g1_node]:</vh></v>
<v t="leo.20231205084805.302"><vh>cdef int num1 = 0</vh></v>
<v t="leo.20231205084805.303"><vh>for neighbor in self.g1.adj[g1_node]:</vh></v>
<v t="leo.20231205084805.304"><vh>cdef int num2 = 0</vh></v>
</v>
</v>
<v t="leo.20231205084805.305"><vh>cdef class GMState</vh>
<v t="leo.20231205084805.306"><vh>cdef GraphMatcher gm</vh></v>
<v t="leo.20231205084805.307"><vh>cdef int g1_node, g2_node, depth</vh></v>
<v t="leo.20231205084805.308"><vh>__cinit__</vh></v>
<v t="leo.20231205084805.309"><vh>):</vh></v>
<v t="leo.20231205084805.310"><vh>cdef int node</vh></v>
<v t="leo.20231205084805.311"><vh>Watch out! g1_node == 0 should evaluate to True.</vh></v>
<v t="leo.20231205084805.312"><vh>cdef void restore</vh>
<v t="leo.20231205084805.313"><vh>cdef int node</vh></v>
</v>
</v>
</v>
<v t="leo.20231205084805.314"><vh>@@clean layout.pyx</vh>
<v t="leo.20231205084805.315"><vh>cpdef dict external_loop_layout</vh>
<v t="leo.20231205084805.316"><vh>cdef int i, n1, n2</vh></v>
<v t="leo.20231205084805.317"><vh>cdef double x1, y1, x2, y2</vh></v>
</v>
<v t="leo.20231205084805.318"><vh>cdef inline dict _line_polygon_layout</vh>
<v t="leo.20231205084805.319"><vh>cdef OrderedSet o_loop = _external_loop</vh></v>
<v t="leo.20231205084805.320"><vh>lines = None</vh></v>
<v t="leo.20231205084805.321"><vh>cdef OrderedSet used_nodes = o_loop.copy</vh></v>
<v t="leo.20231205084805.322"><vh>cdef int start, end</vh></v>
<v t="leo.20231205084805.323"><vh>cdef OrderedSet line</vh></v>
<v t="leo.20231205084805.324"><vh>cdef map[int, map[int, int]] line_limit, line_counter</vh></v>
<v t="leo.20231205084805.325"><vh>for line, start, end in lines:</vh></v>
<v t="leo.20231205084805.326"><vh>cdef int limit</vh></v>
<v t="leo.20231205084805.327"><vh>cdef double p, x1, y1, x2, y2</vh></v>
</v>
<v t="leo.20231205084805.328"><vh>cdef inline void _regular_polygon_layout</vh>
<v t="leo.20231205084805.329"><vh>cdef int edge_count = len</vh></v>
<v t="leo.20231205084805.330"><vh>scale *= 5</vh></v>
<v t="leo.20231205084805.331"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.332"><vh>cdef double angle = M_PI * 1.5</vh></v>
<v t="leo.20231205084805.333"><vh>cdef double angle_step = M_PI * 2 / edge_count</vh></v>
</v>
<v t="leo.20231205084805.334"><vh>cdef inline void _linear_layout</vh></v>
<v t="leo.20231205084805.335"><vh>):</vh></v>
<v t="leo.20231205084805.336"><vh>cdef int count = len</vh></v>
<v t="leo.20231205084805.337"><vh>if count &lt; 1:</vh></v>
<v t="leo.20231205084805.338"><vh>cdef double sx =</vh></v>
<v t="leo.20231205084805.339"><vh>cdef double sy =</vh></v>
<v t="leo.20231205084805.340"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.341"><vh>for i in range(1, count):</vh></v>
<v t="leo.20231205084805.342"><vh>cdef inline void _bezier_layout</vh></v>
<v t="leo.20231205084805.343"><vh>):</vh></v>
<v t="leo.20231205084805.344"><vh>cdef int count = len</vh></v>
<v t="leo.20231205084805.345"><vh>if count &lt; 1:</vh></v>
<v t="leo.20231205084805.346"><vh>cdef double sx = x2 - x1</vh></v>
<v t="leo.20231205084805.347"><vh>cdef double sy = y2 - y1</vh></v>
<v t="leo.20231205084805.348"><vh>cdef double r = hypot</vh></v>
<v t="leo.20231205084805.349"><vh>cdef double direction =</vh></v>
<v t="leo.20231205084805.350"><vh>cdef double cx1 = x1 + r * cos</vh></v>
<v t="leo.20231205084805.351"><vh>cdef double cy1 = y1 + r * sin</vh></v>
<v t="leo.20231205084805.352"><vh>cdef double cx2 = x2 + r * cos</vh></v>
<v t="leo.20231205084805.353"><vh>cdef double cy2 = y2 + r * sin</vh></v>
<v t="leo.20231205084805.354"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.355"><vh>cdef double u</vh></v>
<v t="leo.20231205084805.356"><vh>for i in range(1, count):</vh></v>
<v t="leo.20231205084805.357"><vh>cdef inline tuple _bezier_curve</vh></v>
<v t="leo.20231205084805.358"><vh>):</vh></v>
<v t="leo.20231205084805.359"><vh>cdef double mx = _uv</vh></v>
<v t="leo.20231205084805.360"><vh>cdef double my = _uv</vh></v>
<v t="leo.20231205084805.361"><vh>return (</vh></v>
<v t="leo.20231205084805.362"><vh>cdef inline double _uv</vh></v>
<v t="leo.20231205084805.363"><vh>cdef inline tuple _middle_point</vh></v>
<v t="leo.20231205084805.364"><vh>cdef list _inner_lines</vh>
<v t="leo.20231205084805.365"><vh>cdef OrderedSet vertices = OrderedSet</vh></v>
<v t="leo.20231205084805.366"><vh>if not vertices:</vh></v>
<v t="leo.20231205084805.367"><vh>cdef OrderedSet used_nodes = o_loop.copy</vh></v>
<v t="leo.20231205084805.368"><vh>cdef int n</vh></v>
<v t="leo.20231205084805.369"><vh>cdef OrderedSet line, inter</vh></v>
</v>
<v t="leo.20231205084805.370"><vh>cdef inline bint _split_loop</vh>
<v t="leo.20231205084805.371"><vh>cdef int i, n</vh></v>
<v t="leo.20231205084805.372"><vh>cdef int s0 = -1</vh></v>
<v t="leo.20231205084805.373"><vh>cdef int s1 = -1</vh></v>
<v t="leo.20231205084805.374"><vh>cdef int s2 = -1</vh></v>
<v t="leo.20231205084805.375"><vh>for i, n in enumerate(loop_list):</vh></v>
<v t="leo.20231205084805.376"><vh>cdef int anchor</vh></v>
</v>
<v t="leo.20231205084805.377"><vh>cdef inline OrderedSet _external_loop</vh>
<v t="leo.20231205084805.378"><vh>cdef OrderedSet c1, c2</vh></v>
</v>
<v t="leo.20231205084805.379"><vh>cdef inline bint _merge_inter</vh></v>
<v t="leo.20231205084805.380"><vh>):</vh></v>
<v t="leo.20231205084805.381"><vh>cdef int start = -1</vh></v>
<v t="leo.20231205084805.382"><vh>cdef int end = -1</vh></v>
<v t="leo.20231205084805.383"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.384"><vh>cdef OrderedSet inter</vh></v>
<v t="leo.20231205084805.385"><vh>for i, inter in enumerate(inter_over):</vh></v>
<v t="leo.20231205084805.386"><vh>cdef inline bint _merge_no_inter</vh></v>
<v t="leo.20231205084805.387"><vh>):</vh></v>
<v t="leo.20231205084805.388"><vh>cdef OrderedSet inter = OrderedSet.__new__</vh></v>
<v t="leo.20231205084805.389"><vh>cdef map[int, int] inter_map</vh></v>
<v t="leo.20231205084805.390"><vh>cdef int n1, n2</vh></v>
<v t="leo.20231205084805.391"><vh>for n1, n2 in g.edges:</vh></v>
<v t="leo.20231205084805.392"><vh>cdef int start = inter[0]</vh></v>
<v t="leo.20231205084805.393"><vh>cdef int end = inter[-1]</vh></v>
<v t="leo.20231205084805.394"><vh>cdef int replace_start = c2.index</vh></v>
<v t="leo.20231205084805.395"><vh>cdef int replace_end = c2.index</vh></v>
<v t="leo.20231205084805.396"><vh>if replace_start &gt; replace_end:</vh></v>
<v t="leo.20231205084805.397"><vh>cdef inline void _compare_insert</vh></v>
<v t="leo.20231205084805.398"><vh>):</vh></v>
<v t="leo.20231205084805.399"><vh>cdef int c1_degrees = 0</vh></v>
<v t="leo.20231205084805.400"><vh>cdef int c2_degrees = 0</vh></v>
<v t="leo.20231205084805.401"><vh>cdef OrderedSet c1_slice = c1[insert_start</vh></v>
<v t="leo.20231205084805.402"><vh>cdef OrderedSet c2_slice = c2[replace_start</vh></v>
<v t="leo.20231205084805.403"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.404"><vh>other_nodes = set(c1_slice | c2_slice)</vh></v>
<v t="leo.20231205084805.405"><vh>cdef inline list _cycle_basis</vh>
<v t="leo.20231205084805.406"><vh>cdef int root = -1</vh></v>
<v t="leo.20231205084805.407"><vh>cdef int z, nbr, p</vh></v>
<v t="leo.20231205084805.408"><vh>cdef OrderedSet cycle</vh></v>
</v>
<v t="leo.20231205084805.409"><vh>cdef class _Entry</vh></v>
<v t="leo.20231205084805.410"><vh>cdef _Entry next</vh>
<v t="leo.20231205084805.411"><vh>cdef inline void _add</vh>
<v t="leo.20231205084805.412"><vh>cdef _Entry next_entry = _Entry</vh></v>
</v>
<v t="leo.20231205084805.413"><vh>cdef void _discard</vh></v>
<v t="leo.20231205084805.414"><vh>cdef inline bint _isorderedsubset</vh>
<v t="leo.20231205084805.415"><vh>cdef int seq1_len = len</vh></v>
<v t="leo.20231205084805.416"><vh>if not seq1_len &lt;= len(seq2):</vh></v>
<v t="leo.20231205084805.417"><vh>cdef int matched = 0</vh></v>
</v>
<v t="leo.20231205084805.418"><vh>cdef inline bint _not_subset</vh>
<v t="leo.20231205084805.419"><vh>cdef OrderedSet member</vh></v>
</v>
<v t="leo.20231205084805.420"><vh>cdef class _OrderedSetIterator</vh>
<v t="leo.20231205084805.421"><vh>cdef OrderedSet oset</vh></v>
<v t="leo.20231205084805.422"><vh>cdef _Entry curr</vh></v>
<v t="leo.20231205084805.423"><vh>cdef ssize_t si_used</vh></v>
<v t="leo.20231205084805.424"><vh>__cinit__</vh></v>
<v t="leo.20231205084805.425"><vh>__iter__</vh></v>
<v t="leo.20231205084805.426"><vh>__next__</vh>
<v t="leo.20231205084805.427"><vh>cdef _Entry item</vh></v>
</v>
</v>
<v t="leo.20231205084805.428"><vh>cdef class _OrderedSetReverseIterator</vh>
<v t="leo.20231205084805.429"><vh>cdef OrderedSet oset</vh></v>
<v t="leo.20231205084805.430"><vh>cdef _Entry curr</vh></v>
<v t="leo.20231205084805.431"><vh>cdef ssize_t si_used</vh></v>
<v t="leo.20231205084805.432"><vh>__cinit__</vh></v>
<v t="leo.20231205084805.433"><vh>__iter__</vh></v>
<v t="leo.20231205084805.434"><vh>__next__</vh>
<v t="leo.20231205084805.435"><vh>cdef _Entry item = self.curr.prev</vh></v>
</v>
</v>
<v t="leo.20231205084805.436"><vh>cdef class OrderedSet</vh>
<v t="leo.20231205084805.437"><vh>cdef dict map</vh></v>
<v t="leo.20231205084805.438"><vh>cdef _Entry end</vh></v>
<v t="leo.20231205084805.439"><vh>cdef ssize_t os_used</vh></v>
<v t="leo.20231205084805.440"><vh>__cinit__</vh></v>
<v t="leo.20231205084805.441"><vh>__init__</vh>
<v t="leo.20231205084805.442"><vh>cdef _Entry next_e</vh></v>
<v t="leo.20231205084805.443"><vh>cdef _Entry end = self.end</vh></v>
</v>
<v t="leo.20231205084805.444"><vh>_from_iterable</vh></v>
<v t="leo.20231205084805.445"><vh>cpdef void add</vh></v>
<v t="leo.20231205084805.446"><vh>cpdef void insert</vh></v>
<v t="leo.20231205084805.447"><vh>cpdef void insert_from</vh></v>
<v t="leo.20231205084805.448"><vh>cpdef void discard</vh></v>
<v t="leo.20231205084805.449"><vh>cpdef void roll</vh></v>
<v t="leo.20231205084805.450"><vh>cpdef object pop</vh></v>
<v t="leo.20231205084805.451"><vh>cpdef void remove</vh></v>
<v t="leo.20231205084805.452"><vh>cpdef void clear</vh>
<v t="leo.20231205084805.453"><vh>cdef _Entry end = self.end</vh></v>
</v>
<v t="leo.20231205084805.454"><vh>cpdef OrderedSet copy</vh></v>
<v t="leo.20231205084805.455"><vh>__sub__</vh></v>
<v t="leo.20231205084805.456"><vh>__isub__</vh></v>
<v t="leo.20231205084805.457"><vh>cpdef OrderedSet intersection</vh></v>
<v t="leo.20231205084805.458"><vh>__and__</vh></v>
<v t="leo.20231205084805.459"><vh>__iand__</vh></v>
<v t="leo.20231205084805.460"><vh>cpdef list ordered_intersections</vh>
<v t="leo.20231205084805.461"><vh>cdef int matched_self</vh></v>
<v t="leo.20231205084805.462"><vh>cdef int matched_self_old = -2</vh></v>
<v t="leo.20231205084805.463"><vh>cdef int matched_other = -2</vh></v>
<v t="leo.20231205084805.464"><vh>cdef int matched_other_old = -2</vh></v>
<v t="leo.20231205084805.465"><vh>cdef OrderedSet subset = OrderedSet.__new__</vh></v>
</v>
<v t="leo.20231205084805.466"><vh>cpdef bint isdisjoint</vh></v>
<v t="leo.20231205084805.467"><vh>cpdef bint issubset</vh></v>
<v t="leo.20231205084805.468"><vh>cpdef bint issuperset</vh></v>
<v t="leo.20231205084805.469"><vh>cpdef bint is_ordered_subset</vh></v>
<v t="leo.20231205084805.470"><vh>cpdef bint is_ordered_superset</vh></v>
<v t="leo.20231205084805.471"><vh>__xor__</vh></v>
<v t="leo.20231205084805.472"><vh>__ixor__</vh></v>
<v t="leo.20231205084805.473"><vh>cpdef OrderedSet union</vh></v>
<v t="leo.20231205084805.474"><vh>cpdef void update</vh></v>
<v t="leo.20231205084805.475"><vh>__or__</vh></v>
<v t="leo.20231205084805.476"><vh>__ior__</vh></v>
<v t="leo.20231205084805.477"><vh>cpdef int index</vh>
<v t="leo.20231205084805.478"><vh>cdef _Entry curr = self.end.next</vh></v>
<v t="leo.20231205084805.479"><vh>cdef ssize_t index = 0</vh></v>
</v>
<v t="leo.20231205084805.480"><vh>cdef list _get_slice_entry</vh>
<v t="leo.20231205084805.481"><vh>cdef ssize_t start, stop, step, slicelength</vh></v>
<v t="leo.20231205084805.482"><vh>PySlice_GetIndicesEx(item, len(self), &amp;start, &amp;stop, &amp;step, &amp;slicelength)</vh></v>
<v t="leo.20231205084805.483"><vh>cdef ssize_t place = start</vh></v>
<v t="leo.20231205084805.484"><vh>cdef _Entry curr = self.end</vh></v>
<v t="leo.20231205084805.485"><vh>cdef ssize_t i</vh></v>
</v>
<v t="leo.20231205084805.486"><vh>cdef _Entry _get_index_entry</vh>
<v t="leo.20231205084805.487"><vh>cdef ssize_t _len = len</vh></v>
<v t="leo.20231205084805.488"><vh>if index &gt;= _len or (index &lt; 0 and abs(index) &gt; _len):</vh></v>
<v t="leo.20231205084805.489"><vh>cdef _Entry curr</vh></v>
</v>
<v t="leo.20231205084805.490"><vh>__getitem__</vh>
<v t="leo.20231205084805.491"><vh>cdef _Entry curr = self._get_index_entry</vh></v>
</v>
<v t="leo.20231205084805.492"><vh>__setitem__</vh>
<v t="leo.20231205084805.493"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.494"><vh>cdef _Entry curr</vh></v>
</v>
<v t="leo.20231205084805.495"><vh>__delitem__</vh>
<v t="leo.20231205084805.496"><vh>cdef _Entry curr</vh></v>
</v>
<v t="leo.20231205084805.497"><vh>cpdef void reverse</vh></v>
<v t="leo.20231205084805.498"><vh>__len__</vh></v>
<v t="leo.20231205084805.499"><vh>__contains__</vh></v>
<v t="leo.20231205084805.500"><vh>__iter__</vh></v>
<v t="leo.20231205084805.501"><vh>__reversed__</vh></v>
<v t="leo.20231205084805.502"><vh>__reduce__</vh></v>
<v t="leo.20231205084805.503"><vh>__repr__</vh></v>
<v t="leo.20231205084805.504"><vh>__eq__</vh></v>
<v t="leo.20231205084805.505"><vh>__le__</vh></v>
<v t="leo.20231205084805.506"><vh>__lt__</vh></v>
<v t="leo.20231205084805.507"><vh>__ge__</vh></v>
<v t="leo.20231205084805.508"><vh>__gt__</vh></v>
</v>
</v>
</v>
<v t="leo.20231205084805.509"><vh>@@clean planar.pyx</vh>
<v t="leo.20231205084805.510"><vh>cpdef bint is_planar</vh></v>
<v t="leo.20231205084805.511"><vh>cdef inline _ConflictPair _stack_top</vh></v>
<v t="leo.20231205084805.512"><vh>cdef class _LRPlanarity</vh>
<v t="leo.20231205084805.513"><vh>cdef Graph g, DG</vh></v>
<v t="leo.20231205084805.514"><vh>cdef _PlanarEmbedding embedding</vh></v>
<v t="leo.20231205084805.515"><vh>cdef list s</vh></v>
<v t="leo.20231205084805.516"><vh>cdef dict lowpt, lowpt2, nesting_depth, adjs</vh></v>
<v t="leo.20231205084805.517"><vh>cdef dict ordered_adjs, stack_bottom, lowpt_edge, left_ref, right_ref</vh></v>
<v t="leo.20231205084805.518"><vh>cdef object height, parent_edge, ref, side</vh></v>
<v t="leo.20231205084805.519"><vh>__cinit__</vh></v>
<v t="leo.20231205084805.520"><vh>cdef _PlanarEmbedding lr_planarity</vh>
<v t="leo.20231205084805.521"><vh>cdef int v</vh></v>
<v t="leo.20231205084805.522"><vh>for v in self.g.vertices:</vh></v>
<v t="leo.20231205084805.523"><vh>cdef clist[int] roots</vh></v>
<v t="leo.20231205084805.524"><vh>for v in self.g.vertices:</vh></v>
<v t="leo.20231205084805.525"><vh>cdef int previous_node, w</vh></v>
</v>
<v t="leo.20231205084805.526"><vh>cdef bint dfs_testing</vh>
<v t="leo.20231205084805.527"><vh>cdef clist[int] dfs_stack = [v]</vh></v>
<v t="leo.20231205084805.528"><vh>cdef map[int, int] ind</vh></v>
<v t="leo.20231205084805.529"><vh>bintean to indicate whether to skip the initial work for an edge</vh></v>
<v t="leo.20231205084805.530"><vh>cdef bint skip_final</vh></v>
<v t="leo.20231205084805.531"><vh>cdef int w</vh></v>
</v>
<v t="leo.20231205084805.532"><vh>cdef void dfs_embedding</vh>
<v t="leo.20231205084805.533"><vh>cdef clist[int] dfs_stack = [v]</vh></v>
<v t="leo.20231205084805.534"><vh>cdef map[int, int] ind</vh></v>
<v t="leo.20231205084805.535"><vh>cdef int w</vh></v>
</v>
<v t="leo.20231205084805.536"><vh>cdef void dfs_orientation</vh>
<v t="leo.20231205084805.537"><vh>cdef clist[int] dfs_stack = [v]</vh></v>
<v t="leo.20231205084805.538"><vh>cdef map[int, int] ind</vh></v>
<v t="leo.20231205084805.539"><vh>bintean to indicate whether to skip the initial work for an edge</vh></v>
<v t="leo.20231205084805.540"><vh>cdef int w</vh></v>
</v>
<v t="leo.20231205084805.541"><vh>cdef bint add_constraints</vh>
<v t="leo.20231205084805.542"><vh>cdef _ConflictPair p = _ConflictPair.__new__</vh></v>
<v t="leo.20231205084805.543"><vh>cdef _ConflictPair q</vh></v>
</v>
<v t="leo.20231205084805.544"><vh>cdef void _trim_interval</vh></v>
<v t="leo.20231205084805.545"><vh>cdef void remove_back_edges</vh>
<v t="leo.20231205084805.546"><vh>cdef int u = e[0]</vh></v>
<v t="leo.20231205084805.547"><vh>cdef _ConflictPair p</vh></v>
</v>
<v t="leo.20231205084805.548"><vh>cdef int sign</vh></v>
</v>
<v t="leo.20231205084805.549"><vh>cdef class _ConflictPair</vh>
<v t="leo.20231205084805.550"><vh>cdef _Interval left, right</vh></v>
<v t="leo.20231205084805.551"><vh>__cinit__</vh></v>
<v t="leo.20231205084805.552"><vh>cdef void swap</vh></v>
<v t="leo.20231205084805.553"><vh>cdef int lowest</vh></v>
</v>
<v t="leo.20231205084805.554"><vh>cdef class _Interval</vh>
<v t="leo.20231205084805.555"><vh>cdef tuple low, high</vh></v>
<v t="leo.20231205084805.556"><vh>__cinit__</vh></v>
<v t="leo.20231205084805.557"><vh>cdef bint empty</vh></v>
<v t="leo.20231205084805.558"><vh>cdef _Interval copy</vh></v>
<v t="leo.20231205084805.559"><vh>cdef bint conflicting</vh></v>
</v>
<v t="leo.20231205084805.560"><vh>cdef class _PlanarEmbedding</vh>
<v t="leo.20231205084805.561"><vh>cdef map[int, int] node_label</vh></v>
<v t="leo.20231205084805.562"><vh>cdef map[ipair, ipair] edge_label</vh></v>
<v t="leo.20231205084805.563"><vh>cdef void add_half_edge_cw</vh>
<v t="leo.20231205084805.564"><vh>cdef int cw_reference = self.edge_label[ipair</vh></v>
</v>
<v t="leo.20231205084805.565"><vh>cdef void add_half_edge_ccw</vh>
<v t="leo.20231205084805.566"><vh>cdef int s_f_label</vh></v>
</v>
<v t="leo.20231205084805.567"><vh>cdef void add_half_edge_first</vh></v>
</v>
</v>
<v t="leo.20231205084805.568"><vh>@@clean structural.pyx</vh>
<v t="leo.20231205084805.569"><vh>cdef short[</vh>
<v t="leo.20231205084805.570"><vh>cdef short[</vh></v>
<v t="leo.20231205084805.571"><vh>cdef short[</vh></v>
<v t="leo.20231205084805.572"><vh>cdef short[</vh></v>
<v t="leo.20231205084805.573"><vh>cdef int n = np_prod</vh></v>
<v t="leo.20231205084805.574"><vh>cdef short[</vh></v>
<v t="leo.20231205084805.575"><vh>cdef int array0_size = len</vh></v>
<v t="leo.20231205084805.576"><vh>cdef int m = n / array0_size</vh></v>
<v t="leo.20231205084805.577"><vh>tmp1 = np_repeat(array0, m)</vh></v>
<v t="leo.20231205084805.578"><vh>cdef int j</vh></v>
</v>
<v t="leo.20231205084805.579"><vh>cdef short[</vh></v>
<v t="leo.20231205084805.580"><vh>cdef inline int _m_max</vh></v>
<v t="leo.20231205084805.581"><vh>cdef inline int _sum_factors</vh></v>
<v t="leo.20231205084805.582"><vh>cpdef list link_synthesis</vh>
<v t="leo.20231205084805.583"><vh>cdef int m_max_v = _m_max</vh></v>
<v t="leo.20231205084805.584"><vh>if m_max_v == -1:</vh></v>
<v t="leo.20231205084805.585"><vh>cdef int i, p</vh></v>
<v t="leo.20231205084805.586"><vh>cdef short[</vh></v>
</v>
<v t="leo.20231205084805.587"><vh>cdef inline int _j_m</vh>
<v t="leo.20231205084805.588"><vh>cdef int num</vh></v>
<v t="leo.20231205084805.589"><vh>cdef int i = 3</vh></v>
<v t="leo.20231205084805.590"><vh>cdef float c = 0</vh></v>
</v>
<v t="leo.20231205084805.591"><vh>cdef inline int _j_m_p</vh></v>
<v t="leo.20231205084805.592"><vh>cpdef list contracted_link_synthesis</vh>
<v t="leo.20231205084805.593"><vh>cdef short[</vh></v>
<v t="leo.20231205084805.594"><vh>if len(link_num_list) == 1:</vh></v>
<v t="leo.20231205084805.595"><vh>cdef int j_m_v = _j_m</vh></v>
<v t="leo.20231205084805.596"><vh>cdef int n_c_min = max</vh></v>
<v t="leo.20231205084805.597"><vh>cdef int n_c_max = min</vh></v>
<v t="leo.20231205084805.598"><vh>cdef int i_max = min</vh></v>
<v t="leo.20231205084805.599"><vh>cdef int count, factor, index</vh></v>
<v t="leo.20231205084805.600"><vh>cdef float last_factor</vh></v>
<v t="leo.20231205084805.601"><vh>cdef short[</vh></v>
</v>
<v t="leo.20231205084805.602"><vh>cdef inline short[</vh>
<v t="leo.20231205084805.603"><vh>cdef int i, n</vh></v>
</v>
<v t="leo.20231205084805.604"><vh>cdef inline ullong _factorial</vh></v>
<v t="leo.20231205084805.605"><vh>cdef inline int _gcd</vh>
<v t="leo.20231205084805.606"><vh>cdef int r</vh></v>
</v>
<v t="leo.20231205084805.607"><vh>cdef inline short[</vh>
<v t="leo.20231205084805.608"><vh>cdef int i, num</vh></v>
</v>
<v t="leo.20231205084805.609"><vh>cdef inline Graph _multigraph</vh>
<v t="leo.20231205084805.610"><vh>cdef int c = 0</vh></v>
<v t="leo.20231205084805.611"><vh>cdef int i, j</vh></v>
</v>
<v t="leo.20231205084805.612"><vh>cdef inline void _gauss_elimination</vh></v>
<v t="leo.20231205084805.613"><vh>):</vh></v>
<v t="leo.20231205084805.614"><vh>cdef int i, j, d</vh></v>
<v t="leo.20231205084805.615"><vh>cdef short[</vh></v>
<v t="leo.20231205084805.616"><vh>for j in range(var_count):</vh></v>
<v t="leo.20231205084805.617"><vh>cdef short[</vh></v>
<v t="leo.20231205084805.618"><vh>cdef int c, k</vh></v>
<v t="leo.20231205084805.619"><vh>for i in range(n):</vh></v>
<v t="leo.20231205084805.620"><vh>cdef void _nest_do</vh></v>
<v t="leo.20231205084805.621"><vh>):</vh></v>
<v t="leo.20231205084805.622"><vh>cdef short[</vh></v>
<v t="leo.20231205084805.623"><vh>cdef int c = 0</vh></v>
<v t="leo.20231205084805.624"><vh>cdef int j = -1</vh></v>
<v t="leo.20231205084805.625"><vh>cdef int d</vh></v>
<v t="leo.20231205084805.626"><vh>for d in coefficients:</vh></v>
<v t="leo.20231205084805.627"><vh>cdef short[</vh></v>
<v t="leo.20231205084805.628"><vh>for combine in _product((f_matrix[i, -1],) * c, stop_func):</vh></v>
<v t="leo.20231205084805.629"><vh>cdef inline bint _is_isomorphic</vh></v>
<v t="leo.20231205084805.630"><vh>cdef inline void _test_contracted_graph</vh></v>
<v t="leo.20231205084805.631"><vh>cdef inline void _test_graph</vh></v>
<v t="leo.20231205084805.632"><vh>):</vh></v>
<v t="leo.20231205084805.633"><vh>cdef inline void _contracted_graph</vh></v>
<v t="leo.20231205084805.634"><vh>):</vh></v>
<v t="leo.20231205084805.635"><vh>cdef int n = len</vh></v>
<v t="leo.20231205084805.636"><vh>cdef int var_count = n *</vh></v>
<v t="leo.20231205084805.637"><vh>cdef short[</vh></v>
<v t="leo.20231205084805.638"><vh>f_matrix[:, -1] = limit</vh></v>
<v t="leo.20231205084805.639"><vh>cdef int i, j, k, c</vh></v>
<v t="leo.20231205084805.640"><vh>for i in range(n):</vh></v>
<v t="leo.20231205084805.641"><vh>cdef inline void _dyad_insert</vh>
<v t="leo.20231205084805.642"><vh>cdef int last_num = max</vh></v>
<v t="leo.20231205084805.643"><vh>cdef int n1, n2</vh></v>
</v>
<v t="leo.20231205084805.644"><vh>cdef inline void _permute_combine</vh></v>
<v t="leo.20231205084805.645"><vh>):</vh></v>
<v t="leo.20231205084805.646"><vh>cdef int n = len</vh></v>
<v t="leo.20231205084805.647"><vh>if n &lt; 1:</vh></v>
<v t="leo.20231205084805.648"><vh>cdef vector[int] indices = range</vh></v>
<v t="leo.20231205084805.649"><vh>cdef short[</vh></v>
<v t="leo.20231205084805.650"><vh>cdef short[</vh></v>
<v t="leo.20231205084805.651"><vh>permute_list = set()</vh></v>
<v t="leo.20231205084805.652"><vh>cdef int i, j</vh></v>
<v t="leo.20231205084805.653"><vh>for i, j in enumerate(range(n, 0, -1)):</vh></v>
<v t="leo.20231205084805.654"><vh>cdef vector[int].iterator it2 = indices.begin</vh></v>
<v t="leo.20231205084805.655"><vh>cdef int tmp</vh></v>
<v t="leo.20231205084805.656"><vh>while True:</vh></v>
<v t="leo.20231205084805.657"><vh>cdef inline list _contracted_links</vh>
<v t="leo.20231205084805.658"><vh>cdef int pick_count = len</vh></v>
<v t="leo.20231205084805.659"><vh>if pick_count &lt; 1:</vh></v>
<v t="leo.20231205084805.660"><vh>cdef int confirm_size = sum</vh></v>
<v t="leo.20231205084805.661"><vh>if confirm_size &gt; pick_count or pick_count &gt; len(edges):</vh></v>
<v t="leo.20231205084805.662"><vh>cdef int pool_size = len</vh></v>
<v t="leo.20231205084805.663"><vh>cdef short[</vh></v>
<v t="leo.20231205084805.664"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.665"><vh>for i in range(pick_count):</vh></v>
<v t="leo.20231205084805.666"><vh>cdef int n1, n2</vh></v>
</v>
<v t="leo.20231205084805.667"><vh>cdef inline void _graph_atlas</vh></v>
<v t="leo.20231205084805.668"><vh>):</vh></v>
<v t="leo.20231205084805.669"><vh>cdef int n</vh></v>
<v t="leo.20231205084805.670"><vh>cdef Graph cg, g</vh></v>
<v t="leo.20231205084805.671"><vh>for cg in contracted_graph:</vh></v>
<v t="leo.20231205084805.672"><vh>cdef inline list _loop_chain</vh>
<v t="leo.20231205084805.673"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.674"><vh>cdef int b = 0</vh></v>
</v>
<v t="leo.20231205084805.675"><vh>cpdef list contracted_graph</vh>
<v t="leo.20231205084805.676"><vh>cdef double t0 = process_time</vh></v>
<v t="leo.20231205084805.677"><vh>cdef short[</vh></v>
<v t="leo.20231205084805.678"><vh>logger.debug(f"Link assortment: {list(link_num)}")</vh></v>
<v t="leo.20231205084805.679"><vh>cdef short[</vh></v>
<v t="leo.20231205084805.680"><vh>cdef imap m_limit, count</vh></v>
<v t="leo.20231205084805.681"><vh>cdef int num</vh></v>
<v t="leo.20231205084805.682"><vh>cdef int i = 0</vh></v>
</v>
<v t="leo.20231205084805.683"><vh>cpdef list conventional_graph</vh></v>
<v t="leo.20231205084805.684"><vh>):</vh></v>
<v t="leo.20231205084805.685"><vh>cdef double t0 = process_time</vh></v>
<v t="leo.20231205084805.686"><vh>logger.debug(f"Contracted link assortment: {list(c_j_list)}")</vh></v>
<v t="leo.20231205084805.687"><vh>cdef short[</vh></v>
<v t="leo.20231205084805.688"><vh>result = []</vh></v>
<v t="leo.20231205084805.689"><vh>cdef int i, num</vh></v>
<v t="leo.20231205084805.690"><vh>if not cg_list:</vh></v>
<v t="leo.20231205084805.691"><vh>cdef short[</vh></v>
</v>
</v>
<v t="leo.20231205084805.692"><vh>@path optimization</vh>
<v t="leo.20231205084805.693"><vh>@@clean f_planar.pyx</vh>
<v t="leo.20231205084805.694"><vh>norm_path</vh></v>
<v t="leo.20231205084805.695"><vh>cdef void _norm</vh>
<v t="leo.20231205084805.696"><vh>cdef CCoord centre = CCoord</vh></v>
<v t="leo.20231205084805.697"><vh>cdef double x, y</vh></v>
<v t="leo.20231205084805.698"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.699"><vh>for i in range(len(path)):</vh></v>
<v t="leo.20231205084805.700"><vh>cdef int end = len</vh></v>
<v t="leo.20231205084805.701"><vh>centre.x /= end</vh></v>
<v t="leo.20231205084805.702"><vh>cdef vector[double] angle = vector[double]</vh></v>
<v t="leo.20231205084805.703"><vh>cdef vector[double] length = vector[double]</vh></v>
<v t="leo.20231205084805.704"><vh>cdef int sp = 0</vh></v>
<v t="leo.20231205084805.705"><vh>for i in range(len(path)):</vh></v>
<v t="leo.20231205084805.706"><vh>cdef CCoord bound = CCoord</vh></v>
<v t="leo.20231205084805.707"><vh>cdef double a</vh></v>
</v>
<v t="leo.20231205084805.708"><vh>cdef void roll</vh>
<v t="leo.20231205084805.709"><vh>cdef double[</vh></v>
</v>
<v t="leo.20231205084805.710"><vh>curvature</vh>
<v t="leo.20231205084805.711"><vh>cdef double[</vh></v>
</v>
<v t="leo.20231205084805.712"><vh>cdef double[</vh>
<v t="leo.20231205084805.713"><vh>cdef double[</vh></v>
<v t="leo.20231205084805.714"><vh>cdef double[</vh></v>
<v t="leo.20231205084805.715"><vh>cdef double[</vh></v>
<v t="leo.20231205084805.716"><vh>with gil:</vh></v>
<v t="leo.20231205084805.717"><vh>cdef int i</vh></v>
</v>
<v t="leo.20231205084805.718"><vh>derivative</vh></v>
<v t="leo.20231205084805.719"><vh>cdef double[</vh>
<v t="leo.20231205084805.720"><vh>cdef double[</vh></v>
<v t="leo.20231205084805.721"><vh>with gil:</vh></v>
<v t="leo.20231205084805.722"><vh>cdef double max0 = 0</vh></v>
<v t="leo.20231205084805.723"><vh>cdef double max1 = 0</vh></v>
<v t="leo.20231205084805.724"><vh>cdef int i, j</vh></v>
</v>
<v t="leo.20231205084805.725"><vh>path_signature</vh></v>
<v t="leo.20231205084805.726"><vh>cdef double[</vh>
<v t="leo.20231205084805.727"><vh>cdef double[</vh></v>
<v t="leo.20231205084805.728"><vh>with gil:</vh></v>
<v t="leo.20231205084805.729"><vh>cdef double interval = maximum / len</vh></v>
<v t="leo.20231205084805.730"><vh>cdef double v = 0</vh></v>
<v t="leo.20231205084805.731"><vh>cdef int i</vh></v>
</v>
<v t="leo.20231205084805.732"><vh>cross_correlation</vh></v>
<v t="leo.20231205084805.733"><vh>cdef double[</vh>
<v t="leo.20231205084805.734"><vh>cdef double[</vh></v>
<v t="leo.20231205084805.735"><vh>cdef double[</vh></v>
<v t="leo.20231205084805.736"><vh>p1 = concatenate((p1, p1))</vh></v>
<v t="leo.20231205084805.737"><vh>cdef int s1 = len</vh></v>
<v t="leo.20231205084805.738"><vh>cdef int s2 = len</vh></v>
<v t="leo.20231205084805.739"><vh>cdef int n = s1 + s2 - 1</vh></v>
</v>
<v t="leo.20231205084805.740"><vh>cdef double _extr1d</vh>
<v t="leo.20231205084805.741"><vh>cdef double m = -INF if op else INF</vh></v>
</v>
<v t="leo.20231205084805.742"><vh>cdef void _mul1d</vh></v>
<v t="leo.20231205084805.743"><vh>cdef double[</vh>
<v t="leo.20231205084805.744"><vh>cdef int first = -1</vh></v>
<v t="leo.20231205084805.745"><vh>cdef int second = -1</vh></v>
<v t="leo.20231205084805.746"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.747"><vh>cdef double v</vh></v>
</v>
<v t="leo.20231205084805.748"><vh>cdef class FPlanar</vh>
<v t="leo.20231205084805.749"><vh>cdef bint bfgs_mode, shape_only, use_curvature, full_path, ordered</vh></v>
<v t="leo.20231205084805.750"><vh>cdef int target_count, target_len, input_count, l_base</vh></v>
<v t="leo.20231205084805.751"><vh>cdef public unsigned long callback</vh></v>
<v t="leo.20231205084805.752"><vh>cdef list vpoints</vh></v>
<v t="leo.20231205084805.753"><vh>cdef long[</vh></v>
<v t="leo.20231205084805.754"><vh>cdef double[</vh></v>
<v t="leo.20231205084805.755"><vh>cdef EStack exprs</vh></v>
<v t="leo.20231205084805.756"><vh>cdef cset[int] slider</vh></v>
<v t="leo.20231205084805.757"><vh>cdef map[Sym, CCoord] joint_pos</vh></v>
<v t="leo.20231205084805.758"><vh>cdef map[Sym, double] param</vh></v>
<v t="leo.20231205084805.759"><vh>__cinit__</vh>
<v t="leo.20231205084805.760"><vh>cdef int i, j</vh></v>
<v t="leo.20231205084805.761"><vh>cdef double[</vh></v>
<v t="leo.20231205084805.762"><vh>for i, j in enumerate(target):</vh></v>
<v t="leo.20231205084805.763"><vh>cdef double x, y, r</vh></v>
<v t="leo.20231205084805.764"><vh>for i in self.pivots:</vh></v>
<v t="leo.20231205084805.765"><vh>cdef Expr expr</vh></v>
</v>
<v t="leo.20231205084805.766"><vh>cpdef bint is_two_kernel</vh></v>
<v t="leo.20231205084805.767"><vh>cdef double fitness</vh>
<v t="leo.20231205084805.768"><vh>cdef map[int, vector[CCoord]] target</vh></v>
<v t="leo.20231205084805.769"><vh>cdef map[Sym, double] param = map[Sym, double]</vh></v>
<v t="leo.20231205084805.770"><vh>cdef map[Sym, CCoord] joint_pos = map[Sym, CCoord]</vh></v>
<v t="leo.20231205084805.771"><vh>cdef bint ok</vh></v>
<v t="leo.20231205084805.772"><vh>cdef int i, j, node, vi</vh></v>
<v t="leo.20231205084805.773"><vh>cdef double x, y</vh></v>
<v t="leo.20231205084805.774"><vh>cdef Expr expr</vh></v>
<v t="leo.20231205084805.775"><vh>cdef CCoord c</vh></v>
<v t="leo.20231205084805.776"><vh>cdef pair[Sym, CCoord] jp</vh></v>
<v t="leo.20231205084805.777"><vh>for i in range(self.target_len):</vh></v>
<v t="leo.20231205084805.778"><vh>cdef double fitness = 0</vh></v>
<v t="leo.20231205084805.779"><vh>cdef double scale</vh></v>
<v t="leo.20231205084805.780"><vh>cdef double[</vh></v>
</v>
<v t="leo.20231205084805.781"><vh>cpdef object result</vh>
<v t="leo.20231205084805.782"><vh>cdef map[Sym, double] param = map[Sym, double]</vh></v>
<v t="leo.20231205084805.783"><vh>cdef map[Sym, CCoord] joint_pos = map[Sym, CCoord]</vh></v>
<v t="leo.20231205084805.784"><vh>cdef int vi = 0</vh></v>
<v t="leo.20231205084805.785"><vh>cdef int node</vh></v>
<v t="leo.20231205084805.786"><vh>for node in self.pivots:</vh></v>
<v t="leo.20231205084805.787"><vh>cdef Expr expr</vh></v>
<v t="leo.20231205084805.788"><vh>for expr in self.exprs.stack:</vh></v>
<v t="leo.20231205084805.789"><vh>cdef pair[Sym, CCoord] jp</vh></v>
<v t="leo.20231205084805.790"><vh>if self.bfgs_mode:</vh></v>
<v t="leo.20231205084805.791"><vh>cdef CCoord c</vh></v>
<v t="leo.20231205084805.792"><vh>cdef VPoint vp</vh></v>
<v t="leo.20231205084805.793"><vh>cdef double x, y</vh></v>
</v>
</v>
</v>
<v t="leo.20231205084805.794"><vh>@@clean n_planar.pyx</vh>
<v t="leo.20231205084805.795"><vh>cdef double a = v1[1] / v1[0]</vh></v>
<v t="leo.20231205084805.796"><vh>cdef double b = y_mean - a * x_mean</vh></v>
<v t="leo.20231205084805.797"><vh>cdef double neg_x = 0</vh></v>
<v t="leo.20231205084805.798"><vh>cdef double neg_y = 0</vh></v>
<v t="leo.20231205084805.799"><vh>cdef double pos_x = 0</vh></v>
<v t="leo.20231205084805.800"><vh>cdef double pos_y = 0</vh></v>
<v t="leo.20231205084805.801"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.802"><vh>cdef double val, x, y</vh></v>
<v t="leo.20231205084805.803"><vh>for i in range(len(p1)):</vh></v>
<v t="leo.20231205084805.804"><vh>cdef double neg_dist = sqrt</vh></v>
<v t="leo.20231205084805.805"><vh>cdef double pos_dist = sqrt</vh></v>
<v t="leo.20231205084805.806"><vh>x = abs(v2[0])</vh></v>
<v t="leo.20231205084805.807"><vh>cdef double rotation_angle</vh>
<v t="leo.20231205084805.808"><vh>cdef double cxx = 0</vh></v>
<v t="leo.20231205084805.809"><vh>cdef double cyy = 0</vh></v>
<v t="leo.20231205084805.810"><vh>cdef double cxy = 0</vh></v>
<v t="leo.20231205084805.811"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.812"><vh>cdef double x, y</vh></v>
<v t="leo.20231205084805.813"><vh>for i in range(len(p1)):</vh></v>
<v t="leo.20231205084805.814"><vh>cdef double[</vh></v>
<v t="leo.20231205084805.815"><vh>with gil:</vh></v>
<v t="leo.20231205084805.816"><vh>cdef double a1 = atan2</vh></v>
<v t="leo.20231205084805.817"><vh>x, y = axes_v(v[:, 0], v[:, 1], p1, x_mean, y_mean)</vh></v>
<v t="leo.20231205084805.818"><vh>cdef double a2 = atan2</vh></v>
</v>
<v t="leo.20231205084805.819"><vh>cdef double[</vh></v>
<v t="leo.20231205084805.820"><vh>norm_pca</vh></v>
<v t="leo.20231205084805.821"><vh>cdef void _norm_pca</vh>
<v t="leo.20231205084805.822"><vh>cdef double x_mean = 0</vh></v>
<v t="leo.20231205084805.823"><vh>cdef double y_mean = 0</vh></v>
<v t="leo.20231205084805.824"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.825"><vh>for i in range(len(p1)):</vh></v>
<v t="leo.20231205084805.826"><vh>cdef double alpha = rotation_angle</vh></v>
<v t="leo.20231205084805.827"><vh>Normalized the path points</vh></v>
<v t="leo.20231205084805.828"><vh>cdef int ind = 0</vh></v>
<v t="leo.20231205084805.829"><vh>cdef double p1_max = -INF</vh></v>
<v t="leo.20231205084805.830"><vh>cdef double p1_min = INF</vh></v>
<v t="leo.20231205084805.831"><vh>cdef double d_min = INF</vh></v>
<v t="leo.20231205084805.832"><vh>cdef double d</vh></v>
</v>
<v t="leo.20231205084805.833"><vh>cdef void transform</vh>
<v t="leo.20231205084805.834"><vh>cdef double[</vh></v>
</v>
<v t="leo.20231205084805.835"><vh>cdef double trapezoidal_camp</vh>
<v t="leo.20231205084805.836"><vh>cdef double area = 0</vh></v>
<v t="leo.20231205084805.837"><vh>cdef int i</vh></v>
<v t="leo.20231205084805.838"><vh>cdef double right, left, total</vh></v>
</v>
<v t="leo.20231205084805.839"><vh>cdef class NPlanar</vh>
<v t="leo.20231205084805.840"><vh>cdef int len</vh></v>
<v t="leo.20231205084805.841"><vh>cdef double[</vh></v>
<v t="leo.20231205084805.842"><vh>__cinit__</vh></v>
<v t="leo.20231205084805.843"><vh>cdef double fitness</vh>
<v t="leo.20231205084805.844"><vh>cdef double[</vh></v>
<v t="leo.20231205084805.845"><vh>cdef int i</vh></v>
</v>
<v t="leo.20231205084805.846"><vh>cpdef object path</vh></v>
<v t="leo.20231205084805.847"><vh>cpdef object result</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="leo.20231205084805.850"><vh>@path solvespace</vh>
<v t="leo.20231205084806.1"><vh>@path cython</vh>
<v t="leo.20231205084806.3"><vh>@path python_solvespace</vh>
<v t="leo.20231205084806.4"><vh>@@clean slvs.pyx</vh>
<v t="leo.20231205084806.5"><vh>_create_sys</vh>
<v t="leo.20231205084806.6"><vh>cdef SolverSystem s = SolverSystem.__new__</vh></v>
</v>
<v t="leo.20231205084806.7"><vh>cpdef tuple quaternion_u</vh>
<v t="leo.20231205084806.8"><vh>cdef double x, y, z</vh></v>
</v>
<v t="leo.20231205084806.9"><vh>cpdef tuple quaternion_v</vh>
<v t="leo.20231205084806.10"><vh>cdef double x, y, z</vh></v>
</v>
<v t="leo.20231205084806.11"><vh>cpdef tuple quaternion_n</vh>
<v t="leo.20231205084806.12"><vh>cdef double x, y, z</vh></v>
</v>
<v t="leo.20231205084806.13"><vh>cpdef tuple make_quaternion</vh>
<v t="leo.20231205084806.14"><vh>cdef double qw, qx, qy, qz</vh></v>
</v>
<v t="leo.20231205084806.15"><vh>class Constraint</vh></v>
<v t="leo.20231205084806.16"><vh>class ResultFlag</vh></v>
<v t="leo.20231205084806.17"><vh>cdef class Params</vh>
<v t="leo.20231205084806.18"><vh>cdef Params create</vh></v>
<v t="leo.20231205084806.19"><vh>__richcmp__</vh></v>
<v t="leo.20231205084806.20"><vh>__repr__</vh>
<v t="leo.20231205084806.21"><vh>cdef size_t i</vh></v>
<v t="leo.20231205084806.22"><vh>cdef size_t s = self.param_list.size</vh></v>
</v>
</v>
<v t="leo.20231205084806.23"><vh>cdef Entity _E_FREE_IN_3D = Entity.__new__</vh></v>
<v t="leo.20231205084806.24"><vh>_E_FREE_IN_3D.t = SLVS_E_WORKPLANE</vh></v>
<v t="leo.20231205084806.25"><vh>cdef Entity _E_NONE = Entity.__new__</vh></v>
<v t="leo.20231205084806.26"><vh>_E_NONE.t = 0</vh></v>
<v t="leo.20231205084806.27"><vh>cdef class Entity</vh>
<v t="leo.20231205084806.28"><vh>cdef Entity create</vh>
<v t="leo.20231205084806.29"><vh>cdef Entity entity = Entity.__new__</vh></v>
<v t="leo.20231205084806.30"><vh>with nogil:</vh></v>
<v t="leo.20231205084806.31"><vh>cdef size_t p_size</vh></v>
</v>
<v t="leo.20231205084806.32"><vh>__richcmp__</vh></v>
<v t="leo.20231205084806.33"><vh>cpdef bint is_3d</vh></v>
<v t="leo.20231205084806.34"><vh>cpdef bint is_none</vh></v>
<v t="leo.20231205084806.35"><vh>cpdef bint is_point_2d</vh></v>
<v t="leo.20231205084806.36"><vh>cpdef bint is_point_3d</vh></v>
<v t="leo.20231205084806.37"><vh>cpdef bint is_point</vh></v>
<v t="leo.20231205084806.38"><vh>cpdef bint is_normal_2d</vh></v>
<v t="leo.20231205084806.39"><vh>cpdef bint is_normal_3d</vh></v>
<v t="leo.20231205084806.40"><vh>cpdef bint is_normal</vh></v>
<v t="leo.20231205084806.41"><vh>cpdef bint is_distance</vh></v>
<v t="leo.20231205084806.42"><vh>cpdef bint is_work_plane</vh></v>
<v t="leo.20231205084806.43"><vh>cpdef bint is_line_2d</vh></v>
<v t="leo.20231205084806.44"><vh>cpdef bint is_line_3d</vh></v>
<v t="leo.20231205084806.45"><vh>cpdef bint is_line</vh></v>
<v t="leo.20231205084806.46"><vh>cpdef bint is_cubic</vh></v>
<v t="leo.20231205084806.47"><vh>cpdef bint is_circle</vh></v>
<v t="leo.20231205084806.48"><vh>cpdef bint is_arc</vh></v>
<v t="leo.20231205084806.49"><vh>__repr__</vh>
<v t="leo.20231205084806.50"><vh>cdef int h = &lt;int&gt;self.h</vh></v>
<v t="leo.20231205084806.51"><vh>cdef int g = &lt;int&gt;self.g</vh></v>
<v t="leo.20231205084806.52"><vh>cdef str t = _NAME_OF_ENTITIES[&lt;int&gt;self.t]</vh></v>
</v>
</v>
<v t="leo.20231205084806.53"><vh>cdef class SolverSystem</vh>
<v t="leo.20231205084806.54"><vh>__cinit__</vh></v>
<v t="leo.20231205084806.55"><vh>__reduce__</vh></v>
<v t="leo.20231205084806.56"><vh>entity</vh></v>
<v t="leo.20231205084806.57"><vh>cpdef SolverSystem copy</vh></v>
<v t="leo.20231205084806.58"><vh>cpdef void clear</vh></v>
<v t="leo.20231205084806.59"><vh>cpdef void set_group</vh></v>
<v t="leo.20231205084806.60"><vh>cpdef int group</vh></v>
<v t="leo.20231205084806.61"><vh>cpdef void set_params</vh>
<v t="leo.20231205084806.62"><vh>cdef int i = 0</vh></v>
<v t="leo.20231205084806.63"><vh>cdef Slvs_hParam h</vh></v>
</v>
<v t="leo.20231205084806.64"><vh>cpdef list params</vh>
<v t="leo.20231205084806.65"><vh>cdef Slvs_hParam h</vh></v>
</v>
<v t="leo.20231205084806.66"><vh>cpdef int dof</vh></v>
<v t="leo.20231205084806.67"><vh>cpdef object constraints</vh>
<v t="leo.20231205084806.68"><vh>cdef Slvs_Constraint con</vh></v>
</v>
<v t="leo.20231205084806.69"><vh>cpdef list failures</vh></v>
<v t="leo.20231205084806.70"><vh>cdef int solve_c</vh>
<v t="leo.20231205084806.71"><vh>cdef Slvs_System sys</vh></v>
</v>
<v t="leo.20231205084806.72"><vh>solve</vh></v>
<v t="leo.20231205084806.73"><vh>cpdef size_t param_len</vh></v>
<v t="leo.20231205084806.74"><vh>cpdef size_t entity_len</vh></v>
<v t="leo.20231205084806.75"><vh>cpdef size_t cons_len</vh></v>
<v t="leo.20231205084806.76"><vh>cpdef Entity create_2d_base</vh></v>
<v t="leo.20231205084806.77"><vh>cdef inline Slvs_hParam new_param</vh></v>
<v t="leo.20231205084806.78"><vh>cdef inline Slvs_hEntity eh</vh></v>
<v t="leo.20231205084806.79"><vh>cpdef Entity add_point_2d</vh>
<v t="leo.20231205084806.80"><vh>cdef Slvs_hParam u_p = self.new_param</vh></v>
<v t="leo.20231205084806.81"><vh>cdef Slvs_hParam v_p = self.new_param</vh></v>
</v>
<v t="leo.20231205084806.82"><vh>cpdef Entity add_point_3d</vh>
<v t="leo.20231205084806.83"><vh>cdef Slvs_hParam x_p = self.new_param</vh></v>
<v t="leo.20231205084806.84"><vh>cdef Slvs_hParam y_p = self.new_param</vh></v>
<v t="leo.20231205084806.85"><vh>cdef Slvs_hParam z_p = self.new_param</vh></v>
</v>
<v t="leo.20231205084806.86"><vh>cpdef Entity add_normal_2d</vh></v>
<v t="leo.20231205084806.87"><vh>cpdef Entity add_normal_3d</vh>
<v t="leo.20231205084806.88"><vh>cdef Slvs_hParam w_p = self.new_param</vh></v>
<v t="leo.20231205084806.89"><vh>cdef Slvs_hParam x_p = self.new_param</vh></v>
<v t="leo.20231205084806.90"><vh>cdef Slvs_hParam y_p = self.new_param</vh></v>
<v t="leo.20231205084806.91"><vh>cdef Slvs_hParam z_p = self.new_param</vh></v>
</v>
<v t="leo.20231205084806.92"><vh>cpdef Entity add_distance</vh>
<v t="leo.20231205084806.93"><vh>cdef Slvs_hParam d_p = self.new_param</vh></v>
</v>
<v t="leo.20231205084806.94"><vh>cpdef Entity add_line_2d</vh></v>
<v t="leo.20231205084806.95"><vh>cpdef Entity add_line_3d</vh></v>
<v t="leo.20231205084806.96"><vh>cpdef Entity add_cubic</vh></v>
<v t="leo.20231205084806.97"><vh>cpdef Entity add_arc</vh></v>
<v t="leo.20231205084806.98"><vh>cpdef Entity add_circle</vh></v>
<v t="leo.20231205084806.99"><vh>cpdef Entity add_work_plane</vh></v>
<v t="leo.20231205084806.100"><vh>cpdef void add_constraint</vh></v>
<v t="leo.20231205084806.101"><vh>):</vh></v>
<v t="leo.20231205084806.102"><vh>cdef Entity e</vh></v>
<v t="leo.20231205084806.103"><vh>for e in (p1, p2):</vh></v>
<v t="leo.20231205084806.104"><vh>cdef Slvs_Constraint c</vh></v>
<v t="leo.20231205084806.105"><vh>c.h = &lt;Slvs_hConstraint&gt;self.cons_list.size() + 1</vh></v>
<v t="leo.20231205084806.106"><vh>cpdef void coincident</vh></v>
<v t="leo.20231205084806.107"><vh>cpdef void distance</vh></v>
<v t="leo.20231205084806.108"><vh>):</vh></v>
<v t="leo.20231205084806.109"><vh>cpdef void equal</vh></v>
<v t="leo.20231205084806.110"><vh>cpdef void equal_angle</vh></v>
<v t="leo.20231205084806.111"><vh>):</vh></v>
<v t="leo.20231205084806.112"><vh>cpdef void equal_point_to_line</vh></v>
<v t="leo.20231205084806.113"><vh>):</vh></v>
<v t="leo.20231205084806.114"><vh>cpdef void ratio</vh></v>
<v t="leo.20231205084806.115"><vh>cpdef void symmetric</vh></v>
<v t="leo.20231205084806.116"><vh>):</vh></v>
<v t="leo.20231205084806.117"><vh>cpdef void symmetric_h</vh></v>
<v t="leo.20231205084806.118"><vh>cpdef void symmetric_v</vh></v>
<v t="leo.20231205084806.119"><vh>cpdef void midpoint</vh></v>
<v t="leo.20231205084806.120"><vh>):</vh></v>
<v t="leo.20231205084806.121"><vh>cpdef void horizontal</vh></v>
<v t="leo.20231205084806.122"><vh>cpdef void vertical</vh></v>
<v t="leo.20231205084806.123"><vh>cpdef void diameter</vh></v>
<v t="leo.20231205084806.124"><vh>cpdef void same_orientation</vh></v>
<v t="leo.20231205084806.125"><vh>cpdef void angle</vh></v>
<v t="leo.20231205084806.126"><vh>cpdef void perpendicular</vh></v>
<v t="leo.20231205084806.127"><vh>cpdef void parallel</vh></v>
<v t="leo.20231205084806.128"><vh>cpdef void tangent</vh></v>
<v t="leo.20231205084806.129"><vh>cpdef void distance_proj</vh></v>
<v t="leo.20231205084806.130"><vh>cpdef void dragged</vh></v>
<v t="leo.20231205084806.131"><vh>cpdef void length_diff</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="leo.20231202195533.2">'''Recursively import all python files in a directory and clean the result.'''
# ctrl + b to execute
 
c.recursiveImport(
    dir_ = 'Y:/tmp/metapyslvs/',
    kind = '@@clean', # The new best practice.
    safe_at_file = False,
    theTypes = ['.py']
)</t>
<t tx="leo.20231202195600.1"></t>
<t tx="leo.20231202195600.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="leo.20231202195600.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="leo.20231205082558.1">pyslvs
Pyslvs-UI
metaheuristics</t>
<t tx="leo.20231205083732.1">'''Recursively import all python files in a directory and clean the result.'''
# ctrl + b to execute
 
c.recursiveImport(
    dir_ = 'Y:/tmp/metapyslvs/',
    kind = '@@clean', # The new best practice.
    safe_at_file = False,
    theTypes = ['.pyx']
)</t>
<t tx="leo.20231205084737.1"></t>
<t tx="leo.20231205084737.2"></t>
<t tx="leo.20231205084737.3"></t>
<t tx="leo.20231205084738.1"></t>
<t tx="leo.20231205084738.10">def __init__(
    self,
    vpoints: List[VPoint],
    vlinks: List[VLink],
    row: Union[int, bool],
    parent: QWidget
):
    """Input data reference from main window.

    + Needs VPoints and VLinks information.
    + If row is false: Create action.
    """
    super(EditLinkDialog, self).__init__(parent)
    self.setupUi(self)
    self.setWindowFlags(self.windowFlags()
                        &amp; ~Qt.WindowContextHelpButtonHint)
    self.vpoints = vpoints
    self.vlinks = vlinks
    icon = self.windowIcon()
    self.icon = QIcon(QPixmap("icons:bearing.png"))
    for i, e in enumerate(color_names):
        self.color_box.insertItem(i, color_icon(e), e)
    for i in range(len(self.vpoints)):
        self.no_selected.addItem(QListWidgetItem(self.icon, f'Point{i}'))
    if row is False:
        names = {vlink.name for vlink in self.vlinks}
        n = 1
        name = f"link_{n}"
        while name in names:
            n += 1
            name = f"link_{n}"
        self.name_edit.setText(name)
        self.name_box.setEnabled(False)
        self.name_box.addItem(icon, "New link")
        self.color_box.setCurrentIndex(self.color_box.findText('blue'))
    else:
        for i, vlink in enumerate(self.vlinks):
            self.name_box.insertItem(i, icon, vlink.name)
        self.name_box.setCurrentIndex(row)
    self.name_edit.textChanged.connect(self.__is_ok)
    self.__is_ok()

</t>
<t tx="leo.20231205084738.100">def distance(self, n1: int, n2: int) -&gt; float:
    """Return the distance of two point."""
    x1, y1 = self.pos[n1]
    x2, y2 = self.pos[n2]
    return hypot(x1 - x2, y1 - y2)
</t>
<t tx="leo.20231205084738.101">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/graphics/
# -*- coding: utf-8 -*-

"""Chart dialog of Pyslvs.

This part is using PyQtChart module.
"""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Sequence, List
from qtpy.QtCore import Qt
from qtpy.QtWidgets import QWidget, QVBoxLayout, QDialog
from matplotlib.axes import Axes
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import (
    FigureCanvasQTAgg,
    NavigationToolbar2QT,
)


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.102">class DataChart(QWidget):
    """Chart widget."""
    _ax: List[Axes]

    @others
</t>
<t tx="leo.20231205084738.103">def __init__(self, parent: QWidget, row: int = 1, col: int = 1,
             polar: bool = False):
    """Input title and two axises, QChart class has no parent."""
    super(DataChart, self).__init__(parent)
    layout = QVBoxLayout(self)
    figure = Figure()
    canvas = FigureCanvasQTAgg(figure)
    layout.addWidget(NavigationToolbar2QT(canvas, self))
    layout.addWidget(canvas)
    self._ax = []
    for i in range(1, row * col + 1):
        self._ax.append(figure.add_subplot(row, col, i, polar=polar))

    def set_margin(m: float) -&gt; None:
        figure.tight_layout(pad=m)

    self.set_margin = set_margin

</t>
<t tx="leo.20231205084738.104">def ax(self) -&gt; Sequence[Axes]:
    """Return figure."""
    return self._ax


</t>
<t tx="leo.20231205084738.105">class DataChartDialog(QDialog):
    """Dialog container."""

    @others
</t>
<t tx="leo.20231205084738.106">def __init__(self, parent: QWidget, title: str, row: int = 1, col: int = 1,
             polar: bool = False):
    super(DataChartDialog, self).__init__(parent)
    self.setWindowFlags(self.windowFlags() | Qt.WindowMaximizeButtonHint
                        &amp; ~Qt.WindowContextHelpButtonHint)
    self.setWindowTitle(title)
    self.setModal(True)
    layout = QVBoxLayout(self)
    self._chart = DataChart(self, row, col, polar)
    layout.addWidget(self._chart)

</t>
<t tx="leo.20231205084738.107">def ax(self) -&gt; Sequence[Axes]:
    """Wrapper method."""
    return self._chart.ax()

</t>
<t tx="leo.20231205084738.108">def set_margin(self, m: float) -&gt; None:
    """Wrapper method."""
    self._chart.set_margin(m)
</t>
<t tx="leo.20231205084738.109">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/graphics/
# -*- coding: utf-8 -*-

"""All color options in Pyslvs."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Tuple, Union
from qtpy.QtCore import QSize
from qtpy.QtGui import QColor, QIcon, QPixmap
from pyslvs import color_names, color_rgb

_Color = Union[str, Tuple[int, int, int], None]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.11">@Slot()
def __is_ok(self) -&gt; None:
    """Set button box enable if options are ok."""
    self.btn_box.button(QDialogButtonBox.Ok).setEnabled(
        self.__legal_name(self.name_edit.text())
    )

</t>
<t tx="leo.20231205084738.110">def color_qt(color: _Color) -&gt; QColor:
    """Get color and translate to QColor."""
    if color is None:
        color = "green"
    if isinstance(color, str):
        return QColor(*color_rgb(color))
    else:
        return QColor(*color)


</t>
<t tx="leo.20231205084738.111">def color_num(color_index: int) -&gt; QColor:
    """Get color by index."""
    return color_qt(color_names[color_index % len(color_names)])


</t>
<t tx="leo.20231205084738.112">def color_icon(name: _Color, size: int = 20) -&gt; QIcon:
    """Get color block as QIcon by name."""
    color_block = QPixmap(QSize(size, size))
    color_block.fill(color_qt(name))
    return QIcon(color_block)


</t>
<t tx="leo.20231205084738.113"># Target path color: (line, dot)
_path_color = (
    (color_qt('dark-gray'), color_qt('black')),
    (color_qt('red'), color_qt('dark-red')),
    (color_qt('blue'), color_qt('dark-blue')),
)


</t>
<t tx="leo.20231205084738.114">def target_path_style(color_index: int) -&gt; Tuple[QColor, QColor]:
    """Get path colors."""
    return _path_color[color_index % len(_path_color)]
</t>
<t tx="leo.20231205084738.115">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/graphics/
# -*- coding: utf-8 -*-

"""Painting function of NetworkX."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Mapping, Tuple, Optional
from qtpy.QtCore import Qt, QSize, QPointF, QLineF
from qtpy.QtGui import QImage, QPainter, QBrush, QPen, QIcon, QPixmap, QFont
from pyslvs import edges_view
from pyslvs.graph import Graph, external_loop_layout
from pyslvs_ui.info import logger
from .color import color_qt, color_num
from .canvas import convex_hull, LINK_COLOR

_Pos = Mapping[int, Tuple[float, float]]

engines = (
    "External Loop",
)

_font = QFont("Monospace")
_font.setBold(True)
_font.setStyleHint(QFont.TypeWriter)


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.116">def engine_picker(g: Graph, engine: str, node_mode: bool) -&gt; _Pos:
    """Generate a position dict."""
    if engine == "External Loop":
        try:
            layout: _Pos = external_loop_layout(g, node_mode, scale=30)
        except ValueError as error:
            logger.warn(error)
            return {}
    else:
        raise ValueError(f"engine {engine} is not exist")

    inf = float('inf')
    x_max = -inf
    x_min = inf
    y_max = -inf
    y_min = inf
    for x, y in layout.values():
        if x &gt; x_max:
            x_max = x
        if x &lt; x_min:
            x_min = x
        if y &gt; y_max:
            y_max = y
        if y &lt; y_min:
            y_min = y
    x_cen = (x_max + x_min) / 2
    y_cen = (y_max + y_min) / 2
    return {node: (x - x_cen, y - y_cen) for node, (x, y) in layout.items()}


</t>
<t tx="leo.20231205084738.117">def graph2icon(
    g: Graph,
    width: int,
    node_mode: bool,
    show_label: bool,
    monochrome: bool,
    *,
    except_node: Optional[int] = None,
    engine: str = "",
    pos: Optional[_Pos] = None
) -&gt; QIcon:
    """Draw a generalized chain graph."""
    if engine:
        pos = engine_picker(g, engine, node_mode)
    if pos is None:
        raise ValueError("no engine selected")
    if not pos:
        pixmap = QPixmap(width, width)
        pixmap.fill(Qt.transparent)
        return QIcon(pixmap)

    width_bound = -float('inf')
    for x, y in pos.values():
        if abs(x) &gt; width_bound:
            width_bound = x
        if abs(y) &gt; width_bound:
            width_bound = y
    width_bound *= 2.5
    image = QImage(
        QSize(int(width_bound), int(width_bound)),
        QImage.Format_ARGB32_Premultiplied
    )
    image.fill(Qt.transparent)
    painter = QPainter(image)
    painter.translate(image.width() / 2, image.height() / 2)
    pen = QPen()
    r = int(width_bound / 50)
    pen.setWidth(r)
    painter.setPen(pen)
    _font.setPixelSize(r * 6)
    painter.setFont(_font)

    # Draw edges
    if node_mode:
        for l1, l2 in g.edges:
            if except_node in {l1, l2}:
                pen.setColor(Qt.gray)
            else:
                pen.setColor(Qt.black)
            painter.setPen(pen)
            painter.drawLine(QLineF(pos[l1][0], -pos[l1][1], pos[l2][0], -pos[l2][1]))
    else:
        color = color_qt('dark-gray') if monochrome else LINK_COLOR
        color.setAlpha(150)
        painter.setBrush(QBrush(color))
        for link in g.vertices:
            if link == except_node:
                pen.setColor(Qt.gray)
            else:
                pen.setColor(Qt.black)
            painter.setPen(pen)

            painter.drawPolygon(*convex_hull([
                (pos[n][0], -pos[n][1])
                for n, edge in edges_view(g) if link in edge
            ], as_qpoint=True))

    # Draw vertices
    for k, (x, y) in pos.items():
        if node_mode:
            color = color_num(len(list(g.neighbors(k))) - 1)
            if k == except_node:
                color.setAlpha(150)
        else:
            if monochrome:
                color = Qt.black
            elif except_node in dict(edges_view(g))[k]:
                color = color_qt('green')
            else:
                color = color_qt('blue')
        pen.setColor(color)
        painter.setPen(pen)
        painter.setBrush(QBrush(color))
        point = QPointF(x, -y)
        painter.drawEllipse(point, r, r)
        if show_label:
            pen.setColor(Qt.darkMagenta)
            painter.setPen(pen)
            painter.drawText(point, str(k))
    painter.end()
    return QIcon(QPixmap.fromImage(image).scaledToWidth(width))
</t>
<t tx="leo.20231205084738.118">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/graphics/
# -*- coding: utf-8 -*-

"""Lark parser to parse the ambiguous path."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import cast, Tuple, List, Union
from lark import Lark, Transformer, Tree

_GRAMMAR = Lark(r"""
// Number
DIGIT: "0".."9"
INT: DIGIT+
SIGNED_INT: ["+" | "-"] INT
DECIMAL: INT "." INT? | "." INT
_EXP: ("e" | "E") SIGNED_INT
FLOAT: INT _EXP | DECIMAL _EXP?
NUMBER: FLOAT | INT
SIGNED_NUMBER: ["+" | "-"] NUMBER
number: SIGNED_NUMBER

// White space and new line
WS: /[ \t]+/
CR: /\r/
LF: /\n/
_NEWLINE: (CR? LF)+
%ignore WS

// Main grammar
coord: number ","? number
?coord_style: "[" coord "]" | "(" coord ")" | coord
line: (coord_style (";" | ",")? _NEWLINE*)+
?start: line
""", parser='lalr')


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.119">class _Transformer(Transformer):
    """Transform into 2D coordinates data."""

    @others
</t>
<t tx="leo.20231205084738.12">def __legal_name(self, name: str) -&gt; bool:
    """Return this name is usable or not."""
    if not match("^[A-Za-z0-9_-]+$", name):
        return False
    for i, vlink in enumerate(self.vlinks):
        if i != self.name_box.currentIndex() and name == vlink.name:
            return False
    return True

</t>
<t tx="leo.20231205084738.120">@staticmethod
def number(n: List[str]) -&gt; float:
    return float(n[0])

</t>
<t tx="leo.20231205084738.121">@staticmethod
def complex(n: List[str]) -&gt; float:
    return float(n[0][:-1])

</t>
<t tx="leo.20231205084738.122">@staticmethod
def coord(n: Tuple[float, Union[float, Tree]]) -&gt; Tuple[float, float]:
    if isinstance(n[1], float):
        return n[0], n[1]
    else:
        return n[0], float(cast(str, n[1].children[0]))

</t>
<t tx="leo.20231205084738.123">@staticmethod
def line(n):
    return n


</t>
<t tx="leo.20231205084738.124">_translator = _Transformer()


</t>
<t tx="leo.20231205084738.125">def parse_path(path: str) -&gt; List[Tuple[float, float]]:
    """Parse path from csv."""
    return _translator.transform(_GRAMMAR.parse(path))
</t>
<t tx="leo.20231205084738.126">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/graphics/
# -*- coding: utf-8 -*-

"""'graphics' module contains custom display widgets."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from .color import color_num, color_icon, color_qt, target_path_style
from .chart import DataChart, DataChartDialog
from .canvas import (
    LINK_COLOR, BaseCanvas, AnimationCanvas, PreviewCanvas, convex_hull,
    RangeDetector,
)
from .nx_layout import graph2icon, engine_picker, engines
from .path_parser import parse_path
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.128"></t>
<t tx="leo.20231205084738.129">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/info/
# -*- coding: utf-8 -*-

"""About information."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from requests import get as get_url
from qtpy.QtCore import Qt, QCoreApplication
from qtpy.QtWidgets import QDialog, QWidget, QProgressDialog
from pyslvs_ui import __version__
from .info import SYS_INFO, ARGUMENTS
from .logging_handler import logger
from .about_ui import Ui_Dialog

LICENSE_STRING = (
    "This program is free software; "
    "you can redistribute it and/or modify it under the terms of the "
    "Affero General Public License (AGPL) as published by Affero, Inc. version 3. "
    "This program is distributed in the hope that it will be useful, "
    "but WITHOUT ANY WARRANTY; "
    "without even the implied warranty of "
    "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
)


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.13">def __point_item(self, p: int) -&gt; QListWidgetItem:
    """Create a list item for a point."""
    return QListWidgetItem(self.icon, f'Point{p}')

</t>
<t tx="leo.20231205084738.130">def html(s: str) -&gt; str:
    """Turn simple string to html format."""
    s = s.replace('\n', '&lt;br/&gt;')
    return f"&lt;html&gt;&lt;head/&gt;&lt;body&gt;{s}&lt;/body&gt;&lt;/html&gt;"


</t>
<t tx="leo.20231205084738.131">def _title(name: str) -&gt; str:
    """Wrap title."""
    return f'&lt;h2&gt;{name}&lt;/h2&gt;'


</t>
<t tx="leo.20231205084738.132">def _content(*s: str) -&gt; str:
    """Wrap as paragraph."""
    return f'&lt;p&gt;{"&lt;/p&gt;&lt;p&gt;".join(s)}&lt;/p&gt;'


</t>
<t tx="leo.20231205084738.133">def _order_list(*s: str) -&gt; str:
    """Wrap as list."""
    return f'&lt;ul&gt;&lt;li&gt;{"&lt;/li&gt;&lt;li&gt;".join(s)}&lt;/li&gt;&lt;/ul&gt;'


</t>
<t tx="leo.20231205084738.134">class PyslvsAbout(QDialog, Ui_Dialog):
    """Pyslvs about dialog."""

    @others
</t>
<t tx="leo.20231205084738.135">def __init__(self, parent: QWidget):
    """About description strings."""
    super(PyslvsAbout, self).__init__(parent)
    self.setupUi(self)
    self.setWindowFlags(self.windowFlags()
                        &amp; ~Qt.WindowContextHelpButtonHint)
    self.title_label.setText(html(_title("Pyslvs") + _content(
        f"Version {__version__} 2016-2022"
    )))
    self.description_text.setText(html(_content(
        "A GUI-based tool use to solving 2D linkage subject.",
        f"Author: {__author__}",
        f"Email: {__email__}",
        "If you want to know more, see to our website or contact the email.",
    )))
    self.license_text.setText(LICENSE_STRING)
    self.ver_text.setText(html(_order_list(*SYS_INFO)))
    self.args_text.setText(html(_content("Startup arguments are as follows:") + _order_list(
        f"Open with: {ARGUMENTS.filepath}",
        f"Start Path: {ARGUMENTS.c}",
        f"Fusion style: {ARGUMENTS.fusion}",
        f"Debug mode: {ARGUMENTS.debug_mode}",
        f"Specified kernel: {ARGUMENTS.kernel}",
    ) + _content("Use \"-h\" or \"--help\" argument to view the help.")))


</t>
<t tx="leo.20231205084738.136">def check_update(dlg: QProgressDialog) -&gt; str:
    """Check for update."""
    ver_list = [int(v) for v in __version__.split('.') if v.isdigit()]
    logger.info(f"Getting update for \"{__version__}\":")
    m = len(ver_list)
    for i in range(m):
        if i == 0:
            text = "major"
        elif i == 1:
            text = "minor"
        else:
            text = "micro"
        dlg.setLabelText(f"Checking for {text}...")
        QCoreApplication.processEvents()
        if dlg.wasCanceled():
            return ""
        next_ver = ver_list[:m]
        next_ver[i] += 1
        for j in range(i + 1, m):
            next_ver[j] = 0
        if i == 0:
            next_ver[1] = 1
        elif i == 1:
            if next_ver[1] &gt; 12:
                dlg.setValue(i + 1)
                continue
        url = (
            f"https://github.com/KmolYuan/Pyslvs-UI/releases/tag/"
            f"v{next_ver[0]}.{next_ver[1]:02}.{next_ver[2]}"
        )
        request = get_url(url)
        dlg.setValue(i + 1)
        if request.status_code == 200:
            dlg.setValue(m)
            return url
    return ""
</t>
<t tx="leo.20231205084738.137">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/info/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'about.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.138">class Ui_Dialog(object):
    @others
</t>
<t tx="leo.20231205084738.139">def setupUi(self, Dialog):
    Dialog.setObjectName("Dialog")
    Dialog.setEnabled(True)
    Dialog.resize(586, 494)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:main.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Dialog.setWindowIcon(icon)
    Dialog.setSizeGripEnabled(False)
    Dialog.setModal(True)
    self.verticalLayout_7 = QtWidgets.QVBoxLayout(Dialog)
    self.verticalLayout_7.setContentsMargins(-1, 6, 6, 6)
    self.verticalLayout_7.setObjectName("verticalLayout_7")
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.verticalLayout_2 = QtWidgets.QVBoxLayout()
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.iconLabel = QtWidgets.QLabel(Dialog)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.iconLabel.sizePolicy().hasHeightForWidth())
    self.iconLabel.setSizePolicy(sizePolicy)
    self.iconLabel.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.iconLabel.setObjectName("iconLabel")
    self.verticalLayout_2.addWidget(self.iconLabel)
    spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_2.addItem(spacerItem)
    self.horizontalLayout.addLayout(self.verticalLayout_2)
    self.verticalLayout_3 = QtWidgets.QVBoxLayout()
    self.verticalLayout_3.setObjectName("verticalLayout_3")
    self.title_label = QtWidgets.QLabel(Dialog)
    self.title_label.setText("")
    self.title_label.setObjectName("title_label")
    self.verticalLayout_3.addWidget(self.title_label)
    self.tab_widget = QtWidgets.QTabWidget(Dialog)
    self.tab_widget.setObjectName("tab_widget")
    self.AboutTab = QtWidgets.QWidget()
    self.AboutTab.setObjectName("AboutTab")
    self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.AboutTab)
    self.verticalLayout_4.setContentsMargins(6, 6, 6, 6)
    self.verticalLayout_4.setObjectName("verticalLayout_4")
    self.description_text = QtWidgets.QTextBrowser(self.AboutTab)
    self.description_text.setObjectName("description_text")
    self.verticalLayout_4.addWidget(self.description_text)
    self.tab_widget.addTab(self.AboutTab, "")
    self.LicenseTab = QtWidgets.QWidget()
    self.LicenseTab.setObjectName("LicenseTab")
    self.verticalLayout = QtWidgets.QVBoxLayout(self.LicenseTab)
    self.verticalLayout.setObjectName("verticalLayout")
    self.license_text = QtWidgets.QTextBrowser(self.LicenseTab)
    self.license_text.setObjectName("license_text")
    self.verticalLayout.addWidget(self.license_text)
    self.tab_widget.addTab(self.LicenseTab, "")
    self.VersionsTab = QtWidgets.QWidget()
    self.VersionsTab.setObjectName("VersionsTab")
    self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.VersionsTab)
    self.verticalLayout_6.setContentsMargins(6, 6, 6, 6)
    self.verticalLayout_6.setObjectName("verticalLayout_6")
    self.ver_text = QtWidgets.QTextBrowser(self.VersionsTab)
    self.ver_text.setObjectName("ver_text")
    self.verticalLayout_6.addWidget(self.ver_text)
    self.tab_widget.addTab(self.VersionsTab, "")
    self.ArgumentsTab = QtWidgets.QWidget()
    self.ArgumentsTab.setObjectName("ArgumentsTab")
    self.verticalLayout_9 = QtWidgets.QVBoxLayout(self.ArgumentsTab)
    self.verticalLayout_9.setContentsMargins(6, 6, 6, 6)
    self.verticalLayout_9.setObjectName("verticalLayout_9")
    self.args_text = QtWidgets.QTextBrowser(self.ArgumentsTab)
    self.args_text.setObjectName("args_text")
    self.verticalLayout_9.addWidget(self.args_text)
    self.tab_widget.addTab(self.ArgumentsTab, "")
    self.verticalLayout_3.addWidget(self.tab_widget)
    self.horizontalLayout.addLayout(self.verticalLayout_3)
    self.verticalLayout_7.addLayout(self.horizontalLayout)
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_2.addItem(spacerItem1)
    self.btn_box = QtWidgets.QDialogButtonBox(Dialog)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.btn_box.sizePolicy().hasHeightForWidth())
    self.btn_box.setSizePolicy(sizePolicy)
    self.btn_box.setOrientation(QtCore.Qt.Horizontal)
    self.btn_box.setStandardButtons(QtWidgets.QDialogButtonBox.Ok)
    self.btn_box.setObjectName("btn_box")
    self.horizontalLayout_2.addWidget(self.btn_box)
    self.verticalLayout_7.addLayout(self.horizontalLayout_2)

    self.retranslateUi(Dialog)
    self.tab_widget.setCurrentIndex(0)
    self.btn_box.accepted.connect(Dialog.accept)
    self.btn_box.rejected.connect(Dialog.reject)
    QtCore.QMetaObject.connectSlotsByName(Dialog)

</t>
<t tx="leo.20231205084738.14">@Slot(int, name='on_name_box_currentIndexChanged')
def __set_name(self, index: int) -&gt; None:
    """Load the parameters of the link."""
    if not self.name_box.isEnabled():
        return
    if len(self.vlinks) &gt; index:
        vlink = self.vlinks[index]
        self.name_edit.setText(vlink.name)
        set_custom_color(self.color_box, vlink.color_str)
        self.no_selected.clear()
        self.selected.clear()
        points = set(range(len(self.vpoints)))
        for p in vlink.points:
            points.remove(p)
            self.selected.addItem(self.__point_item(p))
        for p in points:
            self.no_selected.addItem(self.__point_item(p))
    not_ground = index &gt; 0
    for widget in (self.name_edit, self.color_box, self.color_pick_btn):
        widget.setEnabled(not_ground)

</t>
<t tx="leo.20231205084738.140">def retranslateUi(self, Dialog):
    _translate = QtCore.QCoreApplication.translate
    Dialog.setWindowTitle(_translate("Dialog", "About Pyslvs"))
    self.iconLabel.setWhatsThis(_translate("Dialog", "Pyslvs Icon!"))
    self.iconLabel.setText(_translate("Dialog", "&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;img width=\"80\" src=\"icons:main.png\"/&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"))
    self.tab_widget.setTabText(self.tab_widget.indexOf(self.AboutTab), _translate("Dialog", "About"))
    self.tab_widget.setTabText(self.tab_widget.indexOf(self.LicenseTab), _translate("Dialog", "LICENSE"))
    self.tab_widget.setTabText(self.tab_widget.indexOf(self.VersionsTab), _translate("Dialog", "Versions"))
    self.tab_widget.setTabText(self.tab_widget.indexOf(self.ArgumentsTab), _translate("Dialog", "Arguments"))
    self.btn_box.setWhatsThis(_translate("Dialog", "Click to exit"))
</t>
<t tx="leo.20231205084738.141">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/info/
# -*- coding: utf-8 -*-

"""Information.

+ Module versions.
+ Help descriptions.
+ Check for update function.
"""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Optional
from importlib.util import find_spec
from enum import auto, IntEnum
from sys import version_info as _vi
from platform import system, release, machine, python_compiler
from argparse import ArgumentParser
from dataclasses import dataclass
from pyslvs_ui import __version__
from pyslvs_ui.qt_patch import API


@others
ARGUMENTS = Arguments()
KERNELS = [Kernel.PYSLVS, Kernel.SKETCH_SOLVE]
if HAS_SLVS:
    KERNELS.insert(1, Kernel.SOLVESPACE)
KERNELS = tuple(KERNELS)
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.142">def has_module(name: str) -&gt; bool:
    """Test module import."""
    return find_spec(name) is not None


</t>
<t tx="leo.20231205084738.143">HAS_SLVS = has_module('python_solvespace')
HAS_SCIPY = has_module('scipy')
SYS_INFO = [
    f"Pyslvs {__version__}",
    f"OS Type: {system()} {release()} [{machine()}]",
    f"Python Version: {_vi.major}.{_vi.minor}.{_vi.micro} ({_vi.releaselevel})",
    f"Python Compiler: {python_compiler()}",
    f"Qt: {API}",
]
SYS_INFO = tuple(SYS_INFO)
del has_module


</t>
<t tx="leo.20231205084738.144">class Kernel(IntEnum):
    """Kernel list. Mapped to options."""
    PYSLVS = 0
    SOLVESPACE = auto() if HAS_SLVS else 0
    SKETCH_SOLVE = auto()
    SAME_AS_SOLVING = auto()

    @others
</t>
<t tx="leo.20231205084738.145">@property
def title(self) -&gt; str:
    """Reformat enum's names."""
    return self.name.capitalize().replace("_", " ")


</t>
<t tx="leo.20231205084738.146">@dataclass(repr=False, eq=False)
class Arguments:
    """Argument container."""
    cmd: Optional[str] = None
    c: str = ""
    filepath: str = ""
    kernel: str = ""
    debug_mode: bool = False
    fusion: bool = False
    appimage_extract: bool = False
    appimage_mount: bool = False
    appimage_offset: bool = False


</t>
<t tx="leo.20231205084738.147">def parse_args() -&gt; None:
    parser = ArgumentParser(
        prog='pyslvs',
        description=(
            f"Pyslvs {__version__} - "
            f"Open Source Planar Linkage Mechanism Simulation "
            f"and Mechanical Synthesis System"
        ),
        epilog=f"{__copyright__} {__license__} {__author__} {__email__}",
        add_help=False
    )
    main_info = parser.add_argument_group("information options")
    main_info.add_argument(
        '-v',
        '--version',
        action='version',
        version=SYS_INFO[0]
    )
    main_info.add_argument(
        '-d',
        '--debug-mode',
        action='store_true',
        help="show debug message to stdout, and "
             "change the logger from INFO into DEBUG level"
    )
    s = parser.add_subparsers(title="CLI command", dest='cmd')
    s.add_parser(
        'test',
        help="just test the module import states and exit",
        add_help=False
    )
    gui_cmd = s.add_parser('gui', help="arguments for gui only", add_help=False)
    gui_startup = gui_cmd.add_argument_group("startup options")
    gui_startup.add_argument(
        'filepath',
        default="",
        nargs='?',
        type=str,
        help="read a specific project from the file path"
    )
    gui_startup.add_argument(
        '-c',
        metavar="start path",
        default="",
        nargs='?',
        type=str,
        help="change to specified path when startup Pyslvs"
    )
    gui_startup.add_argument(
        '--kernel',
        metavar="kernel",
        default='',
        nargs='?',
        type=str,
        choices=['pyslvs', 'python_solvespace', 'sketch_solve'],
        help="startup Pyslvs with specified solver, "
             "default is depending on local setting"
    )
    qt = gui_cmd.add_argument_group("Qt options")
    qt.add_argument(
        '--fusion',
        default=False,
        action='store_true',
        help="run Pyslvs in Fusion style"
    )
    qt.add_argument(
        '--full-screen',
        default=False,
        action='store_true',
        help="start Pyslvs with full-screen mode"
    )
    qt.add_argument(
        '--platform',
        metavar="plugins",
        default="",
        nargs='?',
        type=str,
        help="startup Pyslvs with specified Qt platform plugins, "
             "such as WebGL (webgl:[port])"
    )
    gui_info = gui_cmd.add_argument_group("information options")
    for group in (main_info, gui_info):
        group.add_argument(
            '-h',
            '--help',
            action='help',
            help="show this help message and exit"
        )
    if system() == "Linux":
        # AppImage options
        appimage = parser.add_argument_group(
            "AppImage arguments",
            "these options only work in package state. "
            "Pyslvs is a type 2 package, "
            "for more information: https://docs.appimage.org/"
        )
        appimage.add_argument(
            '--appimage-extract',
            action='store_true',
            help="extract the files of package into a 'squashfs-root' folder"
        )
        appimage.add_argument(
            '--appimage-mount',
            action='store_true',
            help="temporarily mount entire package into a folder, "
                 "it can stop by terminating this program"
        )
        appimage.add_argument(
            '--appimage-offset',
            action='store_true',
            help="obtain offset value of 'mount' command, then mount it with: "
                 "\"sudo mount PACKAGE MOUNT -o offset=VALUE\""
        )
    args = Arguments(**vars(parser.parse_args()))
    ARGUMENTS.__dict__.update(args.__dict__)


</t>
<t tx="leo.20231205084738.148">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/info/
# -*- coding: utf-8 -*-

"""Following script can output stdout and stderr to Qt text browser."""

from __future__ import annotations

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import cast, Optional, ClassVar
import sys
from os import remove
from os.path import join, expanduser
from platform import system
from logging import (
    DEBUG, INFO, ERROR, basicConfig, getLogger, Handler,
    StreamHandler, LogRecord,
)
from qtpy.QtCore import QObject, Signal
from .info import ARGUMENTS, SYS_INFO

logger = getLogger('matplotlib')
logger.setLevel(ERROR)
logger = getLogger()
_SYS_STDOUT = sys.stdout
_SYS_STDERR = sys.stderr
_std_handler = StreamHandler(_SYS_STDOUT)
_log_path = "pyslvs.log"
if system() not in {'Windows', 'Darwin'}:
    # Cause of AppImages can't use related path
    _log_path = join(expanduser("~"), _log_path)


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.149">def sign_in_logger() -&gt; None:
    basicConfig(
        level=DEBUG if ARGUMENTS.debug_mode else INFO,
        filename=_log_path,
        format="[%(asctime)s] [%(funcName)s]:%(levelname)s: %(message)s",
    )
    logger.addHandler(_std_handler)
    for info_str in SYS_INFO:
        logger.info(info_str)
    logger.info('-' * 7)
    logger.addHandler(_QtHandler())


</t>
<t tx="leo.20231205084738.15">@Slot(int, name='on_color_box_currentIndexChanged')
def __set_color(self, _=None) -&gt; None:
    """Change the color icon of pick button."""
    self.color_pick_btn.setIcon(self.color_box.itemIcon(
        self.color_box.currentIndex()
    ))

</t>
<t tx="leo.20231205084738.150">class _QtHandler(Handler):
    """Logging handle."""

    @others
</t>
<t tx="leo.20231205084738.151">def __init__(self):
    super(_QtHandler, self).__init__()

</t>
<t tx="leo.20231205084738.152">def emit(self, record: LogRecord) -&gt; None:
    """Output to the other side."""
    msg = self.format(record)
    if msg and XStream.replaced():
        XStream.stdout().write(msg + '\n')

</t>
<t tx="leo.20231205084738.153">def close(self) -&gt; None:
    """Remove log file if exit."""
    super(_QtHandler, self).close()
    remove(_log_path)


</t>
<t tx="leo.20231205084738.154">class XStream(QObject):
    """Stream object to imitate Python output."""
    __stdout: ClassVar[Optional[XStream]] = None
    __stderr: ClassVar[Optional[XStream]] = None
    message_written = Signal(str)

    @others
</t>
<t tx="leo.20231205084738.155">def write(self, msg: str) -&gt; None:
    """Output the message."""
    if not self.signalsBlocked():
        self.message_written.emit(msg)

</t>
<t tx="leo.20231205084738.156">@staticmethod
def replaced() -&gt; bool:
    return XStream.__stdout is not None

</t>
<t tx="leo.20231205084738.157">@staticmethod
def stdout() -&gt; XStream:
    """Replace stdout."""
    if not XStream.replaced():
        XStream.__stdout = XStream()
        sys.stdout = XStream.__stdout
        logger.removeHandler(_std_handler)
    return cast(XStream, XStream.__stdout)

</t>
<t tx="leo.20231205084738.158">@staticmethod
def back() -&gt; None:
    """Disconnect from Qt widget."""
    sys.stdout = _SYS_STDOUT
    sys.stderr = _SYS_STDERR
    XStream.__stdout = None
    XStream.__stderr = None
    logger.addHandler(_std_handler)
</t>
<t tx="leo.20231205084738.159">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/info/
# -*- coding: utf-8 -*-

"""'info' module contains Pyslvs program information."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from .info import (
    KERNELS, SYS_INFO, ARGUMENTS, HAS_SLVS, HAS_SCIPY, Kernel, parse_args,
)
from .about import PyslvsAbout, html, check_update
from .logging_handler import logger, sign_in_logger, XStream


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.16">@Slot(name='on_color_pick_btn_clicked')
def __set_rgb(self) -&gt; None:
    """Add a custom color from current color."""
    color = color_qt(self.color_box.currentText())
    color = QColorDialog.getColor(color, self)
    if color.isValid():
        add_custom_color(self.color_box, color)

</t>
<t tx="leo.20231205084738.160">def size_format(num: float) -&gt; str:
    """Calculate file size based on binary."""
    if num &lt; 0:
        raise ValueError("size must be positive value")
    s = "0 B"
    units = ('', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
    for i, u in enumerate(units):
        s = f"{num:3.2f} {u}B"
        if abs(num) &lt; 1024:
            break
        num /= 1024
    return s
</t>
<t tx="leo.20231205084738.161"></t>
<t tx="leo.20231205084738.162">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/
# -*- coding: utf-8 -*-

"""DXF output function.

+ Frame
+ Boundary
"""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Tuple, Sequence, Iterable, Callable, Dict, List
from math import degrees, atan2
import ezdxf
from ezdxf.lldxf.const import versions_supported_by_new, acad_release
from pyslvs import VPoint, VLink
from pyslvs_ui.graphics import convex_hull
from .slvs import boundary_loop

# A list of support versions with "ezdxf" module.
DXF_VERSIONS = versions_supported_by_new
DXF_VERSIONS_MAP = acad_release


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.163">def dxf_frame(
    vpoints: Sequence[VPoint],
    v_to_slvs: Callable[[], Iterable[Tuple[int, int]]],
    version: str,
    file_name: str
):
    """Create frame sketch only."""
    dwg = ezdxf.new(version)
    msp = dwg.modelspace()

    for p1, p2 in v_to_slvs():
        vp1 = vpoints[p1]
        vp2 = vpoints[p2]
        msp.add_line((vp1.cx, vp1.cy), (vp2.cx, vp2.cy))

    dwg.saveas(file_name)


</t>
<t tx="leo.20231205084738.164">def dxf_boundary(
    vpoints: Sequence[VPoint],
    radius: float,
    interval: float,
    version: str,
    file_name: str
):
    """Create parts sketch in same file."""
    vlinks: Dict[str, List[int]] = {}
    for i, vpoint in enumerate(vpoints):
        for link in vpoint.links:
            if link in vlinks:
                vlinks[link].append(i)
            else:
                vlinks[link] = [i]

    dwg = ezdxf.new(version)
    msp = dwg.modelspace()

    # _Interval: Offset with x axis.
    interval += radius * 2
    x_max = -interval

    # Draw link boundaries
    for name in sorted(
        vlinks,
        key=lambda n: min(vpoints[p].cx for p in vlinks[n])
    ):
        if name == VLink.FRAME:
            continue
        # Draw joint holes
        x_min = min(vpoints[p].cx for p in vlinks[name])

        centers = [(
            x_max + interval + (vpoints[p].cx - x_min),
            vpoints[p].cy
        ) for p in vlinks[name]]

        for coord in centers:
            msp.add_circle(coord, radius / 2)

        x_max = max(coord[0] for coord in centers)
        # Sort the centers
        centers_ch = convex_hull(centers)
        boundary = centers_ch.copy()
        for c in centers:
            if c not in centers_ch:
                centers_ch.append(c)
        centers = centers_ch

        # Draw boundary edges
        boundary = boundary_loop(boundary, radius)
        for c1, c2 in boundary:
            msp.add_line((c1.x, c1.y), (c2.x, c2.y))

        # Draw fillets
        for i in range(len(boundary)):
            x, y = centers[i]
            c1 = boundary[i - 1][1]
            c2 = boundary[i][0]
            msp.add_arc(
                centers[i],
                radius,
                degrees(atan2(c1.y - y, c1.x - x)),
                degrees(atan2(c2.y - y, c2.x - x))
            )

    dwg.saveas(file_name)
</t>
<t tx="leo.20231205084738.165">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/
# -*- coding: utf-8 -*-

from __future__ import annotations

"""Genetic format processing editor."""

from abc import abstractmethod
from enum import unique, auto, IntEnum
from typing import (
    TYPE_CHECKING, Tuple, List, Sequence, Dict, Mapping, Union, Any,
)
from qtpy.QtCore import QObject, QFileInfo
from qtpy.QtWidgets import QProgressDialog, QMessageBox
from pyslvs_ui import __version__
from pyslvs_ui.qt_patch import QABCMeta
from pyslvs_ui.info import logger
from .overview import OverviewDialog

if TYPE_CHECKING:
    from pyslvs_ui.io import ProjectWidget
    from pyslvs_ui.widgets import MainWindowBase

_Coord = Tuple[float, float]
_Paths = Sequence[Sequence[_Coord]]
_SliderPaths = Mapping[int, Sequence[_Coord]]
_Pairs = Sequence[Tuple[int, int]]
_Data = Mapping[str, Any]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.166">@unique
class ProjectFormat(IntEnum):
    """Project format."""
    YAML = 0
    C_YAML = auto()
    PICKLE = auto()

    @others
</t>
<t tx="leo.20231205084738.167">@property
def format_name(self):
    if self == ProjectFormat.YAML:
        return "YAML"
    elif self == ProjectFormat.C_YAML:
        return "Compressed YAML"
    elif self == ProjectFormat.PICKLE:
        return "Pickle"
    else:
        raise ValueError("invalid format")


</t>
<t tx="leo.20231205084738.168">class FormatEditor(QObject, metaclass=QABCMeta):
    """A generic loader and dumper."""
    dlg: Union[QProgressDialog, OverviewDialog, None]

    @others
</t>
<t tx="leo.20231205084738.169">@abstractmethod
def __init__(self, project_widget: ProjectWidget, parent: MainWindowBase):
    super(FormatEditor, self).__init__(parent)
    self._parent = parent
    # Undo stack
    self.command_stack = parent.cmd_stack
    # Action group settings
    self.prefer = parent.prefer
    # Point expressions
    self.get_expression = parent.get_expression
    # Link data
    self.vlinks = parent.vlink_list
    # Storage data
    self.get_storage = parent.get_storage
    # Collections data
    self.collect_data = parent.collections.collect_data
    # Triangle data
    self.config_data = parent.collections.config_data
    # Inputs variables data
    self.input_pairs = parent.inputs_widget.input_pairs
    # Algorithm data
    self.algorithm_data = parent.optimizer.mechanism_data
    # Path data
    self.paths = parent.inputs_widget.paths
    self.slider_paths = parent.inputs_widget.slider_paths
    # Background options
    self.background_config = project_widget.background_config
    self.get_background_path = project_widget.get_background_path

    # Add empty links function
    self.add_empty_links = parent.add_empty_links
    # Add points function
    self.parse_expression = parent.parse_expression
    self.add_points = parent.add_points

    # Call to load inputs variables data
    self.load_inputs = parent.inputs_widget.add_inputs_variables
    # Add storage function
    self.load_storage = parent.add_multiple_storage
    # Call to load paths
    self.load_paths = parent.inputs_widget.load_paths
    # Call to load collections data
    self.load_collections = \
        parent.collections.structure_widget.add_collections
    # Call to load config data
    self.load_config = parent.collections.configure_widget.add_collections
    # Call to load algorithm results
    self.load_algorithm = parent.optimizer.load_results
    # Call to load background options
    self.set_background_config = project_widget.set_background_config
    # Clear function for main window
    self.main_clear = parent.clear
    # Dialog for loader
    self.dlg = None

</t>
<t tx="leo.20231205084738.17">@Slot(QListWidgetItem, name='on_no_selected_itemDoubleClicked')
def __add_selected(self, item: QListWidgetItem) -&gt; None:
    """Add item to selected list."""
    self.selected.addItem(
        self.no_selected.takeItem(self.no_selected.row(item))
    )

</t>
<t tx="leo.20231205084738.170">def save_data(self) -&gt; _Data:
    """Save file method."""
    data = {
        'pyslvs_ver': __version__,
        'file_type': self.prefer.file_type_option,
        'mechanism': self.get_expression(),
        'links': {link.name: link.color_str for link in self.vlinks},
        'input': [(b, d) for b, d, _ in self.input_pairs()],
        'storage': self.get_storage(),
        'collection': self.collect_data(),
        'triangle': self.config_data(),
        'algorithm': self.algorithm_data,
        'path': self.paths(),
        'slider_path': self.slider_paths(),
        'background': self.background_config(),
    }
    for k, v in tuple(data.items()):
        if not v:
            data.pop(k)
    return data

</t>
<t tx="leo.20231205084738.171">def load_data(self, file_name: str, data: _Data) -&gt; None:
    """Load file method."""
    self.main_clear()
    ver = data.get('pyslvs_ver', "")
    if ver:
        logger.info(f"Load data from version {ver}")
    del ver
    self.dlg = QProgressDialog("Loading project", "Cancel", 0, 7,
                               self._parent)
    self.dlg.show()
    try:
        mechanism_data = self.__load_mech(data)
        storage_data = self.__load_storage(data)
        input_data = self.__load_input(data)
        paths = self.__load_path(data)
        collection_data = self.__load_collection(data)
        config_data = self.__load_config(data)
        algorithm_data = self.__load_algorithm(data)
        self.__load_background(data)
    except Exception as e:
        QMessageBox.warning(self._parent, "Load error", f"Exception:\n{e}")
        self.dlg.deleteLater()
        self.dlg = None
        return
    # File type option align (ignore previous one)
    self.prefer.file_type_option = data.get('file_type', ProjectFormat.YAML)
    # Show overview dialog
    self.dlg.deleteLater()
    self.dlg = OverviewDialog(
        self._parent,
        QFileInfo(file_name).baseName(),
        mechanism_data,
        storage_data,
        input_data,
        paths,
        collection_data,
        config_data,
        algorithm_data,
        self.get_background_path()
    )
    self.dlg.show()
    self.dlg.exec_()
    self.dlg.deleteLater()
    self.dlg = None

</t>
<t tx="leo.20231205084738.172">def __process(self, title: str) -&gt; None:
    """Increase progress."""
    if not isinstance(self.dlg, QProgressDialog):
        raise ValueError('not in process')
    self.dlg.setValue(self.dlg.value() + 1)
    self.dlg.setLabelText(f"Loading {title}.")
    if self.dlg.wasCanceled():
        self.dlg.deleteLater()
        self.main_clear()
        raise ValueError('load failed')

</t>
<t tx="leo.20231205084738.173">def __load_mech(self, data: _Data) -&gt; str:
    """Load mechanism data."""
    self.__process("mechanism")
    links_data: Mapping[str, str] = data.get('links', {})
    mechanism_data: str = data.get('mechanism', "M[]")
    if len(links_data) &gt; 1 or mechanism_data != "M[]":
        self.__set_group("mechanism")
        self.add_empty_links(links_data)
        self.parse_expression(mechanism_data)
        self.__end_group()
    return mechanism_data

</t>
<t tx="leo.20231205084738.174">def __load_input(self, data: _Data) -&gt; List[Tuple[int, int]]:
    """Load input data."""
    self.__process("input data")
    input_data: List[Sequence[int]] = data.get('input', [])
    # Assert input
    i_attr = [(i[0], i[1]) for i in input_data]
    if input_data:
        self.__set_group("inputs data")
        self.load_inputs(i_attr)
        self.__end_group()
    return i_attr

</t>
<t tx="leo.20231205084738.175">def __load_storage(self, data: _Data) -&gt; Mapping[str, str]:
    """Load storage data."""
    self.__process("storage")
    storage_data: Mapping[str, str] = data.get('storage', {})
    if storage_data:
        self.__set_group("storage")
        self.load_storage(storage_data)
        self.__end_group()
    return storage_data

</t>
<t tx="leo.20231205084738.176">def __load_path(self, data: _Data) -&gt; Mapping[str, _Paths]:
    """Load path data."""
    self.__process("paths")
    paths: Mapping[str, _Paths] = data.get('path', {})
    slider_paths: Mapping[str, _SliderPaths] = data.get('slider_path', {})
    if paths:
        self.__set_group("paths")
        self.load_paths({
            n: [[(c[0], c[1]) for c in p] for p in ps]
            for n, ps in paths.items()
        }, slider_paths)
        self.__end_group()
    return paths

</t>
<t tx="leo.20231205084738.177">def __load_collection(self, data: _Data) -&gt; List[_Pairs]:
    """Load collection data."""
    self.__process("graph collections")
    collection_data: List[_Pairs] = data.get('collection', [])
    if collection_data:
        self.__set_group("graph collections")
        self.load_collections(collection_data)
        self.__end_group()
    return collection_data

</t>
<t tx="leo.20231205084738.178">def __load_config(self, data: _Data) -&gt; Mapping[str, _Data]:
    """Load synthesis configurations."""
    self.__process("synthesis configurations")
    config_data: Mapping[str, _Data] = data.get('triangle', {})
    if config_data:
        self.__set_group("synthesis configurations")
        self.load_config(config_data)
        self.__end_group()
    return config_data

</t>
<t tx="leo.20231205084738.179">def __load_algorithm(self, data: _Data) -&gt; Sequence[_Data]:
    """Load algorithm data."""
    self.__process("synthesis results")
    algorithm_data: List[Dict[str, Any]] = data.get('algorithm', [])
    if algorithm_data:
        self.__set_group("synthesis results")
        # Assert input, it's a mappable object (consist of list)
        for config in algorithm_data:
            config['input'] = [((b, d), a) for (b, d), a in config['input']]
        self.load_algorithm(algorithm_data)
        self.__end_group()
    return algorithm_data

</t>
<t tx="leo.20231205084738.18">@Slot(QListWidgetItem, name='on_selected_itemDoubleClicked')
def __add_no_selected(self, item: QListWidgetItem) -&gt; None:
    """Add item to no selected list."""
    self.no_selected.addItem(
        self.selected.takeItem(self.selected.row(item))
    )
</t>
<t tx="leo.20231205084738.180">def __load_background(self, data: _Data) -&gt; None:
    """Set background."""
    self.__process("background")
    background: Mapping[str, Union[str, float]] = data.get('background', {})
    self.set_background_config(background)

</t>
<t tx="leo.20231205084738.181">def __set_group(self, text: str) -&gt; None:
    """Set group."""
    if self.prefer.open_project_actions_option == 1:
        self.command_stack.beginMacro(f"Add {text}")

</t>
<t tx="leo.20231205084738.182">def __end_group(self) -&gt; None:
    """End group."""
    if self.prefer.open_project_actions_option == 1:
        self.command_stack.endMacro()

</t>
<t tx="leo.20231205084738.183">@staticmethod
def test(file_name: str) -&gt; bool:
    raise NotImplementedError

</t>
<t tx="leo.20231205084738.184">@abstractmethod
def save(self, file_name: str) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084738.185">@abstractmethod
def load(self, file_name: str) -&gt; None:
    raise NotImplementedError
</t>
<t tx="leo.20231205084738.186">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/
# -*- coding: utf-8 -*-

"""Output dialog for slvs format."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from abc import abstractmethod
from typing import Tuple, Callable, Sequence, Iterable, Set, Dict
from os.path import isdir, isfile
from shutil import which
from subprocess import Popen, DEVNULL
from qtpy.QtCore import Slot, Qt, QDir
from qtpy.QtWidgets import (
    QDialog,
    QMessageBox,
    QFileDialog,
    QTextEdit,
    QWidget,
    QLabel,
    QComboBox,
    QCheckBox,
    QDoubleSpinBox,
    QHBoxLayout,
    QSizePolicy,
    QSpacerItem,
)
from qtpy.QtGui import QIcon, QPixmap
from pyslvs import VPoint, VLink
from pyslvs_ui.qt_patch import QABCMeta
from .slvs import slvs2_frame, slvs2_part
from .dxf import DXF_VERSIONS, DXF_VERSIONS_MAP, dxf_frame, dxf_boundary
from .output_option_ui import Ui_Dialog


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.187">def _get_name(widget: QTextEdit, *, ispath: bool = False) -&gt; str:
    """Return the file name of widget."""
    text = widget.toPlainText()
    place_text = widget.placeholderText()
    if ispath:
        return text if isdir(text) else place_text
    return ''.join(x for x in text if x.isalnum() or x in "._- ") or place_text


</t>
<t tx="leo.20231205084738.188">class OutputDialog(QDialog, Ui_Dialog, metaclass=QABCMeta):
    """Output dialog template."""
    format_name: str = ""
    format_icon: str = ""
    assembly_description: str = ""
    frame_description: str = ""

    @others
</t>
<t tx="leo.20231205084738.189">@abstractmethod
def __init__(
    self,
    env: str,
    file_name: str,
    vpoints: Sequence[VPoint],
    v_to_slvs: Callable[[], Iterable[Tuple[int, int]]],
    parent: QWidget
):
    """Comes in environment variable and project name."""
    super(OutputDialog, self).__init__(parent)
    self.setupUi(self)
    self.setWindowFlags(self.windowFlags()
                        &amp; ~Qt.WindowContextHelpButtonHint)
    self.setWindowTitle(f"Export {self.format_name} module project")
    self.setWindowIcon(QIcon(QPixmap(f"icons:{self.format_icon}")))
    self.assembly_label.setText(self.assembly_description)
    self.frame_label.setText(self.frame_description)
    self.path_edit.setPlaceholderText(env)
    self.filename_edit.setPlaceholderText(file_name)
    self.vpoints = vpoints
    self.v_to_slvs = v_to_slvs

</t>
<t tx="leo.20231205084738.19">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/entities/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'edit_link.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.190">@Slot(name='on_choose_dir_btn_clicked')
def __set_dir(self) -&gt; None:
    """Choose path and it will be set as environment variable
     if accepted.
     """
    path = self.path_edit.text()
    if not isdir(path):
        path = self.path_edit.placeholderText()
    path = QFileDialog.getExistingDirectory(self, "Choose a directory",
                                            path)
    if path:
        self.path_edit.setText(path)

</t>
<t tx="leo.20231205084738.191">@Slot(name='on_btn_box_accepted')
def __accepted(self) -&gt; None:
    """Use the file path to export the project."""
    qdir = QDir(_get_name(self.path_edit, ispath=True))
    if self.newfolder_option.isChecked():
        new_folder = self.filename_edit.placeholderText()
        if (not qdir.mkdir(new_folder)) and self.warn_radio.isChecked():
            self.exist_warning(new_folder, folder=True)
            return
        qdir.cd(new_folder)
    try:
        ok = self.do(qdir)
    except PermissionError as error:
        QMessageBox.warning(self, "Permission error", str(error))
    else:
        if ok:
            self.accept()

</t>
<t tx="leo.20231205084738.192">@abstractmethod
def do(self, dir_str: QDir) -&gt; bool:
    """Do the saving work here, return True if done."""
    raise NotImplementedError

</t>
<t tx="leo.20231205084738.193">def exist_warning(self, name: str, *, folder: bool = False) -&gt; None:
    """Show the "file is exist" message box."""
    QMessageBox.warning(
        self,
        f"{'Folder' if folder else 'File'} exist",
        f"The folder named {name} is exist."
        if folder else
        f"The file {name} is exist."
    )


</t>
<t tx="leo.20231205084738.194">class SlvsOutputDialog(OutputDialog):
    """Dialog for Solvespace format."""
    format_name = "Solvespace"
    format_icon = "solvespace.png"
    assembly_description = ("The part sketchs file will be generated "
                            "automatically with target directory.")
    frame_description = ("There is only sketch file of main mechanism "
                         "will be generated.")

    @others
</t>
<t tx="leo.20231205084738.195">def __init__(self, *args):
    super(SlvsOutputDialog, self).__init__(*args)

</t>
<t tx="leo.20231205084738.196">def do(self, dir_str: QDir) -&gt; bool:
    """Output types:

    + Assembly
    + Only wire frame
    """
    file_name = dir_str.filePath(_get_name(self.filename_edit) + '.slvs')
    if isfile(file_name) and self.warn_radio.isChecked():
        self.exist_warning(file_name)
        return False
    # Wire frame
    slvs2_frame(self.vpoints, self.v_to_slvs, file_name)
    # Open Solvespace by commend line if available
    cmd = which("solvespace")
    if cmd:
        Popen([cmd, file_name], stdout=DEVNULL, stderr=DEVNULL)
    if self.frame_radio.isChecked():
        self.accept()
        return False
    # Assembly
    vlinks: Dict[str, Set[int]] = {}
    for i, vpoint in enumerate(self.vpoints):
        for link in vpoint.links:
            if link in vlinks:
                vlinks[link].add(i)
            else:
                vlinks[link] = {i}
    for name, points in vlinks.items():
        if name == VLink.FRAME:
            continue
        file_name = dir_str.filePath(name + '.slvs')
        if isfile(file_name) and self.warn_radio.isChecked():
            self.exist_warning(file_name)
            return False
        slvs2_part([
            self.vpoints[i] for i in points
        ], self.link_radius.value(), file_name)
    return True


</t>
<t tx="leo.20231205084738.197">class DxfOutputDialog(OutputDialog):
    """Dialog for DXF format."""
    format_name = "DXF"
    format_icon = "dxf.png"
    assembly_description = "The sketch of the parts will include in the file."
    frame_description = "There is only wire frame will be generated."

    @others
</t>
<t tx="leo.20231205084738.198">def __init__(self, *args):
    """Type name: "DXF module"."""
    super(DxfOutputDialog, self).__init__(*args)
    # DXF version option
    version_label = QLabel("DXF version:", self)
    self.version_option = QComboBox(self)
    self.version_option.addItems(sorted((
        f"{name} - {DXF_VERSIONS_MAP[name]}" for name in DXF_VERSIONS
    ), key=lambda v: v.split()[-1]))
    self.version_option.setCurrentIndex(self.version_option.count() - 1)
    self.version_option.setSizePolicy(QSizePolicy.Expanding,
                                      QSizePolicy.Preferred)
    layout = QHBoxLayout()
    layout.addWidget(version_label)
    layout.addWidget(self.version_option)
    self.main_layout.insertLayout(3, layout)
    # Parts interval
    self.use_interval = QCheckBox("Parts interval:", self)
    self.use_interval.setCheckState(Qt.Checked)
    self.use_interval.setSizePolicy(QSizePolicy.Fixed,
                                    QSizePolicy.Preferred)
    self.interval_option = QDoubleSpinBox(self)
    self.interval_option.setValue(10)
    self.use_interval.stateChanged.connect(self.interval_option.setEnabled)
    layout = QHBoxLayout()
    layout.addWidget(self.use_interval)
    layout.addWidget(self.interval_option)
    layout.addItem(
        QSpacerItem(40, 20, QSizePolicy.Expanding, QSizePolicy.Preferred)
    )
    self.assembly_layout.insertLayout(2, layout)

</t>
<t tx="leo.20231205084738.199">def do(self, dir_str: QDir) -&gt; bool:
    """Output types:

    + Boundary
    + Frame
    """
    file_name = dir_str.filePath(_get_name(self.filename_edit) + '.dxf')
    if isfile(file_name) and self.warn_radio.isChecked():
        self.exist_warning(file_name)
        return False
    version = self.version_option.currentText().split()[0]
    if self.frame_radio.isChecked():
        # Frame
        dxf_frame(self.vpoints, self.v_to_slvs, version, file_name)
    elif self.assembly_radio.isChecked():
        # Boundary
        dxf_boundary(
            self.vpoints,
            self.link_radius.value(),
            self.interval_option.value()
            if self.use_interval.isChecked() else 0.,
            version,
            file_name
        )
    return True
</t>
<t tx="leo.20231205084738.2">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/
# -*- coding: utf-8 -*-

"""This module contains all the Qt objects we needed.

Customized class will define below.
"""

__all__ = ['API', 'qt_image_suffix', 'qt_image_format', 'QABCMeta']
__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from abc import ABCMeta
from os.path import join, dirname, abspath
from importlib.metadata import version
from qtpy import API_NAME
from qtpy.QtCore import QObject, QDir

API = f"{API_NAME} {version(API_NAME)}"
qt_image_suffix = []
qt_image_format = []
for suffix, name in (
    ('png', "Portable Network Graphics"),
    ('jpg', "Joint Photographic Experts Group"),
    ('bmp', "Bitmap Image file"),
    ('bpm', "Business Process Model"),
    ('tiff', "Tagged Image File Format"),
    ('ico', "Windows Icon"),
    ('wbmp', "Wireless Application Protocol Bitmap"),
    ('xbm', "X Bitmap"),
    ('xpm', "X Pixmap"),
):
    qt_image_suffix.append(suffix)
    qt_image_format.append(f"{name} (*.{suffix})")
qt_image_suffix = tuple(qt_image_suffix)
qt_image_format = tuple(qt_image_format)
del suffix, name
QDir.addSearchPath("icons", join(abspath(dirname(__file__)), "icons"))


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.20">class Ui_Dialog(object):
    @others
</t>
<t tx="leo.20231205084738.200">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'output_option.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.201">class Ui_Dialog(object):
    @others
</t>
<t tx="leo.20231205084738.202">def setupUi(self, Dialog):
    Dialog.setObjectName("Dialog")
    Dialog.resize(637, 663)
    Dialog.setSizeGripEnabled(True)
    Dialog.setModal(True)
    self.main_layout = QtWidgets.QVBoxLayout(Dialog)
    self.main_layout.setObjectName("main_layout")
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    self.path_label = QtWidgets.QLabel(Dialog)
    self.path_label.setObjectName("path_label")
    self.horizontalLayout_2.addWidget(self.path_label)
    self.path_edit = QtWidgets.QLineEdit(Dialog)
    self.path_edit.setObjectName("path_edit")
    self.horizontalLayout_2.addWidget(self.path_edit)
    self.choose_dir_btn = QtWidgets.QToolButton(Dialog)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:loadfile.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.choose_dir_btn.setIcon(icon)
    self.choose_dir_btn.setObjectName("choose_dir_btn")
    self.horizontalLayout_2.addWidget(self.choose_dir_btn)
    self.main_layout.addLayout(self.horizontalLayout_2)
    self.newfolder_option = QtWidgets.QCheckBox(Dialog)
    self.newfolder_option.setChecked(True)
    self.newfolder_option.setObjectName("newfolder_option")
    self.main_layout.addWidget(self.newfolder_option)
    self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_3.setObjectName("horizontalLayout_3")
    self.filename_label = QtWidgets.QLabel(Dialog)
    self.filename_label.setObjectName("filename_label")
    self.horizontalLayout_3.addWidget(self.filename_label)
    self.filename_edit = QtWidgets.QLineEdit(Dialog)
    self.filename_edit.setClearButtonEnabled(True)
    self.filename_edit.setObjectName("filename_edit")
    self.horizontalLayout_3.addWidget(self.filename_edit)
    self.filename_suffix_label = QtWidgets.QLabel(Dialog)
    self.filename_suffix_label.setObjectName("filename_suffix_label")
    self.horizontalLayout_3.addWidget(self.filename_suffix_label)
    self.main_layout.addLayout(self.horizontalLayout_3)
    self.output_group = QtWidgets.QGroupBox(Dialog)
    self.output_group.setObjectName("output_group")
    self.output_layout = QtWidgets.QVBoxLayout(self.output_group)
    self.output_layout.setObjectName("output_layout")
    self.assembly_radio = QtWidgets.QRadioButton(self.output_group)
    self.assembly_radio.setChecked(True)
    self.assembly_radio.setObjectName("assembly_radio")
    self.output_layout.addWidget(self.assembly_radio)
    self.assembly_group = QtWidgets.QWidget(self.output_group)
    self.assembly_group.setObjectName("assembly_group")
    self.assembly_layout = QtWidgets.QVBoxLayout(self.assembly_group)
    self.assembly_layout.setObjectName("assembly_layout")
    self.assembly_label = QtWidgets.QLabel(self.assembly_group)
    self.assembly_label.setWordWrap(True)
    self.assembly_label.setObjectName("assembly_label")
    self.assembly_layout.addWidget(self.assembly_label)
    self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_5.setObjectName("horizontalLayout_5")
    self.link_radius_label = QtWidgets.QLabel(self.assembly_group)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.link_radius_label.sizePolicy().hasHeightForWidth())
    self.link_radius_label.setSizePolicy(sizePolicy)
    self.link_radius_label.setObjectName("link_radius_label")
    self.horizontalLayout_5.addWidget(self.link_radius_label)
    self.link_radius = QtWidgets.QDoubleSpinBox(self.assembly_group)
    self.link_radius.setMinimum(0.01)
    self.link_radius.setProperty("value", 10.0)
    self.link_radius.setObjectName("link_radius")
    self.horizontalLayout_5.addWidget(self.link_radius)
    spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_5.addItem(spacerItem)
    self.assembly_layout.addLayout(self.horizontalLayout_5)
    self.output_layout.addWidget(self.assembly_group)
    self.frame_radio = QtWidgets.QRadioButton(self.output_group)
    self.frame_radio.setObjectName("frame_radio")
    self.output_layout.addWidget(self.frame_radio)
    self.frame_group = QtWidgets.QWidget(self.output_group)
    self.frame_group.setEnabled(False)
    self.frame_group.setObjectName("frame_group")
    self.verticalLayout = QtWidgets.QVBoxLayout(self.frame_group)
    self.verticalLayout.setObjectName("verticalLayout")
    self.frame_label = QtWidgets.QLabel(self.frame_group)
    self.frame_label.setWordWrap(True)
    self.frame_label.setObjectName("frame_label")
    self.verticalLayout.addWidget(self.frame_label)
    self.output_layout.addWidget(self.frame_group)
    self.main_layout.addWidget(self.output_group)
    self.groupBox = QtWidgets.QGroupBox(Dialog)
    self.groupBox.setObjectName("groupBox")
    self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.groupBox)
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.overwrite_radio = QtWidgets.QRadioButton(self.groupBox)
    self.overwrite_radio.setChecked(True)
    self.overwrite_radio.setObjectName("overwrite_radio")
    self.verticalLayout_2.addWidget(self.overwrite_radio)
    self.warn_radio = QtWidgets.QRadioButton(self.groupBox)
    self.warn_radio.setObjectName("warn_radio")
    self.verticalLayout_2.addWidget(self.warn_radio)
    self.main_layout.addWidget(self.groupBox)
    spacerItem1 = QtWidgets.QSpacerItem(20, 158, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.main_layout.addItem(spacerItem1)
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout.addItem(spacerItem2)
    self.btn_box = QtWidgets.QDialogButtonBox(Dialog)
    self.btn_box.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Save)
    self.btn_box.setObjectName("btn_box")
    self.horizontalLayout.addWidget(self.btn_box)
    self.main_layout.addLayout(self.horizontalLayout)

    self.retranslateUi(Dialog)
    self.btn_box.rejected.connect(Dialog.reject)
    self.assembly_radio.toggled['bool'].connect(self.assembly_group.setEnabled)
    self.frame_radio.toggled['bool'].connect(self.frame_group.setEnabled)
    QtCore.QMetaObject.connectSlotsByName(Dialog)

</t>
<t tx="leo.20231205084738.203">def retranslateUi(self, Dialog):
    _translate = QtCore.QCoreApplication.translate
    self.path_label.setText(_translate("Dialog", "Directory:"))
    self.choose_dir_btn.setText(_translate("Dialog", "..."))
    self.newfolder_option.setText(_translate("Dialog", "Export to a folder with project name (it will be create if not exist)"))
    self.filename_label.setText(_translate("Dialog", "Main file name:"))
    self.filename_suffix_label.setText(_translate("Dialog", ".slvs"))
    self.output_group.setTitle(_translate("Dialog", "Output types"))
    self.assembly_radio.setText(_translate("Dialog", "&amp;Assembly"))
    self.link_radius_label.setText(_translate("Dialog", "Fillet radius:"))
    self.frame_radio.setText(_translate("Dialog", "O&amp;nly wire frame"))
    self.groupBox.setTitle(_translate("Dialog", "Write mode"))
    self.overwrite_radio.setText(_translate("Dialog", "A&amp;lways overwrite"))
    self.warn_radio.setText(_translate("Dialog", "Warning &amp;me then back to this dialog"))
</t>
<t tx="leo.20231205084738.204">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/
# -*- coding: utf-8 -*-

"""Use to present project data."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Tuple, Sequence, Mapping, Any
from qtpy.QtCore import Qt
from qtpy.QtWidgets import QWidget, QDialog, QListWidgetItem
from qtpy.QtGui import QPixmap
from .overview_ui import Ui_Dialog

_Paths = Sequence[Sequence[Tuple[float, float]]]
_Pairs = Sequence[Tuple[int, int]]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.205">class OverviewDialog(QDialog, Ui_Dialog):
    """Put all the data into this dialog!!

    User cannot change anything in this interface.
    """

    @others
</t>
<t tx="leo.20231205084738.206">def __init__(
    self,
    parent: QWidget,
    title: str,
    main_expr: str,
    storage_data: Mapping[str, str],
    input_data: Sequence[Tuple[int, int]],
    path_data: Mapping[str, _Paths],
    collection_data: Sequence[_Pairs],
    config_data: Mapping[str, Mapping[str, Any]],
    algorithm_data: Sequence[Mapping[str, Any]],
    background_path: str
):
    """Data come from commit."""
    super(OverviewDialog, self).__init__(parent)
    self.setupUi(self)
    self.setWindowFlags(self.windowFlags()
                        &amp; ~Qt.WindowContextHelpButtonHint)
    self.setWindowTitle(f"Project: {title}")

    # Expression of storage data
    self.main_expr.setText(main_expr)
    for name, expr in storage_data.items():
        item = QListWidgetItem(f"[{name}]: {expr}")
        item.setToolTip(expr)
        self.storage_list.addItem(item)
    size = len(storage_data)
    if main_expr != "M[]":
        size += 1
    self.__set_item_text(0, size)
    # Expression of inputs variable data and Path data
    for a, b in input_data:
        self.variables_list.addItem(f"Point{a}-&gt;Point{b}")
    for name, paths in path_data.items():
        item = QListWidgetItem(name)
        item.setToolTip(", ".join(
            f'[{i}]' for i, path in enumerate(paths) if path
        ))
        self.records_list.addItem(item)
    self.__set_item_text(1, len(input_data), len(path_data))
    # Structure collections and Triangle collections
    for edges in collection_data:
        self.structures_list.addItem(str(edges))
    for name, data in config_data.items():
        item = QListWidgetItem(name)
        item.setToolTip(data['expression'])
        self.triangular_iteration_list.addItem(item)
    self.__set_item_text(2, len(collection_data), len(config_data))
    # Dimensional synthesis
    for data in algorithm_data:
        self.results_list.addItem(data['algorithm'])
    self.__set_item_text(3, len(algorithm_data))
    # Background image
    self.image_path.setText(background_path)
    self.__set_item_text(4, 1 if background_path else 0)
    self.background_preview.setPixmap(QPixmap(background_path))

</t>
<t tx="leo.20231205084738.207">def __set_item_text(self, i: int, *count: int) -&gt; None:
    """Set the title for a specified tab."""
    text = " / ".join(str(c) for c in count)
    self.tab_box.setItemText(i, f"{self.tab_box.itemText(i)} - ({text})")
</t>
<t tx="leo.20231205084738.208">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'overview.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.209">class Ui_Dialog(object):
    @others
</t>
<t tx="leo.20231205084738.21">def setupUi(self, Dialog):
    Dialog.setObjectName("Dialog")
    Dialog.resize(336, 467)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:link.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Dialog.setWindowIcon(icon)
    Dialog.setSizeGripEnabled(True)
    Dialog.setModal(True)
    self.horizontalLayout_4 = QtWidgets.QHBoxLayout(Dialog)
    self.horizontalLayout_4.setObjectName("horizontalLayout_4")
    self.verticalLayout = QtWidgets.QVBoxLayout()
    self.verticalLayout.setObjectName("verticalLayout")
    self.name_label = QtWidgets.QLabel(Dialog)
    self.name_label.setObjectName("name_label")
    self.verticalLayout.addWidget(self.name_label)
    self.name_box = QtWidgets.QComboBox(Dialog)
    self.name_box.setObjectName("name_box")
    self.verticalLayout.addWidget(self.name_box)
    self.name_edit = QtWidgets.QLineEdit(Dialog)
    self.name_edit.setClearButtonEnabled(True)
    self.name_edit.setObjectName("name_edit")
    self.verticalLayout.addWidget(self.name_edit)
    self.color_label = QtWidgets.QLabel(Dialog)
    self.color_label.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.color_label.setObjectName("color_label")
    self.verticalLayout.addWidget(self.color_label)
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    self.color_box = QtWidgets.QComboBox(Dialog)
    self.color_box.setObjectName("color_box")
    self.horizontalLayout_2.addWidget(self.color_box)
    self.color_pick_btn = QtWidgets.QPushButton(Dialog)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.color_pick_btn.sizePolicy().hasHeightForWidth())
    self.color_pick_btn.setSizePolicy(sizePolicy)
    self.color_pick_btn.setObjectName("color_pick_btn")
    self.horizontalLayout_2.addWidget(self.color_pick_btn)
    self.verticalLayout.addLayout(self.horizontalLayout_2)
    self.points_label = QtWidgets.QLabel(Dialog)
    self.points_label.setObjectName("points_label")
    self.verticalLayout.addWidget(self.points_label)
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.no_selected = QtWidgets.QListWidget(Dialog)
    self.no_selected.setDragEnabled(True)
    self.no_selected.setDragDropMode(QtWidgets.QAbstractItemView.DragDrop)
    self.no_selected.setDefaultDropAction(QtCore.Qt.MoveAction)
    self.no_selected.setObjectName("no_selected")
    self.horizontalLayout.addWidget(self.no_selected)
    self.label = QtWidgets.QLabel(Dialog)
    self.label.setObjectName("label")
    self.horizontalLayout.addWidget(self.label)
    self.selected = QtWidgets.QListWidget(Dialog)
    self.selected.setDragEnabled(True)
    self.selected.setDragDropMode(QtWidgets.QAbstractItemView.DragDrop)
    self.selected.setDefaultDropAction(QtCore.Qt.MoveAction)
    self.selected.setObjectName("selected")
    self.horizontalLayout.addWidget(self.selected)
    self.verticalLayout.addLayout(self.horizontalLayout)
    self.horizontalLayout_4.addLayout(self.verticalLayout)
    self.verticalLayout_2 = QtWidgets.QVBoxLayout()
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.btn_box = QtWidgets.QDialogButtonBox(Dialog)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.btn_box.sizePolicy().hasHeightForWidth())
    self.btn_box.setSizePolicy(sizePolicy)
    self.btn_box.setOrientation(QtCore.Qt.Vertical)
    self.btn_box.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok)
    self.btn_box.setObjectName("btn_box")
    self.verticalLayout_2.addWidget(self.btn_box)
    spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_2.addItem(spacerItem)
    self.horizontalLayout_4.addLayout(self.verticalLayout_2)

    self.retranslateUi(Dialog)
    self.btn_box.accepted.connect(Dialog.accept)
    self.btn_box.rejected.connect(Dialog.reject)
    QtCore.QMetaObject.connectSlotsByName(Dialog)

</t>
<t tx="leo.20231205084738.210">def setupUi(self, Dialog):
    Dialog.setObjectName("Dialog")
    Dialog.resize(442, 544)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:id.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Dialog.setWindowIcon(icon)
    Dialog.setSizeGripEnabled(True)
    Dialog.setModal(True)
    self.verticalLayout = QtWidgets.QVBoxLayout(Dialog)
    self.verticalLayout.setObjectName("verticalLayout")
    self.tab_box = QtWidgets.QToolBox(Dialog)
    self.tab_box.setObjectName("tab_box")
    self.page0 = QtWidgets.QWidget()
    self.page0.setGeometry(QtCore.QRect(0, 0, 424, 345))
    self.page0.setObjectName("page0")
    self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.page0)
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.main_expr_label = QtWidgets.QLabel(self.page0)
    self.main_expr_label.setObjectName("main_expr_label")
    self.verticalLayout_2.addWidget(self.main_expr_label)
    self.main_expr = QtWidgets.QLineEdit(self.page0)
    self.main_expr.setReadOnly(True)
    self.main_expr.setObjectName("main_expr")
    self.verticalLayout_2.addWidget(self.main_expr)
    self.storage_label = QtWidgets.QLabel(self.page0)
    self.storage_label.setObjectName("storage_label")
    self.verticalLayout_2.addWidget(self.storage_label)
    self.storage_list = QtWidgets.QListWidget(self.page0)
    self.storage_list.setObjectName("storage_list")
    self.verticalLayout_2.addWidget(self.storage_list)
    icon1 = QtGui.QIcon()
    icon1.addPixmap(QtGui.QPixmap("icons:mechanism.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.tab_box.addItem(self.page0, icon1, "")
    self.page1 = QtWidgets.QWidget()
    self.page1.setGeometry(QtCore.QRect(0, 0, 424, 345))
    self.page1.setObjectName("page1")
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.page1)
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    self.verticalLayout_3 = QtWidgets.QVBoxLayout()
    self.verticalLayout_3.setObjectName("verticalLayout_3")
    self.variables_label = QtWidgets.QLabel(self.page1)
    self.variables_label.setObjectName("variables_label")
    self.verticalLayout_3.addWidget(self.variables_label)
    self.variables_list = QtWidgets.QListWidget(self.page1)
    self.variables_list.setObjectName("variables_list")
    self.verticalLayout_3.addWidget(self.variables_list)
    self.horizontalLayout_2.addLayout(self.verticalLayout_3)
    self.verticalLayout_4 = QtWidgets.QVBoxLayout()
    self.verticalLayout_4.setObjectName("verticalLayout_4")
    self.records_label = QtWidgets.QLabel(self.page1)
    self.records_label.setObjectName("records_label")
    self.verticalLayout_4.addWidget(self.records_label)
    self.records_list = QtWidgets.QListWidget(self.page1)
    self.records_list.setObjectName("records_list")
    self.verticalLayout_4.addWidget(self.records_list)
    self.horizontalLayout_2.addLayout(self.verticalLayout_4)
    icon2 = QtGui.QIcon()
    icon2.addPixmap(QtGui.QPixmap("icons:motor.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.tab_box.addItem(self.page1, icon2, "")
    self.page2 = QtWidgets.QWidget()
    self.page2.setGeometry(QtCore.QRect(0, 0, 424, 345))
    self.page2.setObjectName("page2")
    self.horizontalLayout_3 = QtWidgets.QHBoxLayout(self.page2)
    self.horizontalLayout_3.setObjectName("horizontalLayout_3")
    self.verticalLayout_6 = QtWidgets.QVBoxLayout()
    self.verticalLayout_6.setObjectName("verticalLayout_6")
    self.structures_label = QtWidgets.QLabel(self.page2)
    self.structures_label.setObjectName("structures_label")
    self.verticalLayout_6.addWidget(self.structures_label)
    self.structures_list = QtWidgets.QListWidget(self.page2)
    self.structures_list.setObjectName("structures_list")
    self.verticalLayout_6.addWidget(self.structures_list)
    self.horizontalLayout_3.addLayout(self.verticalLayout_6)
    self.verticalLayout_5 = QtWidgets.QVBoxLayout()
    self.verticalLayout_5.setObjectName("verticalLayout_5")
    self.triangular_iteration_label = QtWidgets.QLabel(self.page2)
    self.triangular_iteration_label.setObjectName("triangular_iteration_label")
    self.verticalLayout_5.addWidget(self.triangular_iteration_label)
    self.triangular_iteration_list = QtWidgets.QListWidget(self.page2)
    self.triangular_iteration_list.setObjectName("triangular_iteration_list")
    self.verticalLayout_5.addWidget(self.triangular_iteration_list)
    self.horizontalLayout_3.addLayout(self.verticalLayout_5)
    icon3 = QtGui.QIcon()
    icon3.addPixmap(QtGui.QPixmap("icons:collections.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.tab_box.addItem(self.page2, icon3, "")
    self.page3 = QtWidgets.QWidget()
    self.page3.setGeometry(QtCore.QRect(0, 0, 424, 345))
    self.page3.setObjectName("page3")
    self.verticalLayout_7 = QtWidgets.QVBoxLayout(self.page3)
    self.verticalLayout_7.setObjectName("verticalLayout_7")
    self.results_label = QtWidgets.QLabel(self.page3)
    self.results_label.setObjectName("results_label")
    self.verticalLayout_7.addWidget(self.results_label)
    self.results_list = QtWidgets.QListWidget(self.page3)
    self.results_list.setObjectName("results_list")
    self.verticalLayout_7.addWidget(self.results_list)
    icon4 = QtGui.QIcon()
    icon4.addPixmap(QtGui.QPixmap("icons:dimensional_synthesis.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.tab_box.addItem(self.page3, icon4, "")
    self.page = QtWidgets.QWidget()
    self.page.setGeometry(QtCore.QRect(0, 0, 424, 345))
    self.page.setObjectName("page")
    self.verticalLayout_8 = QtWidgets.QVBoxLayout(self.page)
    self.verticalLayout_8.setObjectName("verticalLayout_8")
    self.image_path_label = QtWidgets.QLabel(self.page)
    self.image_path_label.setObjectName("image_path_label")
    self.verticalLayout_8.addWidget(self.image_path_label)
    self.image_path = QtWidgets.QLineEdit(self.page)
    self.image_path.setReadOnly(True)
    self.image_path.setObjectName("image_path")
    self.verticalLayout_8.addWidget(self.image_path)
    self.background_preview = QtWidgets.QLabel(self.page)
    self.background_preview.setObjectName("background_preview")
    self.verticalLayout_8.addWidget(self.background_preview)
    spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_8.addItem(spacerItem)
    icon5 = QtGui.QIcon()
    icon5.addPixmap(QtGui.QPixmap("icons:picture.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.tab_box.addItem(self.page, icon5, "")
    self.verticalLayout.addWidget(self.tab_box)
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout.addItem(spacerItem1)
    self.btn_box = QtWidgets.QDialogButtonBox(Dialog)
    self.btn_box.setStandardButtons(QtWidgets.QDialogButtonBox.Close)
    self.btn_box.setObjectName("btn_box")
    self.horizontalLayout.addWidget(self.btn_box)
    self.verticalLayout.addLayout(self.horizontalLayout)

    self.retranslateUi(Dialog)
    self.btn_box.rejected.connect(Dialog.reject)
    QtCore.QMetaObject.connectSlotsByName(Dialog)

</t>
<t tx="leo.20231205084738.211">def retranslateUi(self, Dialog):
    _translate = QtCore.QCoreApplication.translate
    self.main_expr_label.setText(_translate("Dialog", "Current:"))
    self.storage_label.setText(_translate("Dialog", "Storage:"))
    self.tab_box.setItemText(self.tab_box.indexOf(self.page0), _translate("Dialog", "Mechanism"))
    self.variables_label.setText(_translate("Dialog", "Variables:"))
    self.records_label.setText(_translate("Dialog", "Records:"))
    self.tab_box.setItemText(self.tab_box.indexOf(self.page1), _translate("Dialog", "Inputs"))
    self.structures_label.setText(_translate("Dialog", "Structures:"))
    self.triangular_iteration_label.setText(_translate("Dialog", "Triangular iteration:"))
    self.tab_box.setItemText(self.tab_box.indexOf(self.page2), _translate("Dialog", "Collections"))
    self.results_label.setText(_translate("Dialog", "Results:"))
    self.tab_box.setItemText(self.tab_box.indexOf(self.page3), _translate("Dialog", "Dimensional Synthesis"))
    self.image_path_label.setText(_translate("Dialog", "Image path:"))
    self.tab_box.setItemText(self.tab_box.indexOf(self.page), _translate("Dialog", "Background Image"))
</t>
<t tx="leo.20231205084738.212">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/
# -*- coding: utf-8 -*-

"""This module contains the preferences dialog."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Optional
from dataclasses import fields, Field
from qtpy.QtCore import Slot
from qtpy.QtWidgets import (
    QDialog,
    QLineEdit,
    QSpinBox,
    QDoubleSpinBox,
    QCheckBox,
    QComboBox,
    QDialogButtonBox,
    QMessageBox,
)
from qtpy.QtGui import QCloseEvent
from pyslvs_ui.info import KERNELS, Kernel
from pyslvs_ui.widgets import Preferences, MainWindowBase
from .format_editor import ProjectFormat
from .preference_ui import Ui_Dialog


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.213">class PreferencesDialog(QDialog, Ui_Dialog):
    """Preference dialog."""

    @others
</t>
<t tx="leo.20231205084738.214">def __init__(self, parent: MainWindowBase):
    super(PreferencesDialog, self).__init__(parent)
    self.setupUi(self)
    self.file_type_option.addItems([p.format_name for p in ProjectFormat])
    kernels = [s.title for s in KERNELS]
    self.planar_solver_option.addItems(kernels)
    self.path_preview_option.addItems(kernels + [Kernel.SAME_AS_SOLVING.title])
    self.prefer = parent.prefer.copy()
    self.prefer_applied = parent.prefer.copy()

    self.default_zoom_option.setMaximum(parent.zoom_bar.maximum())
    self.default_zoom_option.setMinimum(parent.zoom_bar.minimum())
    self.accepted.connect(self.__get_settings)
    self.btn_box.button(QDialogButtonBox.Apply).clicked.connect(self.__get_settings)
    self.btn_box.button(QDialogButtonBox.Cancel).clicked.connect(self.__cancel)
    self.btn_box.button(QDialogButtonBox.RestoreDefaults).clicked.connect(self.__reset)
    self.__load_settings()

</t>
<t tx="leo.20231205084738.215">@Slot()
def __reset(self) -&gt; None:
    """Reset user options."""
    self.prefer.reset()
    self.__load_settings()

</t>
<t tx="leo.20231205084738.216">@Slot()
def __load_settings(self) -&gt; None:
    """Load settings on UI."""
    for field in fields(self.prefer):  # type: Field
        widget = getattr(self, field.name)
        value = getattr(self.prefer, field.name)
        if isinstance(widget, (QSpinBox, QDoubleSpinBox)):
            widget.setValue(value)
        elif isinstance(widget, QLineEdit):
            widget.setText(value)
        elif isinstance(widget, QCheckBox):
            widget.setChecked(value)
        elif isinstance(widget, QComboBox):
            widget.setCurrentIndex(value)

</t>
<t tx="leo.20231205084738.217">@Slot()
def __get_settings(self, prefer: Optional[Preferences] = None) -&gt; None:
    """Save settings after clicked apply."""
    if prefer is None:
        prefer = self.prefer_applied
    for field in fields(prefer):  # type: Field
        widget = getattr(self, field.name)
        if isinstance(widget, (QSpinBox, QDoubleSpinBox)):
            setattr(prefer, field.name, widget.value())
        elif isinstance(widget, QLineEdit):
            setattr(prefer, field.name, widget.text())
        elif isinstance(widget, QCheckBox):
            setattr(prefer, field.name, widget.isChecked())
        elif isinstance(widget, QComboBox):
            setattr(prefer, field.name, widget.currentIndex())

</t>
<t tx="leo.20231205084738.218">@Slot()
def __cancel(self) -&gt; None:
    """Cancel button clicked."""
    if self.__cancel_check():
        self.reject()

</t>
<t tx="leo.20231205084738.219">def closeEvent(self, event: QCloseEvent):
    if self.__cancel_check():
        event.accept()
    else:
        event.ignore()

</t>
<t tx="leo.20231205084738.22">def retranslateUi(self, Dialog):
    _translate = QtCore.QCoreApplication.translate
    Dialog.setWindowTitle(_translate("Dialog", "Link"))
    self.name_label.setText(_translate("Dialog", "Name:"))
    self.color_label.setText(_translate("Dialog", "Emphatic Color:"))
    self.points_label.setText(_translate("Dialog", "Points:"))
    self.label.setText(_translate("Dialog", "&gt;&gt;"))
</t>
<t tx="leo.20231205084738.220">def __cancel_check(self) -&gt; bool:
    """Ask for saving options."""
    self.__get_settings(self.prefer)
    if sum(1 for _ in self.prefer_applied.diff(self.prefer)) &lt; 1:
        return True
    reply = QMessageBox.question(
        self,
        "Option changed",
        "Do you want to save the changes?",
        QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel
    )
    if reply == QMessageBox.Save:
        self.prefer_applied = self.prefer
        return True
    elif reply == QMessageBox.Discard:
        return True
    else:
        return False
</t>
<t tx="leo.20231205084738.221">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'preference.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.222">class Ui_Dialog(object):
    @others
</t>
<t tx="leo.20231205084738.223">def setupUi(self, Dialog):
    Dialog.setObjectName("Dialog")
    Dialog.resize(865, 427)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:settings.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Dialog.setWindowIcon(icon)
    Dialog.setSizeGripEnabled(True)
    Dialog.setModal(True)
    self.verticalLayout_2 = QtWidgets.QVBoxLayout(Dialog)
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.settings_ui_groupbox = QtWidgets.QGroupBox(Dialog)
    self.settings_ui_groupbox.setObjectName("settings_ui_groupbox")
    self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.settings_ui_groupbox)
    self.verticalLayout_3.setObjectName("verticalLayout_3")
    self.gridLayout = QtWidgets.QGridLayout()
    self.gridLayout.setObjectName("gridLayout")
    self.zoomby_label = QtWidgets.QLabel(self.settings_ui_groupbox)
    self.zoomby_label.setObjectName("zoomby_label")
    self.gridLayout.addWidget(self.zoomby_label, 3, 2, 1, 1)
    self.font_size_option = QtWidgets.QSpinBox(self.settings_ui_groupbox)
    self.font_size_option.setMinimum(1)
    self.font_size_option.setMaximum(30)
    self.font_size_option.setSingleStep(2)
    self.font_size_option.setObjectName("font_size_option")
    self.gridLayout.addWidget(self.font_size_option, 0, 3, 1, 1)
    self.tick_mark_label = QtWidgets.QLabel(self.settings_ui_groupbox)
    self.tick_mark_label.setObjectName("tick_mark_label")
    self.gridLayout.addWidget(self.tick_mark_label, 4, 2, 1, 1)
    self.zoom_by_option = QtWidgets.QComboBox(self.settings_ui_groupbox)
    self.zoom_by_option.setObjectName("zoom_by_option")
    self.zoom_by_option.addItem("")
    self.zoom_by_option.addItem("")
    self.gridLayout.addWidget(self.zoom_by_option, 3, 3, 1, 1)
    self.line_width_option = QtWidgets.QSpinBox(self.settings_ui_groupbox)
    self.line_width_option.setMinimum(1)
    self.line_width_option.setMaximum(10)
    self.line_width_option.setDisplayIntegerBase(10)
    self.line_width_option.setObjectName("line_width_option")
    self.gridLayout.addWidget(self.line_width_option, 0, 1, 1, 1)
    self.scale_factor_option = QtWidgets.QSpinBox(self.settings_ui_groupbox)
    self.scale_factor_option.setMinimum(5)
    self.scale_factor_option.setMaximum(100)
    self.scale_factor_option.setSingleStep(5)
    self.scale_factor_option.setObjectName("scale_factor_option")
    self.gridLayout.addWidget(self.scale_factor_option, 1, 3, 1, 1)
    self.linewidth_label = QtWidgets.QLabel(self.settings_ui_groupbox)
    self.linewidth_label.setObjectName("linewidth_label")
    self.gridLayout.addWidget(self.linewidth_label, 0, 0, 1, 1)
    self.fontsize_label = QtWidgets.QLabel(self.settings_ui_groupbox)
    self.fontsize_label.setObjectName("fontsize_label")
    self.gridLayout.addWidget(self.fontsize_label, 0, 2, 1, 1)
    self.snap_label = QtWidgets.QLabel(self.settings_ui_groupbox)
    self.snap_label.setObjectName("snap_label")
    self.gridLayout.addWidget(self.snap_label, 5, 0, 1, 1)
    self.jointsize_label = QtWidgets.QLabel(self.settings_ui_groupbox)
    self.jointsize_label.setObjectName("jointsize_label")
    self.gridLayout.addWidget(self.jointsize_label, 4, 0, 1, 1)
    self.pathwidth_label = QtWidgets.QLabel(self.settings_ui_groupbox)
    self.pathwidth_label.setObjectName("pathwidth_label")
    self.gridLayout.addWidget(self.pathwidth_label, 1, 0, 1, 1)
    self.linktransparency_label = QtWidgets.QLabel(self.settings_ui_groupbox)
    self.linktransparency_label.setObjectName("linktransparency_label")
    self.gridLayout.addWidget(self.linktransparency_label, 2, 2, 1, 1)
    self.margin_factor_option = QtWidgets.QSpinBox(self.settings_ui_groupbox)
    self.margin_factor_option.setMaximum(30)
    self.margin_factor_option.setSingleStep(5)
    self.margin_factor_option.setObjectName("margin_factor_option")
    self.gridLayout.addWidget(self.margin_factor_option, 3, 1, 1, 1)
    self.toolbar_pos_label = QtWidgets.QLabel(self.settings_ui_groupbox)
    self.toolbar_pos_label.setObjectName("toolbar_pos_label")
    self.gridLayout.addWidget(self.toolbar_pos_label, 5, 2, 1, 1)
    self.selectionradius_label = QtWidgets.QLabel(self.settings_ui_groupbox)
    self.selectionradius_label.setObjectName("selectionradius_label")
    self.gridLayout.addWidget(self.selectionradius_label, 2, 0, 1, 1)
    self.scalefactor_label = QtWidgets.QLabel(self.settings_ui_groupbox)
    self.scalefactor_label.setObjectName("scalefactor_label")
    self.gridLayout.addWidget(self.scalefactor_label, 1, 2, 1, 1)
    self.nav_toolbar_pos_option = QtWidgets.QComboBox(self.settings_ui_groupbox)
    self.nav_toolbar_pos_option.setObjectName("nav_toolbar_pos_option")
    self.nav_toolbar_pos_option.addItem("")
    self.nav_toolbar_pos_option.addItem("")
    self.gridLayout.addWidget(self.nav_toolbar_pos_option, 5, 3, 1, 1)
    self.marginfactor_label = QtWidgets.QLabel(self.settings_ui_groupbox)
    self.marginfactor_label.setObjectName("marginfactor_label")
    self.gridLayout.addWidget(self.marginfactor_label, 3, 0, 1, 1)
    self.joint_size_option = QtWidgets.QSpinBox(self.settings_ui_groupbox)
    self.joint_size_option.setMinimum(1)
    self.joint_size_option.setMaximum(100)
    self.joint_size_option.setObjectName("joint_size_option")
    self.gridLayout.addWidget(self.joint_size_option, 4, 1, 1, 1)
    self.path_width_option = QtWidgets.QSpinBox(self.settings_ui_groupbox)
    self.path_width_option.setMinimum(1)
    self.path_width_option.setMaximum(5)
    self.path_width_option.setObjectName("path_width_option")
    self.gridLayout.addWidget(self.path_width_option, 1, 1, 1, 1)
    self.link_trans_option = QtWidgets.QSpinBox(self.settings_ui_groupbox)
    self.link_trans_option.setMaximum(80)
    self.link_trans_option.setSingleStep(10)
    self.link_trans_option.setObjectName("link_trans_option")
    self.gridLayout.addWidget(self.link_trans_option, 2, 3, 1, 1)
    self.snap_option = QtWidgets.QDoubleSpinBox(self.settings_ui_groupbox)
    self.snap_option.setMaximum(50.0)
    self.snap_option.setObjectName("snap_option")
    self.gridLayout.addWidget(self.snap_option, 5, 1, 1, 1)
    self.tick_mark_option = QtWidgets.QComboBox(self.settings_ui_groupbox)
    self.tick_mark_option.setObjectName("tick_mark_option")
    self.tick_mark_option.addItem("")
    self.tick_mark_option.addItem("")
    self.tick_mark_option.addItem("")
    self.gridLayout.addWidget(self.tick_mark_option, 4, 3, 1, 1)
    self.selection_radius_option = QtWidgets.QSpinBox(self.settings_ui_groupbox)
    self.selection_radius_option.setMinimum(3)
    self.selection_radius_option.setMaximum(10)
    self.selection_radius_option.setObjectName("selection_radius_option")
    self.gridLayout.addWidget(self.selection_radius_option, 2, 1, 1, 1)
    self.default_zoom_label = QtWidgets.QLabel(self.settings_ui_groupbox)
    self.default_zoom_label.setObjectName("default_zoom_label")
    self.gridLayout.addWidget(self.default_zoom_label, 6, 0, 1, 1)
    self.default_zoom_option = QtWidgets.QSpinBox(self.settings_ui_groupbox)
    self.default_zoom_option.setObjectName("default_zoom_option")
    self.gridLayout.addWidget(self.default_zoom_option, 6, 1, 1, 1)
    self.verticalLayout_3.addLayout(self.gridLayout)
    self.grab_no_background_option = QtWidgets.QCheckBox(self.settings_ui_groupbox)
    self.grab_no_background_option.setObjectName("grab_no_background_option")
    self.verticalLayout_3.addWidget(self.grab_no_background_option)
    self.monochrome_option = QtWidgets.QCheckBox(self.settings_ui_groupbox)
    self.monochrome_option.setObjectName("monochrome_option")
    self.verticalLayout_3.addWidget(self.monochrome_option)
    spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_3.addItem(spacerItem)
    self.horizontalLayout.addWidget(self.settings_ui_groupbox)
    self.verticalLayout = QtWidgets.QVBoxLayout()
    self.verticalLayout.setObjectName("verticalLayout")
    self.settings_kernels_groupBox = QtWidgets.QGroupBox(Dialog)
    self.settings_kernels_groupBox.setObjectName("settings_kernels_groupBox")
    self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.settings_kernels_groupBox)
    self.verticalLayout_4.setObjectName("verticalLayout_4")
    self.formLayout_3 = QtWidgets.QFormLayout()
    self.formLayout_3.setObjectName("formLayout_3")
    self.planarsolver_label = QtWidgets.QLabel(self.settings_kernels_groupBox)
    self.planarsolver_label.setObjectName("planarsolver_label")
    self.formLayout_3.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.planarsolver_label)
    self.planar_solver_option = QtWidgets.QComboBox(self.settings_kernels_groupBox)
    self.planar_solver_option.setObjectName("planar_solver_option")
    self.formLayout_3.setWidget(0, QtWidgets.QFormLayout.FieldRole, self.planar_solver_option)
    self.pathpreview_label = QtWidgets.QLabel(self.settings_kernels_groupBox)
    self.pathpreview_label.setObjectName("pathpreview_label")
    self.formLayout_3.setWidget(1, QtWidgets.QFormLayout.LabelRole, self.pathpreview_label)
    self.path_preview_option = QtWidgets.QComboBox(self.settings_kernels_groupBox)
    self.path_preview_option.setObjectName("path_preview_option")
    self.formLayout_3.setWidget(1, QtWidgets.QFormLayout.FieldRole, self.path_preview_option)
    self.verticalLayout_4.addLayout(self.formLayout_3)
    self.console_error_option = QtWidgets.QCheckBox(self.settings_kernels_groupBox)
    self.console_error_option.setObjectName("console_error_option")
    self.verticalLayout_4.addWidget(self.console_error_option)
    self.verticalLayout.addWidget(self.settings_kernels_groupBox)
    self.settings_project_groupbox = QtWidgets.QGroupBox(Dialog)
    self.settings_project_groupbox.setObjectName("settings_project_groupbox")
    self.formLayout_2 = QtWidgets.QFormLayout(self.settings_project_groupbox)
    self.formLayout_2.setObjectName("formLayout_2")
    self.undo_limit_label = QtWidgets.QLabel(self.settings_project_groupbox)
    self.undo_limit_label.setObjectName("undo_limit_label")
    self.formLayout_2.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.undo_limit_label)
    self.undo_limit_option = QtWidgets.QSpinBox(self.settings_project_groupbox)
    self.undo_limit_option.setMinimum(5)
    self.undo_limit_option.setObjectName("undo_limit_option")
    self.formLayout_2.setWidget(0, QtWidgets.QFormLayout.FieldRole, self.undo_limit_option)
    self.open_project_actions_label = QtWidgets.QLabel(self.settings_project_groupbox)
    self.open_project_actions_label.setObjectName("open_project_actions_label")
    self.formLayout_2.setWidget(1, QtWidgets.QFormLayout.LabelRole, self.open_project_actions_label)
    self.open_project_actions_option = QtWidgets.QComboBox(self.settings_project_groupbox)
    self.open_project_actions_option.setObjectName("open_project_actions_option")
    self.open_project_actions_option.addItem("")
    self.open_project_actions_option.addItem("")
    self.open_project_actions_option.addItem("")
    self.formLayout_2.setWidget(1, QtWidgets.QFormLayout.FieldRole, self.open_project_actions_option)
    self.file_type_label = QtWidgets.QLabel(self.settings_project_groupbox)
    self.file_type_label.setObjectName("file_type_label")
    self.formLayout_2.setWidget(2, QtWidgets.QFormLayout.LabelRole, self.file_type_label)
    self.file_type_option = QtWidgets.QComboBox(self.settings_project_groupbox)
    self.file_type_option.setObjectName("file_type_option")
    self.formLayout_2.setWidget(2, QtWidgets.QFormLayout.FieldRole, self.file_type_option)
    self.verticalLayout.addWidget(self.settings_project_groupbox)
    self.settings_misc_groupBox = QtWidgets.QGroupBox(Dialog)
    self.settings_misc_groupBox.setObjectName("settings_misc_groupBox")
    self.verticalLayout_7 = QtWidgets.QVBoxLayout(self.settings_misc_groupBox)
    self.verticalLayout_7.setObjectName("verticalLayout_7")
    self.auto_remove_link_option = QtWidgets.QCheckBox(self.settings_misc_groupBox)
    self.auto_remove_link_option.setObjectName("auto_remove_link_option")
    self.verticalLayout_7.addWidget(self.auto_remove_link_option)
    self.title_full_path_option = QtWidgets.QCheckBox(self.settings_misc_groupBox)
    self.title_full_path_option.setObjectName("title_full_path_option")
    self.verticalLayout_7.addWidget(self.title_full_path_option)
    self.not_save_option = QtWidgets.QCheckBox(self.settings_misc_groupBox)
    self.not_save_option.setObjectName("not_save_option")
    self.verticalLayout_7.addWidget(self.not_save_option)
    spacerItem1 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_7.addItem(spacerItem1)
    self.verticalLayout.addWidget(self.settings_misc_groupBox)
    self.horizontalLayout.addLayout(self.verticalLayout)
    self.verticalLayout_2.addLayout(self.horizontalLayout)
    self.btn_box = QtWidgets.QDialogButtonBox(Dialog)
    self.btn_box.setOrientation(QtCore.Qt.Horizontal)
    self.btn_box.setStandardButtons(QtWidgets.QDialogButtonBox.Apply|QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok|QtWidgets.QDialogButtonBox.RestoreDefaults)
    self.btn_box.setObjectName("btn_box")
    self.verticalLayout_2.addWidget(self.btn_box)

    self.retranslateUi(Dialog)
    self.btn_box.accepted.connect(Dialog.accept)
    QtCore.QMetaObject.connectSlotsByName(Dialog)

</t>
<t tx="leo.20231205084738.224">def retranslateUi(self, Dialog):
    _translate = QtCore.QCoreApplication.translate
    Dialog.setWindowTitle(_translate("Dialog", "Preference"))
    self.settings_ui_groupbox.setTitle(_translate("Dialog", "Main canvas"))
    self.zoomby_label.setText(_translate("Dialog", "Center zooming"))
    self.tick_mark_label.setText(_translate("Dialog", "Tick mark"))
    self.zoom_by_option.setItemText(0, _translate("Dialog", "Cursor"))
    self.zoom_by_option.setItemText(1, _translate("Dialog", "Cavas center"))
    self.linewidth_label.setText(_translate("Dialog", "Line width"))
    self.fontsize_label.setText(_translate("Dialog", "Font size"))
    self.snap_label.setText(_translate("Dialog", "Snap the mouse when dragging"))
    self.jointsize_label.setText(_translate("Dialog", "Joint annotation size (diameter)"))
    self.pathwidth_label.setText(_translate("Dialog", "Path width"))
    self.linktransparency_label.setText(_translate("Dialog", "Link transparency"))
    self.margin_factor_option.setSuffix(_translate("Dialog", "%"))
    self.toolbar_pos_label.setText(_translate("Dialog", "Toolbar position"))
    self.selectionradius_label.setText(_translate("Dialog", "Selection radius"))
    self.scalefactor_label.setText(_translate("Dialog", "Scale factor"))
    self.nav_toolbar_pos_option.setItemText(0, _translate("Dialog", "Top"))
    self.nav_toolbar_pos_option.setItemText(1, _translate("Dialog", "Bottom"))
    self.marginfactor_label.setText(_translate("Dialog", "Margin of \"zoom to fit\""))
    self.link_trans_option.setSuffix(_translate("Dialog", " %"))
    self.tick_mark_option.setItemText(0, _translate("Dialog", "Hide"))
    self.tick_mark_option.setItemText(1, _translate("Dialog", "Display"))
    self.tick_mark_option.setItemText(2, _translate("Dialog", "Display with number"))
    self.default_zoom_label.setText(_translate("Dialog", "Default zoom value"))
    self.default_zoom_option.setSuffix(_translate("Dialog", "%"))
    self.grab_no_background_option.setText(_translate("Dialog", "Use transparent background when capturing."))
    self.monochrome_option.setText(_translate("Dialog", "Monochrome mode for mechanism. (Excluding indicators)"))
    self.settings_kernels_groupBox.setTitle(_translate("Dialog", "Kernels"))
    self.planarsolver_label.setText(_translate("Dialog", "Planar solving"))
    self.pathpreview_label.setText(_translate("Dialog", "Path preview"))
    self.console_error_option.setText(_translate("Dialog", "Show error messages in the console."))
    self.settings_project_groupbox.setTitle(_translate("Dialog", "Project and history"))
    self.undo_limit_label.setText(_translate("Dialog", "Undo limit"))
    self.undo_limit_option.setSuffix(_translate("Dialog", " times"))
    self.open_project_actions_label.setText(_translate("Dialog", "Open project actions"))
    self.open_project_actions_option.setItemText(0, _translate("Dialog", "No undo"))
    self.open_project_actions_option.setItemText(1, _translate("Dialog", "Group with macros"))
    self.open_project_actions_option.setItemText(2, _translate("Dialog", "No group"))
    self.file_type_label.setText(_translate("Dialog", "File type"))
    self.settings_misc_groupBox.setTitle(_translate("Dialog", "Misc"))
    self.auto_remove_link_option.setText(_translate("Dialog", "Remove empty links after deleted points."))
    self.title_full_path_option.setText(_translate("Dialog", "Show full file path on window title."))
    self.not_save_option.setText(_translate("Dialog", "Don\'t save Pyslvs options to local."))
</t>
<t tx="leo.20231205084738.225">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/
# -*- coding: utf-8 -*-

"""SQL database output function."""

from __future__ import annotations

__all__ = ['ProjectFormat', 'ProjectWidget']
__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import TYPE_CHECKING, Mapping, Union
from os.path import join
from qtpy.QtCore import Slot, QFileInfo, QDateTime
from qtpy.QtWidgets import (
    QUndoView,
    QVBoxLayout,
    QWidget,
    QInputDialog,
    QMessageBox,
)
from qtpy.QtGui import QPixmap, QIcon
from pyslvs import example_list, all_examples
from pyslvs_ui.info import logger, size_format
from pyslvs_ui.qt_patch import qt_image_format
from .project_yaml import YamlEditor
from .project_pickle import PickleEditor
from .project_ui import Ui_Form
from .format_editor import ProjectFormat

if TYPE_CHECKING:
    from pyslvs_ui.widgets import MainWindowBase


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.226">class ProjectWidget(QWidget, Ui_Form):
    """The table that stored project data and changes."""

    @others
</t>
<t tx="leo.20231205084738.227">def __init__(self, parent: MainWindowBase):
    super(ProjectWidget, self).__init__(parent)
    self.setupUi(self)
    # Undo view
    self.command_stack = parent.cmd_stack
    undo_view = QUndoView(self.command_stack)
    undo_view.setEmptyLabel("~Start Pyslvs")
    w = QWidget(self)
    layout = QVBoxLayout(w)
    layout.addWidget(undo_view)
    history_icon = QIcon(QPixmap("icons:history.png"))
    self.history_tabs.addTab(w, history_icon, "Mechanism")
    # Settings
    self.prefer = parent.prefer
    # Check project saved function
    self.project_saved = parent.project_saved
    # Open file dialog
    self.input_from = parent.input_from
    # Parse function
    self.parse_expression = parent.parse_expression
    # Call to load inputs variables data
    self.load_inputs = parent.inputs_widget.add_inputs_variables
    # Clear function for main window
    self.main_clear = parent.clear
    # Environment path
    self.env_path = parent.env_path

    self.overview_btn.clicked.connect(parent.show_overview)
    self.ex_expression_btn.clicked.connect(parent.show_expr)
    self.ex_dxf_btn.clicked.connect(parent.export_dxf)
    self.ex_slvs_btn.clicked.connect(parent.export_slvs)
    self.ex_pmks_btn.clicked.connect(parent.save_pmks)
    self.ex_py_btn.clicked.connect(parent.py_script)
    self.ex_image_btn.clicked.connect(parent.export_image)
    self.ex_capture_btn.clicked.connect(parent.save_picture_clipboard)

    self.im_pmks_btn.clicked.connect(parent.import_pmks_url)
    self.im_example_btn.clicked.connect(lambda: self.load_example(is_import=True))

    self.background_option.textChanged.connect(parent.main_canvas.set_background)
    self.background_opacity_option.valueChanged.connect(parent.main_canvas.set_background_opacity)
    self.background_x_option.valueChanged.connect(parent.main_canvas.set_background_offset_x)
    self.background_y_option.valueChanged.connect(parent.main_canvas.set_background_offset_y)
    self.background_scale_option.valueChanged.connect(parent.main_canvas.set_background_scale)

    # Editors
    self.yaml_editor = YamlEditor(self, parent)
    self.pickle_editor = PickleEditor(self, parent)
    # Reset
    self.__file_name = QFileInfo()
    self.__changed = False
    self.reset()

</t>
<t tx="leo.20231205084738.228">def reset(self) -&gt; None:
    """Clear all the things that dependent on database."""
    self.set_file_name(join(self.env_path(), "Untitled"))
    self.__changed = False
    self.command_stack.clear()
    self.command_stack.setUndoLimit(self.prefer.undo_limit_option)
    self.set_background_config({})

</t>
<t tx="leo.20231205084738.229">def set_file_name(self, file_name: str, *, is_example: bool = False) -&gt; None:
    """Set file name."""
    self.__file_name = QFileInfo(file_name)
    self.file_name_label.setText(self.__file_name.fileName())
    self.path_label.setText(self.__file_name.absolutePath())
    self.owner_label.setText(self.__file_name.owner())
    time: QDateTime = self.__file_name.lastModified()
    self.last_modified_label.setText(time.toString())
    self.file_size_label.setText(size_format(self.__file_name.size()))
    if is_example:
        t = "Example (In memory)"
    elif self.file_exist():
        t = f"File ({self.prefer.file_type_option.format_name})"
    else:
        t = "In memory"
    self.type_label.setText(t)

</t>
<t tx="leo.20231205084738.23">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/entities/
# -*- coding: utf-8 -*-

"""The option dialog used to create or edit the point."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import List, Union
from qtpy.QtCore import Slot, Qt
from qtpy.QtWidgets import QDialog, QListWidgetItem, QColorDialog, QWidget
from qtpy.QtGui import QIcon, QPixmap
from pyslvs import VPoint, VLink, color_names
from pyslvs_ui.graphics import color_qt, color_icon
from .utility import set_custom_color, add_custom_color
from .relocate_point import RelocateDialog
from .edit_point_ui import Ui_Dialog


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.230">def file_name(self) -&gt; QFileInfo:
    """Expose file name."""
    return self.__file_name

</t>
<t tx="leo.20231205084738.231">def file_path(self) -&gt; str:
    """Expose absolute file path."""
    return self.__file_name.absoluteFilePath()

</t>
<t tx="leo.20231205084738.232">def base_file_name(self) -&gt; str:
    """Expose base file name."""
    return self.__file_name.baseName()

</t>
<t tx="leo.20231205084738.233">def file_suffix(self) -&gt; str:
    """Expose file name suffix."""
    return self.__file_name.suffix()

</t>
<t tx="leo.20231205084738.234">def file_exist(self) -&gt; bool:
    """Return true if the file is exist."""
    return self.__file_name.isFile()

</t>
<t tx="leo.20231205084738.235">def set_changed(self, changed: bool) -&gt; None:
    """Set file state."""
    self.__changed = changed

</t>
<t tx="leo.20231205084738.236">def changed(self) -&gt; bool:
    """Expose file state."""
    return self.__changed

</t>
<t tx="leo.20231205084738.237">def save(self, file_name: str = "") -&gt; None:
    """Save database, append commit to new branch function."""
    if not file_name:
        file_name = self.file_path()
    if self.prefer.file_type_option == ProjectFormat.PICKLE:
        self.pickle_editor.save(file_name)
    else:
        self.yaml_editor.save(file_name)
    self.set_file_name(file_name)

</t>
<t tx="leo.20231205084738.238">def read(self, file_name: str) -&gt; None:
    """Load database commit."""
    if not QFileInfo(file_name).isFile():
        QMessageBox.warning(self, "File not exist", "The path is invalid.")
        return
    if YamlEditor.test(file_name):
        self.yaml_editor.load(file_name)
    else:
        self.pickle_editor.load(file_name)
    if self.prefer.open_project_actions_option == 0:
        self.command_stack.clear()
        self.command_stack.setUndoLimit(self.prefer.undo_limit_option)
    self.set_file_name(file_name)

</t>
<t tx="leo.20231205084738.239">def load_example(self, is_import: bool = False) -&gt; bool:
    """Load example to new project."""
    # load example by expression
    example_name, ok = QInputDialog.getItem(
        self,
        "Examples",
        "Select an example to load:",
        all_examples(),
        0,
        False
    )
    if not ok:
        return False
    if not is_import:
        self.reset()
        self.main_clear()
        if self.prefer.open_project_actions_option == 1:
            self.command_stack.beginMacro("Add mechanism")
    expr, inputs = example_list(example_name)
    self.parse_expression(expr)
    if not is_import:
        if self.prefer.open_project_actions_option == 1:
            self.command_stack.endMacro()
            self.command_stack.beginMacro("Add inputs data")
        # Import without inputs data
        self.load_inputs(inputs)
        if self.prefer.open_project_actions_option == 0:
            self.command_stack.clear()
            self.command_stack.setUndoLimit(self.prefer.undo_limit_option)
        elif self.prefer.open_project_actions_option == 1:
            self.command_stack.endMacro()
    self.set_file_name(example_name, is_example=True)
    self.project_saved()
    logger.info(f"Example \"{example_name}\" has been loaded.")
    return True

</t>
<t tx="leo.20231205084738.24">class EditPointDialog(QDialog, Ui_Dialog):
    """Option dialog."""

    @others
</t>
<t tx="leo.20231205084738.240">@Slot(name='on_background_choose_dir_clicked')
def __background_choose_dir(self) -&gt; None:
    """Choose background directory."""
    file_name = self.input_from("background image", qt_image_format)
    if file_name:
        self.background_option.setText(file_name)

</t>
<t tx="leo.20231205084738.241">def background_config(self) -&gt; Mapping[str, Union[str, float]]:
    """Return background config."""
    env = self.__file_name.absoluteDir()
    return {
        'background': env.relativeFilePath(self.background_option.text()),
        'background_x': self.background_x_option.value(),
        'background_y': self.background_y_option.value(),
        'background_scale': self.background_scale_option.value(),
        'background_opacity': self.background_opacity_option.value(),
    }

</t>
<t tx="leo.20231205084738.242">def set_background_config(self, config: Mapping[str, Union[str, float]]) -&gt; None:
    """Set background config by dict object."""
    env = self.__file_name.absoluteDir()
    file = QFileInfo(env, config.get('background', ""))
    path = file.absoluteFilePath()
    self.background_option.setText(path if file.isFile() else "")
    self.background_x_option.setValue(config.get('background_x', 0.))
    self.background_y_option.setValue(config.get('background_y', 0.))
    self.background_scale_option.setValue(config.get('background_scale', 1.))
    self.background_opacity_option.setValue(config.get('background_opacity', 1.))

</t>
<t tx="leo.20231205084738.243">def get_background_path(self) -&gt; str:
    """Get background path."""
    path = self.background_option.text()
    return path if QFileInfo(path).isFile() else ""
</t>
<t tx="leo.20231205084738.244">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/
# -*- coding: utf-8 -*-

"""Pickle format processing function."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from pickle import load, dump, UnpicklingError, HIGHEST_PROTOCOL
from qtpy.QtWidgets import QMessageBox
from .format_editor import FormatEditor


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.245">class PickleEditor(FormatEditor):
    """Pickle reader and writer."""

    @others
</t>
<t tx="leo.20231205084738.246">def __init__(self, *args):
    super(PickleEditor, self).__init__(*args)

</t>
<t tx="leo.20231205084738.247">@staticmethod
def test(file_name: str) -&gt; bool:
    """Test the file is valid."""
    try:
        with open(file_name, 'rb') as f:
            load(f)
    except (OSError, UnicodeError, UnpicklingError):
        return False
    else:
        return True

</t>
<t tx="leo.20231205084738.248">def save(self, file_name: str) -&gt; None:
    """Save to pickle file."""
    data = self.save_data()
    with open(file_name, 'wb') as f:
        dump(data, f, HIGHEST_PROTOCOL)

</t>
<t tx="leo.20231205084738.249">def load(self, file_name: str) -&gt; None:
    """Load a pickle file."""
    try:
        with open(file_name, 'rb') as f:
            data = load(f)
    except (OSError, UnicodeError, UnpicklingError) as e:
        QMessageBox.warning(self._parent, "Loader Error", f"{e}")
    self.load_data(file_name, data)
</t>
<t tx="leo.20231205084738.25">def __init__(
    self,
    vpoints: List[VPoint],
    vlinks: List[VLink],
    pos: Union[int, bool],
    parent: QWidget
):
    """Input data reference from main window.

    + Needs VPoints and VLinks information.
    + If row is false: Create action.
    """
    super(EditPointDialog, self).__init__(parent)
    self.setupUi(self)
    self.setWindowFlags(self.windowFlags()
                        &amp; ~Qt.WindowContextHelpButtonHint)
    icon = self.windowIcon()
    self.icon = QIcon(QPixmap("icons:link.png"))
    self.vpoints = vpoints
    self.vlinks = vlinks
    vpoints_count = len(vpoints)
    for i, e in enumerate(color_names):
        self.color_box.insertItem(i, color_icon(e), e)
    for vlink in vlinks:
        self.no_selected.addItem(QListWidgetItem(self.icon, vlink.name))
    if pos is False:
        self.name_box.addItem(icon, f'Point{vpoints_count}')
        self.name_box.setEnabled(False)
        self.color_box.setCurrentIndex(self.color_box.findText('green'))
    else:
        for i in range(vpoints_count):
            self.name_box.insertItem(i, icon, f'Point{i}')
        self.name_box.setCurrentIndex(pos)
    self.type_box.currentIndexChanged.connect(self.__check_angle)
    self.__check_angle()

</t>
<t tx="leo.20231205084738.250">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'project.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.251">class Ui_Form(object):
    @others
</t>
<t tx="leo.20231205084738.252">def setupUi(self, Form):
    Form.setObjectName("Form")
    Form.resize(326, 588)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:id.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Form.setWindowIcon(icon)
    self.verticalLayout_2 = QtWidgets.QVBoxLayout(Form)
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.formLayout = QtWidgets.QFormLayout()
    self.formLayout.setObjectName("formLayout")
    self.file_name_title = QtWidgets.QLabel(Form)
    self.file_name_title.setObjectName("file_name_title")
    self.formLayout.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.file_name_title)
    self.file_name_label = QtWidgets.QLineEdit(Form)
    self.file_name_label.setReadOnly(True)
    self.file_name_label.setObjectName("file_name_label")
    self.formLayout.setWidget(0, QtWidgets.QFormLayout.FieldRole, self.file_name_label)
    self.path_title = QtWidgets.QLabel(Form)
    self.path_title.setObjectName("path_title")
    self.formLayout.setWidget(1, QtWidgets.QFormLayout.LabelRole, self.path_title)
    self.path_label = QtWidgets.QLineEdit(Form)
    self.path_label.setReadOnly(True)
    self.path_label.setObjectName("path_label")
    self.formLayout.setWidget(1, QtWidgets.QFormLayout.FieldRole, self.path_label)
    self.owner_title = QtWidgets.QLabel(Form)
    self.owner_title.setObjectName("owner_title")
    self.formLayout.setWidget(2, QtWidgets.QFormLayout.LabelRole, self.owner_title)
    self.owner_label = QtWidgets.QLabel(Form)
    self.owner_label.setObjectName("owner_label")
    self.formLayout.setWidget(2, QtWidgets.QFormLayout.FieldRole, self.owner_label)
    self.last_modified_title = QtWidgets.QLabel(Form)
    self.last_modified_title.setObjectName("last_modified_title")
    self.formLayout.setWidget(3, QtWidgets.QFormLayout.LabelRole, self.last_modified_title)
    self.last_modified_label = QtWidgets.QLabel(Form)
    self.last_modified_label.setObjectName("last_modified_label")
    self.formLayout.setWidget(3, QtWidgets.QFormLayout.FieldRole, self.last_modified_label)
    self.file_size_title = QtWidgets.QLabel(Form)
    self.file_size_title.setObjectName("file_size_title")
    self.formLayout.setWidget(4, QtWidgets.QFormLayout.LabelRole, self.file_size_title)
    self.file_size_label = QtWidgets.QLabel(Form)
    self.file_size_label.setObjectName("file_size_label")
    self.formLayout.setWidget(4, QtWidgets.QFormLayout.FieldRole, self.file_size_label)
    self.type_title = QtWidgets.QLabel(Form)
    self.type_title.setObjectName("type_title")
    self.formLayout.setWidget(5, QtWidgets.QFormLayout.LabelRole, self.type_title)
    self.type_label = QtWidgets.QLabel(Form)
    self.type_label.setObjectName("type_label")
    self.formLayout.setWidget(5, QtWidgets.QFormLayout.FieldRole, self.type_label)
    self.background_label = QtWidgets.QLabel(Form)
    self.background_label.setObjectName("background_label")
    self.formLayout.setWidget(6, QtWidgets.QFormLayout.LabelRole, self.background_label)
    self.background_layout = QtWidgets.QHBoxLayout()
    self.background_layout.setObjectName("background_layout")
    self.background_option = QtWidgets.QLineEdit(Form)
    self.background_option.setClearButtonEnabled(True)
    self.background_option.setObjectName("background_option")
    self.background_layout.addWidget(self.background_option)
    self.background_choose_dir = QtWidgets.QToolButton(Form)
    icon1 = QtGui.QIcon()
    icon1.addPixmap(QtGui.QPixmap("icons:loadfile.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.background_choose_dir.setIcon(icon1)
    self.background_choose_dir.setObjectName("background_choose_dir")
    self.background_layout.addWidget(self.background_choose_dir)
    self.formLayout.setLayout(6, QtWidgets.QFormLayout.FieldRole, self.background_layout)
    self.background_scale_label = QtWidgets.QLabel(Form)
    self.background_scale_label.setObjectName("background_scale_label")
    self.formLayout.setWidget(7, QtWidgets.QFormLayout.LabelRole, self.background_scale_label)
    self.background_scale_option = QtWidgets.QDoubleSpinBox(Form)
    self.background_scale_option.setMinimum(0.01)
    self.background_scale_option.setMaximum(10.0)
    self.background_scale_option.setSingleStep(0.02)
    self.background_scale_option.setObjectName("background_scale_option")
    self.formLayout.setWidget(7, QtWidgets.QFormLayout.FieldRole, self.background_scale_option)
    self.background_offset_label = QtWidgets.QLabel(Form)
    self.background_offset_label.setObjectName("background_offset_label")
    self.formLayout.setWidget(8, QtWidgets.QFormLayout.LabelRole, self.background_offset_label)
    self.background_offset_layout = QtWidgets.QHBoxLayout()
    self.background_offset_layout.setObjectName("background_offset_layout")
    self.background_x_option = QtWidgets.QDoubleSpinBox(Form)
    self.background_x_option.setMinimum(-999999.0)
    self.background_x_option.setMaximum(999999.0)
    self.background_x_option.setObjectName("background_x_option")
    self.background_offset_layout.addWidget(self.background_x_option)
    self.background_y_option = QtWidgets.QDoubleSpinBox(Form)
    self.background_y_option.setMinimum(-999999.0)
    self.background_y_option.setMaximum(999999.0)
    self.background_y_option.setObjectName("background_y_option")
    self.background_offset_layout.addWidget(self.background_y_option)
    self.formLayout.setLayout(8, QtWidgets.QFormLayout.FieldRole, self.background_offset_layout)
    self.background_opacity_label = QtWidgets.QLabel(Form)
    self.background_opacity_label.setObjectName("background_opacity_label")
    self.formLayout.setWidget(9, QtWidgets.QFormLayout.LabelRole, self.background_opacity_label)
    self.background_opacity_option = QtWidgets.QDoubleSpinBox(Form)
    self.background_opacity_option.setMaximum(1.0)
    self.background_opacity_option.setSingleStep(0.1)
    self.background_opacity_option.setProperty("value", 1.0)
    self.background_opacity_option.setObjectName("background_opacity_option")
    self.formLayout.setWidget(9, QtWidgets.QFormLayout.FieldRole, self.background_opacity_option)
    self.verticalLayout_2.addLayout(self.formLayout)
    self.line = QtWidgets.QFrame(Form)
    self.line.setFrameShape(QtWidgets.QFrame.HLine)
    self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line.setObjectName("line")
    self.verticalLayout_2.addWidget(self.line)
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    self.overview_btn = QtWidgets.QPushButton(Form)
    self.overview_btn.setIcon(icon)
    self.overview_btn.setObjectName("overview_btn")
    self.horizontalLayout_2.addWidget(self.overview_btn)
    self.ex_expression_btn = QtWidgets.QPushButton(Form)
    self.ex_expression_btn.setIcon(icon)
    self.ex_expression_btn.setObjectName("ex_expression_btn")
    self.horizontalLayout_2.addWidget(self.ex_expression_btn)
    self.verticalLayout_2.addLayout(self.horizontalLayout_2)
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.export_group = QtWidgets.QGroupBox(Form)
    self.export_group.setObjectName("export_group")
    self.gridLayout = QtWidgets.QGridLayout(self.export_group)
    self.gridLayout.setObjectName("gridLayout")
    self.ex_dxf_btn = QtWidgets.QPushButton(self.export_group)
    icon2 = QtGui.QIcon()
    icon2.addPixmap(QtGui.QPixmap("icons:dxf.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.ex_dxf_btn.setIcon(icon2)
    self.ex_dxf_btn.setIconSize(QtCore.QSize(50, 50))
    self.ex_dxf_btn.setObjectName("ex_dxf_btn")
    self.gridLayout.addWidget(self.ex_dxf_btn, 0, 0, 1, 1)
    self.ex_slvs_btn = QtWidgets.QPushButton(self.export_group)
    icon3 = QtGui.QIcon()
    icon3.addPixmap(QtGui.QPixmap("icons:solvespace.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.ex_slvs_btn.setIcon(icon3)
    self.ex_slvs_btn.setIconSize(QtCore.QSize(50, 50))
    self.ex_slvs_btn.setObjectName("ex_slvs_btn")
    self.gridLayout.addWidget(self.ex_slvs_btn, 0, 1, 1, 1)
    self.ex_py_btn = QtWidgets.QPushButton(self.export_group)
    icon4 = QtGui.QIcon()
    icon4.addPixmap(QtGui.QPixmap("icons:script.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.ex_py_btn.setIcon(icon4)
    self.ex_py_btn.setIconSize(QtCore.QSize(50, 50))
    self.ex_py_btn.setObjectName("ex_py_btn")
    self.gridLayout.addWidget(self.ex_py_btn, 1, 0, 1, 1)
    self.ex_image_btn = QtWidgets.QPushButton(self.export_group)
    icon5 = QtGui.QIcon()
    icon5.addPixmap(QtGui.QPixmap("icons:picture.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.ex_image_btn.setIcon(icon5)
    self.ex_image_btn.setIconSize(QtCore.QSize(50, 50))
    self.ex_image_btn.setObjectName("ex_image_btn")
    self.gridLayout.addWidget(self.ex_image_btn, 1, 1, 1, 1)
    self.ex_pmks_btn = QtWidgets.QPushButton(self.export_group)
    icon6 = QtGui.QIcon()
    icon6.addPixmap(QtGui.QPixmap("icons:pmks.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.ex_pmks_btn.setIcon(icon6)
    self.ex_pmks_btn.setIconSize(QtCore.QSize(50, 50))
    self.ex_pmks_btn.setObjectName("ex_pmks_btn")
    self.gridLayout.addWidget(self.ex_pmks_btn, 0, 2, 1, 1)
    self.ex_capture_btn = QtWidgets.QPushButton(self.export_group)
    icon7 = QtGui.QIcon()
    icon7.addPixmap(QtGui.QPixmap("icons:capture.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.ex_capture_btn.setIcon(icon7)
    self.ex_capture_btn.setIconSize(QtCore.QSize(50, 50))
    self.ex_capture_btn.setObjectName("ex_capture_btn")
    self.gridLayout.addWidget(self.ex_capture_btn, 1, 2, 1, 1)
    self.horizontalLayout.addWidget(self.export_group)
    self.import_group = QtWidgets.QGroupBox(Form)
    self.import_group.setObjectName("import_group")
    self.verticalLayout = QtWidgets.QVBoxLayout(self.import_group)
    self.verticalLayout.setObjectName("verticalLayout")
    self.im_example_btn = QtWidgets.QPushButton(self.import_group)
    icon8 = QtGui.QIcon()
    icon8.addPixmap(QtGui.QPixmap("icons:example.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.im_example_btn.setIcon(icon8)
    self.im_example_btn.setIconSize(QtCore.QSize(50, 50))
    self.im_example_btn.setObjectName("im_example_btn")
    self.verticalLayout.addWidget(self.im_example_btn)
    self.im_pmks_btn = QtWidgets.QPushButton(self.import_group)
    self.im_pmks_btn.setIcon(icon6)
    self.im_pmks_btn.setIconSize(QtCore.QSize(50, 50))
    self.im_pmks_btn.setObjectName("im_pmks_btn")
    self.verticalLayout.addWidget(self.im_pmks_btn)
    self.horizontalLayout.addWidget(self.import_group)
    self.verticalLayout_2.addLayout(self.horizontalLayout)
    self.history_tabs = QtWidgets.QTabWidget(Form)
    self.history_tabs.setObjectName("history_tabs")
    self.verticalLayout_2.addWidget(self.history_tabs)

    self.retranslateUi(Form)
    self.history_tabs.setCurrentIndex(-1)
    QtCore.QMetaObject.connectSlotsByName(Form)

</t>
<t tx="leo.20231205084738.253">def retranslateUi(self, Form):
    _translate = QtCore.QCoreApplication.translate
    self.file_name_title.setText(_translate("Form", "File name:"))
    self.path_title.setText(_translate("Form", "Path:"))
    self.owner_title.setText(_translate("Form", "Owner:"))
    self.last_modified_title.setText(_translate("Form", "Last modified:"))
    self.file_size_title.setText(_translate("Form", "File size:"))
    self.type_title.setText(_translate("Form", "Type:"))
    self.background_label.setText(_translate("Form", "Background"))
    self.background_option.setPlaceholderText(_translate("Form", "Disabled"))
    self.background_scale_label.setText(_translate("Form", "Background scale"))
    self.background_offset_label.setText(_translate("Form", "Background offset"))
    self.background_opacity_label.setText(_translate("Form", "Background opacity"))
    self.overview_btn.setText(_translate("Form", "Project overview"))
    self.ex_expression_btn.setText(_translate("Form", "Mechanism expression"))
    self.export_group.setTitle(_translate("Form", "Export"))
    self.ex_dxf_btn.setStatusTip(_translate("Form", "Export as DXF format."))
    self.ex_slvs_btn.setStatusTip(_translate("Form", "Export as Solvespace format."))
    self.ex_py_btn.setStatusTip(_translate("Form", "Export as Python script."))
    self.ex_image_btn.setStatusTip(_translate("Form", "Export as image formats."))
    self.ex_pmks_btn.setStatusTip(_translate("Form", "Export as PMKS URL."))
    self.ex_capture_btn.setStatusTip(_translate("Form", "Capture the main canvas into clipboard."))
    self.import_group.setTitle(_translate("Form", "Import"))
    self.im_example_btn.setStatusTip(_translate("Form", "Import from an example."))
    self.im_pmks_btn.setStatusTip(_translate("Form", "Import from PMKS URL."))
</t>
<t tx="leo.20231205084738.254">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/
# -*- coding: utf-8 -*-

"""YAML format processing function."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import cast, Type
from re import sub
from numpy import float64
from yaml import safe_load, safe_dump
from yaml.error import YAMLError
from yaml.representer import SafeRepresenter
from qtpy.QtWidgets import QMessageBox
from .format_editor import FormatEditor, ProjectFormat

# Add a patch for numpy numbers
SafeRepresenter.add_representer(cast(Type[float], float64),
                                SafeRepresenter.represent_float)


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.255">class YamlEditor(FormatEditor):
    """YAML reader and writer."""

    @others
</t>
<t tx="leo.20231205084738.256">def __init__(self, *args):
    super(YamlEditor, self).__init__(*args)

</t>
<t tx="leo.20231205084738.257">@staticmethod
def test(file_name: str) -&gt; bool:
    """Test the file is valid."""
    with open(file_name, 'r', encoding='utf-8') as f:
        try:
            yaml_script = f.read()
            safe_load(yaml_script)
        except (OSError, UnicodeError, YAMLError):
            return False
        else:
            return True

</t>
<t tx="leo.20231205084738.258">def save(self, file_name: str) -&gt; None:
    """Save to YAML file."""
    data = self.save_data()
    opt = self.prefer.file_type_option
    if opt == ProjectFormat.YAML:
        flow_style = False
    elif opt == ProjectFormat.C_YAML:
        flow_style = True
    else:
        raise ValueError(f"unsupported option: {opt}")
    try:
        yaml_script = safe_dump(data, default_flow_style=flow_style)
    except Exception as e:
        QMessageBox.warning(self._parent, "Save error", f"{e}")
        return
    if self.prefer.file_type_option == ProjectFormat.C_YAML:
        yaml_script = sub(r"\s\s+", " ", yaml_script)
    with open(file_name, 'w+', encoding='utf-8') as f:
        f.write(yaml_script)

</t>
<t tx="leo.20231205084738.259">def load(self, file_name: str) -&gt; None:
    """Load a YAML file."""
    with open(file_name, 'r', encoding='utf-8') as f:
        yaml_script = f.read()
    try:
        data = safe_load(yaml_script)
    except (OSError, UnicodeError, YAMLError) as e:
        QMessageBox.warning(self._parent, "Loader Error", f"{e}")
        return
    self.load_data(file_name, data)
</t>
<t tx="leo.20231205084738.26">def __link_item(self, name: str) -&gt; QListWidgetItem:
    """Create a list item for a link."""
    return QListWidgetItem(self.icon, name)

</t>
<t tx="leo.20231205084738.27">@Slot(int, name='on_name_box_currentIndexChanged')
def __set_name(self, index: int) -&gt; None:
    """Load the parameters of the point."""
    if not len(self.vpoints) &gt; index:
        return
    vpoint = self.vpoints[index]
    self.x_box.setValue(vpoint.x)
    self.y_box.setValue(vpoint.y)
    set_custom_color(self.color_box, vpoint.color_str)
    self.type_box.setCurrentIndex(vpoint.type)
    self.angle_box.setValue(vpoint.angle)
    self.no_selected.clear()
    self.selected.clear()
    names = {vlink.name for vlink in self.vlinks}
    for name in vpoint.links:
        names.remove(name)
        self.selected.addItem(self.__link_item(name))
    for name in names:
        self.no_selected.addItem(self.__link_item(name))

</t>
<t tx="leo.20231205084738.28">@Slot(int, name='on_color_box_currentIndexChanged')
def __set_color(self, _=None) -&gt; None:
    """Change the color icon of pick button."""
    self.color_pick_btn.setIcon(self.color_box.itemIcon(
        self.color_box.currentIndex()
    ))

</t>
<t tx="leo.20231205084738.29">@Slot(name='on_color_pick_btn_clicked')
def __set_rgb(self) -&gt; None:
    """Add a custom color from current color."""
    color = QColorDialog.getColor(
        color_qt(self.color_box.currentText()),
        self
    )
    if color.isValid():
        add_custom_color(self.color_box, color)

</t>
<t tx="leo.20231205084738.3">class QABCMeta(type(QObject), ABCMeta):  # type: ignore
    """Qt ABCMeta class.

    Usage:
    &gt;&gt;&gt; from abc import abstractmethod
    &gt;&gt;&gt; class MyQObject(QObject, metaclass=QABCMeta):
    &gt;&gt;&gt;    @abstractmethod
    &gt;&gt;&gt;    def my_abstract_method(self) -&gt; None:
    &gt;&gt;&gt;        raise NotImplementedError
    """
    pass
</t>
<t tx="leo.20231205084738.30">@Slot()
def __check_angle(self) -&gt; None:
    """Toggle the slider angle option."""
    enabled = self.type_box.currentIndex() != 0
    self.angle_label.setEnabled(enabled)
    self.angle_box.setEnabled(enabled)

</t>
<t tx="leo.20231205084738.31">@Slot(QListWidgetItem, name='on_no_selected_itemDoubleClicked')
def __add_selected(self, item: QListWidgetItem) -&gt; None:
    """Add item to selected list."""
    self.selected.addItem(
        self.no_selected.takeItem(self.no_selected.row(item))
    )

</t>
<t tx="leo.20231205084738.32">@Slot(QListWidgetItem, name='on_selected_itemDoubleClicked')
def __add_no_selected(self, item: QListWidgetItem) -&gt; None:
    """Add item to no selected list."""
    self.no_selected.addItem(
        self.selected.takeItem(self.selected.row(item))
    )

</t>
<t tx="leo.20231205084738.33">@Slot(name='on_relocate_option_clicked')
def __relocate(self) -&gt; None:
    """Relocate option."""
    dlg = RelocateDialog(self)
    dlg.show()
    if dlg.exec():
        self.x_box.setValue(dlg.get_x())
        self.y_box.setValue(dlg.get_y())
</t>
<t tx="leo.20231205084738.34">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/entities/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'edit_point.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.35">class Ui_Dialog(object):
    @others
</t>
<t tx="leo.20231205084738.36">def setupUi(self, Dialog):
    Dialog.setObjectName("Dialog")
    Dialog.resize(364, 596)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:bearing.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Dialog.setWindowIcon(icon)
    Dialog.setSizeGripEnabled(True)
    Dialog.setModal(True)
    self.horizontalLayout_5 = QtWidgets.QHBoxLayout(Dialog)
    self.horizontalLayout_5.setObjectName("horizontalLayout_5")
    self.verticalLayout = QtWidgets.QVBoxLayout()
    self.verticalLayout.setObjectName("verticalLayout")
    self.name_label = QtWidgets.QLabel(Dialog)
    self.name_label.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.name_label.setObjectName("name_label")
    self.verticalLayout.addWidget(self.name_label)
    self.name_box = QtWidgets.QComboBox(Dialog)
    self.name_box.setObjectName("name_box")
    self.verticalLayout.addWidget(self.name_box)
    self.color_label = QtWidgets.QLabel(Dialog)
    self.color_label.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.color_label.setObjectName("color_label")
    self.verticalLayout.addWidget(self.color_label)
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    self.color_box = QtWidgets.QComboBox(Dialog)
    self.color_box.setObjectName("color_box")
    self.horizontalLayout_2.addWidget(self.color_box)
    self.color_pick_btn = QtWidgets.QPushButton(Dialog)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.color_pick_btn.sizePolicy().hasHeightForWidth())
    self.color_pick_btn.setSizePolicy(sizePolicy)
    self.color_pick_btn.setObjectName("color_pick_btn")
    self.horizontalLayout_2.addWidget(self.color_pick_btn)
    self.verticalLayout.addLayout(self.horizontalLayout_2)
    self.groupBox = QtWidgets.QGroupBox(Dialog)
    self.groupBox.setObjectName("groupBox")
    self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.groupBox)
    self.verticalLayout_3.setObjectName("verticalLayout_3")
    self.type_box = QtWidgets.QComboBox(self.groupBox)
    self.type_box.setObjectName("type_box")
    self.type_box.addItem("")
    self.type_box.addItem("")
    self.type_box.addItem("")
    self.verticalLayout_3.addWidget(self.type_box)
    self.formLayout_2 = QtWidgets.QFormLayout()
    self.formLayout_2.setObjectName("formLayout_2")
    self.angle_label = QtWidgets.QLabel(self.groupBox)
    self.angle_label.setObjectName("angle_label")
    self.formLayout_2.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.angle_label)
    self.angle_box = QtWidgets.QDoubleSpinBox(self.groupBox)
    self.angle_box.setMaximum(180.0)
    self.angle_box.setObjectName("angle_box")
    self.formLayout_2.setWidget(0, QtWidgets.QFormLayout.FieldRole, self.angle_box)
    self.verticalLayout_3.addLayout(self.formLayout_2)
    self.verticalLayout.addWidget(self.groupBox)
    self.pos_group = QtWidgets.QGroupBox(Dialog)
    self.pos_group.setObjectName("pos_group")
    self.horizontalLayout_4 = QtWidgets.QHBoxLayout(self.pos_group)
    self.horizontalLayout_4.setObjectName("horizontalLayout_4")
    self.formLayout = QtWidgets.QFormLayout()
    self.formLayout.setObjectName("formLayout")
    self.x_label = QtWidgets.QLabel(self.pos_group)
    self.x_label.setObjectName("x_label")
    self.formLayout.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.x_label)
    self.x_box = QtWidgets.QDoubleSpinBox(self.pos_group)
    self.x_box.setDecimals(4)
    self.x_box.setMinimum(-999999.0)
    self.x_box.setMaximum(999999.0)
    self.x_box.setObjectName("x_box")
    self.formLayout.setWidget(0, QtWidgets.QFormLayout.FieldRole, self.x_box)
    self.y_label = QtWidgets.QLabel(self.pos_group)
    self.y_label.setObjectName("y_label")
    self.formLayout.setWidget(1, QtWidgets.QFormLayout.LabelRole, self.y_label)
    self.y_box = QtWidgets.QDoubleSpinBox(self.pos_group)
    self.y_box.setDecimals(4)
    self.y_box.setMinimum(-999999.0)
    self.y_box.setMaximum(999999.0)
    self.y_box.setObjectName("y_box")
    self.formLayout.setWidget(1, QtWidgets.QFormLayout.FieldRole, self.y_box)
    self.horizontalLayout_4.addLayout(self.formLayout)
    self.relocate_option = QtWidgets.QPushButton(self.pos_group)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.relocate_option.sizePolicy().hasHeightForWidth())
    self.relocate_option.setSizePolicy(sizePolicy)
    self.relocate_option.setText("")
    icon1 = QtGui.QIcon()
    icon1.addPixmap(QtGui.QPixmap("icons:calculator.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.relocate_option.setIcon(icon1)
    self.relocate_option.setIconSize(QtCore.QSize(30, 30))
    self.relocate_option.setObjectName("relocate_option")
    self.horizontalLayout_4.addWidget(self.relocate_option)
    self.verticalLayout.addWidget(self.pos_group)
    self.links_label = QtWidgets.QLabel(Dialog)
    self.links_label.setObjectName("links_label")
    self.verticalLayout.addWidget(self.links_label)
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.no_selected = QtWidgets.QListWidget(Dialog)
    self.no_selected.setDragEnabled(True)
    self.no_selected.setDragDropMode(QtWidgets.QAbstractItemView.DragDrop)
    self.no_selected.setDefaultDropAction(QtCore.Qt.MoveAction)
    self.no_selected.setObjectName("no_selected")
    self.horizontalLayout.addWidget(self.no_selected)
    self.label_4 = QtWidgets.QLabel(Dialog)
    self.label_4.setObjectName("label_4")
    self.horizontalLayout.addWidget(self.label_4)
    self.selected = QtWidgets.QListWidget(Dialog)
    self.selected.setDragEnabled(True)
    self.selected.setDragDropMode(QtWidgets.QAbstractItemView.DragDrop)
    self.selected.setDefaultDropAction(QtCore.Qt.MoveAction)
    self.selected.setObjectName("selected")
    self.horizontalLayout.addWidget(self.selected)
    self.verticalLayout.addLayout(self.horizontalLayout)
    self.horizontalLayout_5.addLayout(self.verticalLayout)
    self.verticalLayout_2 = QtWidgets.QVBoxLayout()
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.btn_box = QtWidgets.QDialogButtonBox(Dialog)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.btn_box.sizePolicy().hasHeightForWidth())
    self.btn_box.setSizePolicy(sizePolicy)
    self.btn_box.setOrientation(QtCore.Qt.Vertical)
    self.btn_box.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok)
    self.btn_box.setObjectName("btn_box")
    self.verticalLayout_2.addWidget(self.btn_box)
    spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_2.addItem(spacerItem)
    self.horizontalLayout_5.addLayout(self.verticalLayout_2)

    self.retranslateUi(Dialog)
    self.btn_box.accepted.connect(Dialog.accept)
    self.btn_box.rejected.connect(Dialog.reject)
    QtCore.QMetaObject.connectSlotsByName(Dialog)

</t>
<t tx="leo.20231205084738.37">def retranslateUi(self, Dialog):
    _translate = QtCore.QCoreApplication.translate
    Dialog.setWindowTitle(_translate("Dialog", "Point"))
    self.name_label.setText(_translate("Dialog", "Point Number"))
    self.color_label.setText(_translate("Dialog", "Color"))
    self.groupBox.setTitle(_translate("Dialog", "Type"))
    self.type_box.setItemText(0, _translate("Dialog", "R (pin)"))
    self.type_box.setItemText(1, _translate("Dialog", "P (slider block)"))
    self.type_box.setItemText(2, _translate("Dialog", "RP (pin in slot)"))
    self.angle_label.setText(_translate("Dialog", "Slider angle"))
    self.pos_group.setTitle(_translate("Dialog", "Position"))
    self.x_label.setText(_translate("Dialog", "X"))
    self.y_label.setText(_translate("Dialog", "Y"))
    self.links_label.setText(_translate("Dialog", "Links"))
    self.label_4.setText(_translate("Dialog", "&gt;&gt;"))
</t>
<t tx="leo.20231205084738.38">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/entities/
# -*- coding: utf-8 -*-

"""The option dialog used to relocate the points."""

from __future__ import annotations

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import TYPE_CHECKING
from math import isnan, radians
from qtpy.QtCore import Slot
from qtpy.QtWidgets import QDialog, QDialogButtonBox
from pyslvs import plap, pllp, Coord
from pyslvs_ui.widgets import QRotatableView
from .relocate_point_ui import Ui_Dialog as SubUiDialog

if TYPE_CHECKING:
    from .edit_point import EditPointDialog


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.39">class RelocateDialog(QDialog, SubUiDialog):
    """Relocation option dialog."""

    @others
</t>
<t tx="leo.20231205084738.4">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/
# -*- coding: utf-8 -*-

"""Pyslvs-UI module."""

__version__ = "22.07.0"
__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from warnings import warn
from pyslvs import __version__ as __kernel_version__

if __kernel_version__ != __version__:
    warn(Warning(f"Warning: Use kernel version {__kernel_version__}"))
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.40">def __init__(self, parent: EditPointDialog):
    super(RelocateDialog, self).__init__(parent)
    self.setupUi(self)
    self.__x = self.__y = float('nan')
    self.vpoints = parent.vpoints
    self.plap_dial = QRotatableView(self)
    self.panel_layout.insertWidget(0, self.plap_dial)
    self.plap_dial.value_changed.connect(self.plap_angle_box.setValue)
    icon = self.windowIcon()
    for combo in (self.plap_p1_box, self.pllp_p1_box, self.pllp_p2_box):
        for p in range(len(self.vpoints)):
            combo.addItem(icon, f"Point{p}")
    for spinbox in (
        self.plap_p1x_box,
        self.plap_p1y_box,
        self.plap_distance_box,
        self.plap_angle_box,
        self.pllp_p1x_box,
        self.pllp_p1y_box,
        self.pllp_distance1_box,
        self.pllp_distance2_box,
        self.pllp_p2x_box,
        self.pllp_p2y_box,
    ):
        spinbox.valueChanged.connect(self.__is_ok)
    self.pllp_inversed_box.toggled.connect(self.__is_ok)
    self.tab_widget.currentChanged.connect(self.__is_ok)
    self.__is_ok()

</t>
<t tx="leo.20231205084738.41">@Slot(int, name='on_plap_p1_box_currentIndexChanged')
@Slot(int, name='on_pllp_p1_box_currentIndexChanged')
@Slot(int, name='on_pllp_p2_box_currentIndexChanged')
def __set_pos(self, index: int) -&gt; None:
    """Set position when switch the combobox."""
    p = self.vpoints[index]
    combo = self.sender()
    if combo is self.plap_p1_box:
        self.plap_p1x_box.setValue(p.cx)
        self.plap_p1y_box.setValue(p.cy)
    elif combo is self.pllp_p1_box:
        self.pllp_p1x_box.setValue(p.cx)
        self.pllp_p1y_box.setValue(p.cy)
    elif combo is self.pllp_p2_box:
        self.pllp_p2x_box.setValue(p.cx)
        self.pllp_p2y_box.setValue(p.cy)

</t>
<t tx="leo.20231205084738.42">@Slot()
def __is_ok(self) -&gt; None:
    """Check and show the final position."""
    mode = self.tab_widget.currentIndex()
    if mode == 0:
        x = self.plap_p1x_box.value()
        y = self.plap_p1y_box.value()
        c = plap(
            Coord(x, y),
            self.plap_distance_box.value(),
            radians(self.plap_angle_box.value())
        )
    elif mode == 1:
        x1 = self.pllp_p1x_box.value()
        y1 = self.pllp_p1y_box.value()
        x2 = self.pllp_p2x_box.value()
        y2 = self.pllp_p2y_box.value()
        c = pllp(
            Coord(x1, y1),
            self.pllp_distance1_box.value(),
            self.pllp_distance2_box.value(),
            Coord(x2, y2),
            self.pllp_inversed_box.isChecked()
        )
    else:
        raise ValueError("invalid option")
    self.preview_label.setText(f"({c.x}, {c.y})")
    self.__x = c.x
    self.__y = c.y
    ok_btn = self.btn_box.button(QDialogButtonBox.Ok)
    ok_btn.setEnabled(not (isnan(c.x) or isnan(c.y)))

</t>
<t tx="leo.20231205084738.43">def get_x(self) -&gt; float:
    """Get final x position."""
    return self.__x

</t>
<t tx="leo.20231205084738.44">def get_y(self) -&gt; float:
    """Get final y position."""
    return self.__y
</t>
<t tx="leo.20231205084738.45">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/entities/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'relocate_point.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.46">class Ui_Dialog(object):
    @others
</t>
<t tx="leo.20231205084738.47">def setupUi(self, Dialog):
    Dialog.setObjectName("Dialog")
    Dialog.resize(366, 468)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:calculator.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Dialog.setWindowIcon(icon)
    Dialog.setModal(True)
    self.verticalLayout = QtWidgets.QVBoxLayout(Dialog)
    self.verticalLayout.setObjectName("verticalLayout")
    self.tab_widget = QtWidgets.QTabWidget(Dialog)
    self.tab_widget.setObjectName("tab_widget")
    self.plap_tab = QtWidgets.QWidget()
    self.plap_tab.setObjectName("plap_tab")
    self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.plap_tab)
    self.verticalLayout_4.setObjectName("verticalLayout_4")
    self.panel_layout = QtWidgets.QHBoxLayout()
    self.panel_layout.setObjectName("panel_layout")
    self.verticalLayout_3 = QtWidgets.QVBoxLayout()
    self.verticalLayout_3.setObjectName("verticalLayout_3")
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    self.plap_p1_label = QtWidgets.QLabel(self.plap_tab)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.plap_p1_label.sizePolicy().hasHeightForWidth())
    self.plap_p1_label.setSizePolicy(sizePolicy)
    self.plap_p1_label.setObjectName("plap_p1_label")
    self.horizontalLayout_2.addWidget(self.plap_p1_label)
    self.plap_p1_box = QtWidgets.QComboBox(self.plap_tab)
    self.plap_p1_box.setObjectName("plap_p1_box")
    self.horizontalLayout_2.addWidget(self.plap_p1_box)
    self.verticalLayout_3.addLayout(self.horizontalLayout_2)
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.plap_p1x_label = QtWidgets.QLabel(self.plap_tab)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.plap_p1x_label.sizePolicy().hasHeightForWidth())
    self.plap_p1x_label.setSizePolicy(sizePolicy)
    self.plap_p1x_label.setObjectName("plap_p1x_label")
    self.horizontalLayout.addWidget(self.plap_p1x_label)
    self.plap_p1x_box = QtWidgets.QDoubleSpinBox(self.plap_tab)
    self.plap_p1x_box.setDecimals(4)
    self.plap_p1x_box.setMinimum(-9999.99)
    self.plap_p1x_box.setMaximum(9999.99)
    self.plap_p1x_box.setObjectName("plap_p1x_box")
    self.horizontalLayout.addWidget(self.plap_p1x_box)
    self.plap_p1y_label = QtWidgets.QLabel(self.plap_tab)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.plap_p1y_label.sizePolicy().hasHeightForWidth())
    self.plap_p1y_label.setSizePolicy(sizePolicy)
    self.plap_p1y_label.setObjectName("plap_p1y_label")
    self.horizontalLayout.addWidget(self.plap_p1y_label)
    self.plap_p1y_box = QtWidgets.QDoubleSpinBox(self.plap_tab)
    self.plap_p1y_box.setDecimals(4)
    self.plap_p1y_box.setMinimum(-9999.99)
    self.plap_p1y_box.setMaximum(9999.99)
    self.plap_p1y_box.setObjectName("plap_p1y_box")
    self.horizontalLayout.addWidget(self.plap_p1y_box)
    self.verticalLayout_3.addLayout(self.horizontalLayout)
    self.formLayout = QtWidgets.QFormLayout()
    self.formLayout.setObjectName("formLayout")
    self.plap_angle_label = QtWidgets.QLabel(self.plap_tab)
    self.plap_angle_label.setObjectName("plap_angle_label")
    self.formLayout.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.plap_angle_label)
    self.plap_angle_box = QtWidgets.QDoubleSpinBox(self.plap_tab)
    self.plap_angle_box.setDecimals(4)
    self.plap_angle_box.setMaximum(360.0)
    self.plap_angle_box.setObjectName("plap_angle_box")
    self.formLayout.setWidget(0, QtWidgets.QFormLayout.FieldRole, self.plap_angle_box)
    self.plap_distance_label = QtWidgets.QLabel(self.plap_tab)
    self.plap_distance_label.setObjectName("plap_distance_label")
    self.formLayout.setWidget(1, QtWidgets.QFormLayout.LabelRole, self.plap_distance_label)
    self.plap_distance_box = QtWidgets.QDoubleSpinBox(self.plap_tab)
    self.plap_distance_box.setDecimals(4)
    self.plap_distance_box.setMaximum(9999.99)
    self.plap_distance_box.setObjectName("plap_distance_box")
    self.formLayout.setWidget(1, QtWidgets.QFormLayout.FieldRole, self.plap_distance_box)
    self.verticalLayout_3.addLayout(self.formLayout)
    self.panel_layout.addLayout(self.verticalLayout_3)
    self.verticalLayout_4.addLayout(self.panel_layout)
    spacerItem = QtWidgets.QSpacerItem(20, 126, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_4.addItem(spacerItem)
    self.tab_widget.addTab(self.plap_tab, "")
    self.pllp_tab = QtWidgets.QWidget()
    self.pllp_tab.setObjectName("pllp_tab")
    self.verticalLayout_7 = QtWidgets.QVBoxLayout(self.pllp_tab)
    self.verticalLayout_7.setObjectName("verticalLayout_7")
    self.widget = QtWidgets.QWidget(self.pllp_tab)
    self.widget.setObjectName("widget")
    self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.widget)
    self.verticalLayout_5.setObjectName("verticalLayout_5")
    self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_4.setObjectName("horizontalLayout_4")
    self.pllp_p1_label = QtWidgets.QRadioButton(self.widget)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.pllp_p1_label.sizePolicy().hasHeightForWidth())
    self.pllp_p1_label.setSizePolicy(sizePolicy)
    self.pllp_p1_label.setChecked(True)
    self.pllp_p1_label.setObjectName("pllp_p1_label")
    self.horizontalLayout_4.addWidget(self.pllp_p1_label)
    self.pllp_p1_box = QtWidgets.QComboBox(self.widget)
    self.pllp_p1_box.setObjectName("pllp_p1_box")
    self.horizontalLayout_4.addWidget(self.pllp_p1_box)
    self.verticalLayout_5.addLayout(self.horizontalLayout_4)
    self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_3.setObjectName("horizontalLayout_3")
    self.pllp_p1xy_label = QtWidgets.QRadioButton(self.widget)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.pllp_p1xy_label.sizePolicy().hasHeightForWidth())
    self.pllp_p1xy_label.setSizePolicy(sizePolicy)
    self.pllp_p1xy_label.setText("")
    self.pllp_p1xy_label.setObjectName("pllp_p1xy_label")
    self.horizontalLayout_3.addWidget(self.pllp_p1xy_label)
    self.pllp_p1x_label = QtWidgets.QLabel(self.widget)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.pllp_p1x_label.sizePolicy().hasHeightForWidth())
    self.pllp_p1x_label.setSizePolicy(sizePolicy)
    self.pllp_p1x_label.setObjectName("pllp_p1x_label")
    self.horizontalLayout_3.addWidget(self.pllp_p1x_label)
    self.pllp_p1x_box = QtWidgets.QDoubleSpinBox(self.widget)
    self.pllp_p1x_box.setDecimals(4)
    self.pllp_p1x_box.setMinimum(-9999.99)
    self.pllp_p1x_box.setMaximum(9999.99)
    self.pllp_p1x_box.setObjectName("pllp_p1x_box")
    self.horizontalLayout_3.addWidget(self.pllp_p1x_box)
    self.pllp_p1y_label = QtWidgets.QLabel(self.widget)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.pllp_p1y_label.sizePolicy().hasHeightForWidth())
    self.pllp_p1y_label.setSizePolicy(sizePolicy)
    self.pllp_p1y_label.setObjectName("pllp_p1y_label")
    self.horizontalLayout_3.addWidget(self.pllp_p1y_label)
    self.pllp_p1y_box = QtWidgets.QDoubleSpinBox(self.widget)
    self.pllp_p1y_box.setDecimals(4)
    self.pllp_p1y_box.setMinimum(-9999.99)
    self.pllp_p1y_box.setMaximum(9999.99)
    self.pllp_p1y_box.setObjectName("pllp_p1y_box")
    self.horizontalLayout_3.addWidget(self.pllp_p1y_box)
    self.verticalLayout_5.addLayout(self.horizontalLayout_3)
    self.verticalLayout_7.addWidget(self.widget)
    self.widget1 = QtWidgets.QWidget(self.pllp_tab)
    self.widget1.setObjectName("widget1")
    self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.widget1)
    self.verticalLayout_6.setObjectName("verticalLayout_6")
    self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_5.setObjectName("horizontalLayout_5")
    self.pllp_p2_label = QtWidgets.QRadioButton(self.widget1)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.pllp_p2_label.sizePolicy().hasHeightForWidth())
    self.pllp_p2_label.setSizePolicy(sizePolicy)
    self.pllp_p2_label.setChecked(True)
    self.pllp_p2_label.setObjectName("pllp_p2_label")
    self.horizontalLayout_5.addWidget(self.pllp_p2_label)
    self.pllp_p2_box = QtWidgets.QComboBox(self.widget1)
    self.pllp_p2_box.setObjectName("pllp_p2_box")
    self.horizontalLayout_5.addWidget(self.pllp_p2_box)
    self.verticalLayout_6.addLayout(self.horizontalLayout_5)
    self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_6.setObjectName("horizontalLayout_6")
    self.pllp_p2xy_label = QtWidgets.QRadioButton(self.widget1)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.pllp_p2xy_label.sizePolicy().hasHeightForWidth())
    self.pllp_p2xy_label.setSizePolicy(sizePolicy)
    self.pllp_p2xy_label.setText("")
    self.pllp_p2xy_label.setObjectName("pllp_p2xy_label")
    self.horizontalLayout_6.addWidget(self.pllp_p2xy_label)
    self.pllp_p2x_label = QtWidgets.QLabel(self.widget1)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.pllp_p2x_label.sizePolicy().hasHeightForWidth())
    self.pllp_p2x_label.setSizePolicy(sizePolicy)
    self.pllp_p2x_label.setObjectName("pllp_p2x_label")
    self.horizontalLayout_6.addWidget(self.pllp_p2x_label)
    self.pllp_p2x_box = QtWidgets.QDoubleSpinBox(self.widget1)
    self.pllp_p2x_box.setDecimals(4)
    self.pllp_p2x_box.setMinimum(-9999.99)
    self.pllp_p2x_box.setMaximum(9999.99)
    self.pllp_p2x_box.setObjectName("pllp_p2x_box")
    self.horizontalLayout_6.addWidget(self.pllp_p2x_box)
    self.pllp_p2y_label = QtWidgets.QLabel(self.widget1)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.pllp_p2y_label.sizePolicy().hasHeightForWidth())
    self.pllp_p2y_label.setSizePolicy(sizePolicy)
    self.pllp_p2y_label.setObjectName("pllp_p2y_label")
    self.horizontalLayout_6.addWidget(self.pllp_p2y_label)
    self.pllp_p2y_box = QtWidgets.QDoubleSpinBox(self.widget1)
    self.pllp_p2y_box.setDecimals(4)
    self.pllp_p2y_box.setMinimum(-9999.99)
    self.pllp_p2y_box.setObjectName("pllp_p2y_box")
    self.horizontalLayout_6.addWidget(self.pllp_p2y_box)
    self.verticalLayout_6.addLayout(self.horizontalLayout_6)
    self.verticalLayout_7.addWidget(self.widget1)
    self.formLayout_2 = QtWidgets.QFormLayout()
    self.formLayout_2.setObjectName("formLayout_2")
    self.pllp_distance1_box = QtWidgets.QDoubleSpinBox(self.pllp_tab)
    self.pllp_distance1_box.setDecimals(4)
    self.pllp_distance1_box.setMaximum(9999.99)
    self.pllp_distance1_box.setObjectName("pllp_distance1_box")
    self.formLayout_2.setWidget(0, QtWidgets.QFormLayout.FieldRole, self.pllp_distance1_box)
    self.pllp_distance1_label = QtWidgets.QLabel(self.pllp_tab)
    self.pllp_distance1_label.setObjectName("pllp_distance1_label")
    self.formLayout_2.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.pllp_distance1_label)
    self.pllp_distance2_box = QtWidgets.QDoubleSpinBox(self.pllp_tab)
    self.pllp_distance2_box.setDecimals(4)
    self.pllp_distance2_box.setMaximum(9999.99)
    self.pllp_distance2_box.setObjectName("pllp_distance2_box")
    self.formLayout_2.setWidget(1, QtWidgets.QFormLayout.FieldRole, self.pllp_distance2_box)
    self.pllp_distance2_label = QtWidgets.QLabel(self.pllp_tab)
    self.pllp_distance2_label.setObjectName("pllp_distance2_label")
    self.formLayout_2.setWidget(1, QtWidgets.QFormLayout.LabelRole, self.pllp_distance2_label)
    self.verticalLayout_7.addLayout(self.formLayout_2)
    self.pllp_inversed_box = QtWidgets.QCheckBox(self.pllp_tab)
    self.pllp_inversed_box.setObjectName("pllp_inversed_box")
    self.verticalLayout_7.addWidget(self.pllp_inversed_box)
    spacerItem1 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_7.addItem(spacerItem1)
    self.tab_widget.addTab(self.pllp_tab, "")
    self.verticalLayout.addWidget(self.tab_widget)
    self.preview_label = QtWidgets.QLabel(Dialog)
    self.preview_label.setObjectName("preview_label")
    self.verticalLayout.addWidget(self.preview_label)
    self.btn_box = QtWidgets.QDialogButtonBox(Dialog)
    self.btn_box.setOrientation(QtCore.Qt.Horizontal)
    self.btn_box.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok)
    self.btn_box.setObjectName("btn_box")
    self.verticalLayout.addWidget(self.btn_box)

    self.retranslateUi(Dialog)
    self.btn_box.rejected.connect(Dialog.reject)
    self.btn_box.accepted.connect(Dialog.accept)
    QtCore.QMetaObject.connectSlotsByName(Dialog)

</t>
<t tx="leo.20231205084738.48">def retranslateUi(self, Dialog):
    _translate = QtCore.QCoreApplication.translate
    Dialog.setWindowTitle(_translate("Dialog", "Relocate"))
    self.plap_p1_label.setText(_translate("Dialog", "Point"))
    self.plap_p1x_label.setText(_translate("Dialog", "X"))
    self.plap_p1y_label.setText(_translate("Dialog", "Y"))
    self.plap_angle_label.setText(_translate("Dialog", "Angle"))
    self.plap_distance_label.setText(_translate("Dialog", "Distance"))
    self.tab_widget.setTabText(self.tab_widget.indexOf(self.plap_tab), _translate("Dialog", "Polar"))
    self.pllp_p1_label.setText(_translate("Dialog", "Point &amp;1"))
    self.pllp_p1x_label.setText(_translate("Dialog", "X"))
    self.pllp_p1y_label.setText(_translate("Dialog", "Y"))
    self.pllp_p2_label.setText(_translate("Dialog", "Point &amp;2"))
    self.pllp_p2x_label.setText(_translate("Dialog", "X"))
    self.pllp_p2y_label.setText(_translate("Dialog", "Y"))
    self.pllp_distance1_label.setText(_translate("Dialog", "Distance 1"))
    self.pllp_distance2_label.setText(_translate("Dialog", "Distance 2"))
    self.pllp_inversed_box.setText(_translate("Dialog", "Inverse the position to another side."))
    self.tab_widget.setTabText(self.tab_widget.indexOf(self.pllp_tab), _translate("Dialog", "Two Points"))
</t>
<t tx="leo.20231205084738.49">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/entities/
# -*- coding: utf-8 -*-

"""The functions of the entities dialogs."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from qtpy.QtWidgets import QComboBox
from qtpy.QtGui import QColor
from pyslvs_ui.graphics import color_icon


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.5">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/
# -*- coding: utf-8 -*-

"""Launch script from module level."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from time import process_time

_app = None


@others
if __name__ == '__main__':
    main()
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.50">def set_custom_color(color_box: QComboBox, color_text: str):
    color_index = color_box.findText(color_text)
    if color_index &gt; -1:
        color_box.setCurrentIndex(color_index)
    else:
        color_box.addItem(color_icon(color_text), color_text)
        color_box.setCurrentIndex(color_box.count() - 1)


</t>
<t tx="leo.20231205084738.51">def add_custom_color(color_box: QComboBox, color: QColor):
    rgb_str = f"({color.red()}, {color.green()}, {color.blue()})"
    color_box.addItem(color_icon(rgb_str), rgb_str)
    color_box.setCurrentIndex(color_box.count() - 1)
</t>
<t tx="leo.20231205084738.52">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/entities/
# -*- coding: utf-8 -*-

"""'entities' module contains the option dialogs."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from .edit_link import EditLinkDialog
from .edit_point import EditPointDialog
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.53"></t>
<t tx="leo.20231205084738.54">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/graphics/
# -*- coding: utf-8 -*-

"""All color options in Pyslvs."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import (
    TypeVar, Tuple, List, Sequence, Set, Dict, Mapping, Iterator, Any,
    Optional, ClassVar, overload,
)
from abc import abstractmethod, ABC
from dataclasses import dataclass, field
from enum import auto, unique, IntEnum
from math import radians, sin, cos, atan2, hypot, isnan
from functools import reduce
from qtpy.QtCore import Slot, Qt, QPointF, QRectF, QSizeF, Signal, QLineF
from qtpy.QtWidgets import QWidget, QSizePolicy
from qtpy.QtGui import (
    QPolygonF, QPainter, QBrush, QPen, QColor, QFont,
    QPainterPath, QImage, QPaintEvent, QMouseEvent,
)
from pyslvs import VPoint, edges_view, parse_pos
from pyslvs.graph import Graph
from pyslvs_ui.qt_patch import QABCMeta
from .color import color_num, color_qt, target_path_style

_T = TypeVar('_T')
_Coord = Tuple[float, float]
LINK_COLOR = QColor(226, 219, 190)


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.55">@overload
def convex_hull(points: List[_Coord], *, as_qpoint: bool) -&gt; List[QPointF]:
    pass


</t>
<t tx="leo.20231205084738.56">@overload
def convex_hull(points: List[_Coord]) -&gt; List[_Coord]:
    pass


</t>
<t tx="leo.20231205084738.57">def convex_hull(points, *, as_qpoint=False):
    """Returns points on convex hull in counterclockwise order
    according to Graham's scan algorithm.
    """

    @others
    points.sort()
    lower = reduce(keep_left, points, [])
    upper = reduce(keep_left, reversed(points), [])
    lower.extend(upper[i] for i in range(1, len(upper) - 1))
    return [(QPointF(x, y) if as_qpoint else (x, y)) for x, y in lower]


</t>
<t tx="leo.20231205084738.58">def cmp(a: float, b: float) -&gt; int:
    return int(a &gt; b) - int(a &lt; b)

</t>
<t tx="leo.20231205084738.59">def turn(p: _Coord, q: _Coord, r: _Coord) -&gt; int:
    px, py = p
    qx, qy = q
    rx, ry = r
    return cmp((qx - px) * (ry - py) - (rx - px) * (qy - py), 0)

</t>
<t tx="leo.20231205084738.6">def main() -&gt; None:
    """Startup function."""
    global _app
    t0 = process_time()
    exit_code = 0
    from sys import argv, exit
    from logging import shutdown
    from platform import system
    from pyslvs_ui.info import ARGUMENTS, parse_args, sign_in_logger, logger
    parse_args()
    sign_in_logger()
    if ARGUMENTS.cmd in {'gui', None}:
        from qtpy.QtCore import Qt, qInstallMessageHandler
        from qtpy.QtWidgets import QApplication, QSplashScreen
        from qtpy.QtGui import QPixmap
        _app = QApplication(argv)
        # Depress Qt warning
        qInstallMessageHandler(lambda _0, _1, _2: None)
        # Splash
        sp = QSplashScreen(QPixmap("icons:splash.png"))
        sp.showMessage(f"{__author__} {__copyright__}",
                       Qt.AlignBottom | Qt.AlignRight)
        sp.show()
        # Force enable fusion style on macOS
        if system() == 'Darwin':
            ARGUMENTS.fusion = True
        if ARGUMENTS.fusion:
            _app.setStyle('fusion')
        # Main window
        from pyslvs_ui.main_window import MainWindow
        w = MainWindow.new()
        sp.finish(w)
        sp.deleteLater()
        logger.info(f"Startup with: {process_time() - t0:.02f}s")
        if not ARGUMENTS.debug_mode:
            w.console_connect()
        del sp, w
        exit_code = _app.exec_()
    elif ARGUMENTS.cmd == 'test':
        from importlib import import_module
        import_module('pyslvs_ui.main_window')
        logger.info("All module loaded successfully.")
        logger.info(f"Loaded with: {process_time() - t0:.02f}s")
    else:
        raise ValueError(f"unknown command: {ARGUMENTS.cmd}")
    shutdown()
    exit(exit_code)


</t>
<t tx="leo.20231205084738.60">def keep_left(hull: List[_Coord], r: _Coord) -&gt; List[_Coord]:
    while len(hull) &gt; 1 and turn(hull[-2], hull[-1], r) != 1:
        hull.pop()
    if not hull or hull[-1] != r:
        hull.append(r)
    return hull

</t>
<t tx="leo.20231205084738.61">@dataclass(init=False, repr=False, eq=False)
class RangeDetector:
    """Range detection of points."""
    inf = float('inf')
    right = inf
    left = -inf
    top = -inf
    bottom = inf
    del inf

    @others
</t>
<t tx="leo.20231205084738.62">def __call__(self, right: float, left: float,
             top: float, bottom: float) -&gt; None:
    """Set ranges from new point."""
    if right &lt; self.right:
        self.right = right
    if left &gt; self.left:
        self.left = left
    if top &gt; self.top:
        self.top = top
    if bottom &lt; self.bottom:
        self.bottom = bottom


</t>
<t tx="leo.20231205084738.63">@dataclass(init=False, repr=False, eq=False)
class _PathOption:
    """Path option class.

    Attributes:

    + Path data (-1: Hide, 0: Preview path data)
    + Show mode parameter.
    + The path will be the curve, otherwise using the points.
    """
    path: Sequence[Sequence[_Coord]] = ()
    slider_path: Mapping[int, Sequence[_Coord]] = field(default_factory=dict)
    show: int = -1
    curve: bool = True


</t>
<t tx="leo.20231205084738.64">@unique
class _TickMark(IntEnum):
    """The status of tick mark."""
    HIDE = auto()
    SHOW = auto()
    SHOW_NUM = auto()


</t>
<t tx="leo.20231205084738.65">class BaseCanvas(QWidget, metaclass=QABCMeta):
    """The subclass can draw a blank canvas more easier."""
    ranges: Dict[str, QRectF]
    target_path: Dict[int, Sequence[_Coord]]

    @others
</t>
<t tx="leo.20231205084738.66">@abstractmethod
def __init__(self, parent: QWidget):
    """Set the parameters for drawing."""
    super(BaseCanvas, self).__init__(parent)
    self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
    self.setFocusPolicy(Qt.StrongFocus)
    self.setMouseTracking(True)
    self.painter = QPainter()
    # Origin coordinate
    self.ox = self.width() / 2
    self.oy = self.height() / 2
    # Canvas zoom rate
    self.zoom = 1.
    # Joint size
    self.joint_size = 5
    # Canvas line width
    self.link_width = 3
    self.path_width = 3
    # Font size
    self.font_size = 15
    # Show point mark or dimension
    self.show_ticks = _TickMark.SHOW
    self.show_point_mark = True
    self.show_dimension = True
    # Path track
    self.path = _PathOption()
    # Path solving
    self.ranges = {}
    self.target_path = {}
    self.show_target_path = False
    # Background
    self.background = QImage()
    self.background_opacity = 1.
    self.background_scale = 1.
    self.background_offset = QPointF(0, 0)
    # Monochrome mode
    self.monochrome = False
    # Grab mode
    self.__grab_mode = False

</t>
<t tx="leo.20231205084738.67">def switch_grab(self) -&gt; None:
    """Start grab mode."""
    self.__grab_mode = not self.__grab_mode

</t>
<t tx="leo.20231205084738.68">@staticmethod
def zoom_factor(
    width: int,
    height: int,
    x_right: float,
    x_left: float,
    y_top: float,
    y_bottom: float
) -&gt; float:
    """Calculate the zoom factor."""
    x_diff = x_left - x_right
    y_diff = y_top - y_bottom
    x_diff = x_diff if x_diff else 1.
    y_diff = y_diff if y_diff else 1.
    if width / x_diff &lt; height / y_diff:
        return width / x_diff
    else:
        return height / y_diff

</t>
<t tx="leo.20231205084738.69">@abstractmethod
def paintEvent(self, event: QPaintEvent) -&gt; None:
    """Using a QPainter under 'self',
    so just change QPen or QBrush before painting.
    """
    if not self.__grab_mode:
        self.painter.begin(self)
        self.painter.fillRect(event.rect(), QBrush(Qt.white))
    # Translation
    self.painter.translate(self.ox, self.oy)
    # Background
    if not self.background.isNull():
        rect = self.background.rect()
        self.painter.setOpacity(self.background_opacity)
        self.painter.drawImage(QRectF(
            self.background_offset * self.zoom,
            QSizeF(rect.width(), rect.height())
            * self.background_scale * self.zoom
        ), self.background, QRectF(rect))
        self.painter.setOpacity(1)
    # Show frame
    pen = QPen(Qt.blue)
    pen.setWidth(1)
    self.painter.setPen(pen)
    self.painter.setFont(QFont("Arial", self.font_size))
    # Draw origin lines
    if self.show_ticks not in {_TickMark.SHOW, _TickMark.SHOW_NUM}:
        return
    pen.setColor(Qt.gray)
    self.painter.setPen(pen)
    x_l = -self.ox
    x_r = self.width() - self.ox
    self.painter.drawLine(QLineF(x_l, 0, x_r, 0))
    y_t = self.height() - self.oy
    y_b = -self.oy
    self.painter.drawLine(QLineF(0, y_b, 0, y_t))

    def indexing(v: float) -&gt; int:
        """Draw tick."""
        return int(v / self.zoom - v / self.zoom % 5)

    # Draw tick
    for x in range(indexing(x_l), indexing(x_r) + 1, 5):
        if x == 0:
            continue
        is_ten = x % 10 == 0
        end = QPointF(x * self.zoom, -10 if is_ten else -5)
        self.painter.drawLine(QPointF(x, 0) * self.zoom, end)
        if self.show_ticks == _TickMark.SHOW_NUM and is_ten:
            self.painter.drawText(end + QPointF(0, 3), f"{x}")
    for y in range(indexing(y_b), indexing(y_t) + 1, 5):
        if y == 0:
            continue
        is_ten = y % 10 == 0
        end = QPointF(10 if is_ten else 5, y * self.zoom)
        self.painter.drawLine(QPointF(0, y) * self.zoom, end)
        if self.show_ticks == _TickMark.SHOW_NUM and is_ten:
            self.painter.drawText(end + QPointF(3, 0), f"{-y}")
    # Please to call the "end" method when ending paint event.

</t>
<t tx="leo.20231205084738.7"></t>
<t tx="leo.20231205084738.70">def draw_circle(self, p: QPointF, r: float) -&gt; None:
    """Draw circle."""
    self.painter.drawEllipse(p, r, r)

</t>
<t tx="leo.20231205084738.71">def draw_point(
    self,
    i: int,
    cx: float,
    cy: float,
    fixed: bool,
    color: Optional[Tuple[int, int, int]],
    mul: int = 1
) -&gt; None:
    """Draw a joint."""
    if self.monochrome or color is None:
        color = Qt.black
    else:
        color = QColor(*color)
    pen = QPen(color)
    pen.setWidth(2)
    self.painter.setPen(pen)
    x = cx * self.zoom
    y = cy * -self.zoom
    if fixed:
        # Draw a triangle below
        self.painter.drawPolygon(
            QPointF(x, y),
            QPointF(x - self.joint_size, y + 2 * self.joint_size),
            QPointF(x + self.joint_size, y + 2 * self.joint_size)
        )
    r = self.joint_size
    for _ in range(1 if mul &lt; 1 else mul):
        self.draw_circle(QPointF(x, y), r)
        r += 5
    if not self.show_point_mark:
        return
    pen.setColor(Qt.darkGray)
    pen.setWidth(2)
    self.painter.setPen(pen)
    text = f"[Point{i}]"
    if self.show_dimension:
        text += f":({cx:.02f}, {cy:.02f})"
    self.painter.drawText(QPointF(x, y) + QPointF(6, -6), text)

</t>
<t tx="leo.20231205084738.72">def draw_ranges(self) -&gt; None:
    """Draw rectangle ranges."""
    pen = QPen()
    pen.setWidth(5)
    for i, (tag, rect) in enumerate(self.ranges.items()):
        range_color = QColor(color_num(i + 1))
        range_color.setAlpha(30)
        self.painter.setBrush(range_color)
        range_color.setAlpha(255)
        pen.setColor(range_color)
        self.painter.setPen(pen)
        cx = rect.x() * self.zoom
        cy = rect.y() * -self.zoom
        if rect.width():
            self.painter.drawRect(QRectF(
                QPointF(cx, cy),
                QSizeF(rect.width(), rect.height()) * self.zoom
            ))
        else:
            self.draw_circle(QPointF(cx, cy), 3)
        range_color.setAlpha(255)
        pen.setColor(range_color)
        self.painter.setPen(pen)
        self.painter.drawText(QPointF(cx, cy) + QPointF(6, -6), tag)
        self.painter.setBrush(Qt.NoBrush)

</t>
<t tx="leo.20231205084738.73">def draw_target_path(self) -&gt; None:
    """Draw solving path."""
    pen = QPen()
    pen.setWidth(self.path_width)
    for i, n in enumerate(sorted(self.target_path)):
        path = self.target_path[n]
        if self.monochrome:
            line, dot = target_path_style(0)
        else:
            line, dot = target_path_style(i + 1)
        pen.setColor(line)
        self.painter.setPen(pen)
        if len(path) == 1:
            x, y = path[0]
            p = QPointF(x, -y) * self.zoom
            self.painter.drawText(p + QPointF(6, -6), f"P{n}")
            pen.setColor(dot)
            self.painter.setPen(pen)
            self.draw_circle(p, self.joint_size)
        else:
            painter_path = QPainterPath()
            for j, (x, y) in enumerate(path):
                p = QPointF(x, -y) * self.zoom
                self.draw_circle(p, self.joint_size)
                if j == 0:
                    self.painter.drawText(p + QPointF(6, -6), f"P{n}")
                    painter_path.moveTo(p)
                else:
                    xb, yb = path[j - 1]
                    self.draw_arrow(xb, yb, x, y, line=False)
                    painter_path.lineTo(p)
            pen.setColor(line)
            self.painter.setPen(pen)
            self.painter.drawPath(painter_path)
            for x, y in path:
                pen.setColor(dot)
                self.painter.setPen(pen)
                self.draw_circle(QPointF(x, -y) * self.zoom,
                                 self.joint_size)
    self.painter.setBrush(Qt.NoBrush)

</t>
<t tx="leo.20231205084738.74">def draw_arrow(
    self,
    x1: float,
    y1: float,
    x2: float,
    y2: float,
    *,
    zoom: bool = True,
    line: bool = True,
    text: str = ''
) -&gt; None:
    """Base point -&gt; Vector point"""
    if zoom:
        x1 *= self.zoom
        y1 *= self.zoom
        x2 *= self.zoom
        y2 *= self.zoom
    a = atan2(y1 - y2, x1 - x2)
    x2 = (x1 + x2) / 2 - 7.5 * cos(a)
    y2 = (y1 + y2) / 2 - 7.5 * sin(a)
    first_point = QPointF(x2, -y2)
    if line:
        self.painter.drawLine(QLineF(x1, -y1, x2, -y2))
    self.painter.drawLine(first_point, QPointF(
        x2 + 15 * cos(a + radians(20)),
        -y2 - 15 * sin(a + radians(20))
    ))
    self.painter.drawLine(first_point, QPointF(
        x2 + 15 * cos(a - radians(20)),
        -y2 - 15 * sin(a - radians(20))
    ))
    if not text:
        return
    # Font
    font = self.painter.font()
    font_copy = QFont(font)
    font.setBold(True)
    font.setPointSize(font.pointSize() + 8)
    self.painter.setFont(font)
    # Color
    pen = self.painter.pen()
    color = pen.color()
    pen.setColor(color.darker())
    self.painter.setPen(pen)
    self.painter.drawText(first_point, text)
    pen.setColor(color)
    self.painter.setPen(pen)
    self.painter.setFont(font_copy)

</t>
<t tx="leo.20231205084738.75">def draw_curve(self, path: Sequence[_Coord]) -&gt; None:
    """Draw path as curve."""
    if len(set(path)) &lt; 2:
        return
    painter_path = QPainterPath()
    error = False
    for i, (x, y) in enumerate(path):
        if isnan(x):
            error = True
            self.painter.drawPath(painter_path)
            painter_path = QPainterPath()
        else:
            p = QPointF(x, -y) * self.zoom
            if i == 0:
                painter_path.moveTo(p)
                self.draw_circle(p, 2)
                continue
            if error:
                painter_path.moveTo(p)
                error = False
            else:
                painter_path.lineTo(p)
    self.painter.drawPath(painter_path)

</t>
<t tx="leo.20231205084738.76">def draw_dot(self, path: Sequence[_Coord]) -&gt; None:
    """Draw path as dots."""
    if len(set(path)) &lt; 2:
        return
    for i, (x, y) in enumerate(path):
        if isnan(x):
            continue
        p = QPointF(x, -y) * self.zoom
        if i == 0:
            self.draw_circle(p, 2)
        else:
            self.painter.drawPoint(p)

</t>
<t tx="leo.20231205084738.77">def solution_polygon(
    self,
    func: str,
    args: Sequence[str],
    target: str,
    pos: Sequence[VPoint]
) -&gt; Tuple[List[_Coord], QColor]:
    """Get solution polygon."""
    params = [args[0]]
    if func == 'PLLP':
        color = QColor(121, 171, 252)
        params.append(args[-1])
    elif func == 'PLAP':
        color = QColor(249, 84, 216)
    else:
        if func == 'PLPP':
            color = QColor(94, 255, 185)
        else:
            # PXY
            color = QColor(249, 175, 27)
    params.append(target)
    polygon = []
    for name in params:
        try:
            index = int(name.replace('P', ''))
        except ValueError:
            continue
        else:
            vpoint = pos[index]
            polygon.append((vpoint.cx * self.zoom, -vpoint.cy * self.zoom))
    return polygon, color

</t>
<t tx="leo.20231205084738.78">def draw_solution(
    self,
    func: str,
    args: Sequence[str],
    target: str,
    pos: Sequence[VPoint]
) -&gt; None:
    """Draw the solution triangle."""
    points, color = self.solution_polygon(func, args, target, pos)
    color.setAlpha(150)
    pen = QPen(color)
    pen.setWidth(self.joint_size)
    self.painter.setPen(pen)

    def draw_arrow(index: int, text: str) -&gt; None:
        """Draw arrow."""
        x0, y0 = points[index]
        x1, y1 = points[-1]
        self.draw_arrow(x0, -y0, x1, -y1, zoom=False, line=False, text=text)

    draw_arrow(0, args[1])
    if func == 'PLLP':
        draw_arrow(1, args[2])
    color.setAlpha(30)
    self.painter.setBrush(QBrush(color))
    self.painter.drawPolygon(
        QPolygonF([QPointF(x, y) for x, y in points]))
    self.painter.setBrush(Qt.NoBrush)

</t>
<t tx="leo.20231205084738.79">@Slot(int)
def set_show_ticks(self, show: int):
    """Set the appearance of tick mark."""
    self.show_ticks = _TickMark(show + 1)
    self.update()

</t>
<t tx="leo.20231205084738.8">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/entities/
# -*- coding: utf-8 -*-

"""The option dialog used to create or edit the link."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from re import match
from typing import List, Union
from qtpy.QtCore import Slot, Qt
from qtpy.QtWidgets import (
    QDialog, QListWidgetItem, QDialogButtonBox, QColorDialog, QWidget,
)
from qtpy.QtGui import QIcon, QPixmap
from pyslvs import VPoint, VLink, color_names
from pyslvs_ui.graphics import color_qt, color_icon
from .utility import set_custom_color, add_custom_color
from .edit_link_ui import Ui_Dialog


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084738.80">@Slot(bool)
def set_monochrome_mode(self, monochrome: bool) -&gt; None:
    """Set monochrome mode."""
    self.monochrome = monochrome
    self.update()


</t>
<t tx="leo.20231205084738.81">class AnimationCanvas(BaseCanvas, ABC):
    """A auto zooming canvas with time sequence."""
    update_pos = Signal(float, float)

    @others
</t>
<t tx="leo.20231205084738.82">def __init__(self, parent: QWidget):
    super(AnimationCanvas, self).__init__(parent)
    self.no_mechanism = False

</t>
<t tx="leo.20231205084738.83">def __zoom_to_fit_size(self) -&gt; Tuple[float, float, float, float]:
    """Limitations of four side."""
    r = RangeDetector()
    # Paths
    for i, path in enumerate(self.path.path):
        if self.no_mechanism and i not in self.target_path:
            continue
        for x, y in path:
            r(x, x, y, y)
    # Solving paths
    for path in self.target_path.values():
        for x, y in path:
            r(x, x, y, y)
    # Ranges
    for rect in self.ranges.values():
        r(rect.right(), rect.left(), rect.top(), rect.bottom())
    return r.right, r.left, r.top, r.bottom

</t>
<t tx="leo.20231205084738.84">def paintEvent(self, event: QPaintEvent) -&gt; None:
    """Adjust functions."""
    width = self.width()
    height = self.height()
    x_right, x_left, y_top, y_bottom = self.__zoom_to_fit_size()
    x_diff = x_left - x_right or 1.
    y_diff = y_top - y_bottom or 1.
    if width / x_diff &lt; height / y_diff:
        self.zoom = width / x_diff * 0.95
    else:
        self.zoom = height / y_diff * 0.95
    self.ox = width / 2 - (x_left + x_right) / 2 * self.zoom
    self.oy = height / 2 + (y_top + y_bottom) / 2 * self.zoom
    super(AnimationCanvas, self).paintEvent(event)

</t>
<t tx="leo.20231205084738.85">def mouseMoveEvent(self, event: QMouseEvent) -&gt; None:
    """Set mouse position."""
    self.update_pos.emit((event.x() - self.ox) / self.zoom,
                         (event.y() - self.oy) / self.zoom)


</t>
<t tx="leo.20231205084738.86">class PreviewCanvas(BaseCanvas):
    """A preview canvas use to show structure diagram."""
    cus: Dict[int, int]
    same: Dict[int, int]
    pos: Dict[int, _Coord]
    status: Dict[int, bool]
    driver: Set[int]
    target: Set[int]

    view_size: ClassVar[int] = 240

    @others
</t>
<t tx="leo.20231205084738.87">def __init__(self, parent: QWidget):
    """Input parameters and attributes."""
    super(PreviewCanvas, self).__init__(parent)
    self.graph = Graph([])
    self.cus = {}
    self.same = {}
    self.pos = {}
    self.status = {}
    # Additional attributes
    self.grounded = -1
    self.driver = set()
    self.target = set()
    self.clear()

</t>
<t tx="leo.20231205084738.88">def clear(self) -&gt; None:
    """Clear the attributes."""
    self.graph = Graph([])
    self.cus.clear()
    self.same.clear()
    self.pos.clear()
    self.status.clear()
    self.grounded = -1
    self.driver.clear()
    self.target.clear()
    self.update()

</t>
<t tx="leo.20231205084738.89">def paintEvent(self, event: QPaintEvent) -&gt; None:
    """Draw the structure."""
    width = self.width()
    height = self.height()
    if self.pos:
        x_right, x_left, y_top, y_bottom = self.__zoom_to_fit_limit()
        self.zoom = self.zoom_factor(
            width,
            height,
            x_right,
            x_left,
            y_top,
            y_bottom
        ) * 0.75
        self.ox = width / 2 - (x_left + x_right) / 2 * self.zoom
        self.oy = height / 2 + (y_top + y_bottom) / 2 * self.zoom
    else:
        if width &lt;= height:
            self.zoom = width / PreviewCanvas.view_size
        else:
            self.zoom = height / PreviewCanvas.view_size
        self.ox = width / 2
        self.oy = height / 2
    super(PreviewCanvas, self).paintEvent(event)
    pen = QPen()
    pen.setWidth(self.joint_size)
    self.painter.setPen(pen)
    color = color_qt('dark-gray') if self.monochrome else LINK_COLOR
    color.setAlpha(150)
    self.painter.setBrush(QBrush(color))
    # Links
    for link in self.graph.vertices:
        if link == self.grounded:
            continue
        points = []
        # Points that is belong with the link
        for num, edge in edges_view(self.graph):
            if link in edge:
                if num in self.same:
                    num = self.same[num]
                x, y = self.pos[num]
                points.append((x * self.zoom, y * -self.zoom))
        # Customize points
        for name, link_ in self.cus.items():
            if link == link_:
                x, y = self.pos[name]
                points.append((x * self.zoom, y * -self.zoom))
        self.painter.drawPolygon(*convex_hull(points, as_qpoint=True))

    # Nodes
    for node, (x, y) in self.pos.items():
        if node in self.same:
            continue
        x *= self.zoom
        y *= -self.zoom
        if self.monochrome:
            color = Qt.black
        elif node in self.driver:
            color = color_qt('red')
        elif node in self.target:
            color = color_qt('orange')
        elif self.get_status(node):
            color = color_qt('green')
        else:
            color = color_qt('blue')
        pen.setColor(color)
        self.painter.setPen(pen)
        self.painter.setBrush(QBrush(color))
        self.draw_circle(QPointF(x, y), self.joint_size)
        pen.setColor(Qt.black)
        self.painter.setPen(pen)

    # Text of node
    pen.setColor(Qt.black)
    self.painter.setPen(pen)
    for node, (x, y) in self.pos.items():
        if node in self.same:
            continue
        x *= self.zoom
        x += 2 * self.joint_size
        y *= -self.zoom
        y -= 2 * self.joint_size
        self.painter.drawText(QPointF(x, y), f'P{node}')

    self.painter.end()

</t>
<t tx="leo.20231205084738.9">class EditLinkDialog(QDialog, Ui_Dialog):
    """Option dialog."""

    @others
</t>
<t tx="leo.20231205084738.90">def __zoom_to_fit_limit(self) -&gt; Tuple[float, float, float, float]:
    """Limitations of four side."""
    inf = float('inf')
    x_right = inf
    x_left = -inf
    y_top = -inf
    y_bottom = inf
    for x, y in self.pos.values():
        if x &lt; x_right:
            x_right = x
        if x &gt; x_left:
            x_left = x
        if y &lt; y_bottom:
            y_bottom = y
        if y &gt; y_top:
            y_top = y
    return x_right, x_left, y_top, y_bottom

</t>
<t tx="leo.20231205084738.91">def set_graph(self, graph: Graph, pos: Mapping[int, _Coord]) -&gt; None:
    """Set the graph from NetworkX graph type."""
    self.graph = graph
    self.pos = dict(pos)
    self.status = {k: False for k in pos}
    self.update()

</t>
<t tx="leo.20231205084738.92">def set_grounded(self, link: int) -&gt; None:
    """Set the grounded link number."""
    self.grounded = link
    for n, edge in edges_view(self.graph):
        self.status[n] = self.grounded in edge
    for n, link in self.cus.items():
        self.status[n] = self.grounded == link
    self.update()

</t>
<t tx="leo.20231205084738.93">def set_driver(self, input_list: List[Tuple[int, int]]) -&gt; None:
    """Set driver nodes."""
    self.driver.clear()
    self.driver.update(pair[0] for pair in input_list)
    self.update()

</t>
<t tx="leo.20231205084738.94">def set_target(self, points: Sequence[int]) -&gt; None:
    """Set target nodes."""
    self.target.clear()
    self.target.update(points)
    self.update()

</t>
<t tx="leo.20231205084738.95">def set_status(self, point: str, status: bool) -&gt; None:
    """Set status node."""
    self.status[int(point.replace('P', ''))] = status
    self.update()

</t>
<t tx="leo.20231205084738.96">def get_status(self, point: int) -&gt; bool:
    """Get status. If multiple joints, return true."""
    return self.status[point] or (point in self.same)

</t>
<t tx="leo.20231205084738.97">@staticmethod
def grounded_detect(
    placement: Set[int],
    g: Graph,
    same: Mapping[int, int]
) -&gt; Iterator[int]:
    """Find the grounded link."""
    links: List[Set[int]] = [set() for _ in range(len(g.vertices))]
    for joint, link in edges_view(g):
        for node in link:
            links[node].add(joint)
    for row, link in enumerate(links):
        if placement == link - set(same):
            # Return once
            yield row
            return

</t>
<t tx="leo.20231205084738.98">def from_profile(self, params: Mapping[str, Any]) -&gt; None:
    """Simple load by dict object."""
    # Customize points and multiple joints
    g = Graph(params['graph'])
    expression: str = params['expression']
    pos_list = parse_pos(expression)
    cus: Mapping[int, int] = params['cus']
    same: Mapping[int, int] = params['same']
    self.cus = dict(cus)
    self.same = dict(same)
    for node, ref in sorted(self.same.items()):
        pos_list.insert(node, pos_list[ref])
    self.set_graph(g, {i: (x, y) for i, (x, y) in enumerate(pos_list)})

    # Grounded setting
    for row in self.grounded_detect(set(params['placement']), g, self.same):
        self.set_grounded(row)

    # Driver setting
    input_list: List[Tuple[int, int]] = params['input']
    self.driver.clear()
    self.driver.update(b for b, _ in input_list)

    # Target setting
    target: Mapping[int, Sequence[_Coord]] = params['target']
    self.target.clear()
    self.target.update(target)

    self.update()

</t>
<t tx="leo.20231205084738.99">def is_all_lock(self) -&gt; bool:
    """Is all joint has solution."""
    for node, status in self.status.items():
        if not status and node not in self.same:
            return False
    return True

</t>
<t tx="leo.20231205084739.1">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/
# -*- coding: utf-8 -*-

"""Python script output function."""

from __future__ import annotations

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import TYPE_CHECKING, Tuple, List, Sequence, Set, Optional
from qrcode import make
from qrcode.image.base import BaseImage
from numpy import full, ndarray, uint8
from qtpy.QtCore import Slot, Qt
from qtpy.QtWidgets import (
    QApplication,
    QDialog,
    QDialogButtonBox,
    QTextEdit,
    QWidget,
    QLabel,
    QVBoxLayout,
    QLineEdit,
    QSizePolicy,
)
from qtpy.QtGui import QIcon, QPixmap, QImage, QWheelEvent, QFont
from .script_ui import Ui_Dialog

if TYPE_CHECKING:
    from pyslvs_ui.widgets import MainWindowBase

_Expr = Sequence[Tuple[str, ...]]
_SCRIPT = """
from pyslvs import parse_vpoints, t_config, expr_solving

if __name__ == '__main__':
    vpoints = parse_vpoints(
        "M["\n{}
        "]")
    exprs = t_config(vpoints, {})
    mapping = {{n: f'P{{n}}' for n in range(len(vpoints))}}
    pos = expr_solving(exprs, vpoints, {})
    print(data_dict)
    print(pos)
"""
_CAL_SCRIPT = """
from pyslvs import {}

# {} are known

if __name__ == '__main__':
"""


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.10">class _ScriptBrowser(QTextEdit):
    """Custom text browser to implement text zooming."""

    @others
</t>
<t tx="leo.20231205084739.100">@Slot(QPoint)
def point_context_menu(self, point: QPoint) -&gt; None:
    """EntitiesPoint context menu."""
    self.__enable_point_context()
    self.pop_point.exec_(self.entities_point_widget.mapToGlobal(point))
    self.action_new_link.setVisible(True)
    self.pop_point_m.clear()

</t>
<t tx="leo.20231205084739.101">@Slot(QPoint)
def link_context_menu(self, point: QPoint) -&gt; None:
    """EntitiesLink context menu."""
    self.__enable_link_context()
    self.pop_link.exec_(self.entities_link_widget.mapToGlobal(point))
    self.pop_link_m.clear()

</t>
<t tx="leo.20231205084739.102">@Slot(QPoint)
def canvas_context_menu(self, point: QPoint) -&gt; None:
    """MainCanvas context menu."""
    for action in self.context.opt:
        action.setVisible(
            self.main_panel.currentWidget() is self.synthesis_tab
            and self.synthesis_tab_widget.currentWidget() is self.optimizer
            and self.optimizer.has_target()
        )
    index = self.entities_tab.currentIndex()
    if index == 0:
        self.__enable_point_context()
        self.pop_canvas_p.exec_(self.main_canvas.mapToGlobal(point))
        self.action_new_link.setVisible(True)
        self.pop_point_m.clear()
    elif index == 1:
        self.__enable_link_context()
        self.pop_canvas_l.exec_(self.main_canvas.mapToGlobal(point))
        self.pop_link_m.clear()

</t>
<t tx="leo.20231205084739.103">@Slot()
def enable_mechanism_actions(self) -&gt; None:
    """Enable / disable 'mechanism' menu."""
    point_selection = self.entities_point.selected_rows()
    link_selection = self.entities_link.selected_rows()
    one_point = len(point_selection) == 1
    one_link = len(link_selection) == 1
    point_selected = bool(point_selection)
    link_selected = bool(link_selection and 0 not in link_selection)
    # Edit
    self.action_edit_point.setEnabled(one_point)
    self.action_edit_link.setEnabled(one_link)
    # Delete
    self.action_delete_point.setEnabled(point_selected)
    self.action_delete_link.setEnabled(link_selected)

</t>
<t tx="leo.20231205084739.104">@Slot()
def copy_points_table(self) -&gt; None:
    """Copy text from point table."""
    _copy_table_data(self.entities_point)

</t>
<t tx="leo.20231205084739.105">@Slot()
def copy_links_table(self) -&gt; None:
    """Copy text from link table."""
    _copy_table_data(self.entities_link)

</t>
<t tx="leo.20231205084739.106">def copy_coord(self) -&gt; None:
    """Copy the current coordinate of the point."""
    pos = self.entities_point.current_position(self.entities_point.currentRow())
    text = str(pos[0] if len(pos) == 1 else pos)
    QApplication.clipboard().setText(text)

</t>
<t tx="leo.20231205084739.107">@Slot(name='on_action_preference_triggered')
def __set_preference(self) -&gt; None:
    """Set preference by dialog."""
    dlg = PreferencesDialog(self)
    dlg.show()
    dlg.exec_()
    self.apply_preferences(dlg.prefer_applied)
    dlg.deleteLater()
    self.solve()

</t>
<t tx="leo.20231205084739.108">def apply_preferences(self, prefer: Preferences, *, force: bool = False):
    """Apply preference from a setting."""
    for name in self.prefer.diff(None if force else prefer):
        value: Union[bool, int, float, str] = getattr(prefer, name)
        setattr(self.prefer, name, value)
        if name == 'line_width_option':
            self.main_canvas.set_link_width(cast(int, value))
        elif name == 'path_width_option':
            self.main_canvas.set_path_width(cast(int, value))
        elif name == 'font_size_option':
            self.main_canvas.set_font_size(cast(int, value))
        elif name == 'selection_radius_option':
            self.main_canvas.set_selection_radius(cast(int, value))
        elif name == 'link_trans_option':
            self.main_canvas.set_transparency(cast(int, value))
        elif name == 'margin_factor_option':
            self.main_canvas.set_margin_factor(cast(int, value))
        elif name == 'joint_size_option':
            self.main_canvas.set_joint_size(cast(int, value))
        elif name == 'zoom_by_option':
            self.main_canvas.set_zoom_by(cast(int, value))
        elif name == 'nav_toolbar_pos_option':
            self.__set_nav_toolbar_pos(cast(int, value))
        elif name == 'default_zoom_option':
            self.main_canvas.set_default_zoom(cast(int, value))
        elif name == 'snap_option':
            self.main_canvas.set_snap(cast(float, value))
        elif name == 'title_full_path_option':
            self.set_window_title_full_path()
        for canvas in (
            self.main_canvas,
            self.collections.configure_widget.configure_canvas,
            self.optimizer.preview_canvas,
        ):
            if name == 'tick_mark_option':
                cast(BaseCanvas, canvas).set_show_ticks(cast(int, value))
            elif name == 'monochrome_option':
                cast(BaseCanvas, canvas).set_monochrome_mode(cast(bool, value))

</t>
<t tx="leo.20231205084739.109">def __set_nav_toolbar_pos(self, pos: int) -&gt; None:
    """Set the position of toolbar. (0: top, 1: bottom)"""
    if pos not in {0, 1}:
        raise ValueError("invalid toolbar position.")
    if pos == 1:
        pos = 2
    if self.canvas_layout.indexOf(self.nav_toolbar) == pos:
        return
    self.canvas_layout.insertWidget(pos, self.nav_toolbar)
    self.canvas_layout.insertWidget(1, self.zoom_widget)

</t>
<t tx="leo.20231205084739.11">def __init__(self, parent: QWidget):
    super(_ScriptBrowser, self).__init__(parent)
    self.setLineWrapMode(QTextEdit.NoWrap)
    self.setFont(QFont("Consolas"))
    self.setReadOnly(True)
    self.zoomIn(3)

</t>
<t tx="leo.20231205084739.110">@Slot(bool, name='on_grid_mode_btn_toggled')
def __set_grid_mode(self, enabled: bool) -&gt; None:
    """Return grid mode state."""
    self.main_canvas.set_snap(self.prefer.snap_option if enabled else 0.)
</t>
<t tx="leo.20231205084739.111">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/main_window/
# -*- coding: utf-8 -*-

"""This module contains the functions that main window needed."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import (
    Tuple, Sequence, Set, FrozenSet, Dict, Counter as Counter_t, Union,
    Optional, Iterable,
)
from abc import abstractmethod, ABC
from collections import Counter
from math import sin, cos, radians, isnan
from numpy import array
from qtpy.QtCore import Slot
from qtpy.QtWidgets import (
    QDialogButtonBox,
    QDialog,
    QDoubleSpinBox,
    QLabel,
    QHBoxLayout,
    QVBoxLayout,
    QComboBox,
    QMessageBox,
    QInputDialog,
)
from pyslvs import (
    VJoint, VPoint, VLink, edges_view, SolverSystem, PointArgs,
    LinkArgs, uniform_expr
)
from pyslvs.graph import Graph
from pyslvs_ui.entities import EditPointDialog, EditLinkDialog
from pyslvs_ui.widgets import (
    AddTable,
    DeleteTable,
    EditPointTable,
    EditLinkTable,
    FixSequenceNumber,
)
from pyslvs_ui.widgets import MainWindowBase

_Coord = Tuple[float, float]
_Phase = Tuple[float, float, float]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.112">class _ScaleDialog(QDialog):
    """Scale mechanism dialog."""

    @others
</t>
<t tx="leo.20231205084739.113">def __init__(self, parent: MainWindowBase):
    super(_ScaleDialog, self).__init__(parent)
    self.setWindowTitle("Scale Mechanism")
    self.main_layout = QVBoxLayout(self)
    self.enlarge = QDoubleSpinBox(self)
    self.shrink = QDoubleSpinBox(self)
    self.__add_option("Enlarge", self.enlarge)
    self.__add_option("Shrink", self.shrink)

    btn_box = QDialogButtonBox(self)
    btn_box.setStandardButtons(
        QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
    btn_box.accepted.connect(self.accept)
    btn_box.rejected.connect(self.reject)
    btn_box.button(QDialogButtonBox.Ok).setEnabled(
        bool(parent.vpoint_list))
    self.main_layout.addWidget(btn_box)

</t>
<t tx="leo.20231205084739.114">def __add_option(self, name: str, option: QDoubleSpinBox) -&gt; None:
    """Add widgets for option."""
    layout = QHBoxLayout()
    label = QLabel(name, self)
    option.setValue(1)
    option.setMaximum(99999)
    option.setMinimum(0.01)
    layout.addWidget(label)
    layout.addWidget(option)
    self.main_layout.addLayout(layout)

</t>
<t tx="leo.20231205084739.115">def factor(self) -&gt; float:
    """Return scale value."""
    return self.enlarge.value() / self.shrink.value()


</t>
<t tx="leo.20231205084739.116">class _LinkLengthDialog(QDialog):
    """Link length dialog."""
    vlinks: Dict[str, FrozenSet[int]]

    @others
</t>
<t tx="leo.20231205084739.117">def __init__(self, parent: MainWindowBase):
    super(_LinkLengthDialog, self).__init__(parent)
    self.setWindowTitle("Set Link Length")
    self.main_layout = QVBoxLayout(self)
    layout = QHBoxLayout()
    self.leader = QComboBox(self)
    self.follower = QComboBox(self)
    self.length = QDoubleSpinBox(self)
    layout.addWidget(self.leader)
    layout.addWidget(self.follower)
    layout.addWidget(self.length)
    self.main_layout.addLayout(layout)

    self.vpoints = parent.vpoint_list
    self.vlinks = {
        vlink.name: frozenset(vlink.points) for vlink in parent.vlink_list
    }
    self.leader.currentTextChanged.connect(self.__set_follower)
    self.follower.currentTextChanged.connect(self.__set_length)
    self.leader.addItems([f"P{i}" for i in range(len(self.vpoints))])
    self.leader.setCurrentIndex(0)
    self.length.setMaximum(100000)

    btn_box = QDialogButtonBox(self)
    btn_box.setStandardButtons(
        QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
    btn_box.accepted.connect(self.accept)
    btn_box.rejected.connect(self.reject)
    btn_box.button(QDialogButtonBox.Ok).setEnabled(
        bool(parent.vpoint_list))
    self.main_layout.addWidget(btn_box)

</t>
<t tx="leo.20231205084739.118">@Slot(str)
def __set_follower(self, leader: str) -&gt; None:
    """Set follower options."""
    self.follower.clear()
    n = int(leader.replace('P', ''))
    options: Set[int] = set()
    for name, points in self.vlinks.items():
        if name == VLink.FRAME:
            continue
        if n in points:
            options.update(points)
    options.discard(n)
    self.follower.addItems([f"P{i}" for i in options])

</t>
<t tx="leo.20231205084739.119">@Slot(str)
def __set_length(self, follower: str) -&gt; None:
    """Set the current length of two points."""
    if not follower:
        return
    n1 = self.get_leader()
    n2 = int(follower.replace('P', ''))
    self.length.setValue(self.vpoints[n1].distance(self.vpoints[n2]))

</t>
<t tx="leo.20231205084739.12">def wheelEvent(self, event: QWheelEvent) -&gt; None:
    super(_ScriptBrowser, self).wheelEvent(event)
    if QApplication.keyboardModifiers() != Qt.ControlModifier:
        return
    if event.angleDelta().y() &gt; 0:
        self.zoomIn(1)
    else:
        self.zoomOut(1)


</t>
<t tx="leo.20231205084739.120">def get_leader(self) -&gt; int:
    """Get current leader."""
    return int(self.leader.currentText().replace('P', ''))

</t>
<t tx="leo.20231205084739.121">def get_follower(self) -&gt; int:
    """Get current follower."""
    return int(self.follower.currentText().replace('P', ''))

</t>
<t tx="leo.20231205084739.122">def get_length(self) -&gt; float:
    """Get current length."""
    return self.length.value()


</t>
<t tx="leo.20231205084739.123">class _FourBarDialog(QDialog):
    """Four-bar dialog."""

    @others
</t>
<t tx="leo.20231205084739.124">def __init__(self, parent: MainWindowBase):
    super(_FourBarDialog, self).__init__(parent)
    self.setWindowTitle("Four-bar Mechanism")
    self.main_layout = QVBoxLayout(self)
    for name, label, min_v, max_v in [
        ('x0', 'X offset', -99999, 99999),
        ('y0', 'Y offset', -99999, 99999),
        ('alpha', 'Rotation angle (deg)', 0, 360),
        ('l0', 'Length of ground link', 0.0001, 99999),
        ('l1', 'Length of crank link', 0.0001, 99999),
        ('l2', 'Length of coupler link', 0.0001, 99999),
        ('l3', 'Length of follower link', 0.0001, 99999),
        ('l4', 'Length of extended coupler link', 0.0001, 99999),
        ('gamma', 'Angle of extended coupler link (deg)', 0, 360),
    ]:
        spinbox = QDoubleSpinBox(self)
        spinbox.setDecimals(4)
        spinbox.setMinimum(min_v)
        spinbox.setMaximum(max_v)
        setattr(self, name, spinbox)
        layout = QHBoxLayout(self)
        layout.addWidget(QLabel(label, self))
        layout.addWidget(spinbox)
        self.main_layout.addLayout(layout)
    btn_box = QDialogButtonBox(self)
    btn_box.setStandardButtons(
        QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
    btn_box.accepted.connect(self.accept)
    btn_box.rejected.connect(self.reject)
    self.main_layout.addWidget(btn_box)


</t>
<t tx="leo.20231205084739.125">class EntitiesMethodInterface(MainWindowBase, ABC):
    """Abstract class for entities methods."""

    @others
</t>
<t tx="leo.20231205084739.126">@abstractmethod
def __init__(self):
    """Defined mouse position value on main canvas."""
    super(EntitiesMethodInterface, self).__init__()
    self.mouse_pos_x = 0.
    self.mouse_pos_y = 0.

</t>
<t tx="leo.20231205084739.127">def __edit_point(self, row: Union[int, bool] = False) -&gt; None:
    """Edit point function."""
    dlg = EditPointDialog(self.vpoint_list, self.vlink_list, row, self)
    dlg.show()
    if not dlg.exec_():
        dlg.deleteLater()
        return

    row_count = self.entities_point.rowCount()
    type_str = dlg.type_box.currentText().split()[0]
    if type_str != 'R':
        type_str += f":{dlg.angle_box.value() % 360}"
    args = PointArgs(
        ','.join(
            dlg.selected.item(link).text()
            for link in range(dlg.selected.count())
        ),
        type_str,
        dlg.color_box.currentText(),
        dlg.x_box.value(),
        dlg.y_box.value()
    )
    if row is False:
        self.cmd_stack.beginMacro(f"Add {{Point{row_count}}}")
        self.cmd_stack.push(
            AddTable(self.vpoint_list, self.entities_point))
        row = row_count
    else:
        row = dlg.name_box.currentIndex()
        self.cmd_stack.beginMacro(f"Edit {{Point{row}}}")

    dlg.deleteLater()

    self.cmd_stack.push(EditPointTable(
        row,
        self.vpoint_list,
        self.vlink_list,
        self.entities_point,
        self.entities_link,
        args
    ))
    self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.128">def __edit_link(self, row: Union[int, bool] = False) -&gt; None:
    """Edit link function."""
    dlg = EditLinkDialog(self.vpoint_list, self.vlink_list, row, self)
    dlg.show()
    if not dlg.exec_():
        dlg.deleteLater()
        return

    name = dlg.name_edit.text()
    args = LinkArgs(name, dlg.color_box.currentText(), ','.join(
        dlg.selected.item(point).text()
        for point in range(dlg.selected.count())
    ))
    if row is False:
        self.cmd_stack.beginMacro(f"Add {{Link: {name}}}")
        self.cmd_stack.push(
            AddTable(self.vlink_list, self.entities_link))
        row = self.entities_link.rowCount() - 1
    else:
        row = dlg.name_box.currentIndex()
        self.cmd_stack.beginMacro(f"Edit {{Link: {name}}}")

    dlg.deleteLater()

    self.cmd_stack.push(EditLinkTable(
        row,
        self.vpoint_list,
        self.vlink_list,
        self.entities_point,
        self.entities_link,
        args
    ))
    self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.129">def __get_link_serial_number(self) -&gt; str:
    """Return a new serial number name of link."""
    names = {vlink.name for vlink in self.vlink_list}
    i = 1
    while f"link_{i}" in names:
        i += 1
    return f"link_{i}"

</t>
<t tx="leo.20231205084739.13">class ScriptDialog(QDialog, Ui_Dialog):
    """Dialog of script preview."""
    image: QPixmap

    @others
</t>
<t tx="leo.20231205084739.130">@Slot(name='on_action_delete_point_triggered')
def delete_point(self, row: Optional[int] = None) -&gt; None:
    """Push delete point command to stack."""
    if row is None:
        row = self.entities_point.currentRow()
    if row &lt; 0:
        return
    args = self.entities_point.row_data(row)
    args.links = ''
    self.cmd_stack.beginMacro(f"Delete {{Point{row}}}")
    for i in reversed([
        i for i, (b, d, _) in enumerate(self.inputs_widget.input_pairs())
        if row in {b, d}
    ]):
        self.inputs_widget.remove_var(i)
    self.cmd_stack.push(EditPointTable(
        row,
        self.vpoint_list,
        self.vlink_list,
        self.entities_point,
        self.entities_link,
        args
    ))
    for i in range(self.entities_link.rowCount()):
        self.cmd_stack.push(FixSequenceNumber(
            self.vlink_list,
            self.entities_link,
            i,
            row
        ))
    self.cmd_stack.push(DeleteTable(
        row,
        self.vpoint_list,
        self.entities_point,
        is_rename=True
    ))
    self.inputs_widget.variable_excluding(row)
    self.cmd_stack.endMacro()
    if self.prefer.auto_remove_link_option:
        self.deduce_links()

</t>
<t tx="leo.20231205084739.131">@Slot(name='on_action_delete_link_triggered')
def delete_link(self, row: Optional[int] = None) -&gt; None:
    """Push delete link command to stack.

    Remove link will not remove the points.
    """
    if row is None:
        row = self.entities_link.currentRow()
    if row &lt; 1:
        return
    args = self.entities_link.row_data(row)
    args.points = ''
    self.cmd_stack.beginMacro(
        f"Delete {{Link: {self.vlink_list[row].name}}}")
    self.cmd_stack.push(EditLinkTable(
        row,
        self.vpoint_list,
        self.vlink_list,
        self.entities_point,
        self.entities_link,
        args
    ))
    self.cmd_stack.push(DeleteTable(
        row,
        self.vlink_list,
        self.entities_link,
        is_rename=False
    ))
    self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.132">def delete_points(self, points: Sequence[int]) -&gt; None:
    """Delete multiple points."""
    if not points:
        return
    self.cmd_stack.beginMacro(f"Delete points: {sorted(points)}")
    for row in sorted(points, reverse=True):
        self.delete_point(row)
    self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.133">def delete_links(self, links: Iterable[int]) -&gt; None:
    """Delete multiple links."""
    if not links:
        return
    names = ", ".join(self.vlink_list[i].name for i in sorted(links))
    self.cmd_stack.beginMacro(f"Delete links: [{names}]")
    for row in sorted(links, reverse=True):
        if row == 0:
            continue
        self.delete_link(row)
    self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.134">@Slot(float, float)
def add_point_by_pos(self, x: float, y: float) -&gt; None:
    """Add point group using alt key."""
    if (
        self.main_panel.currentWidget() is self.synthesis_tab
        and self.synthesis_tab_widget.currentWidget() is
        self.optimizer
    ):
        self.add_target_point()
    else:
        self.add_point(x, y)

</t>
<t tx="leo.20231205084739.135">def add_normal_point(self) -&gt; None:
    """Add a point (not fixed)."""
    self.add_point(self.mouse_pos_x, self.mouse_pos_y)

</t>
<t tx="leo.20231205084739.136">def add_fixed_point(self) -&gt; None:
    """Add a point (fixed)."""
    self.add_point(self.mouse_pos_x, self.mouse_pos_y, VLink.FRAME, 'Blue')

</t>
<t tx="leo.20231205084739.137">def add_point(
    self,
    x: float,
    y: float,
    links: str = "",
    color: str = 'Green',
    type_num: Union[int, VJoint] = VJoint.R,
    angle: float = 0.
) -&gt; int:
    """Add an ordinary point. Return the row count of new point."""
    row_count = self.entities_point.rowCount()
    self.cmd_stack.beginMacro(f"Add {{Point{row_count}}}")
    self.cmd_stack.push(AddTable(self.vpoint_list, self.entities_point))
    if type_num == VJoint.R:
        type_str = 'R'
    elif type_num == VJoint.P:
        type_str = f'P:{angle}'
    else:
        type_str = f'RP:{angle}'
    self.cmd_stack.push(EditPointTable(
        row_count,
        self.vpoint_list,
        self.vlink_list,
        self.entities_point,
        self.entities_link,
        PointArgs(links, type_str, color, x, y)
    ))
    self.cmd_stack.endMacro()
    return row_count

</t>
<t tx="leo.20231205084739.138">def add_points(
    self,
    p_attr: Sequence[Tuple[float, float, str, str, int, float]]
) -&gt; None:
    """Add multiple points."""
    for attr in p_attr:
        self.add_point(*attr)

</t>
<t tx="leo.20231205084739.139">def add_points_by_graph(
    self,
    graph: Graph,
    pos: Dict[int, Tuple[float, float]],
    ground_link: Optional[int]
) -&gt; None:
    """Add points by NetworkX graph and position dict."""
    base_count = self.entities_point.rowCount()
    self.cmd_stack.beginMacro(
        "Merge mechanism kit from {Number and Type Synthesis}"
    )

    for i in range(len(pos)):
        x, y = pos[i]
        self.add_point(x, y)

    ground: Optional[int] = None
    for link in graph.vertices:
        self.add_link(self.__get_link_serial_number(), 'Blue', [
            base_count + n for n, edge in edges_view(graph) if link in edge
        ])
        if link == ground_link:
            ground = self.entities_link.rowCount() - 1
    self.cmd_stack.endMacro()
    if ground_link is not None:
        self.constrain_link(ground)

</t>
<t tx="leo.20231205084739.14">def __init__(
    self,
    icon: QIcon,
    script: str,
    filename: str,
    file_format: List[str],
    parent: MainWindowBase,
    *,
    compressed_script: str = "M[]",
    exprs: Optional[_Expr] = None
):
    """Input parameters:

    + Script
    + Lexer
    + File name
    + File suffix
    """
    super(ScriptDialog, self).__init__(parent)
    self.setupUi(self)
    self.setWindowFlags(self.windowFlags() | Qt.WindowMaximizeButtonHint
                        &amp; ~Qt.WindowContextHelpButtonHint)
    self.setWindowIcon(icon)
    self.btn_box.button(QDialogButtonBox.Close).setDefault(True)
    # Calculation function
    if exprs is not None:
        script += "\n###\n" + _expr_to_script(exprs)
    self.script_view = _ScriptBrowser(self)
    self.script_view.setText(script)
    self.main_layout.insertWidget(0, self.script_view)
    self.filename = filename
    self.file_format = file_format
    self.output_to = parent.output_to
    self.save_reply_box = parent.save_reply_box
    self.setWindowTitle(self.filename)
    self.btn_box.button(QDialogButtonBox.Save).clicked.connect(
        self.__save)

    # Compressed script
    self.compressed_script = compressed_script
    if self.compressed_script == "M[]":
        self.show_qrcode.setVisible(False)
        return
    line_edit = QLineEdit(self)
    line_edit.setText(self.compressed_script)
    line_edit.setReadOnly(True)
    self.main_layout.insertWidget(1, line_edit)
    # Image display
    image = make(self.compressed_script, image_factory=_NpImage)
    self.image = QPixmap.fromImage(image.get_qimage())

</t>
<t tx="leo.20231205084739.140">@Slot(list)
def add_normal_link(self, points: Sequence[int]) -&gt; None:
    """Add a link."""
    self.add_link(self.__get_link_serial_number(), 'Blue', points)

</t>
<t tx="leo.20231205084739.141">def add_link(
    self,
    name: str,
    color: str,
    points: Optional[Sequence[int]] = None
) -&gt; None:
    """Push a new link command to stack."""
    if points is None:
        points = []
    args = LinkArgs(name, color, ','.join(f'Point{i}' for i in points))
    self.cmd_stack.beginMacro(f"Add {{Link: {name}}}")
    self.cmd_stack.push(AddTable(self.vlink_list, self.entities_link))
    self.cmd_stack.push(EditLinkTable(
        self.entities_link.rowCount() - 1,
        self.vpoint_list,
        self.vlink_list,
        self.entities_point,
        self.entities_link,
        args
    ))
    self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.142">@Slot(name='on_action_new_point_triggered')
def new_point(self) -&gt; None:
    """Create a point with arguments."""
    self.__edit_point()

</t>
<t tx="leo.20231205084739.143">@Slot(name='on_action_edit_point_triggered')
def edit_point(self) -&gt; None:
    """Edit a point with arguments."""
    row = self.entities_point.currentRow()
    self.__edit_point(row if row &gt; -1 else 0)

</t>
<t tx="leo.20231205084739.144">@Slot()
def lock_points(self) -&gt; None:
    """Turn a group of points to fixed on ground or not."""
    to_fixed = self.action_p_lock.isChecked()
    selected = self.entities_point.selected_rows()
    self.cmd_stack.beginMacro(
        f"{'Grounded' if to_fixed else 'Ungrounded'} "
        f"{sorted(selected)}"
    )
    for row in selected:
        new_links = list(self.vpoint_list[row].links)
        if to_fixed:
            if VLink.FRAME not in new_links:
                new_links.append(VLink.FRAME)
        elif VLink.FRAME in new_links:
            new_links.remove(VLink.FRAME)
        args = self.entities_point.row_data(row)
        args.links = ','.join(s for s in new_links if s)
        self.cmd_stack.push(EditPointTable(
            row,
            self.vpoint_list,
            self.vlink_list,
            self.entities_point,
            self.entities_link,
            args
        ))
    self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.145">def clone_point(self) -&gt; None:
    """Clone a point (with orange color)."""
    row = self.entities_point.currentRow()
    args = self.entities_point.row_data(row)
    args.color = 'Orange'
    row_count = self.entities_point.rowCount()
    self.cmd_stack.beginMacro(
        f"Clone {{Point{row}}} as {{Point{row_count}}}")
    self.cmd_stack.push(AddTable(self.vpoint_list, self.entities_point))
    self.cmd_stack.push(EditPointTable(
        row_count,
        self.vpoint_list,
        self.vlink_list,
        self.entities_point,
        self.entities_link,
        args
    ))
    self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.146">@Slot(name='on_action_new_fourbar_triggered')
def __new_fourbar(self) -&gt; None:
    """Create four-bar linkage."""
    dlg = _FourBarDialog(self)
    if not dlg.exec_():
        dlg.deleteLater()
        return
    x0 = dlg.x0.value()
    y0 = dlg.y0.value()
    alpha = radians(dlg.alpha.value())
    l0 = dlg.l0.value()
    l1 = dlg.l1.value()
    l2 = dlg.l2.value()
    l3 = dlg.l3.value()
    l4 = dlg.l4.value()
    gamma = radians(dlg.gamma.value())
    expr = uniform_expr(array([l0 / l1, l2 / l1, l3 / l1, l4 / l1, gamma]))
    new_expr = []
    for vp in expr:
        if isnan(vp.x) or isnan(vp.y):
            QMessageBox.warning(self, "Solved error", "Invalid dimension.")
            return
        x = vp.c[0, 0] * l1
        y = vp.c[0, 1] * l1
        new_expr.append(VPoint(vp.links, VJoint.R, 0., '',
                               cos(alpha) * x - sin(alpha) * y + x0,
                               sin(alpha) * x + cos(alpha) * y + y0))
    self.merge_result('M[' + ','.join(p.expr() for p in new_expr) + ']', [])

</t>
<t tx="leo.20231205084739.147">@Slot(name='on_action_scale_points_triggered')
def __set_scale(self) -&gt; None:
    """Scale the mechanism."""
    dlg = _ScaleDialog(self)
    if not dlg.exec_():
        dlg.deleteLater()
        return
    factor = dlg.factor()
    dlg.deleteLater()
    self.cmd_stack.beginMacro(f"Scale mechanism: {factor}")
    for row in range(self.entities_point.rowCount()):
        args = self.entities_point.row_data(row)
        args.x *= factor
        args.y *= factor
        self.cmd_stack.push(EditPointTable(
            row,
            self.vpoint_list,
            self.vlink_list,
            self.entities_point,
            self.entities_link,
            args
        ))
    self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.148">@Slot(name='on_action_set_link_length_triggered')
def __set_link_length(self) -&gt; None:
    """Set link length."""
    dlg = _LinkLengthDialog(self)
    dlg.show()
    if not dlg.exec_():
        return
    data = {(dlg.get_leader(), dlg.get_follower()): dlg.get_length()}
    dlg.deleteLater()
    system = SolverSystem(
        self.vpoint_list,
        {(b, d): a for b, d, a in self.inputs_widget.input_pairs()}
    )
    system.set_data(data)
    try:
        result = system.solve()
    except ValueError:
        QMessageBox.warning(self, "Solved error",
                            "The condition is not valid.")
        return
    self.cmd_stack.beginMacro(f"Set link length:{set(data)}")
    for row, c in enumerate(result):
        args = self.entities_point.row_data(row)
        if isinstance(c[0], float):
            args.x, args.y = c
        else:
            (args.x, args.y), _ = c
        self.cmd_stack.push(EditPointTable(
            row,
            self.vpoint_list,
            self.vlink_list,
            self.entities_point,
            self.entities_link,
            args
        ))
    self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.149">@Slot(tuple)
def set_free_move(self, args: Sequence[Tuple[int, _Phase]]):
    """Free move function."""
    points_text = ", ".join(f"Point{c[0]}" for c in args)
    self.cmd_stack.beginMacro(f"Moved {{{points_text}}}")
    for row, (x, y, angle) in args:
        arg = self.entities_point.row_data(row)
        arg.x = x
        arg.y = y
        if arg.type != 'R':
            angle_tag = arg.type.split(':')[0]
            arg.type = f"{angle_tag}:{angle:.02f}"
        self.cmd_stack.push(EditPointTable(
            row,
            self.vpoint_list,
            self.vlink_list,
            self.entities_point,
            self.entities_link,
            arg
        ))
    self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.15">def __save(self) -&gt; None:
    """Save to specific format."""
    path = self.output_to("Script", self.file_format)
    if not path:
        return
    with open(path, 'w+', encoding='utf-8') as f:
        f.write(self.script_view.toPlainText())
    self.save_reply_box("Script", path)

</t>
<t tx="leo.20231205084739.150">@Slot(name='on_action_new_link_triggered')
def new_link(self) -&gt; None:
    """Create a link with arguments.

    + Last than one point:
        + Create a new link (Dialog)
    + Search method:
        + Find the intersection between points that was including any link.
        + Add the points that is not in the intersection to the link.
    + If no, just create a new link by selected points.
    """
    rows = self.entities_point.selected_rows()
    if not len(rows) &gt; 1:
        self.__edit_link()
        return
    inter: Counter_t[str] = Counter()
    for p in rows:
        inter.update(self.vpoint_list[p].links)
    name = inter.most_common(1)[0][0] if inter else ""
    if inter[name] &lt; 2:
        self.add_normal_link(rows)
        return
    row = self.entities_link.find_name(name)
    self.cmd_stack.beginMacro(f"Edit {{Link: {name}}}")
    args = self.entities_link.row_data(row)
    points = set(self.entities_link.get_points(row))
    points.update(rows)
    args.points = ','.join(f'Point{p}' for p in points)
    self.cmd_stack.push(EditLinkTable(
        row,
        self.vpoint_list,
        self.vlink_list,
        self.entities_point,
        self.entities_link,
        args
    ))
    self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.151">@Slot(name='on_action_edit_link_triggered')
def edit_link(self) -&gt; None:
    """Edit a link with arguments."""
    self.__edit_link(self.entities_link.currentRow())

</t>
<t tx="leo.20231205084739.152">@Slot()
def release_ground(self) -&gt; None:
    """Clone ground to a new link, then make ground no points."""
    name = self.__get_link_serial_number()
    args = LinkArgs(name, 'Blue', self.entities_link.item(0, 2).text())
    self.cmd_stack.beginMacro(f"Release ground to {{Link: {name}}}")
    # Free all points
    self.cmd_stack.push(EditLinkTable(
        0,
        self.vpoint_list,
        self.vlink_list,
        self.entities_point,
        self.entities_link,
        LinkArgs(VLink.FRAME, 'White', '')
    ))
    # Create new link
    self.cmd_stack.push(AddTable(self.vlink_list, self.entities_link))
    self.cmd_stack.push(EditLinkTable(
        self.entities_link.rowCount() - 1,
        self.vpoint_list,
        self.vlink_list,
        self.entities_point,
        self.entities_link,
        args
    ))
    self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.153">@Slot()
def constrain_link(self, row1: Optional[int] = None, row2: int = 0) -&gt; None:
    """Turn a link to ground, then delete this link."""
    if row1 is None:
        row1 = self.entities_link.currentRow()
    vlink1 = self.vlink_list[row1]
    link_args = self.entities_link.row_data(row1)
    link_args.points = ''
    new_points = sorted(set(self.vlink_list[0].points) | set(vlink1.points))
    base_args = self.entities_link.row_data(row2)
    base_args.points = ','.join(f"Point{e}" for e in new_points if e)
    self.cmd_stack.beginMacro(
        f"Constrain {{Link: {vlink1.name}}} to ground")
    # Turn to ground
    self.cmd_stack.push(EditLinkTable(
        row2,
        self.vpoint_list,
        self.vlink_list,
        self.entities_point,
        self.entities_link,
        base_args
    ))
    # Free all points and delete the link
    self.cmd_stack.push(EditLinkTable(
        row1,
        self.vpoint_list,
        self.vlink_list,
        self.entities_point,
        self.entities_link,
        link_args
    ))
    self.cmd_stack.push(DeleteTable(
        row1,
        self.vlink_list,
        self.entities_link,
        is_rename=False
    ))
    self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.154">@Slot()
def delete_selected_points(self) -&gt; None:
    """Delete the selected points."""
    self.delete_points(self.entities_point.selected_rows())

</t>
<t tx="leo.20231205084739.155">@Slot()
def delete_selected_links(self) -&gt; None:
    """Delete the selected links."""
    self.delete_links(self.entities_link.selected_rows())

</t>
<t tx="leo.20231205084739.156">@Slot(name='on_action_deduce_links_triggered')
def deduce_links(self) -&gt; None:
    """Delete redundant links."""
    # Empty links
    links = {i for i, vlink in enumerate(self.vlink_list)
             if vlink.name != VLink.FRAME and len(vlink.points) &lt; 2}
    # Only keep one connecting link with the same topology
    recorder = set()
    for i, vlink in enumerate(self.vlink_list):
        if i in links:
            continue
        points = frozenset(vlink.points)
        if points in recorder:
            links.add(i)
        else:
            recorder.add(points)
    self.delete_links(links)

</t>
<t tx="leo.20231205084739.157">def set_coords_as_current(self) -&gt; None:
    """Update points position as current coordinate."""
    self.set_free_move(tuple(
        (row, (vpoint.cx, vpoint.cy, vpoint.angle))
        for row, vpoint in enumerate(self.vpoint_list)
    ))

</t>
<t tx="leo.20231205084739.158">@Slot()
def point_alignment(self) -&gt; None:
    """Alignment function."""
    selected_rows = self.entities_point.selected_rows()
    if not selected_rows:
        QMessageBox.warning(
            self,
            "Points alignment",
            "No selected points with this operation."
        )
        return
    if self.alignment_mode == 0:
        axis = "x"
    elif self.alignment_mode == 1:
        axis = "y"
    else:
        raise ValueError("no such alignment option")
    value, ok = QInputDialog.getDouble(
        self,
        f"Set {axis} axis",
        f"Align the selected points into {axis} axis:",
        0, -9999, 9999, 4)
    if not ok:
        return
    self.cmd_stack.beginMacro(f"Align points with {axis}")
    for row in selected_rows:
        args = self.entities_point.row_data(row)
        if self.alignment_mode == 0:
            args.x = value
        elif self.alignment_mode == 1:
            args.y = value
        else:
            raise ValueError("no such alignment option")
        self.cmd_stack.push(EditPointTable(
            row,
            self.vpoint_list,
            self.vlink_list,
            self.entities_point,
            self.entities_link,
            args
        ))
    self.cmd_stack.endMacro()
</t>
<t tx="leo.20231205084739.159">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/main_window/
# -*- coding: utf-8 -*-

"""This module contains the functions that main window needed."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import (
    Tuple, List, Sequence, Mapping, Callable, Iterator, Union, Type,
)
from abc import ABC
from dataclasses import Field, fields
from lark.exceptions import LarkError
from qtpy.QtCore import Slot, QUrl, QFile, QFileInfo, QMimeData
from qtpy.QtWidgets import (
    QApplication,
    QMessageBox,
    QInputDialog,
    QFileDialog,
    QProgressDialog,
)
from qtpy.QtGui import (
    QDesktopServices,
    QPixmap,
    QIcon,
    QDragEnterEvent,
    QDropEvent,
)
from pyslvs import parse_params, VLink
from pyslvs_ui import __version__
from pyslvs_ui.qt_patch import qt_image_format, qt_image_suffix
from pyslvs_ui.info import (
    ARGUMENTS,
    logger,
    PyslvsAbout,
    check_update,
    size_format,
)
from pyslvs_ui.io import (
    ScriptDialog,
    slvs_process_script,
    SlvsParser,
    SlvsOutputDialog,
    DxfOutputDialog,
    OutputDialog,
    OverviewDialog,
    str_between,
)
from pyslvs_ui.widgets import AddTable, EditPointTable, Preferences
from .actions import ActionMethodInterface

_PREFIX = f"# Generate by Pyslvs {__version__}\n# Project "
Settings = Union[int, float, bool, str]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.16">@Slot(name='on_copy_btn_clicked')
def __copy(self) -&gt; None:
    """Copy to clipboard."""
    QApplication.clipboard().setText(
        self.compressed_script if self.compressed_script else
        self.script_view.toPlainText()
    )

</t>
<t tx="leo.20231205084739.160">class IOMethodInterface(ActionMethodInterface, ABC):
    """Abstract class for action methods."""

    @others
</t>
<t tx="leo.20231205084739.161">def __v_to_slvs(self) -&gt; Callable[[], Iterator[Tuple[int, int]]]:
    """Solvespace edges."""

    def func() -&gt; Iterator[Tuple[int, int]]:
        for vlink in self.vlink_list:
            if vlink.name == VLink.FRAME:
                continue
            for i, p in enumerate(vlink.points):
                if i == 0:
                    continue
                yield vlink.points[0], p
                if i &gt; 1:
                    yield vlink.points[i - 1], p

    return func

</t>
<t tx="leo.20231205084739.162">def __read_slvs(self, file_name: str) -&gt; None:
    """Read slvs format.

    + Choose a group.
    + Read the entities of the group.
    """
    parser = SlvsParser(file_name)
    if not parser.is_valid():
        QMessageBox.warning(self, "Format error",
                            "The format is not support.")
        return
    groups = parser.get_groups()
    if not groups:
        QMessageBox.warning(self, "Format error",
                            "The model file is empty.")
        return
    group, ok = QInputDialog.getItem(
        self,
        "Solvespace groups",
        "Choose a group:\n"
        "(Please know that the group must contain a sketch only.)",
        ["@".join(g) for g in groups],
        0,
        False
    )
    if not ok:
        return
    self.clear()
    logger.debug(f"Read from group: {group}")
    self.parse_expression(parser.parse(group.split('@')[0]))

</t>
<t tx="leo.20231205084739.163">def dragEnterEvent(self, event: QDragEnterEvent) -&gt; None:
    """Drag file in to our window."""
    mime_data: QMimeData = event.mimeData()
    if not mime_data.hasUrls():
        return
    urls = mime_data.urls()
    if len(urls) == 1:
        suffix = QFileInfo(urls[0].toLocalFile()).suffix().lower()
        if suffix in {'yml', 'pyslvs', 'slvs'} | set(qt_image_suffix):
            event.acceptProposedAction()

</t>
<t tx="leo.20231205084739.164">def dropEvent(self, event: QDropEvent) -&gt; None:
    """Drop file in to our window."""
    file = event.mimeData().urls()[0].toLocalFile()
    if QFileInfo(file).suffix().lower() in set(qt_image_suffix):
        self.project_widget.set_background_config({'background': file})
    else:
        self.__load_file(file)
    event.acceptProposedAction()

</t>
<t tx="leo.20231205084739.165">def project_no_save(self) -&gt; None:
    """Project not saved signal."""
    self.project_widget.set_changed(True)
    self.set_window_title_full_path()

</t>
<t tx="leo.20231205084739.166">def project_saved(self) -&gt; None:
    """Project saved signal."""
    self.project_widget.set_changed(False)
    self.set_window_title_full_path()

</t>
<t tx="leo.20231205084739.167">def set_window_title_full_path(self) -&gt; None:
    """Set the option 'window title will show the full path'."""
    file_name = self.project_widget.file_name()
    if self.prefer.title_full_path_option:
        title = file_name.absoluteFilePath()
    else:
        title = file_name.completeBaseName()
    self.setWindowTitle(
        f"Pyslvs - {title}{'*' if self.project_widget.changed() else ''}")

</t>
<t tx="leo.20231205084739.168">def __open_url(self, url: str) -&gt; None:
    """Use to open link."""
    QDesktopServices.openUrl(QUrl(url))
    self.showMinimized()

</t>
<t tx="leo.20231205084739.169">@Slot(name='on_action_mde_tw_triggered')
def __show_help(self) -&gt; None:
    """Open website: mde.tw"""
    self.__open_url("http://mde.tw")

</t>
<t tx="leo.20231205084739.17">@Slot(name='on_show_qrcode_clicked')
def __show_qrcode(self) -&gt; None:
    """Save to image file."""
    dlg = QDialog(self)
    dlg.setWindowTitle("Mechanism QR code")
    dlg.setModal(True)
    layout = QVBoxLayout(dlg)
    label = QLabel(dlg)
    layout.addWidget(label)
    label.setPixmap(self.image)
    dlg.setFixedSize(self.image.size())
    dlg.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
    dlg.show()
</t>
<t tx="leo.20231205084739.170">@Slot(name='on_action_pyslvs_com_triggered')
def __show_pyslvs_com(self) -&gt; None:
    """Open website: pyslvs.com"""
    self.__open_url("http://www.pyslvs.com/content/index.html")

</t>
<t tx="leo.20231205084739.171">@Slot(name='on_action_github_repository_triggered')
def __show_github(self) -&gt; None:
    """Open website: Github repository"""
    self.__open_url("https://github.com/KmolYuan/Pyslvs-UI")

</t>
<t tx="leo.20231205084739.172">@Slot(name='on_action_documentation_triggered')
def __show_doc(self) -&gt; None:
    """Open website: Readthedocs"""
    self.__open_url("https://pyslvs-ui.readthedocs.io")

</t>
<t tx="leo.20231205084739.173">@Slot(name='on_action_about_triggered')
def __about(self) -&gt; None:
    """Open Pyslvs about."""
    dlg = PyslvsAbout(self)
    dlg.show()
    dlg.exec_()
    dlg.deleteLater()

</t>
<t tx="leo.20231205084739.174">@Slot(name='on_action_example_triggered')
def __load_example(self) -&gt; None:
    """Load examples from "DatabaseWidget"."""
    if self.check_file_changed():
        return
    if self.project_widget.load_example():
        self.show_expr()
        self.main_canvas.zoom_to_fit()

</t>
<t tx="leo.20231205084739.175">@Slot(name='on_action_new_project_triggered')
def __new_project(self) -&gt; None:
    """Create (Clean) a new project."""
    if self.check_file_changed():
        return
    self.clear()
    logger.info("Created a new project.")

</t>
<t tx="leo.20231205084739.176">def clear(self) -&gt; None:
    """Clear to create commit stage."""
    self.free_move_disable.trigger()
    self.mechanism_storage_name_tag.clear()
    self.mechanism_storage.clear()
    self.collections.clear()
    self.structure_synthesis.clear()
    self.inputs_widget.clear()
    self.optimizer.clear()
    self.entities_point.clear()
    self.entities_link.clear()
    self.vpoint_list.clear()
    self.vlink_list[1:] = []
    self.entities_expr.clear()
    self.solve()
    self.project_widget.reset()
    self.project_saved()

</t>
<t tx="leo.20231205084739.177">@Slot()
def import_pmks_url(self) -&gt; None:
    """Load PMKS URL and turn it to expression."""
    url, ok = QInputDialog.getText(
        self,
        "PMKS URL input",
        "Please input link string:"
    )
    if not ok:
        return
    if not url:
        QMessageBox.warning(
            self,
            "Loading failed",
            "Your link is in an incorrect format."
        )
        return
    try:
        for s in url.split('?')[-1].split('&amp;'):
            if 'mech=' in s:
                expr = s.replace('mech=', '').split('|')
                break
        else:
            raise ValueError

        text_list = [s for s in expr if s not in ('', " ", '\n')]
        expr.clear()
        while text_list:
            item = text_list.pop(0).split(',')[:-1]
            for i, e in enumerate(reversed(item)):
                if e in {'R', 'P', 'RP'}:
                    t = -(i + 1)
                    break
            else:
                raise ValueError
            links = item[:t]
            item = item[t:]
            type_text = f"{item[0]}:{item[-1]}" if item[0] != 'R' else 'R'
            links_text = ", ".join(links)
            expr.append(
                f"J[{type_text}, P[{item[1]}, {item[2]}], L[{links_text}]]")
        expr = "M[" + ", ".join(expr) + "]"
    except (ValueError, IndexError):
        QMessageBox.warning(
            self,
            "Loading failed",
            "Your link is in an incorrect format."
        )
    else:
        self.parse_expression(expr)

</t>
<t tx="leo.20231205084739.178">def parse_expression(self, expr: str) -&gt; None:
    """Parse expression."""
    try:
        args_list = parse_params(expr)
    except LarkError:
        QMessageBox.warning(self, "Loading failed",
                            "Your expression is in an incorrect format.")
    else:
        for args in args_list:
            links = args.links.split(',')
            link_names = {vlink.name for vlink in self.vlink_list}
            for link_name in links:
                # If link name not exist
                if link_name not in link_names:
                    self.add_link(link_name, 'Blue')
            row_count = self.entities_point.rowCount()
            self.cmd_stack.beginMacro(f"Add {{Point{row_count}}}")
            self.cmd_stack.push(AddTable(
                self.vpoint_list,
                self.entities_point
            ))
            self.cmd_stack.push(EditPointTable(
                row_count,
                self.vpoint_list,
                self.vlink_list,
                self.entities_point,
                self.entities_link,
                args
            ))
            self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.179">def add_empty_links(self, link_color: Mapping[str, str]) -&gt; None:
    """Use to add empty link when loading database."""
    for name, color in link_color.items():
        if name != VLink.FRAME:
            self.add_link(name, color)

</t>
<t tx="leo.20231205084739.18">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'script.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.180">@Slot(name='on_action_load_file_triggered')
def __load_file(self, file_name: str = "") -&gt; None:
    """Load a supported format in Pyslvs."""
    if self.check_file_changed():
        return

    if not file_name:
        file_name = self.input_from("project", [
            "Pyslvs project (*.pyslvs)",
            "Solvespace 2.x-3.x (*.slvs)",
        ])
        if not file_name:
            return

    suffix = QFileInfo(file_name).suffix().lower()
    if suffix == 'pyslvs':
        self.project_widget.read(file_name)
    elif suffix == 'slvs':
        self.__read_slvs(file_name)
    else:
        QMessageBox.warning(
            self,
            "Invalid file suffix",
            "Only support '*.pyslvs' or '*.slvs'."
        )
        return

    self.project_saved()
    self.main_canvas.zoom_to_fit()

</t>
<t tx="leo.20231205084739.181">@Slot(name='on_action_save_triggered')
def save(self) -&gt; None:
    """Save action. (YAML)"""
    if self.project_widget.file_exist():
        self.project_widget.save()
        self.project_saved()
    else:
        self.__save_as()

</t>
<t tx="leo.20231205084739.182">@Slot(name='on_action_save_as_triggered')
def __save_as(self) -&gt; None:
    """Save as action."""
    file_name = self.output_to("Pyslvs project",
                               ["Pyslvs project (*.pyslvs)"])
    if not file_name:
        return
    self.project_widget.save(file_name)
    self.project_saved()
    self.save_reply_box("YAML Profile", file_name)

</t>
<t tx="leo.20231205084739.183">def __cad_export(self, dialog: Type[OutputDialog], title: str) -&gt; None:
    """Export to cad format."""
    dlg = dialog(self.env, self.project_widget.base_file_name(),
                 self.vpoint_list, self.__v_to_slvs(), self)
    dlg.show()
    if dlg.exec_():
        path = dlg.path_edit.text() or dlg.path_edit.placeholderText()
        self.set_locate(path)
        self.save_reply_box(title, path)
    dlg.deleteLater()

</t>
<t tx="leo.20231205084739.184">@Slot()
def export_slvs(self) -&gt; None:
    """Solvespace 2d save function."""
    self.__cad_export(SlvsOutputDialog, "Solvespace sketch")

</t>
<t tx="leo.20231205084739.185">@Slot()
def export_dxf(self) -&gt; None:
    """DXF 2d save function."""
    self.__cad_export(DxfOutputDialog, "Drawing Exchange Format")

</t>
<t tx="leo.20231205084739.186">@Slot()
def export_image(self) -&gt; None:
    """Picture save function."""
    if self.prefer.grab_no_background_option:
        pixmap = self.main_canvas.grab_no_background()
    else:
        pixmap = self.main_canvas.grab()
    file_name = self.output_to("picture", qt_image_format)
    if not file_name:
        return
    pixmap.save(file_name)
    self.save_reply_box("Picture", file_name)

</t>
<t tx="leo.20231205084739.187">def output_to(self, format_name: str, format_choose: Sequence[str]) -&gt; str:
    """Simple to support multiple format."""
    file_name, suffix = QFileDialog.getSaveFileName(
        self,
        f"Save to {format_name}...",
        self.env + '/' + self.project_widget.base_file_name()
        + str_between(format_choose[0], '(', ')').split('*')[-1],
        ';;'.join(format_choose)
    )
    if file_name:
        suffix = str_between(suffix, '(', ')').split('*')[-1]
        logger.debug(f"Format: {suffix}")
        info = QFileInfo(file_name)
        if info.suffix().lower() != suffix[1:]:
            file_name += suffix
            info = QFileInfo(file_name)
            if info.isFile() and QMessageBox.question(
                self,
                "File exist",
                f"{file_name} already exists.\nDo you want to replace it?"
            ) == QMessageBox.No:
                return ""
        self.set_locate(info.absolutePath())
    return file_name

</t>
<t tx="leo.20231205084739.188">def input_from(
    self,
    format_name: str,
    format_choose: Sequence[str]
) -&gt; str:
    """Get external file name."""
    file_name, suffix = QFileDialog.getOpenFileName(
        self,
        f"Open {format_name}",
        self.env,
        ';;'.join(format_choose)
    )
    if file_name:
        self.set_locate(QFileInfo(file_name).absolutePath())
    return file_name

</t>
<t tx="leo.20231205084739.189">def input_from_multiple(
    self,
    format_name: str,
    format_choose: Sequence[str]
) -&gt; List[str]:
    """Get external file names."""
    file_names, suffix = QFileDialog.getOpenFileNames(
        self,
        f"Open {format_name} files ...",
        self.env,
        ';;'.join(format_choose)
    )
    if file_names:
        self.set_locate(QFileInfo(file_names[0]).absolutePath())
    return file_names

</t>
<t tx="leo.20231205084739.19">class Ui_Dialog(object):
    @others
</t>
<t tx="leo.20231205084739.190">def save_reply_box(self, title: str, file_name: str) -&gt; None:
    """Show message when successfully saved."""
    size = size_format(QFileInfo(file_name).size())
    QMessageBox.information(
        self,
        f"Initial Saved: {title}",
        f"Successfully saved:\n{file_name}\n"
        f"Size: {size}"
    )
    logger.info(f"Saved: [\"{file_name}\"] ({size})")

</t>
<t tx="leo.20231205084739.191">@Slot()
def save_pmks(self) -&gt; None:
    """Output to PMKS as URL."""
    url = "http://designengrlab.github.io/PMKS/pmks.html?mech="
    url_table = []
    for row in range(len(self.vpoint_list)):
        type_and_angle = self.entities_point.item(row, 2).text().split(':')
        point_data = [
            self.entities_point.item(row, 1).text(),
            type_and_angle[0],
            self.entities_point.item(row, 4).text(),
            self.entities_point.item(row, 5).text(),
        ]
        if len(type_and_angle) == 2:
            point_data.append(type_and_angle[1])
        point_data.append('tfff')
        url_table.append(','.join(point_data))
    url += '|'.join(url_table) + '|'
    text = '\n'.join((
        "Copy and past this link to web browser:\n",
        url + '\n',
        "If you have installed Microsoft Silverlight in "
        "Internet Explorer as default browser, "
        "just click \"Open\" button to open it in PMKS website."
    ))
    reply = QMessageBox.information(
        self,
        "PMKS web server",
        text,
        (QMessageBox.Save | QMessageBox.Open | QMessageBox.Close),
        QMessageBox.Save
    )
    if reply == QMessageBox.Open:
        self.__open_url(url)
    elif reply == QMessageBox.Save:
        QApplication.clipboard().setText(url)

</t>
<t tx="leo.20231205084739.192">@Slot(name='on_action_screenshot_triggered')
def save_picture_clipboard(self) -&gt; None:
    """Capture the canvas image to clipboard."""
    if self.prefer.grab_no_background_option:
        pixmap = self.main_canvas.grab_no_background()
    else:
        pixmap = self.main_canvas.grab()
    QApplication.clipboard().setPixmap(pixmap)
    QMessageBox.information(
        self,
        "Captured!",
        "Canvas widget picture is copy to clipboard."
    )

</t>
<t tx="leo.20231205084739.193">@Slot()
def show_expr(self) -&gt; None:
    """Output as expression."""
    dlg = ScriptDialog(
        QIcon(QPixmap("icons:id.png")),
        _PREFIX + f"\"{self.project_widget.base_file_name()}\"\n"
        + self.get_expression(indent=4),
        "Pyslvs expression",
        ["Text file (*.txt)"],
        self,
        compressed_script=self.get_expression().replace(", ", ",")
    )
    dlg.show()
    dlg.exec_()
    dlg.deleteLater()

</t>
<t tx="leo.20231205084739.194">@Slot()
def py_script(self) -&gt; None:
    """Output to Python script for Jupyter notebook."""
    dlg = ScriptDialog(
        QIcon(QPixmap("icons:script.png")),
        _PREFIX + f"\"{self.project_widget.base_file_name()}\"\n"
        + slvs_process_script(
            tuple(vpoint.expr() for vpoint in self.vpoint_list),
            tuple((b, d) for b, d, _ in self.inputs_widget.input_pairs())
        ),
        "Python script",
        ["Python3 Script (*.py)"],
        self,
        exprs=self.get_triangle().as_list()
    )
    dlg.show()
    dlg.exec_()
    dlg.deleteLater()

</t>
<t tx="leo.20231205084739.195">@Slot(name='on_action_check_update_triggered')
def __check_update(self) -&gt; None:
    """Check for update."""
    dlg = QProgressDialog("Checking update ...", "Cancel", 0, 3, self)
    dlg.setWindowTitle("Check for update")
    dlg.resize(400, dlg.height())
    dlg.setModal(True)
    dlg.show()
    url = check_update(dlg)
    dlg.deleteLater()
    if url:
        if QMessageBox.question(
            self,
            "Pyslvs has update",
            "Do you want to get it from Github?"
        ) == QMessageBox.Yes:
            self.__open_url(url)
    else:
        QMessageBox.information(
            self,
            "Pyslvs is up to date",
            "You are using the latest version of Pyslvs."
        )

</t>
<t tx="leo.20231205084739.196">@Slot(name='on_action_report_issue_triggered')
def __report_issue(self) -&gt; None:
    """Open website: Pyslvs issue page."""
    self.__open_url("https://github.com/KmolYuan/Pyslvs-UI/issues")

</t>
<t tx="leo.20231205084739.197">def check_file_changed(self) -&gt; bool:
    """If the user has not saved the change.

    Return True if user want to CANCEL the operation.
    """
    if not self.project_widget.changed():
        return False

    reply = QMessageBox.question(
        self,
        "Message",
        "Are you sure to quit?\nAny changes won't be saved.",
        (QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel),
        QMessageBox.Save
    )
    if reply == QMessageBox.Save:
        self.save()
        return self.project_widget.changed()
    elif reply == QMessageBox.Discard:
        return False
    return True

</t>
<t tx="leo.20231205084739.198">def restore_settings(self) -&gt; None:
    """Restore Pyslvs settings."""
    prefer = Preferences()
    for field in fields(prefer):  # type: Field
        setting = self.settings.value(field.name, field.default)
        setattr(prefer, field.name, setting)
    # Specified solver setting
    kernel = ARGUMENTS.kernel
    if kernel:
        if kernel == "python_solvespace":
            prefer.planar_solver_option = 1
        elif kernel == "sketch_solve":
            prefer.planar_solver_option = 2
        elif kernel == "pyslvs":
            prefer.planar_solver_option = 0
        else:
            QMessageBox.warning(
                self,
                "Kernel not found",
                f"No such kernel: {kernel}"
            )
    self.apply_preferences(prefer, force=True)

</t>
<t tx="leo.20231205084739.199">def save_settings(self) -&gt; None:
    """Save Pyslvs settings (auto save when close event)."""
    if self.prefer.not_save_option:
        f = QFile(self.settings.fileName())
        if f.exists():
            f.remove()
        return
    self.settings.setValue("ENV", self.env)
    for field in fields(self.prefer):  # type: Field
        self.settings.setValue(field.name, getattr(self.prefer, field.name))

</t>
<t tx="leo.20231205084739.2">class _NpImage(BaseImage):
    """NumPy image for QR code."""

    @others
</t>
<t tx="leo.20231205084739.20">def setupUi(self, Dialog):
    Dialog.setObjectName("Dialog")
    Dialog.setEnabled(True)
    Dialog.resize(533, 564)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:script.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Dialog.setWindowIcon(icon)
    Dialog.setAutoFillBackground(True)
    Dialog.setSizeGripEnabled(True)
    Dialog.setModal(True)
    self.main_layout = QtWidgets.QVBoxLayout(Dialog)
    self.main_layout.setObjectName("main_layout")
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.show_qrcode = QtWidgets.QPushButton(Dialog)
    self.show_qrcode.setAutoDefault(False)
    self.show_qrcode.setObjectName("show_qrcode")
    self.horizontalLayout.addWidget(self.show_qrcode)
    self.copy_btn = QtWidgets.QPushButton(Dialog)
    self.copy_btn.setContextMenuPolicy(QtCore.Qt.NoContextMenu)
    self.copy_btn.setAutoDefault(False)
    self.copy_btn.setObjectName("copy_btn")
    self.horizontalLayout.addWidget(self.copy_btn)
    spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout.addItem(spacerItem)
    self.btn_box = QtWidgets.QDialogButtonBox(Dialog)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.btn_box.sizePolicy().hasHeightForWidth())
    self.btn_box.setSizePolicy(sizePolicy)
    self.btn_box.setOrientation(QtCore.Qt.Horizontal)
    self.btn_box.setStandardButtons(QtWidgets.QDialogButtonBox.Close|QtWidgets.QDialogButtonBox.Save)
    self.btn_box.setObjectName("btn_box")
    self.horizontalLayout.addWidget(self.btn_box)
    self.main_layout.addLayout(self.horizontalLayout)

    self.retranslateUi(Dialog)
    self.btn_box.rejected.connect(Dialog.reject)
    QtCore.QMetaObject.connectSlotsByName(Dialog)

</t>
<t tx="leo.20231205084739.200">def load_from_args(self) -&gt; None:
    filepath = ARGUMENTS.filepath
    if not filepath:
        return
    suffix = QFileInfo(filepath).suffix().lower()
    if suffix == 'pyslvs':
        self.project_widget.read(filepath)
    elif suffix == 'slvs':
        self.__read_slvs(filepath)
    else:
        QMessageBox.warning(
            self,
            "Invalid file suffix",
            "Only support '*.pyslvs' or '*.slvs'."
        )

</t>
<t tx="leo.20231205084739.201">@Slot(int)
def command_reload(self, index: int) -&gt; None:
    """The time of withdrawal and redo action."""
    self.project_no_save()
    self.entities_point.clearSelection()
    self.inputs_widget.variable_reload()
    self.solve()

</t>
<t tx="leo.20231205084739.202">@Slot()
def show_overview(self) -&gt; None:
    """Show overview dialog."""
    dlg = OverviewDialog(
        self,
        self.project_widget.base_file_name(),
        self.get_expression(),
        self.get_storage(),
        [(b, d) for b, d, _ in self.inputs_widget.input_pairs()],
        self.inputs_widget.paths(),
        self.collections.collect_data(),
        self.collections.config_data(),
        self.optimizer.mechanism_data,
        self.project_widget.get_background_path()
    )
    dlg.show()
    dlg.exec_()
    dlg.deleteLater()
</t>
<t tx="leo.20231205084739.203">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/main_window/
# -*- coding: utf-8 -*-

"""This module contains the functions that main window needed."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import cast, Tuple, List, Sequence, Set, Dict, Union, Optional, Any
from math import radians, cos, sin
from abc import ABC, abstractmethod
from traceback import format_exc
from qtpy.QtCore import Slot
from pyslvs import (
    edges_view,
    graph2vpoints,
    t_config,
    get_vlinks,
    VJoint,
    VPoint,
    VLink,
    expr_solving,
    vpoint_dof,
    SolverSystem,
    EStack,
)
from pyslvs.graph import Graph
from pyslvs_ui.info import logger, HAS_SLVS, Kernel
from .entities import EntitiesMethodInterface

if HAS_SLVS:
    from python_solvespace import ResultFlag, Entity, SolverSystem as PySolver
_Coord = Tuple[float, float]
_Inputs = Dict[Tuple[int, int], float]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.204">def _offset(p: VPoint) -&gt; _Coord:
    """Make offset coordinate."""
    x = p.c[1, 0]
    y = p.c[1, 1]
    if p.has_offset() and p.true_offset() &lt;= 0.1:
        if p.offset() &gt; 0:
            x += 0.1
            y += 0.1
        else:
            x -= 0.1
            y -= 0.1
    return x, y


</t>
<t tx="leo.20231205084739.205">def _slvs_solve(
    vpoints: Sequence[VPoint],
    inputs: Dict[Tuple[int, int], float]
) -&gt; Tuple[List[Union[_Coord, Tuple[_Coord, _Coord]]], int]:
    """Use element module to convert into Solvespace expression."""
    if not vpoints:
        return [], 0
    # VLinks with strings
    vlinks = {}
    for vlink in get_vlinks(vpoints):
        vlinks[vlink.name] = vlink
    # Solvespace kernel
    sys = PySolver()
    sys.set_group(1)
    wp = sys.create_2d_base()
    origin_2d = sys.add_point_2d(0., 0., wp)
    sys.dragged(origin_2d, wp)
    origin_2d_p = sys.add_point_2d(10., 0., wp)
    sys.dragged(origin_2d_p, wp)
    hv = sys.add_line_2d(origin_2d, origin_2d_p, wp)
    sys.set_group(2)
    points: List[Entity] = []
    sliders: Dict[int, int] = {}
    slider_bases: List[Entity] = []
    slider_slots: List[Entity] = []
    for i, vpoint in enumerate(vpoints):
        if vpoint.no_link():
            x = vpoint.c[0, 0]
            y = vpoint.c[0, 1]
            point = sys.add_point_2d(x, y, wp)
            sys.dragged(point, wp)
            points.append(point)
            continue
        if vpoint.grounded():
            x = vpoint.c[0, 0]
            y = vpoint.c[0, 1]
            if vpoint.type in {VJoint.P, VJoint.RP}:
                sliders[i] = len(slider_bases)
                # Base point (slot) is fixed
                point = sys.add_point_2d(x, y, wp)
                sys.dragged(point, wp)
                slider_bases.append(point)
                # Slot point (slot) is movable
                x += cos(vpoint.angle)
                y += sin(vpoint.angle)
                slider_slots.append(sys.add_point_2d(x, y, wp))
                # Pin is movable
                x, y = _offset(vpoint)
                points.append(sys.add_point_2d(x, y, wp))
            else:
                point = sys.add_point_2d(x, y, wp)
                sys.dragged(point, wp)
                points.append(point)
            continue
        x = vpoint.c[0, 0]
        y = vpoint.c[0, 1]
        point = sys.add_point_2d(x, y, wp)
        if vpoint.type in {VJoint.P, VJoint.RP}:
            sliders[i] = len(slider_bases)
            # Base point (slot) is movable
            slider_bases.append(point)
            # Slot point (slot) is movable
            x += cos(vpoint.angle)
            y += sin(vpoint.angle)
            slider_slots.append(sys.add_point_2d(x, y, wp))
            if vpoint.pin_grounded():
                # Pin is fixed
                x = vpoint.c[1, 0]
                y = vpoint.c[1, 1]
                point = sys.add_point_2d(x, y, wp)
                sys.dragged(point, wp)
                points.append(point)
            else:
                # Pin is movable
                x, y = _offset(vpoint)
                points.append(sys.add_point_2d(x, y, wp))
            continue
        # Point is movable
        points.append(point)

    @others
    for a, b in sliders.items():
        # Base point
        vp1 = vpoints[a]
        p1 = points[a]
        # Base slot
        slider_slot = sys.add_line_2d(slider_bases[b], slider_slots[b], wp)
        if vp1.grounded():
            # Slot is grounded
            sys.angle(hv, slider_slot, vp1.angle, wp)
            sys.coincident(p1, slider_slot, wp)
            if vp1.has_offset():
                p2 = slider_bases[b]
                if vp1.offset():
                    sys.distance(p2, p1, vp1.offset(), wp)
                else:
                    sys.coincident(p2, p1, wp)
        else:
            # Slider between links
            for name in vp1.links[:1]:
                vlink = vlinks[name]
                ret = get_friend(vlink, a)
                if ret is None:
                    continue
                vp2, p2 = ret
                sys.angle(
                    slider_slot,
                    sys.add_line_2d(slider_bases[b], p2, wp),
                    vp1.slope_angle(vp2) - vp1.angle,
                    wp
                )
                sys.coincident(p1, slider_slot, wp)
                if vp1.has_offset():
                    p2 = slider_bases[b]
                    if vp1.offset():
                        sys.distance(p2, p1, vp1.offset(), wp)
                    else:
                        sys.coincident(p2, p1, wp)
            if vp1.type != VJoint.P:
                continue
            for name in vp1.links[1:]:
                vlink = vlinks[name]
                ret = get_friend(vlink, a)
                if ret is None:
                    continue
                vp2, p2 = ret
                sys.angle(
                    slider_slot,
                    sys.add_line_2d(p1, p2, wp),
                    vp1.slope_angle(vp2) - vp1.angle,
                    wp
                )
    for (b, d), angle in inputs.items():
        # The constraints of drive shaft
        # Simulate the input variables to the mechanism
        # The 'base points' are shaft center
        if b == d:
            continue
        vp1 = vpoints[b]
        if vp1.type == VJoint.R:
            p1 = points[b]
        else:
            p1 = slider_bases[sliders[b]]
        angle = radians(angle)
        p2 = sys.add_point_2d(vp1.cx + cos(angle), vp1.cy + sin(angle), wp)
        sys.dragged(p2, wp)
        # The virtual link that dragged by "hand".
        leader = sys.add_line_2d(p1, p2, wp)
        # Make another virtual link that should follow "hand".
        vp2 = vpoints[d]
        if vp2.type == VJoint.R:
            p2 = points[d]
        else:
            p2 = slider_bases[sliders[d]]
        link = sys.add_line_2d(p1, p2, wp)
        sys.angle(link, leader, 0.5, wp)
    # Solve
    result_flag = sys.solve()
    if result_flag == ResultFlag.OKAY:
        result_list: List[Union[_Coord, Tuple[_Coord, _Coord]]] = []
        for i, vpoint in enumerate(vpoints):
            p1 = points[i]
            x1, y1 = sys.params(p1.params)
            if vpoint.type == VJoint.R:
                result_list.append((x1, y1))
            else:
                p2 = slider_bases[sliders[i]]
                x2, y2 = sys.params(p2.params)
                result_list.append(((x2, y2), (x1, y1)))
        return result_list, sys.dof()
    if result_flag == ResultFlag.INCONSISTENT:
        error = "inconsistent"
    elif result_flag == ResultFlag.DIDNT_CONVERGE:
        error = "didn't converge"
    else:
        error = "too many unknowns"
    raise ValueError(f"{error}: {sys.failures()}\n{sys.constraints()}")


</t>
<t tx="leo.20231205084739.206">def pick_slider(i1: int, i2: int) -&gt; Tuple[Entity, Entity, float]:
    n1 = vpoints[i1]
    n2 = vpoints[i2]
    if n1.is_slot_link(vlink.name):
        e1 = slider_bases[sliders[i1]]
    else:
        e1 = points[i1]
    if n2.is_slot_link(vlink.name):
        e2 = slider_bases[sliders[i2]]
    else:
        e2 = points[i2]
    return e1, e2, n1.distance(n2)

</t>
<t tx="leo.20231205084739.207">for vlink in vlinks.values():
    if len(vlink.points) &lt; 2:
        continue
    if vlink.name == VLink.FRAME:
        continue
    a = vlink.points[0]
    b = vlink.points[1]
    p1, p2, d = pick_slider(a, b)
    sys.distance(p1, p2, d, wp)
    for c in vlink.points[2:]:
        for d in (a, b):
            p1, p2, x = pick_slider(c, d)
            sys.distance(p1, p2, x, wp)

</t>
<t tx="leo.20231205084739.208">def get_friend(group: VLink, base: int) -&gt; Optional[Tuple[VPoint, Entity]]:
    """Get friend for slider."""
    # A base link friend
    index = group.points[0]
    if index == base:
        if len(group.points) &lt; 2:
            # If no any friend
            return None
        index = group.points[1]
    vp = vpoints[index]
    if vp.is_slot_link(group.name):
        # c is a slider, and it is be connected with slot link.
        return vp, slider_bases[sliders[index]]
    else:
        # c is a R joint or it is not connected with slot link
        return vp, points[index]

</t>
<t tx="leo.20231205084739.209">class SolverMethodInterface(EntitiesMethodInterface, ABC):
    """Abstract class for solver methods."""

    @others
</t>
<t tx="leo.20231205084739.21">def retranslateUi(self, Dialog):
    _translate = QtCore.QCoreApplication.translate
    self.show_qrcode.setText(_translate("Dialog", "Show QR code"))
    self.copy_btn.setText(_translate("Dialog", "Copy"))
    self.btn_box.setWhatsThis(_translate("Dialog", "Click to exit"))
</t>
<t tx="leo.20231205084739.210">@abstractmethod
def __init__(self):
    super(SolverMethodInterface, self).__init__()
    self.__dof = 0

</t>
<t tx="leo.20231205084739.211">def get_back_position(self) -&gt; None:
    """Make current position back."""
    self.entities_point.get_back_position()
    for vpoint in self.vpoint_list:
        vpoint.move((vpoint.x, vpoint.y))

</t>
<t tx="leo.20231205084739.212">def solve(self) -&gt; None:
    """Resolve coordinates and preview path."""
    self.resolve()
    self.main_canvas.update_preview_path()

</t>
<t tx="leo.20231205084739.213">@Slot()
def resolve(self) -&gt; None:
    """Resolve: Using three libraries to solve the system.

    + Pyslvs
    + Python-Solvespace
    + Sketch Solve
    """
    for b, d, a in self.inputs_widget.input_pairs():
        if b == d:
            self.vpoint_list[b].set_offset(a)
    solve_kernel = self.prefer.planar_solver_option
    input_pair = {(b, d): a for b, d, a in self.inputs_widget.input_pairs()}
    try:
        if solve_kernel == Kernel.PYSLVS:
            result = expr_solving(
                self.get_triangle(),
                self.vpoint_list,
                input_pair
            )
        elif solve_kernel == Kernel.SOLVESPACE:
            result, _ = _slvs_solve(
                self.vpoint_list,
                input_pair if not self.free_move_btn.isChecked() else {}
            )
        elif solve_kernel == Kernel.SKETCH_SOLVE:
            result = SolverSystem(self.vpoint_list, input_pair).solve()
        else:
            raise ValueError("incorrect kernel")
    except ValueError as error:
        # Error: Show warning without update data.
        if self.prefer.console_error_option:
            logger.warn(format_exc())
        error_text = f"Error: {error}"
        self.conflict.setToolTip(error_text)
        self.conflict.setStatusTip(error_text)
        self.conflict.setVisible(True)
        self.dof_view.setVisible(False)
    else:
        self.entities_point.update_current_position(result)
        for i, c in enumerate(result):
            if isinstance(c[0], float):
                self.vpoint_list[i].move(c)
            else:
                c1, c2 = c
                self.vpoint_list[i].move(c1, c2)
        self.__dof = vpoint_dof(self.vpoint_list)
        self.dof_view.setText(
            f"{self.__dof} ({self.inputs_widget.input_count()})")
        self.conflict.setVisible(False)
        self.dof_view.setVisible(True)
    self.reload_canvas()

</t>
<t tx="leo.20231205084739.214">def preview_path(
    self,
    auto_preview: List[List[Tuple[float, float]]],
    slider_auto_preview: Dict[int, List[Tuple[float, float]]],
    vpoints: Sequence[VPoint]
):
    """Resolve auto preview path."""
    auto_preview.clear()
    slider_auto_preview.clear()
    if not self.right_input():
        return
    vpoints = tuple(vpoint.copy() for vpoint in vpoints)
    solve_kernel = self.prefer.path_preview_option
    if solve_kernel == Kernel.SAME_AS_SOLVING:
        solve_kernel = self.prefer.planar_solver_option
    interval = self.inputs_widget.interval()
    # path: [[p]: ((x0, y0), (x1, y1), (x2, y2), ...), ...]
    for i, vpoint in enumerate(vpoints):
        auto_preview.append([])
        if vpoint.type in {VJoint.P, VJoint.RP}:
            slider_auto_preview[i] = []
    input_pair = {(b, d): a for b, d, a in self.inputs_widget.input_pairs()}
    # Cumulative angle
    angles_cum = dict.fromkeys(input_pair, 0.)
    nan = float('nan')
    for dp in input_pair:
        for interval in (interval, -interval):
            while 0 &lt;= angles_cum[dp] &lt;= 360:
                try:
                    if solve_kernel == Kernel.PYSLVS:
                        result = expr_solving(
                            self.get_triangle(vpoints),
                            vpoints,
                            input_pair
                        )
                    elif solve_kernel == Kernel.SOLVESPACE:
                        result, _ = _slvs_solve(
                            vpoints,
                            {}
                            if self.free_move_btn.isChecked() else
                            input_pair
                        )
                    elif solve_kernel == Kernel.SKETCH_SOLVE:
                        result = SolverSystem(vpoints, input_pair).solve()
                    else:
                        raise ValueError("incorrect kernel")
                except ValueError:
                    # Update with error sign
                    for i in range(len(vpoints)):
                        auto_preview[i].append((nan, nan))
                    # Back to last feasible solution
                    input_pair[dp] -= interval
                    break
                # Update with result
                for i, vpoint in enumerate(vpoints):
                    if vpoint.type == VJoint.R:
                        auto_preview[i].append(cast(_Coord, result[i]))
                        vpoint.move(cast(_Coord, result[i]))
                    elif vpoint.type in {VJoint.P, VJoint.RP}:
                        slot, pin = cast(Tuple[_Coord, _Coord], result[i])
                        # Pin path
                        auto_preview[i].append(pin)
                        # Slot path
                        slider_auto_preview[i].append(slot)
                        vpoint.move(slot, pin)
                angles_cum[dp] += abs(interval)
                input_pair[dp] += interval
                input_pair[dp] %= 360
    for path in auto_preview:
        path[:] = path[:-1]

</t>
<t tx="leo.20231205084739.215">def get_graph(self) -&gt; Tuple[
    Graph,
    List[int],
    List[Tuple[int, int]],
    Dict[int, Tuple[float, float]],
    Dict[int, int],
    Dict[int, int]
]:
    """Generalization Algorithm

    Return edges data, grounded list, variable list and multiple joints.
    VLinks will become graph vertices.
    """
    link_names = [vlink.name for vlink in self.vlink_list]
    input_pair = set()
    for b, d, _ in self.inputs_widget.input_pairs():
        input_pair.update({b, d})
    # links name for RP joint
    k = len(self.vlink_list)
    graph = Graph([])
    grounded_list = []
    pos = {}
    same = {}
    used_point: Set[int] = set()
    mapping = {}
    # Link names will change to index number
    for i, vlink in enumerate(self.vlink_list):
        for p in vlink.points:
            if p in used_point:
                continue
            vpoint = self.vpoint_list[p]
            base_num = len(graph.edges)
            mapping[p] = base_num
            pos[base_num] = (vpoint.x, vpoint.y)
            for link_name in vpoint.links:
                if vlink.name == link_name:
                    continue
                m = link_names.index(link_name)
                grounded = VLink.FRAME in {vlink.name, link_name}
                ref_num = len(graph.edges)
                if ref_num != base_num:
                    pos[ref_num] = (vpoint.x, vpoint.y)
                if vpoint.type == VJoint.RP:
                    graph.add_edge(i, k)
                    if grounded:
                        grounded_list.append(len(graph.edges))
                    graph.add_edge(k, m)
                    k += 1
                else:
                    if ref_num != base_num:
                        same[ref_num] = base_num
                    graph.add_edge(i, m)
                if grounded and ref_num not in same:
                    grounded_list.append(ref_num)
            used_point.add(p)
    counter = len(graph.edges)
    cus = {}
    for vpoint in self.vpoint_list:
        if len(vpoint.links) == 1:
            cus[counter] = link_names.index(vpoint.links[0])
            counter += 1
    return (
        graph,
        grounded_list,
        [(mapping[b], mapping[d])
         for b, d, _ in self.inputs_widget.input_pairs()],
        pos,
        cus,
        same,
    )

</t>
<t tx="leo.20231205084739.216">def get_configure(self) -&gt; Dict[str, Any]:
    """Return collection data.

    + Expression
    + input
    + Graph
    + Placement
    + Target
    + cus
    + same
    """
    for vpoint in self.vpoint_list:
        if vpoint.type in {VJoint.P, VJoint.RP}:
            raise ValueError("not support for prismatic joint yet")
    graph, grounded_list, input_list, pos, cus, same = self.get_graph()
    links: List[Set[int]] = [set() for _ in range(len(graph.vertices))]
    for joint, pair in edges_view(graph):
        for node in pair:
            links[node].add(joint)
    placement = set(grounded_list)
    for row, link in enumerate(links):
        if placement == link - set(same):
            grounded = row
            break
    else:
        raise ValueError("no grounded link")
    vpoints = graph2vpoints(graph, pos, cus, same, grounded)
    return {
        'expression': self.get_expression(vpoints),
        'input': input_list,
        'graph': graph.edges,
        'placement': {p: None for p in grounded_list},
        'target': {p: None for p in cus},
        'cus': cus,
        'same': same,
    }

</t>
<t tx="leo.20231205084739.217">def get_triangle(
    self,
    vpoints: Optional[Sequence[VPoint]] = None
) -&gt; EStack:
    """Update triangle expression here.

    Special function for VPoints.
    """
    if vpoints is None:
        vpoints = self.vpoint_list
    status: Dict[int, bool] = {}
    exprs = t_config(
        vpoints,
        [(b, d) for b, d, _ in self.inputs_widget.input_pairs()],
        status
    )
    self.entities_expr.set_expr(exprs, tuple(p for p, s in status.items()
                                             if not s))
    return exprs

</t>
<t tx="leo.20231205084739.218">def right_input(self) -&gt; bool:
    """Is input same as DOF?"""
    inputs = self.inputs_widget.input_count() == self.__dof
    if not inputs:
        self.entities_expr.clear()
    return inputs

</t>
<t tx="leo.20231205084739.219">def reload_canvas(self) -&gt; None:
    """Update main canvas data, without resolving."""
    paths, slider_paths = self.inputs_widget.current_path()
    self.main_canvas.update_canvas(
        self.get_triangle().as_list(),
        paths,
        slider_paths
    )

</t>
<t tx="leo.20231205084739.22">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/
# -*- coding: utf-8 -*-

"""'io' module contains Pyslvs IO and undo redo functions."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from .script import ScriptDialog, slvs_process_script
from .slvs import SlvsParser
from .output_option import SlvsOutputDialog, DxfOutputDialog, OutputDialog
from .overview import OverviewDialog
from .project import ProjectWidget, ProjectFormat
from .preferences import PreferencesDialog


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.220">def dof(self) -&gt; int:
    """Return DOF."""
    return self.__dof
</t>
<t tx="leo.20231205084739.221">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/main_window/
# -*- coding: utf-8 -*-

"""This module contains the functions that main window needed."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Sequence, Dict, Mapping, Optional
from abc import ABC
from qtpy.QtCore import Slot
from qtpy.QtWidgets import (
    QApplication,
    QListWidgetItem,
    QInputDialog,
    QMessageBox,
)
from pyslvs import parse_params, VPoint
from pyslvs_ui.widgets import (
    AddStorage,
    DeleteStorage,
    AddStorageName,
    ClearStorageName,
)
from pyslvs_ui.info import logger
from .solver import SolverMethodInterface


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.222">class StorageMethodInterface(SolverMethodInterface, ABC):
    """Abstract class for storage methods."""

    @others
</t>
<t tx="leo.20231205084739.223">def __add_storage(self, name: str, expr: str) -&gt; None:
    """Add storage data function."""
    self.cmd_stack.push(AddStorage(
        name,
        self.mechanism_storage,
        expr
    ))

</t>
<t tx="leo.20231205084739.224">@Slot(name='on_mechanism_storage_add_clicked')
def __add_current_storage(self) -&gt; None:
    name = (
        self.mechanism_storage_name_tag.text()
        or self.mechanism_storage_name_tag.placeholderText()
    )
    self.cmd_stack.beginMacro(f"Add {{Mechanism: {name}}}")
    self.__add_storage(name, self.get_expression())
    self.cmd_stack.push(ClearStorageName(self.mechanism_storage_name_tag))
    self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.225">@Slot(name='on_mechanism_storage_copy_clicked')
def __copy_storage(self) -&gt; None:
    """Copy the expression from a storage data."""
    item = self.mechanism_storage.currentItem()
    if item:
        QApplication.clipboard().setText(item.expr)

</t>
<t tx="leo.20231205084739.226">@Slot(name='on_mechanism_storage_paste_clicked')
def __paste_storage(self) -&gt; None:
    """Add the storage data from string."""
    expr, ok = QInputDialog.getMultiLineText(
        self,
        "Storage",
        "Please input expression:"
    )
    if not ok:
        return
    self.ask_add_storage(expr)

</t>
<t tx="leo.20231205084739.227">def ask_add_storage(self, expr: str) -&gt; bool:
    try:
        # Put the expression into parser to see if it is legal
        parse_params(expr)
    except Exception as error:
        logger.warn(error)
        QMessageBox.warning(
            self,
            "Loading failed",
            "Your expression is in an incorrect format."
        )
        return False
    name, ok = QInputDialog.getText(
        self,
        "Storage",
        "Please input name tag:"
    )
    if not ok:
        return False
    name_list = [
        self.mechanism_storage.item(i).text()
        for i in range(self.mechanism_storage.count())
    ]
    i = 0
    name = name or f"Prototype_{i}"
    while name in name_list:
        name = f"Prototype_{i}"
        i += 1
    self.__add_storage(name, expr)
    return True

</t>
<t tx="leo.20231205084739.228">@Slot(name='on_mechanism_storage_delete_clicked')
def __delete_storage(self) -&gt; None:
    """Delete the storage data."""
    row = self.mechanism_storage.currentRow()
    if not row &gt; -1:
        return
    self.cmd_stack.push(DeleteStorage(row, self.mechanism_storage))

</t>
<t tx="leo.20231205084739.229">@Slot(name='on_mechanism_storage_restore_clicked')
@Slot(QListWidgetItem, name='on_mechanism_storage_itemDoubleClicked')
def __restore_storage(self, item: Optional[QListWidgetItem] = None) -&gt; None:
    """Restore the storage data."""
    if item is None:
        item = self.mechanism_storage.currentItem()
    if not item:
        return

    if QMessageBox.question(
        self,
        "Storage",
        "Restore mechanism will overwrite the canvas.\n"
        "Do you want to continue?"
    ) != QMessageBox.Yes:
        return

    name = item.text()
    self.cmd_stack.beginMacro(f"Restore from {{Mechanism: {name}}}")

    # Clean all the item of two table widgets
    for i in range(self.entities_point.rowCount()):
        self.delete_point(0)
    for i in range(self.entities_link.rowCount() - 1):
        self.delete_link(1)

    self.parse_expression(item.expr)
    self.cmd_stack.push(DeleteStorage(
        self.mechanism_storage.row(item),
        self.mechanism_storage
    ))
    self.cmd_stack.push(AddStorageName(name, self.mechanism_storage_name_tag))
    self.cmd_stack.endMacro()
    self.main_canvas.zoom_to_fit()

</t>
<t tx="leo.20231205084739.23">def str_between(s: str, front: str, back: str) -&gt; str:
    """Get from parenthesis."""
    return s[(s.find(front) + 1):s.find(back)]


</t>
<t tx="leo.20231205084739.230">def get_storage(self) -&gt; Mapping[str, str]:
    """Get storage data."""
    storage: Dict[str, str] = {}
    for row in range(self.mechanism_storage.count()):
        item: QListWidgetItem = self.mechanism_storage.item(row)
        storage[item.text()] = item.expr
    return storage

</t>
<t tx="leo.20231205084739.231">def add_multiple_storage(self, exprs: Mapping[str, str]) -&gt; None:
    """Add storage data from database."""
    for name, expr in exprs.items():
        self.__add_storage(name, expr)

</t>
<t tx="leo.20231205084739.232">def get_expression(
    self,
    points: Optional[Sequence[VPoint]] = None,
    indent: int = -1
) -&gt; str:
    """Get current mechanism expression."""
    if points is None:
        points = self.vpoint_list
    if not points:
        return "M[]"
    sep = ",\n" if indent &gt; 0 else ", "
    head = "M["
    end = "]"
    if indent &gt; 0:
        head += '\n'
        end = '\n' + end
    return head + sep.join(" " * indent + p.expr() for p in points) + end
</t>
<t tx="leo.20231205084739.233">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/main_window/
# -*- coding: utf-8 -*-

"""'main_window' module contains the methods of main window.

Abstract classes (ordered):
+ MainWindowBase (imported from pyslvs_ui.widget.custom)
+ EntitiesMethodInterface (entities)
+ SolverMethodInterface (solver)
+ StorageMethodInterface (storage)
+ ActionMethodInterface (actions)
+ IOMethodInterface (io)
"""

from __future__ import annotations

__all__ = ['MainWindow']
__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Tuple, Sequence
from qtpy.QtCore import Slot
from qtpy.QtWidgets import QMessageBox, QInputDialog
from qtpy.QtGui import QTextCursor, QCloseEvent
from pyslvs_ui.info import XStream, logger
from .io import IOMethodInterface


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.234">class MainWindow(IOMethodInterface):
    """The main window of Pyslvs.

    Inherited from QMainWindow.
    Exit with QApplication.

    The main window is so much method that was been split it
    to wrapper function in 'main_window' module.
    """

    @others
</t>
<t tx="leo.20231205084739.235">def __init__(self):
    """Notes:

    + Input command line arguments object from Python parser.
    + Command line arguments excluding any Qt startup option.
    + Start main window with no parent.
    """
    super(MainWindow, self).__init__()
    self.restore_settings()

    # Start first solve function calling
    self.solve()
    # Load project from argument
    self.load_from_args()

</t>
<t tx="leo.20231205084739.236">@staticmethod
@Slot()
def new() -&gt; MainWindow:
    """Create a new main window."""
    m = MainWindow()
    m.show()
    m.main_canvas.zoom_to_fit()
    return m

</t>
<t tx="leo.20231205084739.237">def closeEvent(self, event: QCloseEvent) -&gt; None:
    """Close event to avoid user close the window accidentally."""
    if self.check_file_changed():
        event.ignore()
        return
    if self.inputs_widget.inputs_play_shaft.isActive():
        self.inputs_widget.inputs_play_shaft.stop()
    self.save_settings()
    XStream.back()
    logger.info("Exit")
    event.accept()

</t>
<t tx="leo.20231205084739.238">@Slot(int, name='on_zoom_bar_valueChanged')
def __set_zoom(self, value: int) -&gt; None:
    """Reset the text when zoom bar changed."""
    self.zoom_btn.setText(f'{value}px')

</t>
<t tx="leo.20231205084739.239">@Slot(name='on_zoom_cus_btn_clicked')
def __customize_zoom(self) -&gt; None:
    """Customize zoom value."""
    value, ok = QInputDialog.getInt(
        self,
        "Zooming",
        "Enter a zoom value: (px)",
        self.zoom_bar.value(),
        self.zoom_bar.minimum(),
        self.zoom_bar.maximum(),
        10
    )
    if ok:
        self.zoom_bar.setValue(value)

</t>
<t tx="leo.20231205084739.24">def str_before(s: str, front: str) -&gt; str:
    """Get from parenthesis."""
    return s[:s.find(front)]
</t>
<t tx="leo.20231205084739.240">@Slot(name='on_reset_canvas_btn_clicked')
def __reset_zoom(self) -&gt; None:
    """Reset to default zoom."""
    self.main_canvas.zoom_to_fit()

</t>
<t tx="leo.20231205084739.241">@Slot(bool, name='on_action_show_dimensions_toggled')
def __set_show_dimensions(self, toggled: bool) -&gt; None:
    """If turn on dimension labels, turn on the point marks."""
    if toggled:
        self.action_show_point_mark.setChecked(True)

</t>
<t tx="leo.20231205084739.242">@Slot(bool, name='on_action_show_point_mark_toggled')
def __set_show_point_mark(self, toggled: bool) -&gt; None:
    """If no point marks, turn off the dimension labels."""
    if not toggled:
        self.action_show_dimensions.setChecked(False)

</t>
<t tx="leo.20231205084739.243">@Slot(name='on_action_path_style_triggered')
def __set_curve_mode(self) -&gt; None:
    """Set path style as curve (true) or dots (false)."""
    self.main_canvas.set_curve_mode(self.action_path_style.isChecked())

</t>
<t tx="leo.20231205084739.244">@Slot(int, name='on_main_panel_currentChanged')
@Slot(int, name='on_synthesis_tab_widget_currentChanged')
def __set_show_target_path(self, _=None) -&gt; None:
    """Dimensional synthesis information will show on the canvas."""
    self.main_canvas.set_show_target_path(
        self.main_panel.currentWidget() is self.synthesis_tab
        and self.synthesis_tab_widget.currentWidget() is self.optimizer
    )

</t>
<t tx="leo.20231205084739.245">def add_target_point(self) -&gt; None:
    """Use context menu to add a target path coordinate."""
    self.optimizer.add_point(self.mouse_pos_x, self.mouse_pos_y)

</t>
<t tx="leo.20231205084739.246">def merge_result(
    self,
    expr: str,
    path: Sequence[Sequence[Tuple[float, float]]]
) -&gt; None:
    """Merge result function of dimensional synthesis."""
    if not self.ask_add_storage(expr):
        return
    # Add the path
    i = 0
    while f"Mechanism {i}" in self.inputs_widget.paths():
        i += 1
    if path:
        self.inputs_widget.add_path(f"Mechanism {i}", path, {})

</t>
<t tx="leo.20231205084739.247">@Slot(name='on_console_connect_btn_clicked')
def console_connect(self) -&gt; None:
    """Turn the OS command line (stdout) log to console."""
    logger.info("Connect to GUI console.")
    XStream.stdout().message_written.connect(self.__append_to_console)
    self.console_connect_btn.setEnabled(False)
    self.console_disconnect_btn.setEnabled(True)
    logger.info("Connect to GUI console.")

</t>
<t tx="leo.20231205084739.248">@Slot(name='on_console_disconnect_btn_clicked')
def console_disconnect(self) -&gt; None:
    """Turn the console log to OS command line (stdout)."""
    logger.info("Disconnect from GUI console.")
    XStream.back()
    self.console_connect_btn.setEnabled(True)
    self.console_disconnect_btn.setEnabled(False)
    logger.info("Disconnect from GUI console.")

</t>
<t tx="leo.20231205084739.249">@Slot(str)
def __append_to_console(self, log: str) -&gt; None:
    """After inserted the text, move cursor to end."""
    self.console_widget_browser.moveCursor(QTextCursor.End)
    self.console_widget_browser.insertPlainText(log)
    self.console_widget_browser.moveCursor(QTextCursor.End)

</t>
<t tx="leo.20231205084739.25"></t>
<t tx="leo.20231205084739.250">@Slot(bool, name='on_action_full_screen_toggled')
def __full_screen(self, full_screen: bool) -&gt; None:
    """Show full screen or not."""
    if full_screen:
        self.showFullScreen()
    else:
        self.showMaximized()

</t>
<t tx="leo.20231205084739.251">@Slot(name='on_action_about_qt_triggered')
def __about_qt(self) -&gt; None:
    """Open Qt about."""
    QMessageBox.aboutQt(self)
</t>
<t tx="leo.20231205084739.252"></t>
<t tx="leo.20231205084739.253">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/
# -*- coding: utf-8 -*-

"""Thread of synthesis process."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from abc import abstractmethod
from qtpy.QtCore import Slot, QThread
from qtpy.QtWidgets import QWidget
from pyslvs_ui.qt_patch import QABCMeta


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.254">class BaseThread(QThread, metaclass=QABCMeta):
    """Base thread of Cython functions."""

    @others
</t>
<t tx="leo.20231205084739.255">@abstractmethod
def __init__(self, parent: QWidget):
    super(BaseThread, self).__init__(parent)
    self.finished.connect(self.deleteLater)
    self.is_stop = False

</t>
<t tx="leo.20231205084739.256">@Slot()
def stop(self) -&gt; None:
    """Stop the algorithm."""
    self.is_stop = True
</t>
<t tx="leo.20231205084739.257">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/
# -*- coding: utf-8 -*-

"""'synthesis' module contains synthesis functional interfaces."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from .collections import Collections, CollectionsDialog, ConfigureWidget
from .structure_synthesis import StructureSynthesis
from .dimensional_synthesis import Optimizer
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.258"></t>
<t tx="leo.20231205084739.259">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/collections/
# -*- coding: utf-8 -*-

"""The widget of 'Triangular iteration' tab."""

from __future__ import annotations

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import (
    TYPE_CHECKING, List, Tuple, Sequence, Dict, Mapping, Callable, Optional,
    Any,
)
from math import hypot
import pprint
from qtpy.QtCore import Signal, Slot
from qtpy.QtWidgets import (
    QWidget,
    QMessageBox,
    QInputDialog,
    QListWidgetItem,
    QLabel,
    QApplication,
)
from qtpy.QtGui import QMouseEvent
from pyslvs import edges_view, graph2vpoints, parse_pos
from pyslvs.graph import Graph
from pyslvs_ui.graphics import PreviewCanvas
from .dialogs import CollectionsDialog, CustomsDialog, TargetsDialog, list_texts
from .configure_widget_ui import Ui_Form

if TYPE_CHECKING:
    from pyslvs_ui.widgets.main_base import MainWindowBase

_Coord = Tuple[float, float]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.26">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/slvs/
# -*- coding: utf-8 -*-

"""Solvespace format output as frame sketch."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Tuple, Sequence, Iterable, Callable, List
from pyslvs import VPoint
from .write import SlvsWriter2


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.260">class _ConfigureCanvas(PreviewCanvas):
    """Customized preview window has some functions of mouse interaction.

    Emit signal call to change current point when pressed a dot.
    """
    edit_size = 1000
    set_joint_number = Signal(int)

    @others
</t>
<t tx="leo.20231205084739.261">def __init__(self, parent: ConfigureWidget):
    """Add a function use to get current point from parent."""
    super(_ConfigureCanvas, self).__init__(parent)
    self.pressed = False
    self.get_joint_number = parent.joint_name.currentIndex

</t>
<t tx="leo.20231205084739.262">def mousePressEvent(self, event: QMouseEvent) -&gt; None:
    """Check if get close to a joint."""
    mx = (event.x() - self.ox) / self.zoom
    my = (event.y() - self.oy) / -self.zoom
    for node, (x, y) in self.pos.items():
        if node in self.same:
            continue
        if hypot(x - mx, y - my) &lt;= 5:
            self.set_joint_number.emit(node)
            self.pressed = True
            break

</t>
<t tx="leo.20231205084739.263">def mouseReleaseEvent(self, event: QMouseEvent) -&gt; None:
    """Cancel the drag."""
    self.pressed = False

</t>
<t tx="leo.20231205084739.264">def mouseMoveEvent(self, event: QMouseEvent) -&gt; None:
    """Drag to move the joint."""
    if not self.pressed:
        return
    row = self.get_joint_number()
    if not row &gt; -1:
        return
    mx = (event.x() - self.ox) / self.zoom
    my = (event.y() - self.oy) / -self.zoom
    hv = _ConfigureCanvas.edit_size / 2
    if -hv &lt;= mx &lt;= hv:
        self.pos[row] = (mx, self.pos[row][1])
    else:
        if -hv &lt;= mx:
            x = hv
        else:
            x = -hv
        self.pos[row] = (x, self.pos[row][1])
    if -hv &lt;= my &lt;= hv:
        self.pos[row] = (self.pos[row][0], my)
    else:
        if -hv &lt;= my:
            y = hv
        else:
            y = -hv
        self.pos[row] = (self.pos[row][0], y)
    self.update()


</t>
<t tx="leo.20231205084739.265">def _set_warning(label: QLabel, warning: bool) -&gt; None:
    """Show a warning sign front of label."""
    warning_icon = "&lt;img width=\"15\" src=\"icons:warning.png\"/&gt; "
    label.setText(label.text().replace(warning_icon, ''))
    if warning:
        label.setText(warning_icon + label.text())


</t>
<t tx="leo.20231205084739.266">class ConfigureWidget(QWidget, Ui_Form):
    """Configure widget.

    This interface use to modify structure profile.
    """
    collections: Dict[str, Dict[str, Any]]
    configure_canvas: _ConfigureCanvas

    @others
</t>
<t tx="leo.20231205084739.267">def __init__(
    self,
    add_collection: Callable[[Sequence[Tuple[int, int]]], None],
    parent: MainWindowBase
):
    """We need some function from structure collections."""
    super(ConfigureWidget, self).__init__(parent)
    self.setupUi(self)
    self.project_no_save = parent.project_no_save
    self.get_configure = parent.get_configure
    self.add_collection = add_collection
    self.prefer = parent.prefer
    self.get_expression = parent.get_expression
    # Iteration data
    self.collections = {}
    # Customized preview canvas
    self.configure_canvas = _ConfigureCanvas(self)
    self.configure_canvas.set_joint_number.connect(
        self.joint_name.setCurrentIndex
    )
    self.main_layout.insertWidget(0, self.configure_canvas)
    self.main_splitter.setSizes([300, 300])
    self.__clear_panel()

</t>
<t tx="leo.20231205084739.268">def add_collections(self,
                    collections: Mapping[str, Mapping[str, Any]]) -&gt; None:
    """Update the new collections."""
    self.collections.update({n: dict(d) for n, d in collections.items()})

</t>
<t tx="leo.20231205084739.269">def clear(self) -&gt; None:
    """Clear all sub-widgets."""
    self.collections.clear()
    self.__clear_panel()

</t>
<t tx="leo.20231205084739.27">def slvs2_frame(
    vpoints: Sequence[VPoint],
    v_to_slvs: Callable[[], Iterable[Tuple[int, int]]],
    file_name: str
):
    """Generate frame sketch, ignore all points that was no any connection."""
    edges = tuple(v_to_slvs())

    # Writer object
    writer = SlvsWriter2()

    # Add "Param"
    for i, edge in enumerate(edges):
        writer.param_num += 0x10
        for p in edge:
            writer.param_val(writer.param_num, vpoints[p].cx)
            writer.param_num += 1
            writer.param_val(writer.param_num, vpoints[p].cy)
            writer.param_num += 2
        writer.param_shift16()

    # Add "Request"
    for _ in range(len(edges)):
        writer.request_line(writer.request_num)
        writer.request_num += 1

    # The number of same points
    point_num: List[List[int]] = [[] for _ in range(len(vpoints))]
    # The number of same lines
    line_num: List[List[int]] = [[] for _ in range(len(edges))]

    # Add "Entity"
    for i, edge in enumerate(edges):
        writer.entity_line(writer.entity_num)
        for p in edge:
            writer.entity_num += 1
            point_num[p].append(writer.entity_num)
            writer.entity_point_2d(writer.entity_num, vpoints[p].cx, vpoints[p].cy)
            line_num[i].append(writer.entity_num)
        writer.entity_shift16()

    # Add "Constraint
    # Same point constraint
    for ps in point_num:
        for p in ps[1:]:
            writer.constraint_point(writer.constraint_num, ps[0], p)
            writer.constraint_num += 1
    # Position constraint
    for i, vpoint in enumerate(vpoints):
        if "ground" in vpoint.links and point_num[i]:
            writer.constraint_grounded(writer.constraint_num, point_num[i][0], vpoint.cx, vpoint.cy)
            writer.constraint_num += 2
    # Distance constraint
    for i, (n1, n2) in enumerate(line_num):
        p1, p2 = edges[i]
        writer.constraint_distance(writer.constraint_num, n1, n2, vpoints[p1].distance(vpoints[p2]))
        writer.constraint_num += 1
    # Comment constraint
    for i, vpoint in enumerate(vpoints):
        writer.constraint_comment(writer.constraint_num, f"Point{i}", vpoint.cx, vpoint.cy)
        writer.constraint_num += 1

    # Write file
    writer.save(file_name)
</t>
<t tx="leo.20231205084739.270">def __clear_panel(self) -&gt; None:
    """Clear the settings of sub-widgets."""
    self.profile_name.clear()
    self.configure_canvas.clear()
    self.joint_name.clear()
    self.grounded_list.clear()
    self.driver_list.clear()
    self.target_list.clear()
    self.expr_show.clear()
    for label in [
        self.grounded_label,
        self.driver_label,
        self.target_label,
    ]:
        _set_warning(label, True)

</t>
<t tx="leo.20231205084739.271">@Slot(name='on_clear_btn_clicked')
def __user_clear(self) -&gt; bool:
    """Ask user before clear."""
    if not self.configure_canvas.graph.vertices:
        return True
    if QMessageBox.question(
        self,
        "New profile",
        "Do you want to create a new profile?\n"
        "Unsaved changes will be cleared!"
    ) == QMessageBox.Yes:
        self.__clear_panel()
        return True
    return False

</t>
<t tx="leo.20231205084739.272">@Slot(name='on_add_collection_btn_clicked')
def __add_collection(self) -&gt; None:
    """Add the graph back to structure collections."""
    self.add_collection(tuple(self.configure_canvas.graph.edges))

</t>
<t tx="leo.20231205084739.273">@Slot(Graph, dict)
def set_graph(
    self,
    graph: Graph,
    pos: Dict[int, _Coord]
) -&gt; bool:
    """Set the graph to preview canvas, return False if no clear."""
    if not self.__user_clear():
        return False
    self.configure_canvas.set_graph(graph, pos)
    links: List[List[str]] = [[] for _ in range(len(graph.vertices))]
    for joint, nodes in edges_view(graph):
        for node in nodes:
            links[node].append(f'P{joint}')
    for link in links:
        self.grounded_list.addItem("(" + ", ".join(link) + ")")
    # Point name is (P1, P2, P3, ...)
    for node in pos:
        self.joint_name.addItem(f'P{node}')
    return True

</t>
<t tx="leo.20231205084739.274">@Slot(int, name='on_grounded_list_currentRowChanged')
def __set_grounded(self, row: int) -&gt; None:
    """Change current grounded link. Reset all settings."""
    has_choose = row &gt; -1
    _set_warning(self.grounded_label, not has_choose)
    self.configure_canvas.set_grounded(row)
    self.driver_list.clear()
    self.driver_base.clear()
    self.driver_rotator.clear()
    if has_choose:
        item: Optional[QListWidgetItem] = self.grounded_list.item(row)
        if item is None:
            return

        items = item.text().replace('(', '').replace(')', '').split(", ")
        self.driver_base.addItems(items)

    _set_warning(self.driver_label, True)
    if row == self.grounded_list.currentRow():
        return

    self.grounded_list.blockSignals(True)
    self.grounded_list.setCurrentRow(row)
    self.grounded_list.blockSignals(False)

</t>
<t tx="leo.20231205084739.275">@Slot(str, name='on_driver_base_currentIndexChanged')
def __set_driver_base(self, name: str) -&gt; None:
    self.driver_rotator.clear()
    if not name:
        return

    def find_friends(node: int) -&gt; List[str]:
        """Find all the nodes that are same link with input node."""
        ev = dict(edges_view(self.configure_canvas.graph))
        link = set(ev[node])
        tmp_list = []
        for node_, link_ in ev.items():
            if node_ == node:
                continue
            inter = set(link_) &amp; link
            if inter and inter.pop() != self.configure_canvas.grounded:
                tmp_list.append(f'P{node_}')
        return tmp_list

    self.driver_rotator.addItems(find_friends(int(name.replace('P', ''))))

</t>
<t tx="leo.20231205084739.276">@Slot(name='on_driver_add_clicked')
def __add_driver(self) -&gt; None:
    """Add a input pair."""
    d1 = self.driver_base.currentText()
    d2 = self.driver_rotator.currentText()
    if d1 == d2 == "":
        return
    d1_d2 = f"({d1}, {d2})"
    for n in list_texts(self.driver_list):
        if n == d1_d2:
            return
    self.driver_list.addItem(d1_d2)
    self.__update_driver()
    _set_warning(self.driver_label, False)

</t>
<t tx="leo.20231205084739.277">@Slot(name='on_driver_del_clicked')
def __del_driver(self) -&gt; None:
    """Remove a input pair."""
    row = self.driver_list.currentRow()
    if not row &gt; -1:
        return
    self.driver_list.takeItem(row)
    self.__update_driver()
    _set_warning(self.driver_label, self.driver_list.count() == 0)

</t>
<t tx="leo.20231205084739.278">def __update_driver(self) -&gt; None:
    """Update driver for canvas."""
    self.configure_canvas.set_driver([
        eval(s.replace('P', '')) for s in list_texts(self.driver_list)
    ])

</t>
<t tx="leo.20231205084739.279">@Slot(name='on_add_customization_clicked')
def __set_cus_same(self) -&gt; None:
    """Custom points and multiple joints option."""
    dlg = CustomsDialog(self)
    dlg.show()
    dlg.exec_()
    dlg.deleteLater()
    self.configure_canvas.update()

</t>
<t tx="leo.20231205084739.28">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/slvs/
# -*- coding: utf-8 -*-

"""Solvespace format output as linkage sketch."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Sequence, List, Tuple, Iterator
from math import radians, sin, cos, atan2
from pyslvs import VPoint, Coord
from pyslvs_ui.graphics import convex_hull
from .write import SlvsWriter2

_Coord = Tuple[float, float]
_CoordsPair = Tuple[Coord, Coord]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.280">def __get_current_mech(self) -&gt; Dict[str, Any]:
    """Get the current mechanism parameters."""
    self.__set_parm_bind()
    input_list: List[Tuple[Tuple[int, int], List[int]]] = []
    for s in list_texts(self.driver_list):
        pair: Tuple[int, int] = eval(s.replace('P', ''))
        if set(pair) &amp; set(self.configure_canvas.same):
            continue
        input_list.append((pair, [0, 360]))
    place_list: Dict[int, None] = {}
    for i in range(self.driver_base.count()):
        joint = int(self.driver_base.itemText(i).replace('P', ''))
        if joint in self.configure_canvas.same:
            continue
        place_list[joint] = None
    target_list: Dict[int, None] = {}
    for s in list_texts(self.target_list):
        target_list[int(s.replace('P', ''))] = None
    return {
        'expression': self.expr_show.text(),
        'input': input_list,
        'graph': self.configure_canvas.graph.edges,
        'placement': place_list,
        'target': target_list,
        'cus': self.configure_canvas.cus.copy(),
        'same': self.configure_canvas.same.copy(),
    }

</t>
<t tx="leo.20231205084739.281">@Slot(name='on_load_btn_clicked')
def __from_profile(self) -&gt; None:
    """Show up the dialog to load structure data."""
    dlg = CollectionsDialog(
        self.collections,
        self.get_configure,
        self.project_no_save,
        self.prefer.tick_mark_option,
        self.configure_canvas.monochrome,
        self
    )
    dlg.show()
    if not dlg.exec_():
        dlg.deleteLater()
        return
    # Add customize joints
    params = dlg.params
    graph = Graph(params['graph'])
    expression: str = params['expression']
    pos_list = parse_pos(expression)
    cus: Dict[int, int] = params['cus']
    same: Dict[int, int] = params['same']
    for node, ref in sorted(same.items()):
        pos_list.insert(node, pos_list[ref])
    if not self.set_graph(graph, {i: (x, y) for i, (x, y) in enumerate(pos_list)}):
        dlg.deleteLater()
        return
    self.profile_name.setText(dlg.name)
    dlg.deleteLater()
    del dlg
    self.configure_canvas.cus = cus
    self.configure_canvas.same = same
    # Grounded setting
    for row in PreviewCanvas.grounded_detect(set(params['placement']), graph, same):
        self.__set_grounded(row)
    # Driver, Target
    input_list: List[Tuple[Tuple[int, int], Tuple[float, float]]] = params['input']
    self.driver_list.addItems(f"(P{b}, P{d})" for (b, d), _ in input_list)
    self.configure_canvas.set_driver([d for d, _ in input_list])
    _set_warning(self.driver_label, self.driver_list.count() == 0)
    target_list: Dict[int, Sequence[_Coord]] = params['target']
    self.configure_canvas.set_target(sorted(target_list))
    self.target_list.addItems(f"P{n}" for n in target_list)
    _set_warning(self.target_label, self.target_list.count() == 0)
    # Expression
    self.expr_show.setText(params['expression'])

</t>
<t tx="leo.20231205084739.282">@Slot(name='on_target_btn_clicked')
def __set_target(self) -&gt; None:
    """Show up target joints dialog."""
    dlg = TargetsDialog(
        "Choose the target points.",
        'P',
        set(self.configure_canvas.pos) - self.configure_canvas.target,
        self.configure_canvas.target,
        self
    )
    dlg.show()
    if not dlg.exec_():
        dlg.deleteLater()
        return
    self.target_list.clear()
    self.target_list.addItems(list_texts(dlg.targets_list))
    self.configure_canvas.set_target(dlg.targets())
    dlg.deleteLater()
    _set_warning(self.target_label, self.target_list.count() == 0)

</t>
<t tx="leo.20231205084739.283">@Slot(QListWidgetItem)
def __set_parm_bind(self, _=None) -&gt; None:
    """Set parameters binding."""
    link_expr_list = []
    for row, gs in enumerate(list_texts(self.grounded_list)):
        try:
            link_expr = []
            # Links from grounded list
            for name in gs.replace('(', '').replace(')', '').split(", "):
                num = int(name.replace('P', ''))
                if num in self.configure_canvas.same:
                    name = f'P{self.configure_canvas.same[num]}'
                link_expr.append(name)
        except KeyError:
            continue
        else:
            # Customize joints
            for joint, link in self.configure_canvas.cus.items():
                if row == link:
                    link_expr.append(f"P{joint}")
            link_expr_str = ','.join(sorted(set(link_expr)))
            if row != self.grounded_list.currentRow():
                link_expr_list.append(link_expr_str)
            else:
                link_expr_list.insert(0, link_expr_str)
    self.expr_show.setText(self.get_expression(graph2vpoints(
        self.configure_canvas.graph,
        self.configure_canvas.pos,
        self.configure_canvas.cus,
        self.configure_canvas.same,
        self.grounded_list.currentRow()
    )))

</t>
<t tx="leo.20231205084739.284">@Slot(name='on_save_btn_clicked')
def __save(self) -&gt; None:
    """Save the profile to database."""
    if self.profile_name.text():
        name = self.profile_name.text()
        ok = True
    else:
        name, ok = QInputDialog.getText(
            self,
            "Profile name",
            "Please enter the profile name:"
        )
    if not ok:
        return
    i = 0
    while (name not in self.collections) and (not name):
        name = f"Structure_{i}"
    self.collections[name] = self.__get_current_mech()
    self.profile_name.setText(name)
    self.project_no_save()

</t>
<t tx="leo.20231205084739.285">@Slot(name='on_clipboard_btn_clicked')
def __copy(self) -&gt; None:
    """Copy the mechanism params into clipboard."""
    QApplication.clipboard().setText(
        pprint.pformat(self.__get_current_mech())
    )
</t>
<t tx="leo.20231205084739.286">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/collections/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'configure_widget.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.287">class Ui_Form(object):
    @others
</t>
<t tx="leo.20231205084739.288">def setupUi(self, Form):
    Form.setObjectName("Form")
    Form.resize(361, 397)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:configure.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Form.setWindowIcon(icon)
    self.verticalLayout_4 = QtWidgets.QVBoxLayout(Form)
    self.verticalLayout_4.setObjectName("verticalLayout_4")
    self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_4.setObjectName("horizontalLayout_4")
    self.load_btn = QtWidgets.QPushButton(Form)
    icon1 = QtGui.QIcon()
    icon1.addPixmap(QtGui.QPixmap("icons:collections.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.load_btn.setIcon(icon1)
    self.load_btn.setObjectName("load_btn")
    self.horizontalLayout_4.addWidget(self.load_btn)
    self.save_btn = QtWidgets.QPushButton(Form)
    icon2 = QtGui.QIcon()
    icon2.addPixmap(QtGui.QPixmap("icons:save_file.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.save_btn.setIcon(icon2)
    self.save_btn.setObjectName("save_btn")
    self.horizontalLayout_4.addWidget(self.save_btn)
    self.profile_name = QtWidgets.QLineEdit(Form)
    self.profile_name.setReadOnly(True)
    self.profile_name.setObjectName("profile_name")
    self.horizontalLayout_4.addWidget(self.profile_name)
    self.add_collection_btn = QtWidgets.QPushButton(Form)
    icon3 = QtGui.QIcon()
    icon3.addPixmap(QtGui.QPixmap("icons:structure.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.add_collection_btn.setIcon(icon3)
    self.add_collection_btn.setObjectName("add_collection_btn")
    self.horizontalLayout_4.addWidget(self.add_collection_btn)
    self.clipboard_btn = QtWidgets.QPushButton(Form)
    icon4 = QtGui.QIcon()
    icon4.addPixmap(QtGui.QPixmap("icons:copy.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.clipboard_btn.setIcon(icon4)
    self.clipboard_btn.setObjectName("clipboard_btn")
    self.horizontalLayout_4.addWidget(self.clipboard_btn)
    self.line_5 = QtWidgets.QFrame(Form)
    self.line_5.setFrameShape(QtWidgets.QFrame.VLine)
    self.line_5.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line_5.setObjectName("line_5")
    self.horizontalLayout_4.addWidget(self.line_5)
    self.clear_btn = QtWidgets.QPushButton(Form)
    icon5 = QtGui.QIcon()
    icon5.addPixmap(QtGui.QPixmap("icons:clean.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.clear_btn.setIcon(icon5)
    self.clear_btn.setObjectName("clear_btn")
    self.horizontalLayout_4.addWidget(self.clear_btn)
    self.verticalLayout_4.addLayout(self.horizontalLayout_4)
    self.line = QtWidgets.QFrame(Form)
    self.line.setFrameShape(QtWidgets.QFrame.HLine)
    self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line.setObjectName("line")
    self.verticalLayout_4.addWidget(self.line)
    self.main_splitter = QtWidgets.QSplitter(Form)
    self.main_splitter.setOrientation(QtCore.Qt.Vertical)
    self.main_splitter.setObjectName("main_splitter")
    self.verticalLayoutWidget = QtWidgets.QWidget(self.main_splitter)
    self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")
    self.main_layout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
    self.main_layout.setContentsMargins(0, 0, 0, 0)
    self.main_layout.setObjectName("main_layout")
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    self.joint_name = QtWidgets.QComboBox(self.verticalLayoutWidget)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.joint_name.sizePolicy().hasHeightForWidth())
    self.joint_name.setSizePolicy(sizePolicy)
    self.joint_name.setObjectName("joint_name")
    self.horizontalLayout_2.addWidget(self.joint_name)
    self.add_customization = QtWidgets.QPushButton(self.verticalLayoutWidget)
    icon6 = QtGui.QIcon()
    icon6.addPixmap(QtGui.QPixmap("icons:properties.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.add_customization.setIcon(icon6)
    self.add_customization.setObjectName("add_customization")
    self.horizontalLayout_2.addWidget(self.add_customization)
    self.main_layout.addLayout(self.horizontalLayout_2)
    self.layoutWidget = QtWidgets.QWidget(self.main_splitter)
    self.layoutWidget.setObjectName("layoutWidget")
    self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.layoutWidget)
    self.verticalLayout_5.setContentsMargins(0, 0, 0, 0)
    self.verticalLayout_5.setObjectName("verticalLayout_5")
    self.line_3 = QtWidgets.QFrame(self.layoutWidget)
    self.line_3.setLineWidth(3)
    self.line_3.setFrameShape(QtWidgets.QFrame.HLine)
    self.line_3.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line_3.setObjectName("line_3")
    self.verticalLayout_5.addWidget(self.line_3)
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.verticalLayout_3 = QtWidgets.QVBoxLayout()
    self.verticalLayout_3.setObjectName("verticalLayout_3")
    self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_7.setSpacing(0)
    self.horizontalLayout_7.setObjectName("horizontalLayout_7")
    self.target_label = QtWidgets.QLabel(self.layoutWidget)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.target_label.sizePolicy().hasHeightForWidth())
    self.target_label.setSizePolicy(sizePolicy)
    self.target_label.setObjectName("target_label")
    self.horizontalLayout_7.addWidget(self.target_label)
    self.target_btn = QtWidgets.QPushButton(self.layoutWidget)
    self.target_btn.setObjectName("target_btn")
    self.horizontalLayout_7.addWidget(self.target_btn)
    self.verticalLayout_3.addLayout(self.horizontalLayout_7)
    self.target_list = QtWidgets.QListWidget(self.layoutWidget)
    self.target_list.setObjectName("target_list")
    self.verticalLayout_3.addWidget(self.target_list)
    self.horizontalLayout.addLayout(self.verticalLayout_3)
    self.verticalLayout_2 = QtWidgets.QVBoxLayout()
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_5.setObjectName("horizontalLayout_5")
    self.driver_base = QtWidgets.QComboBox(self.layoutWidget)
    self.driver_base.setObjectName("driver_base")
    self.horizontalLayout_5.addWidget(self.driver_base)
    self.driver_arrow_label = QtWidgets.QLabel(self.layoutWidget)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.driver_arrow_label.sizePolicy().hasHeightForWidth())
    self.driver_arrow_label.setSizePolicy(sizePolicy)
    self.driver_arrow_label.setObjectName("driver_arrow_label")
    self.horizontalLayout_5.addWidget(self.driver_arrow_label)
    self.driver_rotator = QtWidgets.QComboBox(self.layoutWidget)
    self.driver_rotator.setObjectName("driver_rotator")
    self.horizontalLayout_5.addWidget(self.driver_rotator)
    self.verticalLayout_2.addLayout(self.horizontalLayout_5)
    self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_3.setObjectName("horizontalLayout_3")
    self.driver_add = QtWidgets.QPushButton(self.layoutWidget)
    icon7 = QtGui.QIcon()
    icon7.addPixmap(QtGui.QPixmap("icons:motor.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.driver_add.setIcon(icon7)
    self.driver_add.setObjectName("driver_add")
    self.horizontalLayout_3.addWidget(self.driver_add)
    self.driver_del = QtWidgets.QPushButton(self.layoutWidget)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.driver_del.sizePolicy().hasHeightForWidth())
    self.driver_del.setSizePolicy(sizePolicy)
    icon8 = QtGui.QIcon()
    icon8.addPixmap(QtGui.QPixmap("icons:delete.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.driver_del.setIcon(icon8)
    self.driver_del.setObjectName("driver_del")
    self.horizontalLayout_3.addWidget(self.driver_del)
    self.verticalLayout_2.addLayout(self.horizontalLayout_3)
    self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_8.setObjectName("horizontalLayout_8")
    self.verticalLayout = QtWidgets.QVBoxLayout()
    self.verticalLayout.setObjectName("verticalLayout")
    self.driver_label = QtWidgets.QLabel(self.layoutWidget)
    self.driver_label.setObjectName("driver_label")
    self.verticalLayout.addWidget(self.driver_label)
    self.driver_list = QtWidgets.QListWidget(self.layoutWidget)
    self.driver_list.setObjectName("driver_list")
    self.verticalLayout.addWidget(self.driver_list)
    self.horizontalLayout_8.addLayout(self.verticalLayout)
    self.verticalLayout_15 = QtWidgets.QVBoxLayout()
    self.verticalLayout_15.setObjectName("verticalLayout_15")
    self.grounded_label = QtWidgets.QLabel(self.layoutWidget)
    self.grounded_label.setObjectName("grounded_label")
    self.verticalLayout_15.addWidget(self.grounded_label)
    self.grounded_list = QtWidgets.QListWidget(self.layoutWidget)
    self.grounded_list.setObjectName("grounded_list")
    self.verticalLayout_15.addWidget(self.grounded_list)
    self.horizontalLayout_8.addLayout(self.verticalLayout_15)
    self.verticalLayout_2.addLayout(self.horizontalLayout_8)
    self.horizontalLayout.addLayout(self.verticalLayout_2)
    self.verticalLayout_5.addLayout(self.horizontalLayout)
    self.verticalLayout_4.addWidget(self.main_splitter)
    self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_6.setObjectName("horizontalLayout_6")
    self.expression_label = QtWidgets.QLabel(Form)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.expression_label.sizePolicy().hasHeightForWidth())
    self.expression_label.setSizePolicy(sizePolicy)
    self.expression_label.setObjectName("expression_label")
    self.horizontalLayout_6.addWidget(self.expression_label)
    self.expr_show = QtWidgets.QLineEdit(Form)
    self.expr_show.setReadOnly(True)
    self.expr_show.setObjectName("expr_show")
    self.horizontalLayout_6.addWidget(self.expr_show)
    self.verticalLayout_4.addLayout(self.horizontalLayout_6)
    self.main_splitter.raise_()
    self.line.raise_()

    self.retranslateUi(Form)
    QtCore.QMetaObject.connectSlotsByName(Form)

</t>
<t tx="leo.20231205084739.289">def retranslateUi(self, Form):
    _translate = QtCore.QCoreApplication.translate
    Form.setWindowTitle(_translate("Form", "Form"))
    self.load_btn.setStatusTip(_translate("Form", "Triangular iteration data and common structure data collections."))
    self.save_btn.setStatusTip(_translate("Form", "Save this iteration profile to data collections."))
    self.add_collection_btn.setStatusTip(_translate("Form", "Turn this structure diagram back to structure collections."))
    self.clipboard_btn.setStatusTip(_translate("Form", "Save this iteration profile to clipboard as a string."))
    self.clear_btn.setStatusTip(_translate("Form", "Create a new iteration profile."))
    self.add_customization.setStatusTip(_translate("Form", "Customize joints and multiple joints option interface."))
    self.add_customization.setText(_translate("Form", "Joint Properties"))
    self.target_btn.setText(_translate("Form", "Targets"))
    self.target_list.setStatusTip(_translate("Form", "Target points will match as the target path of dimensional synthesis."))
    self.driver_arrow_label.setText(_translate("Form", "-&gt;"))
    self.driver_add.setText(_translate("Form", "Add Driver"))
    self.driver_label.setText(_translate("Form", "Inputs"))
    self.driver_list.setStatusTip(_translate("Form", "These joints will setup an revolute input. The number of them as same as DOF."))
    self.grounded_label.setText(_translate("Form", "Gounded"))
    self.grounded_list.setStatusTip(_translate("Form", "Set a link as the ground. Existing solutions will be reset."))
    self.expression_label.setText(_translate("Form", "Expression"))
    self.expr_show.setStatusTip(_translate("Form", "Expression of the mechanism"))
</t>
<t tx="leo.20231205084739.29">def _by_frame() -&gt; Iterator[int]:
    """Number code of frame."""
    yield 0
    yield 1
    k = 2
    while True:
        for code in (0, 1):
            yield code
            yield k
        k += 1


</t>
<t tx="leo.20231205084739.290">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/collections/
# -*- coding: utf-8 -*-

"""The widget of 'Structure' tab."""

from __future__ import annotations

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import TYPE_CHECKING, List, Tuple, Sequence, Dict, Iterable
from qtpy.QtCore import Signal, Slot, Qt, QSize, QPointF, QCoreApplication
from qtpy.QtWidgets import (
    QMessageBox,
    QProgressDialog,
    QListWidgetItem,
    QInputDialog,
    QWidget,
    QApplication,
)
from qtpy.QtGui import QImage, QPainter, QPixmap
from pyslvs.graph import (
    Graph,
    link_assortment,
    contracted_link_assortment,
    labeled_enumerate,
    is_planar,
    external_loop_layout,
)
from pyslvs_ui.qt_patch import qt_image_format
from pyslvs_ui.graphics import graph2icon, engine_picker, engines
from .dialogs.targets import TargetsDialog
from .structure_widget_ui import Ui_Form

if TYPE_CHECKING:
    from pyslvs_ui.widgets import MainWindowBase


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.291">class StructureWidget(QWidget, Ui_Form):
    """Structure widget.

    Preview the structures that was been added in collection list by user.
    """
    collections: List[Graph]
    collections_layouts: List[Dict[int, Tuple[float, float]]]
    collections_grounded: List[Graph]

    layout_sender = Signal(Graph, dict)

    @others
</t>
<t tx="leo.20231205084739.292">def __init__(self, parent: MainWindowBase):
    """Get IO dialog functions from parent."""
    super(StructureWidget, self).__init__(parent)
    self.setupUi(self)
    self.output_to = parent.output_to
    self.save_reply_box = parent.save_reply_box
    self.input_from_multiple = parent.input_from_multiple
    self.add_points_by_graph = parent.add_points_by_graph
    self.project_no_save = parent.project_no_save
    self.prefer = parent.prefer

    # Data structures
    self.collections = []
    self.collections_layouts = []
    self.collections_grounded = []

    # Engine list
    self.graph_engine.addItems(engines)

</t>
<t tx="leo.20231205084739.293">def clear(self) -&gt; None:
    """Clear all sub-widgets."""
    for button in (
        self.merge_btn,
        self.configure_btn,
        self.duplicate_btn,
    ):
        button.setEnabled(False)
    self.collections.clear()
    self.collection_list.clear()
    self.__clear_selection()

</t>
<t tx="leo.20231205084739.294">@Slot(name='on_clear_btn_clicked')
def __user_clear(self) -&gt; None:
    """Ask user before clear."""
    if not self.collections:
        return
    if QMessageBox.question(
        self,
        "Delete",
        "Sure to remove all your collections?"
    ) != QMessageBox.Yes:
        return
    self.clear()
    self.project_no_save()

</t>
<t tx="leo.20231205084739.295">@Slot(name='on_reload_atlas_clicked')
@Slot(bool, name='on_graph_link_as_node_toggled')
@Slot(bool, name='on_graph_show_label_toggled')
@Slot(int, name='on_graph_engine_currentIndexChanged')
def __reload_atlas(self) -&gt; None:
    """Reload atlas with the engine."""
    current_pos = self.collection_list.currentRow()
    self.collections_layouts.clear()
    self.collection_list.clear()
    self.__clear_selection()
    if not self.collections:
        return
    dlg = QProgressDialog(
        "Drawing atlas...",
        "Cancel",
        0,
        len(self.collections),
        self
    )
    dlg.setWindowTitle("Type synthesis")
    dlg.resize(400, dlg.height())
    dlg.setModal(True)
    dlg.show()
    engine_str = self.graph_engine.currentText()
    for i, g in enumerate(self.collections):
        QCoreApplication.processEvents()
        if dlg.wasCanceled():
            dlg.deleteLater()
            return
        item = QListWidgetItem(f"No. {i + 1}")
        pos = engine_picker(g, engine_str, self.graph_link_as_node.isChecked())
        item.setIcon(graph2icon(
            g,
            self.collection_list.iconSize().width(),
            self.graph_link_as_node.isChecked(),
            self.graph_show_label.isChecked(),
            self.prefer.monochrome_option,
            pos=pos
        ))
        self.collections_layouts.append(dict(pos))
        item.setToolTip(f"{g.edges}")
        self.collection_list.addItem(item)
        dlg.setValue(i + 1)
    dlg.deleteLater()
    if current_pos &gt; -1:
        self.collection_list.setCurrentRow(current_pos)
        self.__set_selection(self.collection_list.currentItem())

</t>
<t tx="leo.20231205084739.296">def __is_valid_graph(self, edges: Iterable[Tuple[int, int]]) -&gt; str:
    """Test graph and return True if it is valid."""
    try:
        g = Graph(edges)
    except (TypeError, ValueError):
        return "wrong format"
    if not g.edges:
        return "is an empty graph"
    if not g.is_connected():
        return "is not a close chain"
    if not is_planar(g):
        return "is not a planar chain"
    if g.has_cut_link():
        return "has cut link"
    try:
        external_loop_layout(g, True)
    except ValueError as error:
        return str(error)
    for h in self.collections:
        if g.is_isomorphic(h):
            return f"is isomorphic with: {h.edges}"
    return ""

</t>
<t tx="leo.20231205084739.297">def add_collection(self, edges: Iterable[Tuple[int, int]], *, reload: bool = True) -&gt; None:
    """Add collection by in put edges."""
    error = self.__is_valid_graph(edges)
    if error:
        QMessageBox.warning(self, "Add Collection Error", f"Error: {error}")
        return
    self.collections.append(Graph(edges))
    self.project_no_save()
    if reload:
        self.__reload_atlas()

</t>
<t tx="leo.20231205084739.298">def add_collections(self, collections: Sequence[Sequence[Tuple[int, int]]]) -&gt; None:
    """Add collections."""
    for edges in collections:
        self.add_collection(edges)

</t>
<t tx="leo.20231205084739.299">@Slot(name='on_add_by_edges_btn_clicked')
def __add_from_edges(self) -&gt; None:
    """Add collection by input string."""
    edges_str = ""
    while not edges_str:
        edges_str, ok = QInputDialog.getText(
            self,
            "Add by edges",
            "Please enter a connection expression:\n"
            "Example: [(0, 1), (1, 2), (2, 3), (3, 0)]"
        )
        if not ok:
            return
    try:
        edges = eval(edges_str)
        if any(len(edge) != 2 for edge in edges):
            raise ValueError("wrong format")
    except (SyntaxError, ValueError) as error:
        QMessageBox.warning(self, str(error), f"Error: {error}")
        return
    else:
        self.add_collection(edges)

</t>
<t tx="leo.20231205084739.3">def __init__(self, border, width, box_size, *args, **kwargs):
    super(_NpImage, self).__init__(border, width, box_size, *args, **kwargs)

</t>
<t tx="leo.20231205084739.30">def _by_boundary(length: int) -&gt; Iterator[int]:
    """Number code of boundary."""
    k = 0
    while True:
        yield k
        k += 1
        k %= length
        yield k


</t>
<t tx="leo.20231205084739.300">@Slot(name='on_add_by_files_btn_clicked')
def __add_from_files(self) -&gt; None:
    """Append atlas by text files."""
    file_names = self.input_from_multiple(
        "edges data",
        ["Text File (*.txt)"]
    )
    if not file_names:
        return
    read_data = []
    for file_name in file_names:
        with open(file_name, 'r', encoding='utf-8') as f:
            for line in f:
                read_data.append(line)
    errors = []
    for edges_str in read_data:
        try:
            edges = eval(edges_str)
            if any(len(edge) != 2 for edge in edges):
                raise ValueError("wrong format")
        except (SyntaxError, ValueError) as error:
            errors.append(str(error))
        else:
            self.add_collection(edges, reload=False)
    if errors:
        QMessageBox.warning(self, "Loaded Error", "Error:" + '\n'.join(errors))
    self.__reload_atlas()

</t>
<t tx="leo.20231205084739.301">@Slot(name='on_capture_graph_clicked')
def __save_graph(self) -&gt; None:
    """Save the current graph."""
    if self.selection_window.count() != 1:
        return
    file_name = self.output_to("atlas image", qt_image_format)
    if not file_name:
        return
    pixmap: QPixmap = self.selection_window.item(0).icon().pixmap(self.selection_window.iconSize())
    pixmap.save(file_name)
    self.save_reply_box("Graph", file_name)

</t>
<t tx="leo.20231205084739.302">@Slot(name='on_save_atlas_clicked')
def __save_atlas(self) -&gt; None:
    """Save function as same as type synthesis widget."""
    count = self.collection_list.count()
    if count &lt; 1:
        return
    lateral, ok = QInputDialog.getInt(
        self,
        "Atlas",
        "The number of lateral:",
        5, 1
    )
    if not ok:
        return
    file_name = self.output_to("atlas image", qt_image_format)
    if not file_name:
        return
    icon_size = self.collection_list.iconSize()
    width = icon_size.width()
    image = self.collection_list.item(0).icon().pixmap(icon_size).toImage()
    image_main = QImage(QSize(
        lateral if count &gt; lateral else count,
        (count // lateral) + bool(count % lateral)
    ) * width, image.format())
    image_main.fill(Qt.transparent)
    painter = QPainter(image_main)
    for row in range(count):
        image = self.collection_list.item(row).icon().pixmap(icon_size).toImage()
        painter.drawImage(QPointF(row % lateral, row // lateral) * width, image)
    painter.end()
    pixmap = QPixmap()
    pixmap.convertFromImage(image_main)
    pixmap.save(file_name)
    self.save_reply_box("Atlas", file_name)

</t>
<t tx="leo.20231205084739.303">@Slot(name='on_save_edges_clicked')
def __save_edges(self) -&gt; None:
    """Save function as same as type synthesis widget."""
    count = self.collection_list.count()
    if count &lt; 1:
        return
    file_name = self.output_to("atlas edges expression", ["Text file (*.txt)"])
    if not file_name:
        return
    with open(file_name, 'w+', encoding='utf-8') as f:
        f.write('\n'.join(str(g.edges) for g in self.collections))
    self.save_reply_box("edges expression", file_name)

</t>
<t tx="leo.20231205084739.304">@Slot(QListWidgetItem, name='on_collection_list_itemClicked')
def __set_selection(self, item: QListWidgetItem) -&gt; None:
    """Show the data of collection.

    Save the layout position to keep the graphs
    will be in same appearance.
    """
    for button in (
        self.delete_btn,
        self.configure_btn,
        self.duplicate_btn,
    ):
        button.setEnabled(item is not None)
    self.selection_window.clear()
    if item is None:
        return
    # Preview item
    link_is_node = self.graph_link_as_node.isChecked()
    item_preview = QListWidgetItem(item.text())
    row = self.collection_list.row(item)
    g = self.collections[row]
    self.ground_engine = self.collections_layouts[row]
    item_preview.setIcon(graph2icon(
        g,
        self.selection_window.iconSize().width(),
        link_is_node,
        self.graph_show_label.isChecked(),
        self.prefer.monochrome_option,
        pos=self.ground_engine
    ))
    self.selection_window.addItem(item_preview)
    # Set attributes
    self.edges_text.setText(str(list(g.edges)))
    self.nl_label.setText(str(len(g.vertices)))
    self.nj_label.setText(str(len(g.edges)))
    self.dof_label.setText(str(g.dof()))
    self.is_degenerate_label.setText(str(g.is_degenerate()))
    self.link_assortment_label.setText(str(link_assortment(g)))
    self.contracted_link_assortment_label.setText(str(contracted_link_assortment(g)))
    # Buttons
    self.duplicate_btn.setEnabled(link_is_node)
    self.configure_btn.setEnabled(not link_is_node)
    self.merge_btn.setEnabled(not link_is_node)
    self.__grounded()

</t>
<t tx="leo.20231205084739.305">def __clear_selection(self) -&gt; None:
    """Clear the selection preview data."""
    self.grounded_list.clear()
    self.selection_window.clear()
    self.edges_text.clear()
    self.nl_label.setText('0')
    self.nj_label.setText('0')
    self.dof_label.setText('0')
    self.is_degenerate_label.setText("N/A")
    self.link_assortment_label.setText("N/A")
    self.contracted_link_assortment_label.setText("N/A")

</t>
<t tx="leo.20231205084739.306">@Slot(name='on_expr_copy_clicked')
def __copy_expr(self) -&gt; None:
    """Copy the expression."""
    string = self.edges_text.text()
    if string:
        QApplication.clipboard().setText(string)
        self.edges_text.selectAll()

</t>
<t tx="leo.20231205084739.307">@Slot(name='on_delete_btn_clicked')
def __delete_collection(self) -&gt; None:
    """Delete the selected collection."""
    row = self.collection_list.currentRow()
    if not row &gt; -1:
        return
    if QMessageBox.question(
        self,
        "Delete",
        f"Sure to remove #{row} from your collections?"
    ) != QMessageBox.Yes:
        return
    self.collection_list.takeItem(row)
    self.collections.pop(row)
    self.collections_layouts.pop(row)
    self.__clear_selection()
    self.project_no_save()

</t>
<t tx="leo.20231205084739.308">@Slot(name='on_duplicate_btn_clicked')
def __make_duplicate(self) -&gt; None:
    """Make current graph symmetric."""
    row = self.collection_list.currentRow()
    if not row &gt; -1:
        return
    graph = self.collections[row]
    dlg = TargetsDialog(
        "Select the vertices (links) you want to copy.\n"
        "The duplication will keep adjacency",
        "",
        graph.vertices,
        (),
        self
    )
    dlg.show()
    if not dlg.exec_():
        dlg.deleteLater()
        return
    targets = dlg.targets()
    dlg.deleteLater()
    times, ok = QInputDialog.getInt(
        self,
        "Make duplicate",
        "The count of duplication:",
        1, 1
    )
    if not ok:
        return
    new_graph = graph.duplicate(targets, times)
    self.add_collection(new_graph.edges)

</t>
<t tx="leo.20231205084739.309">@Slot(name='on_configure_btn_clicked')
def __configuration(self) -&gt; None:
    """Triangular iteration."""
    self.layout_sender.emit(
        self.collections[self.collection_list.currentRow()],
        self.ground_engine.copy()
    )

</t>
<t tx="leo.20231205084739.31">def boundary_loop(
    boundary: Sequence[_Coord],
    radius: float
) -&gt; List[_CoordsPair]:
    """Create boundary edges by pairs of coordinates."""
    boundary_tmp = []
    for i in range(len(boundary)):
        p1 = Coord(*boundary[i])
        p2 = Coord(*boundary[i + 1 if i + 1 &lt; len(boundary) else 0])
        alpha = atan2(p2.y - p1.y, p2.x - p1.x) - radians(90)
        offset_x = radius * cos(alpha)
        offset_y = radius * sin(alpha)
        boundary_tmp.append((
            Coord(p1.x + offset_x, p1.y + offset_y),
            Coord(p2.x + offset_x, p2.y + offset_y),
        ))
    return boundary_tmp


</t>
<t tx="leo.20231205084739.310">def __grounded(self) -&gt; None:
    """Grounded combinations."""
    current_item = self.collection_list.currentItem()
    self.collections_grounded.clear()
    self.grounded_list.clear()
    g = self.collections[self.collection_list.row(current_item)]
    item = QListWidgetItem("Released")
    icon = graph2icon(
        g,
        self.grounded_list.iconSize().width(),
        self.graph_link_as_node.isChecked(),
        self.graph_show_label.isChecked(),
        self.prefer.monochrome_option,
        pos=self.ground_engine
    )
    item.setIcon(icon)
    self.collections_grounded.append(g)
    self.grounded_list.addItem(item)
    for node, graph_ in labeled_enumerate(g):
        item = QListWidgetItem(f"link_{node}")
        icon = graph2icon(
            g,
            self.grounded_list.iconSize().width(),
            self.graph_link_as_node.isChecked(),
            self.graph_show_label.isChecked(),
            self.prefer.monochrome_option,
            except_node=node,
            pos=self.ground_engine
        )
        item.setIcon(icon)
        self.collections_grounded.append(graph_)
        self.grounded_list.addItem(item)

</t>
<t tx="leo.20231205084739.311">@Slot(name='on_merge_btn_clicked')
def __grounded_merge(self) -&gt; None:
    """Merge the grounded result."""
    item = self.grounded_list.currentItem()
    if not item:
        return
    graph = self.collections_grounded[0]
    text = item.text()
    if text == "Released":
        ground_link = None
    else:
        ground_link = int(text.split("_")[1])
    if QMessageBox.question(
        self,
        "Message",
        f"Merge \"{text}\" chain to your canvas?"
    ) == QMessageBox.Yes:
        self.add_points_by_graph(
            graph,
            self.ground_engine,
            ground_link
        )
</t>
<t tx="leo.20231205084739.312">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/collections/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'structure_widget.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.313">class Ui_Form(object):
    @others
</t>
<t tx="leo.20231205084739.314">def setupUi(self, Form):
    Form.setObjectName("Form")
    Form.resize(518, 745)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:structure.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Form.setWindowIcon(icon)
    self.verticalLayout_2 = QtWidgets.QVBoxLayout(Form)
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.add_by_files_btn = QtWidgets.QPushButton(Form)
    icon1 = QtGui.QIcon()
    icon1.addPixmap(QtGui.QPixmap("icons:loadfile.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.add_by_files_btn.setIcon(icon1)
    self.add_by_files_btn.setObjectName("add_by_files_btn")
    self.horizontalLayout.addWidget(self.add_by_files_btn)
    self.add_by_edges_btn = QtWidgets.QPushButton(Form)
    self.add_by_edges_btn.setIcon(icon)
    self.add_by_edges_btn.setObjectName("add_by_edges_btn")
    self.horizontalLayout.addWidget(self.add_by_edges_btn)
    self.line = QtWidgets.QFrame(Form)
    self.line.setFrameShape(QtWidgets.QFrame.VLine)
    self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line.setObjectName("line")
    self.horizontalLayout.addWidget(self.line)
    self.save_edges = QtWidgets.QPushButton(Form)
    icon2 = QtGui.QIcon()
    icon2.addPixmap(QtGui.QPixmap("icons:save_file.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.save_edges.setIcon(icon2)
    self.save_edges.setObjectName("save_edges")
    self.horizontalLayout.addWidget(self.save_edges)
    self.save_atlas = QtWidgets.QPushButton(Form)
    icon3 = QtGui.QIcon()
    icon3.addPixmap(QtGui.QPixmap("icons:picture.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.save_atlas.setIcon(icon3)
    self.save_atlas.setObjectName("save_atlas")
    self.horizontalLayout.addWidget(self.save_atlas)
    spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout.addItem(spacerItem)
    self.delete_btn = QtWidgets.QPushButton(Form)
    self.delete_btn.setEnabled(False)
    icon4 = QtGui.QIcon()
    icon4.addPixmap(QtGui.QPixmap("icons:delete.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.delete_btn.setIcon(icon4)
    self.delete_btn.setObjectName("delete_btn")
    self.horizontalLayout.addWidget(self.delete_btn)
    self.clear_btn = QtWidgets.QPushButton(Form)
    icon5 = QtGui.QIcon()
    icon5.addPixmap(QtGui.QPixmap("icons:clean.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.clear_btn.setIcon(icon5)
    self.clear_btn.setObjectName("clear_btn")
    self.horizontalLayout.addWidget(self.clear_btn)
    self.verticalLayout_2.addLayout(self.horizontalLayout)
    self.splitter = QtWidgets.QSplitter(Form)
    self.splitter.setOrientation(QtCore.Qt.Vertical)
    self.splitter.setObjectName("splitter")
    self.collection_list = QtWidgets.QListWidget(self.splitter)
    self.collection_list.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.collection_list.setIconSize(QtCore.QSize(100, 100))
    self.collection_list.setMovement(QtWidgets.QListView.Static)
    self.collection_list.setResizeMode(QtWidgets.QListView.Adjust)
    self.collection_list.setViewMode(QtWidgets.QListView.IconMode)
    self.collection_list.setUniformItemSizes(True)
    self.collection_list.setObjectName("collection_list")
    self.verticalLayoutWidget = QtWidgets.QWidget(self.splitter)
    self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")
    self.verticalLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
    self.verticalLayout.setContentsMargins(0, 0, 0, 0)
    self.verticalLayout.setObjectName("verticalLayout")
    self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_7.setObjectName("horizontalLayout_7")
    self.graph_engine = QtWidgets.QComboBox(self.verticalLayoutWidget)
    self.graph_engine.setObjectName("graph_engine")
    self.horizontalLayout_7.addWidget(self.graph_engine)
    self.reload_atlas = QtWidgets.QPushButton(self.verticalLayoutWidget)
    self.reload_atlas.setText("")
    icon6 = QtGui.QIcon()
    icon6.addPixmap(QtGui.QPixmap("icons:data_update.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.reload_atlas.setIcon(icon6)
    self.reload_atlas.setObjectName("reload_atlas")
    self.horizontalLayout_7.addWidget(self.reload_atlas)
    spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_7.addItem(spacerItem1)
    self.graph_link_as_node = QtWidgets.QCheckBox(self.verticalLayoutWidget)
    self.graph_link_as_node.setObjectName("graph_link_as_node")
    self.horizontalLayout_7.addWidget(self.graph_link_as_node)
    self.graph_show_label = QtWidgets.QCheckBox(self.verticalLayoutWidget)
    self.graph_show_label.setChecked(True)
    self.graph_show_label.setObjectName("graph_show_label")
    self.horizontalLayout_7.addWidget(self.graph_show_label)
    self.verticalLayout.addLayout(self.horizontalLayout_7)
    self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_3.setObjectName("horizontalLayout_3")
    self.edges_text = QtWidgets.QLineEdit(self.verticalLayoutWidget)
    self.edges_text.setReadOnly(True)
    self.edges_text.setObjectName("edges_text")
    self.horizontalLayout_3.addWidget(self.edges_text)
    self.expr_copy = QtWidgets.QPushButton(self.verticalLayoutWidget)
    icon7 = QtGui.QIcon()
    icon7.addPixmap(QtGui.QPixmap("icons:copy.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.expr_copy.setIcon(icon7)
    self.expr_copy.setObjectName("expr_copy")
    self.horizontalLayout_3.addWidget(self.expr_copy)
    self.capture_graph = QtWidgets.QPushButton(self.verticalLayoutWidget)
    self.capture_graph.setIcon(icon3)
    self.capture_graph.setObjectName("capture_graph")
    self.horizontalLayout_3.addWidget(self.capture_graph)
    self.verticalLayout.addLayout(self.horizontalLayout_3)
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    self.selection_window = QtWidgets.QListWidget(self.verticalLayoutWidget)
    self.selection_window.setMinimumSize(QtCore.QSize(210, 230))
    self.selection_window.setMaximumSize(QtCore.QSize(210, 230))
    self.selection_window.setSelectionMode(QtWidgets.QAbstractItemView.NoSelection)
    self.selection_window.setIconSize(QtCore.QSize(200, 200))
    self.selection_window.setMovement(QtWidgets.QListView.Static)
    self.selection_window.setViewMode(QtWidgets.QListView.IconMode)
    self.selection_window.setObjectName("selection_window")
    self.horizontalLayout_2.addWidget(self.selection_window)
    self.verticalLayout_5 = QtWidgets.QVBoxLayout()
    self.verticalLayout_5.setObjectName("verticalLayout_5")
    self.formLayout = QtWidgets.QFormLayout()
    self.formLayout.setObjectName("formLayout")
    self.nl_text = QtWidgets.QLabel(self.verticalLayoutWidget)
    self.nl_text.setObjectName("nl_text")
    self.formLayout.setWidget(1, QtWidgets.QFormLayout.LabelRole, self.nl_text)
    self.nl_label = QtWidgets.QLabel(self.verticalLayoutWidget)
    self.nl_label.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
    self.nl_label.setObjectName("nl_label")
    self.formLayout.setWidget(1, QtWidgets.QFormLayout.FieldRole, self.nl_label)
    self.nj_text = QtWidgets.QLabel(self.verticalLayoutWidget)
    self.nj_text.setObjectName("nj_text")
    self.formLayout.setWidget(2, QtWidgets.QFormLayout.LabelRole, self.nj_text)
    self.nj_label = QtWidgets.QLabel(self.verticalLayoutWidget)
    self.nj_label.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
    self.nj_label.setObjectName("nj_label")
    self.formLayout.setWidget(2, QtWidgets.QFormLayout.FieldRole, self.nj_label)
    self.dof_text = QtWidgets.QLabel(self.verticalLayoutWidget)
    self.dof_text.setObjectName("dof_text")
    self.formLayout.setWidget(3, QtWidgets.QFormLayout.LabelRole, self.dof_text)
    self.dof_label = QtWidgets.QLabel(self.verticalLayoutWidget)
    self.dof_label.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
    self.dof_label.setObjectName("dof_label")
    self.formLayout.setWidget(3, QtWidgets.QFormLayout.FieldRole, self.dof_label)
    self.is_degenerate_text = QtWidgets.QLabel(self.verticalLayoutWidget)
    self.is_degenerate_text.setObjectName("is_degenerate_text")
    self.formLayout.setWidget(4, QtWidgets.QFormLayout.LabelRole, self.is_degenerate_text)
    self.is_degenerate_label = QtWidgets.QLabel(self.verticalLayoutWidget)
    self.is_degenerate_label.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
    self.is_degenerate_label.setObjectName("is_degenerate_label")
    self.formLayout.setWidget(4, QtWidgets.QFormLayout.FieldRole, self.is_degenerate_label)
    self.verticalLayout_5.addLayout(self.formLayout)
    self.verticalLayout_4 = QtWidgets.QVBoxLayout()
    self.verticalLayout_4.setObjectName("verticalLayout_4")
    self.link_assortment_text = QtWidgets.QLabel(self.verticalLayoutWidget)
    self.link_assortment_text.setObjectName("link_assortment_text")
    self.verticalLayout_4.addWidget(self.link_assortment_text)
    self.link_assortment_label = QtWidgets.QLabel(self.verticalLayoutWidget)
    self.link_assortment_label.setObjectName("link_assortment_label")
    self.verticalLayout_4.addWidget(self.link_assortment_label)
    self.contracted_link_assortment_text = QtWidgets.QLabel(self.verticalLayoutWidget)
    self.contracted_link_assortment_text.setObjectName("contracted_link_assortment_text")
    self.verticalLayout_4.addWidget(self.contracted_link_assortment_text)
    self.contracted_link_assortment_label = QtWidgets.QLabel(self.verticalLayoutWidget)
    self.contracted_link_assortment_label.setObjectName("contracted_link_assortment_label")
    self.verticalLayout_4.addWidget(self.contracted_link_assortment_label)
    self.duplicate_btn = QtWidgets.QPushButton(self.verticalLayoutWidget)
    self.duplicate_btn.setEnabled(False)
    icon8 = QtGui.QIcon()
    icon8.addPixmap(QtGui.QPixmap("icons:reflect.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.duplicate_btn.setIcon(icon8)
    self.duplicate_btn.setObjectName("duplicate_btn")
    self.verticalLayout_4.addWidget(self.duplicate_btn)
    self.configure_btn = QtWidgets.QPushButton(self.verticalLayoutWidget)
    self.configure_btn.setEnabled(False)
    icon9 = QtGui.QIcon()
    icon9.addPixmap(QtGui.QPixmap("icons:configure.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.configure_btn.setIcon(icon9)
    self.configure_btn.setObjectName("configure_btn")
    self.verticalLayout_4.addWidget(self.configure_btn)
    self.merge_btn = QtWidgets.QPushButton(self.verticalLayoutWidget)
    self.merge_btn.setEnabled(False)
    icon10 = QtGui.QIcon()
    icon10.addPixmap(QtGui.QPixmap("icons:merge.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.merge_btn.setIcon(icon10)
    self.merge_btn.setObjectName("merge_btn")
    self.verticalLayout_4.addWidget(self.merge_btn)
    self.verticalLayout_5.addLayout(self.verticalLayout_4)
    self.horizontalLayout_2.addLayout(self.verticalLayout_5)
    self.verticalLayout.addLayout(self.horizontalLayout_2)
    self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_4.setObjectName("horizontalLayout_4")
    self.grounded_list = QtWidgets.QListWidget(self.verticalLayoutWidget)
    self.grounded_list.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.grounded_list.setIconSize(QtCore.QSize(150, 150))
    self.grounded_list.setMovement(QtWidgets.QListView.Static)
    self.grounded_list.setResizeMode(QtWidgets.QListView.Adjust)
    self.grounded_list.setViewMode(QtWidgets.QListView.IconMode)
    self.grounded_list.setUniformItemSizes(True)
    self.grounded_list.setObjectName("grounded_list")
    self.horizontalLayout_4.addWidget(self.grounded_list)
    self.verticalLayout.addLayout(self.horizontalLayout_4)
    self.verticalLayout_2.addWidget(self.splitter)

    self.retranslateUi(Form)
    self.graph_engine.setCurrentIndex(-1)
    QtCore.QMetaObject.connectSlotsByName(Form)

</t>
<t tx="leo.20231205084739.315">def retranslateUi(self, Form):
    _translate = QtCore.QCoreApplication.translate
    Form.setWindowTitle(_translate("Form", "Form"))
    self.add_by_files_btn.setStatusTip(_translate("Form", "Add the chain by edge expression from text files."))
    self.add_by_edges_btn.setStatusTip(_translate("Form", "Add the chain by edge expression."))
    self.save_edges.setStatusTip(_translate("Form", "Save the edges of atlas to text file."))
    self.save_edges.setText(_translate("Form", "Save as list"))
    self.save_atlas.setStatusTip(_translate("Form", "Save the atlas to image file."))
    self.save_atlas.setText(_translate("Form", "Save as image"))
    self.delete_btn.setStatusTip(_translate("Form", "Delete this structure."))
    self.clear_btn.setStatusTip(_translate("Form", "Delete all of structures."))
    self.graph_engine.setStatusTip(_translate("Form", "Layout engine from NetworkX."))
    self.reload_atlas.setToolTip(_translate("Form", "Re-layout"))
    self.graph_link_as_node.setText(_translate("Form", "Link as node"))
    self.graph_show_label.setText(_translate("Form", "Labels"))
    self.expr_copy.setStatusTip(_translate("Form", "Copy expression."))
    self.capture_graph.setStatusTip(_translate("Form", "Save current graph image."))
    self.nl_text.setToolTip(_translate("Form", "Number of links"))
    self.nl_text.setText(_translate("Form", "NL: (?)"))
    self.nl_label.setText(_translate("Form", "0"))
    self.nj_text.setToolTip(_translate("Form", "Number of joints"))
    self.nj_text.setText(_translate("Form", "NJ: (?)"))
    self.nj_label.setText(_translate("Form", "0"))
    self.dof_text.setToolTip(_translate("Form", "Degrees of freedom"))
    self.dof_text.setText(_translate("Form", "DOF: (?)"))
    self.dof_label.setText(_translate("Form", "0"))
    self.is_degenerate_text.setText(_translate("Form", "Is degenerate:"))
    self.is_degenerate_label.setText(_translate("Form", "N/A"))
    self.link_assortment_text.setToolTip(_translate("Form", "Link assortment"))
    self.link_assortment_text.setText(_translate("Form", "LA: (?)"))
    self.link_assortment_label.setText(_translate("Form", "N/A"))
    self.contracted_link_assortment_text.setToolTip(_translate("Form", "Contracted link assortment"))
    self.contracted_link_assortment_text.setText(_translate("Form", "CLA: (?)"))
    self.contracted_link_assortment_label.setText(_translate("Form", "N/A"))
    self.duplicate_btn.setText(_translate("Form", "Make Duplicate"))
    self.configure_btn.setStatusTip(_translate("Form", "Use trangular formula to do dimentional synthesis."))
    self.configure_btn.setText(_translate("Form", "Configure"))
    self.merge_btn.setStatusTip(_translate("Form", "Merge the specified chain to canvas with current layout."))
    self.merge_btn.setText(_translate("Form", "Merge"))
</t>
<t tx="leo.20231205084739.316">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/collections/
# -*- coding: utf-8 -*-

"""'collections' module contains
the result from type synthesis and triangular iteration by users.
"""

from __future__ import annotations

__all__ = [
    'Collections',
    'StructureWidget',
    'ConfigureWidget',
    'CollectionsDialog',
]
__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import TYPE_CHECKING, List, Tuple, Sequence, Dict, Any
from qtpy.QtWidgets import QWidget, QVBoxLayout, QTabWidget
from qtpy.QtGui import QIcon, QPixmap
from .structure_widget import StructureWidget
from .configure_widget import ConfigureWidget
from .dialogs import CollectionsDialog

if TYPE_CHECKING:
    from pyslvs_ui.widgets import MainWindowBase


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.317">class Collections(QWidget):
    """Just a widget contains a sub tab widget."""

    @others
</t>
<t tx="leo.20231205084739.318">def __init__(self, parent: MainWindowBase):
    """Create two widget page and using main window to make their parent."""
    super(Collections, self).__init__(parent)
    layout = QVBoxLayout(self)
    self.tab_widget = QTabWidget(self)
    layout.addWidget(self.tab_widget)
    self.setWindowIcon(QIcon(QPixmap("icons:collections.png")))
    self.structure_widget = StructureWidget(parent)
    self.configure_widget = ConfigureWidget(
        self.structure_widget.add_collection,
        parent
    )
    self.tab_widget.addTab(
        self.structure_widget,
        self.structure_widget.windowIcon(),
        "Structures"
    )
    self.tab_widget.addTab(
        self.configure_widget,
        self.configure_widget.windowIcon(),
        "Configuration"
    )
    self.structure_widget.configure_btn.clicked.connect(
        lambda: self.tab_widget.setCurrentIndex(1)
    )
    self.structure_widget.layout_sender.connect(
        self.configure_widget.set_graph
    )

</t>
<t tx="leo.20231205084739.319">def clear(self) -&gt; None:
    """Clear the sub-widgets."""
    self.structure_widget.clear()
    self.configure_widget.clear()

</t>
<t tx="leo.20231205084739.32">def slvs2_part(vpoints: List[VPoint], radius: float, file_name: str) -&gt; None:
    """Generate a linkage sketch by specified radius."""
    # Translate
    min_x = min(vpoint.cx for vpoint in vpoints)
    min_y = min(vpoint.cy for vpoint in vpoints)
    centers = [(vpoint.cx - min_x, vpoint.cy - min_y) for vpoint in vpoints]
    # Synchronous the point coordinates after using convex hull
    centers_ch = convex_hull(centers)
    _boundary = centers_ch.copy()
    for x, y in centers:
        if (x, y) not in centers_ch:
            centers_ch.append((x, y))
    centers = centers_ch
    del vpoints, min_x, min_y

    # Frame (p1, p2, p3) -&gt; ((p1, p2), (p3, p1), (p3, p2))
    frame: List[_CoordsPair] = [(
        Coord(centers[-2][0], centers[-2][1]),
        Coord(centers[-1][0], centers[-1][1]),
    )]
    for x, y in centers[2:]:
        frame.append((frame[0][0], Coord(x, y)))
        frame.append((frame[0][1], Coord(x, y)))

    # Boundary
    boundary = boundary_loop(_boundary, radius)
    del _boundary

    # Writer object
    writer = SlvsWriter2()
    writer.script_group.pop()
    writer.group_normal(0x3, "boundary")

    @others
    for i, (x, y) in enumerate(centers):
        add_circle(i, x, y)
    circles.clear()
    for i in range(len(boundary)):
        x, y = centers[i]
        add_arc(i, x, y)
    # Write file
    writer.save(file_name)
</t>
<t tx="leo.20231205084739.320">def collect_data(self) -&gt; List[Sequence[Tuple[int, int]]]:
    """Return collections to database."""
    return [tuple(G.edges) for G in self.structure_widget.collections]

</t>
<t tx="leo.20231205084739.321">def config_data(self) -&gt; Dict[str, Dict[str, Any]]:
    """Return profiles to database."""
    return self.configure_widget.collections
</t>
<t tx="leo.20231205084739.322"></t>
<t tx="leo.20231205084739.323">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/collections/dialogs/
# -*- coding: utf-8 -*-

"""The option dialog to load the structure data."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from copy import deepcopy
from typing import Dict, Mapping, Callable, Any
from qtpy.QtCore import Qt, Slot
from qtpy.QtWidgets import (
    QDialog,
    QDialogButtonBox,
    QInputDialog,
    QMessageBox,
    QListWidgetItem,
    QWidget,
)
from pyslvs import collection_list, all_collections
from pyslvs_ui.graphics import PreviewCanvas
from .collections_ui import Ui_Dialog


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.324">class CollectionsDialog(QDialog, Ui_Dialog):
    """Option dialog.

    Load the settings after closed.
    Any add, rename, delete operations will be apply immediately
    """
    collections: Dict[str, Any]
    params: Mapping[str, Any]

    @others
</t>
<t tx="leo.20231205084739.325">def __init__(
    self,
    collections: Mapping[str, Any],
    get_collection: Callable[[], Mapping[str, Any]],
    project_no_save: Callable[[], None],
    show_ticks: int,
    monochrome: bool,
    parent: QWidget
):
    """We put the 'collections' (from iteration widget) reference here."""
    super(CollectionsDialog, self).__init__(parent)
    self.setupUi(self)
    self.setWindowFlags(self.windowFlags() | Qt.WindowMaximizeButtonHint
                        &amp; ~Qt.WindowContextHelpButtonHint)
    self.collections = dict(collections)
    self.get_collection = get_collection
    self.project_no_save = project_no_save

    # Current profile name
    self.name = ""
    self.params = {}
    self.preview_canvas = PreviewCanvas(self)
    self.preview_layout.addWidget(self.preview_canvas)
    self.preview_canvas.set_show_ticks(show_ticks)
    self.preview_canvas.set_monochrome_mode(monochrome)
    self.common_list.addItems(all_collections())
    self.collections_list.addItems(self.collections)

    # Splitter
    self.main_splitter.setSizes([200, 200])
    self.sub_splitter.setSizes([100, 200])

    self.__has_collection()
    self.__can_open()

</t>
<t tx="leo.20231205084739.326">@Slot(str, name='on_collections_list_currentTextChanged')
def __can_open(self, _=None) -&gt; None:
    """Set the button box to enable when data is already."""
    self.btn_box.button(QDialogButtonBox.Open).setEnabled(
        self.collections_list.currentRow() &gt; -1
    )

</t>
<t tx="leo.20231205084739.327">def __has_collection(self) -&gt; None:
    """Set the buttons to enable when user choose a data."""
    has_collection = bool(self.collections)
    for button in [
        self.rename_btn,
        self.copy_btn,
        self.delete_btn
    ]:
        button.setEnabled(has_collection)

</t>
<t tx="leo.20231205084739.328">@Slot(name='on_rename_btn_clicked')
def __rename(self) -&gt; None:
    """Show up a string input to change the data name."""
    row = self.collections_list.currentRow()
    if not row &gt; -1:
        return

    name, ok = QInputDialog.getText(
        self,
        "Profile name",
        "Please enter the profile name:"
    )
    if not ok:
        return

    if not name:
        QMessageBox.warning(
            self,
            "Profile name",
            "Can not use blank string to rename."
        )
        return

    item = self.collections_list.item(row)
    self.collections[name] = self.collections.pop(item.text())
    item.setText(name)
    self.project_no_save()

</t>
<t tx="leo.20231205084739.329">@Slot(name='on_copy_btn_clicked')
def __copy(self) -&gt; None:
    """Ask a name to copy a data."""
    row = self.collections_list.currentRow()
    if not row &gt; -1:
        return

    name, ok = QInputDialog.getText(
        self,
        "Profile name",
        "Please enter a new profile name:"
    )
    if not ok:
        return

    if not name:
        QMessageBox.warning(
            self,
            "Profile name",
            "Can not use blank string to rename."
        )
        return

    name_old = self.collections_list.item(row).text()
    self.collections[name] = self.collections[name_old].copy()
    self.collections_list.addItem(name)
    self.project_no_save()

</t>
<t tx="leo.20231205084739.33"># Add "Param"
def add_param(edges: Sequence[_CoordsPair]) -&gt; None:
    """Add param by pair of coordinates."""
    for edge in edges:
        writer.param_num += 0x10
        for coord in edge:
            writer.param_val(writer.param_num, coord.x)
            writer.param_num += 1
            writer.param_val(writer.param_num, coord.y)
            writer.param_num += 2
        writer.param_shift16()

</t>
<t tx="leo.20231205084739.330">@Slot(name='on_delete_btn_clicked')
def __delete(self) -&gt; None:
    """Delete a data."""
    row = self.collections_list.currentRow()
    if not row &gt; -1:
        return

    if QMessageBox.question(
        self,
        "Delete",
        "Do you want to delete this structure?"
    ) != QMessageBox.Yes:
        return

    item = self.collections_list.takeItem(row)
    self.collections.pop(item.text())
    self.preview_canvas.clear()
    self.__has_collection()
    self.project_no_save()

</t>
<t tx="leo.20231205084739.331">@Slot(QListWidgetItem, name='on_common_list_itemClicked')
def __choose_common(self, _=None) -&gt; None:
    """Update preview canvas for common data."""
    item = self.common_list.currentItem()
    if not item:
        return

    self.name = item.text()
    self.params = collection_list(self.name)
    self.preview_canvas.from_profile(self.params)

</t>
<t tx="leo.20231205084739.332">@Slot(QListWidgetItem, name='on_collections_list_itemClicked')
def __choose_collections(self, _=None) -&gt; None:
    """Update preview canvas for a project data."""
    item = self.collections_list.currentItem()
    if not item:
        return

    self.name = item.text()
    self.params = deepcopy(self.collections[self.name])
    self.preview_canvas.from_profile(self.params)

</t>
<t tx="leo.20231205084739.333">@Slot(name='on_project_btn_clicked')
def __from_canvas(self) -&gt; None:
    """Get a collection data from current mechanism."""
    try:
        collection = self.get_collection()
    except ValueError as error:
        QMessageBox.warning(self, "Mechanism not support.", str(error))
        return

    num = 0
    name = f"mechanism{num}"
    while name in self.collections:
        name = f"mechanism{num}"
        num += 1
    self.collections[name] = deepcopy(collection)
    self.collections_list.addItem(name)
    self.project_no_save()
    self.__has_collection()

</t>
<t tx="leo.20231205084739.334">@Slot(name='on_common_load_clicked')
@Slot(QListWidgetItem, name='on_common_list_itemDoubleClicked')
def __load_common(self, _=None) -&gt; None:
    """Load a common data and close."""
    self.__choose_common()
    self.accept()

</t>
<t tx="leo.20231205084739.335">@Slot(name='on_btn_box_accepted')
@Slot(QListWidgetItem, name='on_collections_list_itemDoubleClicked')
def __load_collections(self, _=None) -&gt; None:
    """Load a project data and close."""
    self.__choose_collections()
    self.accept()
</t>
<t tx="leo.20231205084739.336">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/collections/dialogs/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'collections.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.337">class Ui_Dialog(object):
    @others
</t>
<t tx="leo.20231205084739.338">def setupUi(self, Dialog):
    Dialog.setObjectName("Dialog")
    Dialog.resize(651, 532)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:collections.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Dialog.setWindowIcon(icon)
    Dialog.setSizeGripEnabled(True)
    Dialog.setModal(True)
    self.verticalLayout_4 = QtWidgets.QVBoxLayout(Dialog)
    self.verticalLayout_4.setObjectName("verticalLayout_4")
    self.main_splitter = QtWidgets.QSplitter(Dialog)
    self.main_splitter.setOrientation(QtCore.Qt.Horizontal)
    self.main_splitter.setObjectName("main_splitter")
    self.preview_box = QtWidgets.QGroupBox(self.main_splitter)
    self.preview_box.setObjectName("preview_box")
    self.preview_layout = QtWidgets.QVBoxLayout(self.preview_box)
    self.preview_layout.setObjectName("preview_layout")
    self.sub_splitter = QtWidgets.QSplitter(self.main_splitter)
    self.sub_splitter.setOrientation(QtCore.Qt.Vertical)
    self.sub_splitter.setObjectName("sub_splitter")
    self.layoutWidget = QtWidgets.QWidget(self.sub_splitter)
    self.layoutWidget.setObjectName("layoutWidget")
    self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.layoutWidget)
    self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.common_label = QtWidgets.QLabel(self.layoutWidget)
    self.common_label.setObjectName("common_label")
    self.verticalLayout_2.addWidget(self.common_label)
    self.common_list = QtWidgets.QListWidget(self.layoutWidget)
    self.common_list.setObjectName("common_list")
    self.verticalLayout_2.addWidget(self.common_list)
    self.common_load = QtWidgets.QPushButton(self.layoutWidget)
    icon1 = QtGui.QIcon()
    icon1.addPixmap(QtGui.QPixmap("icons:data.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.common_load.setIcon(icon1)
    self.common_load.setObjectName("common_load")
    self.verticalLayout_2.addWidget(self.common_load)
    self.verticalLayoutWidget = QtWidgets.QWidget(self.sub_splitter)
    self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")
    self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
    self.verticalLayout_3.setContentsMargins(0, 0, 0, 0)
    self.verticalLayout_3.setObjectName("verticalLayout_3")
    self.line = QtWidgets.QFrame(self.verticalLayoutWidget)
    self.line.setFrameShape(QtWidgets.QFrame.HLine)
    self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line.setObjectName("line")
    self.verticalLayout_3.addWidget(self.line)
    self.Collections_label = QtWidgets.QLabel(self.verticalLayoutWidget)
    self.Collections_label.setObjectName("Collections_label")
    self.verticalLayout_3.addWidget(self.Collections_label)
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    self.collections_list = QtWidgets.QListWidget(self.verticalLayoutWidget)
    self.collections_list.setObjectName("collections_list")
    self.horizontalLayout_2.addWidget(self.collections_list)
    self.verticalLayout = QtWidgets.QVBoxLayout()
    self.verticalLayout.setObjectName("verticalLayout")
    self.project_btn = QtWidgets.QPushButton(self.verticalLayoutWidget)
    icon2 = QtGui.QIcon()
    icon2.addPixmap(QtGui.QPixmap("icons:mechanism.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.project_btn.setIcon(icon2)
    self.project_btn.setObjectName("project_btn")
    self.verticalLayout.addWidget(self.project_btn)
    self.line_2 = QtWidgets.QFrame(self.verticalLayoutWidget)
    self.line_2.setFrameShape(QtWidgets.QFrame.HLine)
    self.line_2.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line_2.setObjectName("line_2")
    self.verticalLayout.addWidget(self.line_2)
    self.rename_btn = QtWidgets.QPushButton(self.verticalLayoutWidget)
    icon3 = QtGui.QIcon()
    icon3.addPixmap(QtGui.QPixmap("icons:rename.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.rename_btn.setIcon(icon3)
    self.rename_btn.setAutoDefault(False)
    self.rename_btn.setObjectName("rename_btn")
    self.verticalLayout.addWidget(self.rename_btn)
    self.copy_btn = QtWidgets.QPushButton(self.verticalLayoutWidget)
    icon4 = QtGui.QIcon()
    icon4.addPixmap(QtGui.QPixmap("icons:copy.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.copy_btn.setIcon(icon4)
    self.copy_btn.setObjectName("copy_btn")
    self.verticalLayout.addWidget(self.copy_btn)
    spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout.addItem(spacerItem)
    self.delete_btn = QtWidgets.QPushButton(self.verticalLayoutWidget)
    icon5 = QtGui.QIcon()
    icon5.addPixmap(QtGui.QPixmap("icons:delete.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.delete_btn.setIcon(icon5)
    self.delete_btn.setAutoDefault(False)
    self.delete_btn.setObjectName("delete_btn")
    self.verticalLayout.addWidget(self.delete_btn)
    self.horizontalLayout_2.addLayout(self.verticalLayout)
    self.verticalLayout_3.addLayout(self.horizontalLayout_2)
    self.verticalLayout_4.addWidget(self.main_splitter)
    self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_3.setObjectName("horizontalLayout_3")
    spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_3.addItem(spacerItem1)
    self.btn_box = QtWidgets.QDialogButtonBox(Dialog)
    self.btn_box.setStandardButtons(QtWidgets.QDialogButtonBox.Close|QtWidgets.QDialogButtonBox.Open)
    self.btn_box.setObjectName("btn_box")
    self.horizontalLayout_3.addWidget(self.btn_box)
    self.verticalLayout_4.addLayout(self.horizontalLayout_3)

    self.retranslateUi(Dialog)
    self.btn_box.rejected.connect(Dialog.reject)
    self.btn_box.accepted.connect(Dialog.accept)
    self.common_load.clicked.connect(Dialog.accept)
    QtCore.QMetaObject.connectSlotsByName(Dialog)

</t>
<t tx="leo.20231205084739.339">def retranslateUi(self, Dialog):
    _translate = QtCore.QCoreApplication.translate
    Dialog.setWindowTitle(_translate("Dialog", "Profile collections"))
    self.preview_box.setTitle(_translate("Dialog", "Preview"))
    self.common_label.setText(_translate("Dialog", "Common:"))
    self.common_load.setText(_translate("Dialog", "Load common structure"))
    self.Collections_label.setText(_translate("Dialog", "Project Collections:"))
    self.project_btn.setText(_translate("Dialog", "Mechanism"))
    self.rename_btn.setText(_translate("Dialog", "Rename"))
    self.copy_btn.setText(_translate("Dialog", "Copy"))
    self.delete_btn.setText(_translate("Dialog", "Delete"))
</t>
<t tx="leo.20231205084739.34">def arc_coords(
    index: int,
    _cx: float,
    _cy: float
) -&gt; Iterator[_Coord]:
    yield from (
        (_cx, _cy),
        (boundary[index - 1][1].x, boundary[index - 1][1].y),
        (boundary[index][0].x, boundary[index][0].y),
    )

</t>
<t tx="leo.20231205084739.340">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/collections/dialogs/
# -*- coding: utf-8 -*-

"""The option dialog to set the custom points and the multiple joints."""

from __future__ import annotations

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import TYPE_CHECKING
from qtpy.QtCore import Slot, Qt
from qtpy.QtWidgets import QDialog
from .customs_ui import Ui_Dialog

if TYPE_CHECKING:
    from pyslvs_ui.synthesis import ConfigureWidget


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.341">class CustomsDialog(QDialog, Ui_Dialog):
    """Option dialog.

    name: str = 'P1', 'P2', ...
    num: int = 1, 2, ...

    Settings will be edited in each operation.
    """

    @others
</t>
<t tx="leo.20231205084739.342">def __init__(self, parent: ConfigureWidget):
    """Add data and widget references from the parent."""
    super(CustomsDialog, self).__init__(parent)
    self.setupUi(self)
    self.setWindowFlags(self.windowFlags()
                        &amp; ~Qt.WindowContextHelpButtonHint)
    canvas = parent.configure_canvas
    self.cus = canvas.cus
    self.same = canvas.same
    self.pos = canvas.pos
    self.status = canvas.status
    self.joint_combobox = parent.joint_name
    for row in range(parent.grounded_list.count()):
        self.link_choose.addItem(parent.grounded_list.item(row).text())
    for name, link in self.cus.items():
        self.custom_list.addItem(f"P{name} -&gt; {link}")
    self.__reload_quote_choose()
    self.quote_choose.setCurrentIndex(0)
    for s, qs in self.same.items():
        self.multiple_list.addItem(f"P{s} -&gt; P{qs}")

</t>
<t tx="leo.20231205084739.343">def __reload_quote_choose(self) -&gt; None:
    """Reload joints from 'pos' dict."""
    s_old = self.quote_choose.currentText()
    self.quote_choose.clear()
    for i in self.pos:
        if i not in self.same:
            self.quote_choose.addItem(f'P{i}')
    self.quote_choose.setCurrentIndex(self.quote_choose.findText(s_old))

</t>
<t tx="leo.20231205084739.344">@Slot(name='on_add_btn_clicked')
def __add_cus(self) -&gt; None:
    """Add a custom point by dependents."""
    row = self.link_choose.currentIndex()
    if not row &gt; -1:
        return

    try:
        new_num = max(self.cus)
    except ValueError:
        new_num = max(self.pos)
    new_num += 1
    new_name = f"P{new_num}"
    self.cus[new_num] = row
    self.pos[new_num] = (0., 0.)
    self.status[new_num] = False
    self.custom_list.addItem(f"{new_name} -&gt; {self.link_choose.itemText(row)}")
    self.joint_combobox.addItem(new_name)

</t>
<t tx="leo.20231205084739.345">@Slot(name='on_delete_btn_clicked')
def __delete_cus(self) -&gt; None:
    """Remove a custom point."""
    row = self.custom_list.currentRow()
    if not row &gt; -1:
        return

    name = self.custom_list.item(row).text().split(" -&gt; ")[0]
    num = int(name.replace('P', ''))
    self.cus.pop(num)
    self.pos.pop(num)
    self.status.pop(num)
    self.custom_list.takeItem(row)
    self.joint_combobox.removeItem(num)

</t>
<t tx="leo.20231205084739.346">@Slot(str, name='on_quote_choose_currentIndexChanged')
def __set_quote(self, s: str) -&gt; None:
    """Update the joint symbols when switch quote."""
    self.quote_link_choose.clear()
    if not s:
        return

    for row in range(self.link_choose.count()):
        link_text = self.link_choose.itemText(row)
        if s in link_text.replace('(', '').replace(')', '').split(", "):
            self.quote_link_choose.addItem(link_text)

</t>
<t tx="leo.20231205084739.347">@Slot(str, name='on_quote_link_choose_currentIndexChanged')
def __set_quote_link(self, s: str) -&gt; None:
    """Update the joint symbols when switch quote link."""
    self.joint_choose.clear()
    if not s:
        return

    for joint in s.replace('(', '').replace(')', '').split(", "):
        if joint == self.quote_choose.currentText():
            continue
        if int(joint.replace('P', '')) in self.same:
            continue
        self.joint_choose.addItem(joint)

</t>
<t tx="leo.20231205084739.348">@Slot(name='on_add_mj_btn_clicked')
def __add_multi_joint(self) -&gt; None:
    """Add a multiple joint by dependents."""
    s = self.joint_choose.currentText()
    if not s:
        return

    joint = int(s.replace('P', ''))
    qs = self.quote_choose.currentText()
    self.same[joint] = int(qs.replace('P', ''))
    self.multiple_list.addItem(f"{s} -&gt; {qs}")
    self.__reload_quote_choose()

</t>
<t tx="leo.20231205084739.349">@Slot(name='on_delete_mj_btn_clicked')
def __delete_multi_joint(self) -&gt; None:
    """Remove a multiple joint."""
    row = self.multiple_list.currentRow()
    if not row &gt; -1:
        return

    name = self.multiple_list.item(row).text().split(" -&gt; ")[0]
    joint = int(name.replace('P', ''))
    self.same.pop(joint)
    self.multiple_list.takeItem(row)
    self.__reload_quote_choose()
</t>
<t tx="leo.20231205084739.35">add_param(frame)
add_param(boundary)
# Circles
for x, y in centers:
    writer.param_num += 0x10
    writer.param_val(writer.param_num, x)
    writer.param_num += 1
    writer.param_val(writer.param_num, y)
    # Shift to 0x40
    writer.param_num += 0x2f
    writer.param_val(writer.param_num, radius / 2)
    writer.param_shift16()
# Arc
for i in range(len(boundary)):
    cx, cy = centers[i]
    writer.param_num += 0x10
    for x, y in arc_coords(i, cx, cy):
        writer.param_val(writer.param_num, x)
        writer.param_num += 1
        writer.param_val(writer.param_num, y)
        writer.param_num += 2
    writer.param_shift16()

# Group 2:
point_count = len(centers)
# The number of same points
point_num: List[List[int]] = [[] for _ in range(point_count)]
# The number of same lines
line_num: List[List[int]] = [[] for _ in range(len(frame))]

</t>
<t tx="leo.20231205084739.350">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/collections/dialogs/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'customs.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.351">class Ui_Dialog(object):
    @others
</t>
<t tx="leo.20231205084739.352">def setupUi(self, Dialog):
    Dialog.setObjectName("Dialog")
    Dialog.resize(388, 627)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:configure.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Dialog.setWindowIcon(icon)
    Dialog.setSizeGripEnabled(True)
    Dialog.setModal(True)
    self.verticalLayout_3 = QtWidgets.QVBoxLayout(Dialog)
    self.verticalLayout_3.setObjectName("verticalLayout_3")
    self.new_group = QtWidgets.QGroupBox(Dialog)
    self.new_group.setObjectName("new_group")
    self.horizontalLayout_3 = QtWidgets.QHBoxLayout(self.new_group)
    self.horizontalLayout_3.setObjectName("horizontalLayout_3")
    self.custom_list = QtWidgets.QListWidget(self.new_group)
    self.custom_list.setObjectName("custom_list")
    self.horizontalLayout_3.addWidget(self.custom_list)
    self.verticalLayout = QtWidgets.QVBoxLayout()
    self.verticalLayout.setObjectName("verticalLayout")
    self.link_choose_label = QtWidgets.QLabel(self.new_group)
    self.link_choose_label.setObjectName("link_choose_label")
    self.verticalLayout.addWidget(self.link_choose_label)
    self.link_choose = QtWidgets.QComboBox(self.new_group)
    self.link_choose.setObjectName("link_choose")
    self.verticalLayout.addWidget(self.link_choose)
    spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout.addItem(spacerItem)
    self.add_btn = QtWidgets.QPushButton(self.new_group)
    self.add_btn.setObjectName("add_btn")
    self.verticalLayout.addWidget(self.add_btn)
    self.delete_btn = QtWidgets.QPushButton(self.new_group)
    icon1 = QtGui.QIcon()
    icon1.addPixmap(QtGui.QPixmap("icons:delete.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.delete_btn.setIcon(icon1)
    self.delete_btn.setObjectName("delete_btn")
    self.verticalLayout.addWidget(self.delete_btn)
    self.horizontalLayout_3.addLayout(self.verticalLayout)
    self.verticalLayout_3.addWidget(self.new_group)
    self.multiple_group = QtWidgets.QGroupBox(Dialog)
    self.multiple_group.setObjectName("multiple_group")
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.multiple_group)
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    self.multiple_list = QtWidgets.QListWidget(self.multiple_group)
    self.multiple_list.setObjectName("multiple_list")
    self.horizontalLayout_2.addWidget(self.multiple_list)
    self.verticalLayout_2 = QtWidgets.QVBoxLayout()
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.quote_choose_label = QtWidgets.QLabel(self.multiple_group)
    self.quote_choose_label.setObjectName("quote_choose_label")
    self.verticalLayout_2.addWidget(self.quote_choose_label)
    self.quote_choose = QtWidgets.QComboBox(self.multiple_group)
    self.quote_choose.setObjectName("quote_choose")
    self.verticalLayout_2.addWidget(self.quote_choose)
    self.quote_link_choose_label = QtWidgets.QLabel(self.multiple_group)
    self.quote_link_choose_label.setObjectName("quote_link_choose_label")
    self.verticalLayout_2.addWidget(self.quote_link_choose_label)
    self.quote_link_choose = QtWidgets.QComboBox(self.multiple_group)
    self.quote_link_choose.setObjectName("quote_link_choose")
    self.verticalLayout_2.addWidget(self.quote_link_choose)
    self.joint_choose_label = QtWidgets.QLabel(self.multiple_group)
    self.joint_choose_label.setObjectName("joint_choose_label")
    self.verticalLayout_2.addWidget(self.joint_choose_label)
    self.joint_choose = QtWidgets.QComboBox(self.multiple_group)
    self.joint_choose.setObjectName("joint_choose")
    self.verticalLayout_2.addWidget(self.joint_choose)
    spacerItem1 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_2.addItem(spacerItem1)
    self.add_mj_btn = QtWidgets.QPushButton(self.multiple_group)
    self.add_mj_btn.setObjectName("add_mj_btn")
    self.verticalLayout_2.addWidget(self.add_mj_btn)
    self.delete_mj_btn = QtWidgets.QPushButton(self.multiple_group)
    self.delete_mj_btn.setIcon(icon1)
    self.delete_mj_btn.setObjectName("delete_mj_btn")
    self.verticalLayout_2.addWidget(self.delete_mj_btn)
    self.horizontalLayout_2.addLayout(self.verticalLayout_2)
    self.verticalLayout_3.addWidget(self.multiple_group)
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout.addItem(spacerItem2)
    self.btn_box = QtWidgets.QDialogButtonBox(Dialog)
    self.btn_box.setStandardButtons(QtWidgets.QDialogButtonBox.Close)
    self.btn_box.setObjectName("btn_box")
    self.horizontalLayout.addWidget(self.btn_box)
    self.verticalLayout_3.addLayout(self.horizontalLayout)

    self.retranslateUi(Dialog)
    self.btn_box.rejected.connect(Dialog.reject)
    QtCore.QMetaObject.connectSlotsByName(Dialog)

</t>
<t tx="leo.20231205084739.353">def retranslateUi(self, Dialog):
    _translate = QtCore.QCoreApplication.translate
    Dialog.setWindowTitle(_translate("Dialog", "Custom points"))
    self.new_group.setTitle(_translate("Dialog", "New joints"))
    self.link_choose_label.setText(_translate("Dialog", "Belong with the link of:"))
    self.add_btn.setText(_translate("Dialog", "Add"))
    self.delete_btn.setText(_translate("Dialog", "Delete"))
    self.multiple_group.setTitle(_translate("Dialog", "Multiple joints"))
    self.quote_choose_label.setText(_translate("Dialog", "Quoted from:"))
    self.quote_link_choose_label.setText(_translate("Dialog", "Belong with:"))
    self.joint_choose_label.setText(_translate("Dialog", "Joint:"))
    self.add_mj_btn.setText(_translate("Dialog", "Add"))
    self.delete_mj_btn.setText(_translate("Dialog", "Delete"))
</t>
<t tx="leo.20231205084739.354">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/collections/dialogs/
# -*- coding: utf-8 -*-

"""The option dialog to specify target points."""

from __future__ import annotations

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import List, Iterable, Iterator
from qtpy.QtCore import Slot, Qt
from qtpy.QtWidgets import QWidget, QDialog, QListWidget, QListWidgetItem
from .targets_ui import Ui_Dialog


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.355">def list_texts(widget: QListWidget) -&gt; Iterator[str]:
    """Generator to get the text from list widget."""
    for row in range(widget.count()):
        yield widget.item(row).text()


</t>
<t tx="leo.20231205084739.356">class TargetsDialog(QDialog, Ui_Dialog):
    """Option dialog.

    Select the targets from a group of options.
    """

    @others
</t>
<t tx="leo.20231205084739.357">def __init__(
    self,
    description: str,
    prefix: str,
    not_target: Iterable[int],
    target: Iterable[int],
    parent: QWidget
):
    """Filter and show the target option (just like movable points)."""
    super(TargetsDialog, self).__init__(parent)
    self.setupUi(self)
    self.setWindowFlags(self.windowFlags()
                        &amp; ~Qt.WindowContextHelpButtonHint)
    self.main_label.setText(description)
    self.prefix = prefix
    self.other_list.addItems(f"{self.prefix}{i}" for i in not_target)
    self.targets_list.addItems(f"{self.prefix}{i}" for i in target)

</t>
<t tx="leo.20231205084739.358">@Slot(name='on_targets_add_clicked')
@Slot(QListWidgetItem, name='on_other_list_itemDoubleClicked')
def __add(self) -&gt; None:
    """Add a new target joint."""
    row = self.other_list.currentRow()
    if not row &gt; -1:
        return
    self.targets_list.addItem(self.other_list.takeItem(row))

</t>
<t tx="leo.20231205084739.359">@Slot(name='on_other_add_clicked')
@Slot(QListWidgetItem, name='on_targets_list_itemDoubleClicked')
def __remove(self) -&gt; None:
    """Remove a target joint."""
    row = self.targets_list.currentRow()
    if not row &gt; -1:
        return
    self.other_list.addItem(self.targets_list.takeItem(row))

</t>
<t tx="leo.20231205084739.36">def segment_processing(edges: Sequence[_CoordsPair], *,
                       is_frame: bool = True) -&gt; None:
    """Add edges to work plane. (No any constraint.)"""
    # Add "Request"
    for _ in range(len(edges)):
        writer.request_line(writer.request_num)
        writer.request_num += 1

    # Add "Entity"
    p_counter = _by_frame() if is_frame else _by_boundary(len(point_num))
    for index, edge in enumerate(edges):
        writer.entity_line(writer.entity_num)
        for j, coord in enumerate(edge):
            writer.entity_num += 1
            point_num[next(p_counter)].append(writer.entity_num)
            writer.entity_point_2d(writer.entity_num, coord.x, coord.y)
            line_num[index].append(writer.entity_num)
        writer.entity_shift16()

</t>
<t tx="leo.20231205084739.360">def targets(self) -&gt; List[int]:
    """Return a list of targets."""
    target_list = []
    for target in list_texts(self.targets_list):
        target_list.append(int(target[len(self.prefix):]))
    return target_list
</t>
<t tx="leo.20231205084739.361">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/collections/dialogs/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'targets.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.362">class Ui_Dialog(object):
    @others
</t>
<t tx="leo.20231205084739.363">def setupUi(self, Dialog):
    Dialog.setObjectName("Dialog")
    Dialog.resize(346, 309)
    Dialog.setSizeGripEnabled(True)
    Dialog.setModal(True)
    self.verticalLayout_4 = QtWidgets.QVBoxLayout(Dialog)
    self.verticalLayout_4.setObjectName("verticalLayout_4")
    self.main_label = QtWidgets.QLabel(Dialog)
    self.main_label.setObjectName("main_label")
    self.verticalLayout_4.addWidget(self.main_label)
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.verticalLayout_3 = QtWidgets.QVBoxLayout()
    self.verticalLayout_3.setObjectName("verticalLayout_3")
    self.other_label = QtWidgets.QLabel(Dialog)
    self.other_label.setObjectName("other_label")
    self.verticalLayout_3.addWidget(self.other_label)
    self.other_list = QtWidgets.QListWidget(Dialog)
    self.other_list.setObjectName("other_list")
    self.verticalLayout_3.addWidget(self.other_list)
    self.horizontalLayout.addLayout(self.verticalLayout_3)
    self.verticalLayout = QtWidgets.QVBoxLayout()
    self.verticalLayout.setObjectName("verticalLayout")
    self.targets_add = QtWidgets.QPushButton(Dialog)
    self.targets_add.setMaximumSize(QtCore.QSize(30, 16777215))
    self.targets_add.setObjectName("targets_add")
    self.verticalLayout.addWidget(self.targets_add)
    self.other_add = QtWidgets.QPushButton(Dialog)
    self.other_add.setMaximumSize(QtCore.QSize(30, 16777215))
    self.other_add.setObjectName("other_add")
    self.verticalLayout.addWidget(self.other_add)
    self.horizontalLayout.addLayout(self.verticalLayout)
    self.verticalLayout_2 = QtWidgets.QVBoxLayout()
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.targets_label = QtWidgets.QLabel(Dialog)
    self.targets_label.setObjectName("targets_label")
    self.verticalLayout_2.addWidget(self.targets_label)
    self.targets_list = QtWidgets.QListWidget(Dialog)
    self.targets_list.setObjectName("targets_list")
    self.verticalLayout_2.addWidget(self.targets_list)
    self.horizontalLayout.addLayout(self.verticalLayout_2)
    self.verticalLayout_4.addLayout(self.horizontalLayout)
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_2.addItem(spacerItem)
    self.btn_box = QtWidgets.QDialogButtonBox(Dialog)
    self.btn_box.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok)
    self.btn_box.setObjectName("btn_box")
    self.horizontalLayout_2.addWidget(self.btn_box)
    self.verticalLayout_4.addLayout(self.horizontalLayout_2)

    self.retranslateUi(Dialog)
    self.btn_box.accepted.connect(Dialog.accept)
    self.btn_box.rejected.connect(Dialog.reject)
    QtCore.QMetaObject.connectSlotsByName(Dialog)

</t>
<t tx="leo.20231205084739.364">def retranslateUi(self, Dialog):
    _translate = QtCore.QCoreApplication.translate
    Dialog.setWindowTitle(_translate("Dialog", "Select Option"))
    self.other_label.setText(_translate("Dialog", "To be selected:"))
    self.targets_add.setText(_translate("Dialog", "&gt;&gt;"))
    self.other_add.setText(_translate("Dialog", "&lt;&lt;"))
    self.targets_label.setText(_translate("Dialog", "Tragets:"))
</t>
<t tx="leo.20231205084739.365">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/collections/dialogs/
# -*- coding: utf-8 -*-

"""'dialogs' module contains the dialog of this tab."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from .collections import CollectionsDialog
from .customs import CustomsDialog
from .targets import TargetsDialog, list_texts
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.366"></t>
<t tx="leo.20231205084739.367">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/dimensional_synthesis/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'dimension_widget.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.37">segment_processing(frame, is_frame=True)
center_num = [nums[0] for nums in point_num]
# Add "Constraint"
# Same point constraint
for p in point_num:
    for p_ in p[1:]:
        writer.constraint_point(writer.constraint_num, p[0], p_)
        writer.constraint_num += 1
for i, (n1, n2) in enumerate(line_num):
    p1, p2 = frame[i]
    writer.constraint_distance(writer.constraint_num, n1, n2,
                               p1.distance(p2))
    writer.constraint_num += 1
# Add "Constraint" of position
for i, c in enumerate(frame[0]):
    writer.constraint_grounded(writer.constraint_num, point_num[i][0], c.x, c.y)
    if i == 1:
        writer.script_constraint.pop()
        writer.constraint_num += 1
    else:
        writer.constraint_num += 2

# Group 3:
writer.set_group(0x3)

# The number of same points
point_num = [[] for _ in range(len(boundary))]
# The number of same lines
line_num = [[] for _ in range(len(boundary))]
segment_processing(boundary)
# The number of circles
circles = []

</t>
<t tx="leo.20231205084739.38">def add_circle(index: int, _x: float, _y: float) -&gt; None:
    """Add circle"""
    # Add "Request"
    writer.request_circle(writer.request_num)
    writer.request_num += 1
    # Add "Entity"
    writer.entity_circle(writer.entity_num)
    circles.append(writer.entity_num)
    writer.entity_num += 1
    writer.entity_point_2d(writer.entity_num, _x, _y)
    num = writer.entity_num
    # Shift to 0x20
    writer.entity_num += 0x1f
    writer.entity_normal_2d(writer.entity_num, num)
    # Shift to 0x40
    writer.entity_num += 0x20
    writer.entity_distance(writer.entity_num, radius / 2)
    writer.entity_shift16()
    # Add "Constraint" for centers
    writer.constraint_point(writer.constraint_num, num, center_num[index])
    writer.constraint_num += 1
    # Add "Constraint" for diameter
    if index == 0:
        writer.constraint_diameter(writer.constraint_num, circles[-1],
                                   radius)
    else:
        writer.constraint_equal_radius(writer.constraint_num, circles[-1],
                                       circles[0])
    writer.constraint_num += 1

</t>
<t tx="leo.20231205084739.39">def add_arc(index: int, _cx: float, _cy: float) -&gt; None:
    """Add arc"""
    # Add "Request"
    writer.request_arc(writer.request_num)
    writer.request_num += 1
    # Add "Entity"
    writer.entity_arc(writer.entity_num)
    circles.append(writer.entity_num)
    p3 = []
    for ax, ay in arc_coords(index, _cx, _cy):
        writer.entity_num += 1
        writer.entity_point_2d(writer.entity_num, ax, ay)
        p3.append(writer.entity_num)
    writer.entity_num += 0x3d
    writer.entity_normal_2d(writer.entity_num, p3[0])
    writer.entity_shift16()
    # Add "Constraint" for three points
    num1 = point_num[index][0]
    num2 = point_num[index][1]
    if num1 % 16 &lt; num2 % 16:
        num1, num2 = num2, num1
    for j, num in enumerate([center_num[index], num1, num2]):
        writer.constraint_point(writer.constraint_num, p3[j], num)
        writer.constraint_num += 1
    # Add "Constraint" for diameter
    if index == 0:
        writer.constraint_diameter(writer.constraint_num, circles[-1],
                                   radius * 2)
    else:
        writer.constraint_equal_radius(writer.constraint_num, circles[-1],
                                       circles[0])
    writer.constraint_num += 1
    # Add "Constraint" for become tangent line
    for j, num in enumerate((num1 - num1 % 16, num2 - num2 % 16)):
        writer.constraint_arc_line_tangent(
            writer.constraint_num,
            circles[-1],
            num,
            reverse=(j == 1)
        )
        writer.constraint_num += 1

</t>
<t tx="leo.20231205084739.4">def new_image(self, **kwargs) -&gt; ndarray:
    """Build the image class."""
    return full((self.pixel_size, self.pixel_size, 3), 255, dtype=uint8)

</t>
<t tx="leo.20231205084739.40">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/slvs/
# -*- coding: utf-8 -*-

"""Solvespace format output function."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Tuple, List, Set, Dict
from pyslvs import VLink


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.41">class SlvsParser:
    """Use to read data from solvespace file format."""
    groups: List[Dict[str, str]]
    requests: List[Dict[str, str]]
    entities: List[Dict[str, str]]
    constraints: List[Dict[str, str]]

    @others
</t>
<t tx="leo.20231205084739.42">def __init__(self, file_name: str):
    """Open the file when initialize."""
    self.groups = []
    self.requests = []
    self.entities = []
    self.constraints = []
    dataset: Dict[str, List[Dict[str, str]]] = {
        'AddGroup': self.groups,
        'AddParam': [],
        'AddRequest': self.requests,
        'AddEntity': self.entities,
        'AddConstraint': self.constraints,
    }
    args: Dict[str, str] = {}
    with open(file_name, 'r', encoding="iso-8859-15") as f:
        if f.readline() != "±²³SolveSpaceREVa\n":
            return
        for line in f:
            if line == '\n':
                args = {}
            elif '=' in line:
                attribute, data = line[:-1].split('=')
                args[attribute] = data
            elif line[:-1] in dataset:
                dataset[line[:-1]].append(args)

</t>
<t tx="leo.20231205084739.43">def is_valid(self) -&gt; bool:
    """Simple check whether if file is valid."""
    return bool(self.groups)

</t>
<t tx="leo.20231205084739.44">def get_groups(self) -&gt; List[Tuple[str, str]]:
    """Read and return group names."""
    groups = []
    for group in self.groups:
        # Number code and group name
        groups.append((
            group['Group.h.v'],
            "".join(x for x in group['Group.name'] if x.isalnum() or x in "._- ")
        ))
    return groups[1:]

</t>
<t tx="leo.20231205084739.45">def parse(self, group: str) -&gt; str:
    """Parse as PMKS expression for specified group.

    + Requests: Get all links.
        + Independence points will be ignored.
    + Constraint: Adjacency.
        + Collecting links for each point.
    + Entities: Get positions.
    """

    def int16(n: str) -&gt; int:
        """Generate 16 bit interger."""
        return int(n, 16)

    # Requests: Get all links
    requests = []
    for request in self.requests:
        if request['Request.group.v'] == group:
            # 0x4 &lt;&lt; 16 == 0x40000
            requests.append(int16(request['Request.h.v']) &lt;&lt; 16)

    links: Dict[int, Set[int]] = {link: {link + 1, link + 2} for link in requests}
    links[0] = set()

    # Constraint: Adjacency
    # Grounded. Other links at least will greater than 4
    for constraint in self.constraints:
        if constraint['Constraint.group.v'] != group:
            continue
        if constraint['Constraint.type'] == '20':
            now_replace = int16(constraint['Constraint.ptA.v'])
            for vlink in links.values():
                num = int16(constraint['Constraint.ptB.v'])
                if num in vlink:
                    vlink.remove(num)
                    vlink.add(now_replace)
        elif constraint['Constraint.type'] == '31':
            links[0].add(int16(constraint['Constraint.ptA.v']))

    pos: Dict[int, Tuple[str, str]] = {}
    for vlink in links.values():
        for point in vlink:
            if point not in pos:
                pos[point] = ('0', '0')

    # Entities: Get positions
    for entity in self.entities:
        if entity['Entity.type'] != '2001':
            continue
        num = int16(entity['Entity.h.v'])
        if num in pos:
            pos[num] = (
                entity.get('Entity.actPoint.x', '0'),
                entity.get('Entity.actPoint.y', '0'),
            )

    # Rename link names
    vlinks = {}
    for i, name in enumerate(sorted(links)):
        if i == 0:
            vlinks[VLink.FRAME] = links.pop(name)
        else:
            vlinks[f'link_{i - 1}'] = links.pop(name)
    exprs = []
    for num in sorted(pos):
        x, y = pos[num]
        links_str = ", ".join(name for name, link in vlinks.items() if num in link)
        exprs.append(f"J[R, color[Green], P[{x}, {y}], L[{links_str}]]")
    return "M[" + ", ".join(exprs) + "]"
</t>
<t tx="leo.20231205084739.46">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/slvs/
# -*- coding: utf-8 -*-

"""Solvespace format output function.

This module are use a workplane and two groups for sketching and placing
comments.
But the number codes can decide by functions.
The number code is all hexadecimal.

Here is the type codes of Solvespace (from "sketch.h"):

class EntityBase {
public:
    enum class Type : uint32_t {
        POINT_IN_3D            =  2000,
        POINT_IN_2D            =  2001,
        POINT_N_TRANS          =  2010,
        POINT_N_ROT_TRANS      =  2011,
        POINT_N_COPY           =  2012,
        POINT_N_ROT_AA         =  2013,

        NORMAL_IN_3D           =  3000,
        NORMAL_IN_2D           =  3001,
        NORMAL_N_COPY          =  3010,
        NORMAL_N_ROT           =  3011,
        NORMAL_N_ROT_AA        =  3012,

        DISTANCE               =  4000,
        DISTANCE_N_COPY        =  4001,

        FACE_NORMAL_PT         =  5000,
        FACE_XPROD             =  5001,
        FACE_N_ROT_TRANS       =  5002,
        FACE_N_TRANS           =  5003,
        FACE_N_ROT_AA          =  5004,

        WORKPLANE              = 10000,
        LINE_SEGMENT           = 11000,
        CUBIC                  = 12000,
        CUBIC_PERIODIC         = 12001,
        CIRCLE                 = 13000,
        ARC_OF_CIRCLE          = 14000,
        TTF_TEXT               = 15000,
        IMAGE                  = 16000
    };
}

class ConstraintBase {
public:
    enum class Type : uint32_t {
        POINTS_COINCIDENT      =  20,
        PT_PT_DISTANCE         =  30,
        PT_PLANE_DISTANCE      =  31,
        PT_LINE_DISTANCE       =  32,
        PT_FACE_DISTANCE       =  33,
        PROJ_PT_DISTANCE       =  34,
        PT_IN_PLANE            =  41,
        PT_ON_LINE             =  42,
        PT_ON_FACE             =  43,
        EQUAL_LENGTH_LINES     =  50,
        LENGTH_RATIO           =  51,
        EQ_LEN_PT_LINE_D       =  52,
        EQ_PT_LN_DISTANCES     =  53,
        EQUAL_ANGLE            =  54,
        EQUAL_LINE_ARC_LEN     =  55,
        LENGTH_DIFFERENCE      =  56,
        SYMMETRIC              =  60,
        SYMMETRIC_HORIZ        =  61,
        SYMMETRIC_VERT         =  62,
        SYMMETRIC_LINE         =  63,
        AT_MIDPOINT            =  70,
        HORIZONTAL             =  80,
        VERTICAL               =  81,
        DIAMETER               =  90,
        PT_ON_CIRCLE           = 100,
        SAME_ORIENTATION       = 110,
        ANGLE                  = 120,
        PARALLEL               = 121,
        PERPENDICULAR          = 122,
        ARC_LINE_TANGENT       = 123,
        CUBIC_LINE_TANGENT     = 124,
        CURVE_CURVE_TANGENT    = 125,
        EQUAL_RADIUS           = 130,
        WHERE_DRAGGED          = 200,

        COMMENT                = 1000
    };
}
"""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import List


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.47">def _shift16(num: int) -&gt; int:
    """Left shift with 16 bit.

    Usage:
    &gt;&gt;&gt; hex(_shift16(0x20009))
    0x30000
    """
    ten = 1 &lt;&lt; 16
    return num + ten - (num % ten)


</t>
<t tx="leo.20231205084739.48">class SlvsWriter2:
    """Use to save data with solvespace file format."""
    script_param: List[str]
    script_request: List[str]
    script_entity: List[str]
    script_constraint: List[str]

    @others
</t>
<t tx="leo.20231205084739.49">def __init__(
    self,
    *,
    group: int = 0x2,
    comment_group: int = 0x3,
    workplane: int = 0x80020000
):
    """Initialize the settings and collections."""
    self.__group = group
    self.__comment_group = comment_group
    self.__workplane = workplane

    self.script_group = ["±²³SolveSpaceREVa\n"]
    self.group_origin(0x1)
    self.group_normal(0x2, "sketch-in-plane")
    self.group_normal(0x3, "comments")

    self.param_num = 0x40000
    self.script_param = []
    for n in range(3):
        self.param(0x10010 + n)
    self.param_val(0x10020, 1)
    for n in range(1, 4):
        self.param(0x10020 + n)
    for n in range(3):
        self.param(0x20010 + n)
    for n in range(4):
        self.param_val(0x20020 + n, 0.5)
    for n in range(3):
        self.param(0x30010 + n)
    for n in range(4):
        self.param_val(0x30020 + n, 0.5 if (n == 0) else -0.5)

    self.request_num = 0x4
    self.script_request = []
    for n in range(1, 4):
        self.request_workplane(n)

    self.entity_num = 0x40000
    self.script_entity = []
    self.entity_plane(0x10000, 0x10001, 0x10020)
    self.entity_point(0x10001)
    self.entity_normal_3d(0x10020, 0x10001)
    self.entity_plane(0x20000, 0x20001, 0x20020)
    self.entity_point(0x20001)
    self.entity_normal_3d_wxyz(0x20020, 0x20001)
    self.entity_plane(0x30000, 0x30001, 0x30020)
    self.entity_point(0x30001)
    self.entity_normal_3d_wxyz(0x30020, 0x30001, reverse=True)

    self.constraint_num = 0x1
    self.script_constraint = []

</t>
<t tx="leo.20231205084739.5">def drawrect(self, row: int, col: int) -&gt; None:
    """Draw a single rectangle of the QR code."""
    (x, y), (x2, y2) = self.pixel_box(row, col)
    for r in range(self.box_size):
        self._img[y + r, x:x2 + 1] = (0, 0, 0)

</t>
<t tx="leo.20231205084739.50">def set_group(self, num: int) -&gt; None:
    """Set the group number."""
    self.__group = num

</t>
<t tx="leo.20231205084739.51">def set_comment_group(self, num: int) -&gt; None:
    """Set the comment group number."""
    self.__comment_group = num

</t>
<t tx="leo.20231205084739.52">def set_workplane(self, num: int) -&gt; None:
    """Set main workplane."""
    self.__workplane = num

</t>
<t tx="leo.20231205084739.53">def param_shift16(self) -&gt; None:
    """Shift param counting."""
    self.param_num = _shift16(self.param_num)

</t>
<t tx="leo.20231205084739.54">def entity_shift16(self) -&gt; None:
    """Shift entity counting."""
    self.entity_num = _shift16(self.entity_num)

</t>
<t tx="leo.20231205084739.55">def group_origin(self, num: int = 1, name: str = "#references") -&gt; None:
    """First group called "#references"."""
    self.script_group.append('\n'.join([
        f"Group.h.v={num:08x}",
        f"Group.type={5000}",
        f"Group.name={name}",
        "Group.color=ff000000",
        "Group.skipFirst=0",
        "Group.predef.swapUV=0",
        "Group.predef.negateU=0",
        "Group.predef.negateV=0",
        "Group.visible=1",
        "Group.suppress=0",
        "Group.relaxConstraints=0",
        "Group.allowRedundant=0",
        "Group.allDimsReference=0",
        "Group.remap={\n}",
        "AddGroup",
    ]))

</t>
<t tx="leo.20231205084739.56">def group_normal(self, num: int, name: str) -&gt; None:
    """A normal group."""
    self.script_group.append('\n'.join([
        f"Group.h.v={num:08x}",
        f"Group.type={5001}",
        "Group.order=1",
        f"Group.name={name}",
        f"Group.activeWorkplane.v={self.__workplane:08x}",
        "Group.color=ff000000",
        "Group.subtype=6000",
        "Group.skipFirst=0",
        f"Group.predef.q.w={1:.020f}",
        f"Group.predef.origin.v={(1 &lt;&lt; 16) + 1:08x}",
        "Group.predef.swapUV=0",
        "Group.predef.negateU=0",
        "Group.predef.negateV=0",
        "Group.visible=1",
        "Group.suppress=0",
        "Group.relaxConstraints=0",
        "Group.allowRedundant=0",
        "Group.allDimsReference=0",
        "Group.remap={\n}",
        "AddGroup",
    ]))

</t>
<t tx="leo.20231205084739.57">def param(self, num: int) -&gt; None:
    """A no value parameter."""
    self.script_param.append('\n'.join((
        f"Param.h.v.={num:08x}",
        "AddParam",
    )))

</t>
<t tx="leo.20231205084739.58">def param_val(self, num: int, val: float) -&gt; None:
    """A value parameter."""
    self.script_param.append('\n'.join([
        f"Param.h.v.={num:08x}",
        f"Param.val={val:.20f}",
        "AddParam",
    ]))

</t>
<t tx="leo.20231205084739.59">def request(self, num: int, type_i: int) -&gt; None:
    """A request for an entity."""
    self.script_request.append('\n'.join([
        f"Request.h.v={num:08x}",
        f"Request.type={type_i}",
        f"Request.workplane.v={self.__workplane:08x}",
        f"Request.group.v={self.__group:08x}",
        "Request.construction=0",
        "AddRequest",
    ]))

</t>
<t tx="leo.20231205084739.6">def get_qimage(self) -&gt; QImage:
    """To QImage."""
    height, width, color = self._img.shape
    return QImage(
        self._img.data,
        width,
        height,
        color * height,
        QImage.Format_RGB888
    )

</t>
<t tx="leo.20231205084739.60">def request_workplane(self, num: int) -&gt; None:
    """Workplane request."""
    self.script_request.append('\n'.join([
        f"Request.h.v={num:08x}",
        f"Request.type={100}",
        f"Request.group.v={1:08x}",
        "Request.construction=0",
        "AddRequest",
    ]))

</t>
<t tx="leo.20231205084739.61">def request_line(self, num: int) -&gt; None:
    """Line segment request."""
    self.request(num, 200)

</t>
<t tx="leo.20231205084739.62">def request_arc(self, num: int) -&gt; None:
    """Arc request."""
    self.request(num, 500)

</t>
<t tx="leo.20231205084739.63">def request_circle(self, num: int) -&gt; None:
    """Circle request."""
    self.request(num, 400)

</t>
<t tx="leo.20231205084739.64">def entity_plane(self, num: int, origin: int, normal: int) -&gt; None:
    """A workplane."""
    self.script_entity.append('\n'.join([
        f"Entity.h.v={num:08x}",
        f"Entity.type={10000}",
        "Entity.construction=0",
        f"Entity.point[0].v={origin:08x}",
        f"Entity.normal.v={normal:08x}",
        "Entity.actVisible=1",
        "AddEntity",
    ]))

</t>
<t tx="leo.20231205084739.65">def entity_point(self, num: int) -&gt; None:
    """A independent point."""
    self.script_entity.append('\n'.join([
        f"Entity.h.v={num:08x}",
        f"Entity.type={2000}",
        "Entity.construction=0",
        "Entity.actVisible=1",
        "AddEntity",
    ]))

</t>
<t tx="leo.20231205084739.66">def entity_normal(self, num: int, p: int, type_i: int) -&gt; None:
    """A 3D normal."""
    self.script_entity.append('\n'.join([
        f"Entity.h.v={num:08x}",
        f"Entity.type={type_i}",
        "Entity.construction=0",
        f"Entity.point[0].v={p:08x}",
        f"Entity.actNormal.w={1:.020f}",
        "Entity.actVisible=1",
        "AddEntity",
    ]))

</t>
<t tx="leo.20231205084739.67">def entity_normal_3d(self, num: int, p: int) -&gt; None:
    """A 3D normal."""
    self.entity_normal(num, p, 3000)

</t>
<t tx="leo.20231205084739.68">def entity_normal_3d_wxyz(self, num: int, p: int, *,
                          reverse: bool = False) -&gt; None:
    """A 3D normal from quaternion."""
    unit = -0.5 if reverse else 0.5
    self.script_entity.append('\n'.join([
        f"Entity.h.v={num:08x}",
        f"Entity.type={3000}",
        "Entity.construction=0",
        f"Entity.point[0].v={p:08x}",
        f"Entity.actNormal.w={0.5:.020f}",
        f"Entity.actNormal.vx={unit:.020f}",
        f"Entity.actNormal.vy={unit:.020f}",
        f"Entity.actNormal.vz={unit:.020f}",
        "Entity.actVisible=1",
        "AddEntity",
    ]))

</t>
<t tx="leo.20231205084739.69">def entity_normal_2d(self, num: int, p: int) -&gt; None:
    """A 2D normal."""
    unit = 1
    self.script_entity.append('\n'.join([
        f"Entity.h.v={num:08x}",
        f"Entity.type={3001}",
        "Entity.construction=0",
        f"Entity.point[0].v={p:08x}",
        f"Entity.workplane.v={self.__workplane:08x}",
        f"Entity.actNormal.w={unit:.020f}",
        "Entity.actVisible=1",
        "AddEntity",
    ]))

</t>
<t tx="leo.20231205084739.7">def save(self, stream, kind=None) -&gt; None:
    """Do nothing."""
    pass


</t>
<t tx="leo.20231205084739.70">def entity_normal_copy(self, num: int, p: int) -&gt; None:
    """A copied normal."""
    self.entity_normal(num, p, 3010)

</t>
<t tx="leo.20231205084739.71">def __2d_point_line(self, t: int, num: int, p1: str, p2: str) -&gt; None:
    """Used for 2D point and line creation."""
    self.script_entity.append('\n'.join([
        f"Entity.h.v={num:08x}",
        f"Entity.type={t}",
        "Entity.construction=0",
        f"Entity.workplane.v={self.__workplane:08x}",
        p1, p2,
        "Entity.actVisible=1",
        "AddEntity",
    ]))

</t>
<t tx="leo.20231205084739.72">def entity_point_2d(self, num: int, x: float, y: float) -&gt; None:
    """A point related with the entity."""
    self.__2d_point_line(2001, num,
                         f"Entity.actPoint.x={x:.20f}",
                         f"Entity.actPoint.y={y:.20f}")

</t>
<t tx="leo.20231205084739.73">def entity_line(self, num: int) -&gt; None:
    """A line segment."""
    self.__2d_point_line(11000, num,
                         f"Entity.point[0].v={num + 1:08x}",
                         f"Entity.point[1].v={num + 2:08x}")

</t>
<t tx="leo.20231205084739.74">def entity_arc(self, num: int) -&gt; None:
    """An arc."""
    self.script_entity.append('\n'.join([
        f"Entity.h.v={num:08x}",
        f"Entity.type={14000}",
        "Entity.construction=0",
        f"Entity.point[0].v={num + 1:08x}",
        f"Entity.point[1].v={num + 2:08x}",
        f"Entity.point[2].v={num + 3:08x}",
        f"Entity.normal.v={num + 0x20:08x}",
        f"Entity.workplane.v={self.__workplane:08x}",
        "Entity.actVisible=1",
        "AddEntity",
    ]))

</t>
<t tx="leo.20231205084739.75">def entity_circle(self, num: int) -&gt; None:
    """A circle."""
    self.script_entity.append('\n'.join([
        f"Entity.h.v={num:08x}",
        f"Entity.type={13000}",
        "Entity.construction=0",
        f"Entity.point[0].v={num + 1:08x}",
        f"Entity.normal.v={num + 0x20:08x}",
        f"Entity.distance.v={num + 0x40:08x}",
        f"Entity.workplane.v={self.__workplane:08x}",
        "Entity.actVisible=1",
        "AddEntity",
    ]))

</t>
<t tx="leo.20231205084739.76">def entity_distance(self, num: int, val: float) -&gt; None:
    """A distance entity."""
    self.script_entity.append('\n'.join([
        f"Entity.h.v={num:08x}",
        f"Entity.type={4000}",
        "Entity.construction=0",
        f"Entity.workplane.v={self.__workplane:08x}",
        f"Entity.actDistance={val:.20f}",
        "Entity.actVisible=1",
        "AddEntity",
    ]))

</t>
<t tx="leo.20231205084739.77">def __cons_point_radius(self, t: int, num: int, e1: str, e2: str) -&gt; None:
    """Used for point / radius equally constrain creation."""
    self.script_constraint.append('\n'.join([
        f"Constraint.h.v={num:08x}",
        f"Constraint.type={t}",
        f"Constraint.group.v={self.__group:08x}",
        f"Constraint.workplane.v={self.__workplane:08x}",
        e1, e2,
        "Constraint.other=0",
        "Constraint.other2=0",
        "Constraint.reference=0",
        "AddConstraint",
    ]))

</t>
<t tx="leo.20231205084739.78">def constraint_point(self, num: int, p1: int, p2: int) -&gt; None:
    """Constraint two points as same one."""
    self.__cons_point_radius(20, num,
                             f"Constraint.ptA.v={p1:08x}",
                             f"Constraint.ptB.v={p2:08x}")

</t>
<t tx="leo.20231205084739.79">def constraint_equal_radius(self, num: int, e1: int, e2: int) -&gt; None:
    """Constraint two arcs or circles are be the same radius."""
    self.__cons_point_radius(130, num,
                             f"Constraint.entityA.v={e1:08x}",
                             f"Constraint.entityB.v={e2:08x}")

</t>
<t tx="leo.20231205084739.8">def slvs_process_script(
    script: Sequence[str],
    inputs: Sequence[Tuple[int, int]]
) -&gt; str:
    """Return parser function script."""
    return _SCRIPT.format(
        '\n'.join(" " * 8 + f'"{expr}, "' for expr in script),
        inputs,
        {pair: 0. for pair in inputs}
    )


</t>
<t tx="leo.20231205084739.80">def constraint_grounded(
    self,
    num: int,
    p0: int,
    x: float,
    y: float,
    *,
    offset: int = 10
):
    """Constraint two distance between two workplane."""

    def constraint_fix_hv(n: int, phv: int, val: float) -&gt; None:
        """Constraint a distance from a point to a plane."""
        self.script_constraint.append('\n'.join([
            f"Constraint.h.v={n:08x}",
            f"Constraint.type={31}",
            f"Constraint.group.v={self.__group:08x}",
            f"Constraint.workplane.v={self.__workplane:08x}",
            f"Constraint.valA={val:.20f}",
            f"Constraint.ptA.v={p0:08x}",
            f"Constraint.entityA.v={phv:08x}",
            "Constraint.other=0",
            "Constraint.other2=0",
            "Constraint.reference=0",
            f"Constraint.disp.offset.x={offset:.20f}",
            f"Constraint.disp.offset.y={offset:.20f}",
            "AddConstraint",
        ]))

    constraint_fix_hv(num, 0x30000, y)
    constraint_fix_hv(num + 1, 0x20000, x)

</t>
<t tx="leo.20231205084739.81">def __cons_val(self, t: int, num: int, a: int, b: int, val: float, *,
               offset: float = 10) -&gt; None:
    """Used for valued constrain creation."""
    self.script_constraint.append('\n'.join([
        f"Constraint.h.v={num:08x}",
        f"Constraint.type={t}",
        f"Constraint.group.v={self.__group:08x}",
        f"Constraint.workplane.v={self.__workplane:08x}",
        f"Constraint.valA={val:.20f}",
        f"Constraint.ptA.v={a:08x}",
        f"Constraint.ptB.v={b:08x}",
        "Constraint.other=0",
        "Constraint.other2=0",
        "Constraint.reference=0",
        f"Constraint.disp.offset.x={offset:.20f}",
        f"Constraint.disp.offset.y={offset:.20f}",
        "AddConstraint",
    ]))

</t>
<t tx="leo.20231205084739.82">def constraint_distance(self, num: int, p1: int, p2: int, length: float, *,
                        offset: float = 10):
    """Constraint the distance of line segment."""
    self.__cons_val(30, num, p1, p2, length, offset=offset)

</t>
<t tx="leo.20231205084739.83">def constraint_angle(self, num: int, l1: int, l2: int, angle: float, *,
                     offset: float = 10):
    """Constraint the angle between two line segments."""
    self.__cons_val(120, num, l1, l2, angle, offset=offset)

</t>
<t tx="leo.20231205084739.84">def constraint_diameter(
    self,
    num: int,
    e1: int,
    val: float,
    *,
    offset: float = -1
):
    """Constraint the diameter of a circle."""
    if offset &lt; 0:
        offset = val / 2
    self.script_constraint.append('\n'.join([
        f"Constraint.h.v={num:08x}",
        f"Constraint.type={90}",
        f"Constraint.group.v={self.__group:08x}",
        f"Constraint.workplane.v={self.__workplane:08x}",
        f"Constraint.valA={val:.20f}",
        f"Constraint.entityA.v={e1:08x}",
        "Constraint.other=0",
        "Constraint.other2=0",
        "Constraint.reference=0",
        f"Constraint.disp.offset.x={offset:.20f}",
        f"Constraint.disp.offset.y={offset:.20f}",
        "AddConstraint",
    ]))

</t>
<t tx="leo.20231205084739.85">def constraint_arc_line_tangent(
    self,
    num: int,
    e1: int,
    e2: int,
    *,
    reverse: bool = False
):
    """Constraint an arc is tangent with a line."""
    self.script_constraint.append('\n'.join([
        f"Constraint.h.v={num:08x}",
        f"Constraint.type={123}",
        f"Constraint.group.v={self.__group:08x}",
        f"Constraint.workplane.v={self.__workplane:08x}",
        f"Constraint.entityA.v={e1:08x}",
        f"Constraint.entityB.v={e2:08x}",
        f"Constraint.other={1 if reverse else 0}",
        "Constraint.other2=0",
        "Constraint.reference=0",
        "AddConstraint",
    ]))

</t>
<t tx="leo.20231205084739.86">def constraint_comment(
    self,
    num: int,
    comment: str,
    x: float,
    y: float,
    *,
    offset: int = 5
):
    """Comment in group."""
    self.script_constraint.append('\n'.join([
        f"Constraint.h.v={num:08x}",
        f"Constraint.type={1000}",
        f"Constraint.group.v={self.__comment_group:08x}",
        f"Constraint.workplane.v={self.__workplane:08x}",
        "Constraint.other=0",
        "Constraint.other2=0",
        "Constraint.reference=0",
        f"Constraint.comment={comment}",
        f"Constraint.disp.offset.x={x + offset:.20f}",
        f"Constraint.disp.offset.y={y + offset:.20f}",
        "AddConstraint",
    ]))

</t>
<t tx="leo.20231205084739.87">def save(self, file_name: str) -&gt; None:
    """Save the file."""
    self.entity_plane(0x80020000, 0x80020002, 0x80020001)
    self.entity_normal_copy(0x80020001, 0x80020002)
    self.entity_point_2d(0x80020002, 2012, 1)
    with open(file_name, 'w+', encoding="iso-8859-15") as f:
        f.write('\n\n'.join('\n\n'.join(script) for script in [
            self.script_group,
            self.script_param,
            self.script_request,
            self.script_entity,
            self.script_constraint,
        ]) + '\n\n')
</t>
<t tx="leo.20231205084739.88">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/io/slvs/
# -*- coding: utf-8 -*-

"""'slvs' module contains IO support functions of Solvespace format."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from .read import SlvsParser
from .frame import slvs2_frame
from .part import slvs2_part, boundary_loop
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.89"></t>
<t tx="leo.20231205084739.9">def _expr_to_script(exprs: _Expr) -&gt; str:
    cmd = []
    functions = set()
    symbols: Set[str] = set()
    targets = set()
    for expr in exprs:
        func = expr[0].lower()
        target = expr[-1].lower()
        sym = tuple(e.lower() for e in expr[1:-1])
        args = ", ".join(sym)
        cmd.append(" " * 4 + f"{target} = {func}({args})")
        functions.add(func)
        symbols.update(sym)
        targets.add(target)
    script = _CAL_SCRIPT.format(", ".join(sorted(functions)),
                                ", ".join(sorted(symbols - targets)))
    return script + '\n'.join(cmd)


</t>
<t tx="leo.20231205084739.90">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/main_window/
# -*- coding: utf-8 -*-

"""This module contains the functions that main window needed."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import cast, Sequence, Callable, Union
from abc import ABC
from qtpy.QtCore import Slot, QPoint
from qtpy.QtWidgets import QAction, QApplication, QTableWidget
from pyslvs import VLink
from pyslvs_ui.graphics import BaseCanvas
from pyslvs_ui.widgets import EditPointTable, EditLinkTable, Preferences
from pyslvs_ui.io import PreferencesDialog
from .storage import StorageMethodInterface


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084739.91">def _copy_table_data(table: QTableWidget) -&gt; None:
    """Copy item text to clipboard."""
    text = table.currentItem().text()
    if text:
        QApplication.clipboard().setText(text)


</t>
<t tx="leo.20231205084739.92">class ActionMethodInterface(StorageMethodInterface, ABC):
    """Abstract class for action methods."""

    @others
</t>
<t tx="leo.20231205084739.93">def __enable_point_context(self) -&gt; None:
    """Adjust the status of QActions.

    What ever we have least one point or not,
    need to enable / disable QAction.
    """
    selection = self.entities_point.selected_rows()
    # Set grounded state
    if selection:
        self.action_p_lock.setChecked(all(
            VLink.FRAME in self.vpoint_list[row].links for row in selection
        ))
    self.context.point_enable(len(selection))

    def mj_func(order: int) -&gt; Callable[[], None]:
        """Generate a merge function."""
        @others
        return func

    for i, p in enumerate(selection):
        action = QAction(f"Base on Point{p}", self)
        action.triggered.connect(mj_func(i))
        self.pop_point_m.addAction(action)

</t>
<t tx="leo.20231205084739.94">@Slot()
def func() -&gt; None:
    self.__merge_joint(order, selection)
</t>
<t tx="leo.20231205084739.95">def __enable_link_context(self) -&gt; None:
    """Enable / disable link's QAction, same as point table."""
    selection = self.entities_link.selected_rows()
    row = self.entities_link.currentRow()
    self.context.link_enable(len(selection), row)

    def ml_func(order: int) -&gt; Callable[[], None]:
        """Generate a merge function."""
        @others
        return func

    for i, row in enumerate(selection):
        action = QAction(f"Base on \"{self.vlink_list[row].name}\"", self)
        action.triggered.connect(ml_func(i))
        self.pop_link_m.addAction(action)

</t>
<t tx="leo.20231205084739.96">@Slot(int)
def func() -&gt; None:
    self.__merge_link(order, selection)
</t>
<t tx="leo.20231205084739.97">def __merge_joint(self, index: int, points: Sequence[int]) -&gt; None:
    """Merge the joints into a specific joint."""
    base = points[index]
    self.cmd_stack.beginMacro(
        f"Merge {sorted(points)} based on {{Point{base}}}"
    )
    links = list(self.vpoint_list[base].links)
    args = self.entities_point.row_data(base)
    for p in points:
        if p != base:
            links.extend(set(self.vpoint_list[p].links) - set(links))
    args.links = ','.join(links)
    self.cmd_stack.push(EditPointTable(
        base,
        self.vpoint_list,
        self.vlink_list,
        self.entities_point,
        self.entities_link,
        args
    ))
    for p in sorted(points, reverse=True):
        if p != base:
            self.delete_point(p)
    self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.98">def __merge_link(self, index: int, links: Sequence[int]) -&gt; None:
    """Merge links to a base link.

    @index: The index of main joint in the sequence.
    """
    row = links[index]
    links_text = ", ".join(self.vlink_list[link].name for link in links)
    name = self.vlink_list[row].name
    self.cmd_stack.beginMacro(f"Merge {{{links_text}}} to joint {{{name}}}")
    points = list(self.vlink_list[row].points)
    args = self.entities_link.row_data(row)
    for link in sorted(links, reverse=True):
        if self.vlink_list[link].name == self.vlink_list[row].name:
            continue
        for point in self.vlink_list[link].points:
            if point not in points:
                points.append(point)
        self.delete_link(link)
    args.points = ','.join(f'Point{p}' for p in points)
    row = [vlink.name for vlink in self.vlink_list].index(args.name)
    self.cmd_stack.push(EditLinkTable(
        row,
        self.vpoint_list,
        self.vlink_list,
        self.entities_point,
        self.entities_link,
        args
    ))
    self.cmd_stack.endMacro()

</t>
<t tx="leo.20231205084739.99">@Slot(float, float)
def set_mouse_pos(self, x: float, y: float) -&gt; None:
    """Mouse position on canvas."""
    self.mouse_pos_x = x
    self.mouse_pos_y = y

</t>
<t tx="leo.20231205084740.1">class Ui_Form(object):
    @others
</t>
<t tx="leo.20231205084740.10">@Slot(name='on_clear_btn_clicked')
def __user_clear(self) -&gt; None:
    if not self.profile_name.text():
        return
    if QMessageBox.question(
        self,
        "Clear setting",
        "Do you want to clear the setting?"
    ) == QMessageBox.Yes:
        self.__clear_settings()

</t>
<t tx="leo.20231205084740.100">def __init__(
    self,
    algorithm: AlgorithmType,
    mech: Dict[str, Any],
    setting: Dict[str, Any],
    parent
):
    super(ProgressDialog, self).__init__(parent)
    self.setupUi(self)
    self.setWindowFlags(self.windowFlags()
                        &amp; ~Qt.WindowContextHelpButtonHint)
    self.rejected.connect(self.__close_work)

    self.mechanisms = []
    # Batch label
    if 'max_gen' in setting:
        self.limit = setting['max_gen']
        if self.limit &gt; 0:
            self.batch_label.setText(f"{self.limit} generation(s)")
        else:
            self.batch_label.setText('∞')
        self.limit_mode = 'max_gen'
    elif 'min_fit' in setting:
        self.limit = setting['min_fit']
        self.batch_label.setText(f"fitness less then {self.limit}")
        self.limit_mode = 'min_fit'
    elif 'max_time' in setting:
        self.limit = setting['max_time']
        self.batch_label.setText(
            f"{self.limit // 3600:02d}:"
            f"{self.limit % 3600 // 60:02d}:"
            f"{self.limit % 3600 % 60:02d}"
        )
        self.limit_mode = 'max_time'
    else:
        self.limit = 0
        self.batch_label.setText('∞')
        self.limit_mode = 'max_gen'
    self.loopTime.setEnabled(self.limit &gt; 0)

    # Timer
    self.time = 0
    self.timer = QTimer()
    self.timer.setInterval(1000)
    self.timer.timeout.connect(self.__set_time)
    self.time_spend = 0.

    # Worker thread
    self.work = DimensionalThread(algorithm, mech, setting, self)
    self.stop_signal.connect(self.work.stop)
    if self.work.planar.is_two_kernel():
        self.fast_kernel_label.hide()
    else:
        self.full_kernel_label.hide()
    self.work.progress_update.connect(self.__set_progress)
    self.work.result.connect(self.__get_result)
    self.work.finished.connect(self.__finish)

</t>
<t tx="leo.20231205084740.101">@Slot(int, str)
def __set_progress(self, progress: int, fitness: str) -&gt; None:
    """Progress bar will always full if no generation counter."""
    value = progress + self.limit * self.work.loop
    if self.limit_mode in {'min_fit', 'max_time'} or self.limit == 0:
        self.progress_bar.setMaximum(value)
    self.progress_bar.setValue(value)
    self.fitness_label.setText(fitness)

</t>
<t tx="leo.20231205084740.102">@Slot()
def __set_time(self) -&gt; None:
    """Set time label."""
    self.time += 1
    t_min = self.time % 3600
    self.time_label.setText(
        f"{self.time // 3600:02d}:"
        f"{t_min // 60:02d}:"
        f"{t_min % 60:02d}"
    )

</t>
<t tx="leo.20231205084740.103">@Slot(name='on_start_btn_clicked')
def __start(self) -&gt; None:
    """Start the process."""
    loop = self.loopTime.value()
    self.progress_bar.setMaximum(self.limit * loop)
    if self.limit_mode in {'min_fit', 'max_time'} or self.limit == 0:
        # Progress bar will show generations instead of percent
        self.progress_bar.setFormat("%v generations")
    self.work.set_loop(loop)
    self.timer.start()
    self.work.start()
    self.start_btn.setEnabled(False)
    self.loopTime.setEnabled(False)
    self.interrupt_btn.setEnabled(True)

</t>
<t tx="leo.20231205084740.104">@Slot(dict)
def __get_result(self, mechanism: Dict[str, Any]) -&gt; None:
    """Get the result."""
    self.mechanisms.append(mechanism)
    self.time_spend += mechanism['time']

</t>
<t tx="leo.20231205084740.105">@Slot()
def __finish(self) -&gt; None:
    """Finish the process."""
    self.timer.stop()
    self.work.wait()
    self.accept()

</t>
<t tx="leo.20231205084740.106">@Slot(name='on_interrupt_btn_clicked')
def __interrupt(self) -&gt; None:
    """Interrupt the process."""
    if self.work.isRunning():
        self.stop_signal.emit()
        logger.info("The thread has been interrupted.")

</t>
<t tx="leo.20231205084740.107">@Slot()
def __close_work(self) -&gt; None:
    """Close the thread."""
    if not self.work.isRunning():
        return
    self.stop_signal.emit()
    logger.info("The thread has been canceled.")
    self.work.wait()
</t>
<t tx="leo.20231205084740.108">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/dimensional_synthesis/dialogs/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'progress.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.109">class Ui_Dialog(object):
    @others
</t>
<t tx="leo.20231205084740.11">def load_results(self, mechanism_data: Sequence[Mapping[str, Any]]) -&gt; None:
    """Append results of project database to memory."""
    for e in mechanism_data:
        self.mechanism_data.append(dict(e))
        self.__add_result(e)

</t>
<t tx="leo.20231205084740.110">def setupUi(self, Dialog):
    Dialog.setObjectName("Dialog")
    Dialog.resize(567, 197)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:dimensional_synthesis.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Dialog.setWindowIcon(icon)
    Dialog.setModal(True)
    self.verticalLayout = QtWidgets.QVBoxLayout(Dialog)
    self.verticalLayout.setObjectName("verticalLayout")
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    self.label_6 = QtWidgets.QLabel(Dialog)
    self.label_6.setObjectName("label_6")
    self.horizontalLayout_2.addWidget(self.label_6)
    self.time_label = QtWidgets.QLabel(Dialog)
    self.time_label.setObjectName("time_label")
    self.horizontalLayout_2.addWidget(self.time_label)
    spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_2.addItem(spacerItem)
    self.label_4 = QtWidgets.QLabel(Dialog)
    self.label_4.setObjectName("label_4")
    self.horizontalLayout_2.addWidget(self.label_4)
    self.batch_label = QtWidgets.QLabel(Dialog)
    self.batch_label.setObjectName("batch_label")
    self.horizontalLayout_2.addWidget(self.batch_label)
    self.label_7 = QtWidgets.QLabel(Dialog)
    self.label_7.setObjectName("label_7")
    self.horizontalLayout_2.addWidget(self.label_7)
    self.loopTime = QtWidgets.QSpinBox(Dialog)
    self.loopTime.setMinimum(1)
    self.loopTime.setMaximum(10)
    self.loopTime.setObjectName("loopTime")
    self.horizontalLayout_2.addWidget(self.loopTime)
    self.label_5 = QtWidgets.QLabel(Dialog)
    self.label_5.setObjectName("label_5")
    self.horizontalLayout_2.addWidget(self.label_5)
    self.verticalLayout.addLayout(self.horizontalLayout_2)
    spacerItem1 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout.addItem(spacerItem1)
    self.fast_kernel_label = QtWidgets.QLabel(Dialog)
    self.fast_kernel_label.setWordWrap(True)
    self.fast_kernel_label.setObjectName("fast_kernel_label")
    self.verticalLayout.addWidget(self.fast_kernel_label)
    self.full_kernel_label = QtWidgets.QLabel(Dialog)
    self.full_kernel_label.setWordWrap(True)
    self.full_kernel_label.setObjectName("full_kernel_label")
    self.verticalLayout.addWidget(self.full_kernel_label)
    self.interrupt_label = QtWidgets.QLabel(Dialog)
    self.interrupt_label.setWordWrap(True)
    self.interrupt_label.setObjectName("interrupt_label")
    self.verticalLayout.addWidget(self.interrupt_label)
    self.progress_bar = QtWidgets.QProgressBar(Dialog)
    self.progress_bar.setObjectName("progress_bar")
    self.verticalLayout.addWidget(self.progress_bar)
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setSpacing(6)
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.label_3 = QtWidgets.QLabel(Dialog)
    self.label_3.setObjectName("label_3")
    self.horizontalLayout.addWidget(self.label_3)
    self.fitness_label = QtWidgets.QLabel(Dialog)
    self.fitness_label.setObjectName("fitness_label")
    self.horizontalLayout.addWidget(self.fitness_label)
    spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout.addItem(spacerItem2)
    self.start_btn = QtWidgets.QPushButton(Dialog)
    self.start_btn.setObjectName("start_btn")
    self.horizontalLayout.addWidget(self.start_btn)
    self.interrupt_btn = QtWidgets.QPushButton(Dialog)
    self.interrupt_btn.setEnabled(False)
    self.interrupt_btn.setObjectName("interrupt_btn")
    self.horizontalLayout.addWidget(self.interrupt_btn)
    self.btn_box = QtWidgets.QDialogButtonBox(Dialog)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.btn_box.sizePolicy().hasHeightForWidth())
    self.btn_box.setSizePolicy(sizePolicy)
    self.btn_box.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel)
    self.btn_box.setObjectName("btn_box")
    self.horizontalLayout.addWidget(self.btn_box)
    self.verticalLayout.addLayout(self.horizontalLayout)

    self.retranslateUi(Dialog)
    self.btn_box.rejected.connect(Dialog.reject)
    QtCore.QMetaObject.connectSlotsByName(Dialog)

</t>
<t tx="leo.20231205084740.111">def retranslateUi(self, Dialog):
    _translate = QtCore.QCoreApplication.translate
    Dialog.setWindowTitle(_translate("Dialog", "Dimensional Synthesis"))
    self.label_6.setText(_translate("Dialog", "Time spent:"))
    self.time_label.setText(_translate("Dialog", "00:00:00"))
    self.label_4.setText(_translate("Dialog", "Batch execution:"))
    self.label_7.setText(_translate("Dialog", "with"))
    self.label_5.setText(_translate("Dialog", "time(s)."))
    self.fast_kernel_label.setText(_translate("Dialog", "&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=\" color:#00aa00;\"&gt;※ The mechanism of configuration has enabled logical acceleration process, the performance can be more faster.&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"))
    self.full_kernel_label.setText(_translate("Dialog", "&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=\" color:#ff0000;\"&gt;※ The mechanism of configuration has enabled full CAD kernel process, the performance might be more slower.&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"))
    self.interrupt_label.setText(_translate("Dialog", "&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=\" color:#ff0000;\"&gt;※ The interrupt button will stop the process, but you can keep the result.&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"))
    self.label_3.setText(_translate("Dialog", "Fitness: "))
    self.fitness_label.setText(_translate("Dialog", "N/A"))
    self.start_btn.setText(_translate("Dialog", "Start"))
    self.interrupt_btn.setText(_translate("Dialog", "Interrupt"))
</t>
<t tx="leo.20231205084740.112">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/dimensional_synthesis/dialogs/
# -*- coding: utf-8 -*-

"""Thread of dimensional synthesis."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import cast, Dict, Any
from time import process_time
from platform import system, release, machine, processor
from qtpy.QtCore import Signal
from qtpy.QtWidgets import QWidget
from pyslvs.optimization import FPlanar, FConfig
from pyslvs.metaheuristics import algorithm, AlgorithmType, Setting
from pyslvs_ui.info import logger
from pyslvs_ui.synthesis.thread import BaseThread


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.113">class DimensionalThread(BaseThread):
    """The QThread class to handle algorithm."""
    progress_update = Signal(int, str)
    result = Signal(dict)

    @others
</t>
<t tx="leo.20231205084740.114">def __init__(
    self,
    alg: AlgorithmType,
    mech: Dict[str, Any],
    settings: Dict[str, Any],
    parent: QWidget
):
    super(DimensionalThread, self).__init__(parent)
    self.alg = alg
    self.mech = cast(FConfig, mech)
    self.planar = FPlanar(self.mech)
    self.settings = cast(Setting, settings)
    self.loop = 1

</t>
<t tx="leo.20231205084740.115">def set_loop(self, loop: int) -&gt; None:
    """Set the loop times."""
    self.loop = loop

</t>
<t tx="leo.20231205084740.116">def run(self) -&gt; None:
    """Start the algorithm loop."""
    for name, path in self.mech['target'].items():
        logger.debug(f"- [P{name}] ({len(path)})")
    t0 = process_time()
    for self.loop in range(self.loop):
        logger.info(f"Algorithm [{self.loop + 1}]: {self.alg}")
        if self.is_stop:
            # Cancel the remaining tasks
            logger.info("Canceled.")
            continue
        self.result.emit(self.__task())
    logger.info(f"total cost time: {process_time() - t0:.02f} [s]")
    self.finished.emit()

</t>
<t tx="leo.20231205084740.117">def __task(self) -&gt; Dict[str, Any]:
    """Get the algorithm result."""
    t0 = process_time()
    a = algorithm(self.alg)(
        self.planar,
        self.settings,
        progress_fun=self.progress_update.emit,
        interrupt_fun=lambda: self.is_stop,
    )
    expression = a.run()
    tf = a.history()
    time_spend = process_time() - t0
    last_gen = tf[-1][0]
    mechanism = {
        'algorithm': self.alg.value,
        'time': time_spend,
        'last_gen': last_gen,
        'last_fitness': tf[-1][1],
        'interrupted': str(last_gen) if self.is_stop else 'False',
        'settings': self.settings,
        'hardware_info': {
            'os': f"{system()} {release()} {machine()}",
            'cpu': processor(),
        },
        'time_fitness': tf,
        'callback': self.planar.callback,
    }
    mechanism.update(self.mech)
    mechanism['expression'] = expression
    logger.info(f"cost time: {time_spend:.02f} [s]")
    return mechanism
</t>
<t tx="leo.20231205084740.118">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/dimensional_synthesis/dialogs/
# -*- coding: utf-8 -*-

"""'dialogs' module contains contains the dialog of this tab."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from .options import AlgorithmOptionDialog
from .edit_path import EditPathDialog
from .progress import ProgressDialog
from .preview import PreviewDialog
from .chart import ChartDialog
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.119"></t>
<t tx="leo.20231205084740.12">def __current_path_changed(self) -&gt; None:
    """Call the canvas to update to current target path."""
    self.set_solving_path({n: tuple(p) for n, p in self.path.items()})
    self.__able_to_generate()

</t>
<t tx="leo.20231205084740.120">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/structure_synthesis/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'structure_widget.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.121">class Ui_Form(object):
    @others
</t>
<t tx="leo.20231205084740.122">def setupUi(self, Form):
    Form.setObjectName("Form")
    Form.resize(444, 654)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:number.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Form.setWindowIcon(icon)
    self.verticalLayout = QtWidgets.QVBoxLayout(Form)
    self.verticalLayout.setObjectName("verticalLayout")
    self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_4.setObjectName("horizontalLayout_4")
    self.edges_label = QtWidgets.QLabel(Form)
    self.edges_label.setObjectName("edges_label")
    self.horizontalLayout_4.addWidget(self.edges_label)
    self.edges_text = QtWidgets.QLineEdit(Form)
    self.edges_text.setReadOnly(True)
    self.edges_text.setObjectName("edges_text")
    self.horizontalLayout_4.addWidget(self.edges_text)
    self.expr_copy = QtWidgets.QPushButton(Form)
    icon1 = QtGui.QIcon()
    icon1.addPixmap(QtGui.QPixmap("icons:copy.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.expr_copy.setIcon(icon1)
    self.expr_copy.setObjectName("expr_copy")
    self.horizontalLayout_4.addWidget(self.expr_copy)
    self.expr_add_collection = QtWidgets.QPushButton(Form)
    self.expr_add_collection.setText("")
    icon2 = QtGui.QIcon()
    icon2.addPixmap(QtGui.QPixmap("icons:collections.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.expr_add_collection.setIcon(icon2)
    self.expr_add_collection.setObjectName("expr_add_collection")
    self.horizontalLayout_4.addWidget(self.expr_add_collection)
    self.from_mechanism_btn = QtWidgets.QPushButton(Form)
    icon3 = QtGui.QIcon()
    icon3.addPixmap(QtGui.QPixmap("icons:merge_from.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.from_mechanism_btn.setIcon(icon3)
    self.from_mechanism_btn.setAutoDefault(True)
    self.from_mechanism_btn.setDefault(True)
    self.from_mechanism_btn.setObjectName("from_mechanism_btn")
    self.horizontalLayout_4.addWidget(self.from_mechanism_btn)
    self.verticalLayout.addLayout(self.horizontalLayout_4)
    self.line = QtWidgets.QFrame(Form)
    self.line.setFrameShape(QtWidgets.QFrame.HLine)
    self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line.setObjectName("line")
    self.verticalLayout.addWidget(self.line)
    self.main_splitter = QtWidgets.QSplitter(Form)
    self.main_splitter.setOrientation(QtCore.Qt.Vertical)
    self.main_splitter.setObjectName("main_splitter")
    self.verticalLayoutWidget = QtWidgets.QWidget(self.main_splitter)
    self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")
    self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
    self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.gridLayout = QtWidgets.QGridLayout()
    self.gridLayout.setObjectName("gridLayout")
    self.nj_label = QtWidgets.QLabel(self.verticalLayoutWidget)
    self.nj_label.setObjectName("nj_label")
    self.gridLayout.addWidget(self.nj_label, 0, 1, 1, 1)
    self.nl_label = QtWidgets.QLabel(self.verticalLayoutWidget)
    self.nl_label.setObjectName("nl_label")
    self.gridLayout.addWidget(self.nl_label, 0, 0, 1, 1)
    self.nl_input = QtWidgets.QSpinBox(self.verticalLayoutWidget)
    self.nl_input.setMinimum(4)
    self.nl_input.setObjectName("nl_input")
    self.gridLayout.addWidget(self.nl_input, 2, 0, 1, 1)
    self.nj_input = QtWidgets.QSpinBox(self.verticalLayoutWidget)
    self.nj_input.setMinimum(4)
    self.nj_input.setObjectName("nj_input")
    self.gridLayout.addWidget(self.nj_input, 2, 1, 1, 1)
    self.dof_label = QtWidgets.QLabel(self.verticalLayoutWidget)
    self.dof_label.setObjectName("dof_label")
    self.gridLayout.addWidget(self.dof_label, 0, 2, 1, 1)
    self.dof = QtWidgets.QSpinBox(self.verticalLayoutWidget)
    self.dof.setEnabled(False)
    self.dof.setMinimum(-99)
    self.dof.setProperty("value", 1)
    self.dof.setObjectName("dof")
    self.gridLayout.addWidget(self.dof, 2, 2, 1, 1)
    self.verticalLayout_2.addLayout(self.gridLayout)
    self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_7.setObjectName("horizontalLayout_7")
    self.graph_degenerate = QtWidgets.QComboBox(self.verticalLayoutWidget)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.graph_degenerate.sizePolicy().hasHeightForWidth())
    self.graph_degenerate.setSizePolicy(sizePolicy)
    self.graph_degenerate.setObjectName("graph_degenerate")
    self.graph_degenerate.addItem("")
    self.graph_degenerate.addItem("")
    self.graph_degenerate.addItem("")
    self.horizontalLayout_7.addWidget(self.graph_degenerate)
    spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_7.addItem(spacerItem)
    self.keep_dof = QtWidgets.QCheckBox(self.verticalLayoutWidget)
    self.keep_dof.setChecked(True)
    self.keep_dof.setObjectName("keep_dof")
    self.horizontalLayout_7.addWidget(self.keep_dof)
    self.verticalLayout_2.addLayout(self.horizontalLayout_7)
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    self.number_synthesis_btn = QtWidgets.QPushButton(self.verticalLayoutWidget)
    self.number_synthesis_btn.setAutoDefault(True)
    self.number_synthesis_btn.setObjectName("number_synthesis_btn")
    self.horizontalLayout_2.addWidget(self.number_synthesis_btn)
    self.assortment_clear_btn = QtWidgets.QPushButton(self.verticalLayoutWidget)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.assortment_clear_btn.sizePolicy().hasHeightForWidth())
    self.assortment_clear_btn.setSizePolicy(sizePolicy)
    icon4 = QtGui.QIcon()
    icon4.addPixmap(QtGui.QPixmap("icons:clean.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.assortment_clear_btn.setIcon(icon4)
    self.assortment_clear_btn.setObjectName("assortment_clear_btn")
    self.horizontalLayout_2.addWidget(self.assortment_clear_btn)
    self.verticalLayout_2.addLayout(self.horizontalLayout_2)
    self.link_assortment_list = QtWidgets.QTreeWidget(self.verticalLayoutWidget)
    self.link_assortment_list.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
    self.link_assortment_list.setIndentation(10)
    self.link_assortment_list.setObjectName("link_assortment_list")
    self.verticalLayout_2.addWidget(self.link_assortment_list)
    self.verticalLayoutWidget_2 = QtWidgets.QWidget(self.main_splitter)
    self.verticalLayoutWidget_2.setObjectName("verticalLayoutWidget_2")
    self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_2)
    self.verticalLayout_3.setContentsMargins(0, 0, 0, 0)
    self.verticalLayout_3.setObjectName("verticalLayout_3")
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.graph_engine = QtWidgets.QComboBox(self.verticalLayoutWidget_2)
    self.graph_engine.setObjectName("graph_engine")
    self.horizontalLayout.addWidget(self.graph_engine)
    self.reload_atlas = QtWidgets.QPushButton(self.verticalLayoutWidget_2)
    self.reload_atlas.setText("")
    icon5 = QtGui.QIcon()
    icon5.addPixmap(QtGui.QPixmap("icons:data_update.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.reload_atlas.setIcon(icon5)
    self.reload_atlas.setObjectName("reload_atlas")
    self.horizontalLayout.addWidget(self.reload_atlas)
    spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout.addItem(spacerItem1)
    self.graph_link_as_node = QtWidgets.QCheckBox(self.verticalLayoutWidget_2)
    self.graph_link_as_node.setObjectName("graph_link_as_node")
    self.horizontalLayout.addWidget(self.graph_link_as_node)
    self.graph_show_label = QtWidgets.QCheckBox(self.verticalLayoutWidget_2)
    self.graph_show_label.setChecked(True)
    self.graph_show_label.setObjectName("graph_show_label")
    self.horizontalLayout.addWidget(self.graph_show_label)
    self.verticalLayout_3.addLayout(self.horizontalLayout)
    self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_5.setObjectName("horizontalLayout_5")
    self.structure_synthesis_all_btn = QtWidgets.QPushButton(self.verticalLayoutWidget_2)
    self.structure_synthesis_all_btn.setMaximumSize(QtCore.QSize(100, 16777215))
    self.structure_synthesis_all_btn.setAutoDefault(True)
    self.structure_synthesis_all_btn.setObjectName("structure_synthesis_all_btn")
    self.horizontalLayout_5.addWidget(self.structure_synthesis_all_btn)
    self.structure_synthesis_btn = QtWidgets.QPushButton(self.verticalLayoutWidget_2)
    self.structure_synthesis_btn.setObjectName("structure_synthesis_btn")
    self.horizontalLayout_5.addWidget(self.structure_synthesis_btn)
    self.structure_list_clear_btn = QtWidgets.QPushButton(self.verticalLayoutWidget_2)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.structure_list_clear_btn.sizePolicy().hasHeightForWidth())
    self.structure_list_clear_btn.setSizePolicy(sizePolicy)
    self.structure_list_clear_btn.setIcon(icon4)
    self.structure_list_clear_btn.setObjectName("structure_list_clear_btn")
    self.horizontalLayout_5.addWidget(self.structure_list_clear_btn)
    self.verticalLayout_3.addLayout(self.horizontalLayout_5)
    self.structure_list = QtWidgets.QListWidget(self.verticalLayoutWidget_2)
    self.structure_list.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.structure_list.setIconSize(QtCore.QSize(200, 200))
    self.structure_list.setResizeMode(QtWidgets.QListView.Adjust)
    self.structure_list.setViewMode(QtWidgets.QListView.IconMode)
    self.structure_list.setUniformItemSizes(True)
    self.structure_list.setObjectName("structure_list")
    self.verticalLayout_3.addWidget(self.structure_list)
    self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_3.setObjectName("horizontalLayout_3")
    self.save_edges = QtWidgets.QPushButton(self.verticalLayoutWidget_2)
    icon6 = QtGui.QIcon()
    icon6.addPixmap(QtGui.QPixmap("icons:save_file.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.save_edges.setIcon(icon6)
    self.save_edges.setObjectName("save_edges")
    self.horizontalLayout_3.addWidget(self.save_edges)
    self.save_atlas = QtWidgets.QPushButton(self.verticalLayoutWidget_2)
    icon7 = QtGui.QIcon()
    icon7.addPixmap(QtGui.QPixmap("icons:picture.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.save_atlas.setIcon(icon7)
    self.save_atlas.setObjectName("save_atlas")
    self.horizontalLayout_3.addWidget(self.save_atlas)
    self.edges2atlas_btn = QtWidgets.QPushButton(self.verticalLayoutWidget_2)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.edges2atlas_btn.sizePolicy().hasHeightForWidth())
    self.edges2atlas_btn.setSizePolicy(sizePolicy)
    icon8 = QtGui.QIcon()
    icon8.addPixmap(QtGui.QPixmap("icons:edges_to_atlas.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.edges2atlas_btn.setIcon(icon8)
    self.edges2atlas_btn.setIconSize(QtCore.QSize(40, 16))
    self.edges2atlas_btn.setObjectName("edges2atlas_btn")
    self.horizontalLayout_3.addWidget(self.edges2atlas_btn)
    self.verticalLayout_3.addLayout(self.horizontalLayout_3)
    self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_6.setObjectName("horizontalLayout_6")
    self.time_title_label = QtWidgets.QLabel(self.verticalLayoutWidget_2)
    self.time_title_label.setObjectName("time_title_label")
    self.horizontalLayout_6.addWidget(self.time_title_label)
    self.time_label = QtWidgets.QLabel(self.verticalLayoutWidget_2)
    self.time_label.setObjectName("time_label")
    self.horizontalLayout_6.addWidget(self.time_label)
    self.paint_time_title_label = QtWidgets.QLabel(self.verticalLayoutWidget_2)
    self.paint_time_title_label.setObjectName("paint_time_title_label")
    self.horizontalLayout_6.addWidget(self.paint_time_title_label)
    self.paint_time_label = QtWidgets.QLabel(self.verticalLayoutWidget_2)
    self.paint_time_label.setObjectName("paint_time_label")
    self.horizontalLayout_6.addWidget(self.paint_time_label)
    spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_6.addItem(spacerItem2)
    self.verticalLayout_3.addLayout(self.horizontalLayout_6)
    self.verticalLayout.addWidget(self.main_splitter)

    self.retranslateUi(Form)
    self.graph_degenerate.setCurrentIndex(1)
    self.graph_engine.setCurrentIndex(-1)
    QtCore.QMetaObject.connectSlotsByName(Form)

</t>
<t tx="leo.20231205084740.123">def retranslateUi(self, Form):
    _translate = QtCore.QCoreApplication.translate
    Form.setWindowTitle(_translate("Form", "Form"))
    self.edges_label.setText(_translate("Form", "Edge Set:"))
    self.expr_copy.setStatusTip(_translate("Form", "Copy expression."))
    self.expr_add_collection.setStatusTip(_translate("Form", "Add to collection."))
    self.from_mechanism_btn.setStatusTip(_translate("Form", "Analyze current mechanism from canvas."))
    self.nj_label.setToolTip(_translate("Form", "Number of joints"))
    self.nj_label.setText(_translate("Form", "NJ (?)"))
    self.nl_label.setToolTip(_translate("Form", "Number of links"))
    self.nl_label.setText(_translate("Form", "NL (?)"))
    self.dof_label.setToolTip(_translate("Form", "Degree of freedom"))
    self.dof_label.setText(_translate("Form", "DOF (?)"))
    self.graph_degenerate.setItemText(0, _translate("Form", "Only degenerate"))
    self.graph_degenerate.setItemText(1, _translate("Form", "No degenerate"))
    self.graph_degenerate.setItemText(2, _translate("Form", "All"))
    self.keep_dof.setStatusTip(_translate("Form", "Keep the degrees of freedom when adjusting numbers."))
    self.keep_dof.setText(_translate("Form", "Keep DOF"))
    self.number_synthesis_btn.setStatusTip(_translate("Form", "Find the possible number of different joints."))
    self.number_synthesis_btn.setText(_translate("Form", "Number Synthesis"))
    self.link_assortment_list.headerItem().setText(0, _translate("Form", "Link Assortment"))
    self.link_assortment_list.headerItem().setText(1, _translate("Form", "Count"))
    self.graph_engine.setStatusTip(_translate("Form", "Layout engine from NetworkX."))
    self.reload_atlas.setToolTip(_translate("Form", "Re-layout"))
    self.graph_link_as_node.setStatusTip(_translate("Form", "Show the edges as vertices."))
    self.graph_link_as_node.setText(_translate("Form", "Link as node"))
    self.graph_show_label.setText(_translate("Form", "Labels"))
    self.structure_synthesis_all_btn.setStatusTip(_translate("Form", "Find the structure of mechanism from all numbers."))
    self.structure_synthesis_all_btn.setText(_translate("Form", "Find All"))
    self.structure_synthesis_btn.setText(_translate("Form", "Find by Assortment"))
    self.save_edges.setStatusTip(_translate("Form", "Save the edges of atlas to text file."))
    self.save_edges.setText(_translate("Form", "Save as list"))
    self.save_atlas.setStatusTip(_translate("Form", "Save the atlas to image file."))
    self.save_atlas.setText(_translate("Form", "Save as image"))
    self.edges2atlas_btn.setStatusTip(_translate("Form", "Load the edges data from text file, then save them to image files."))
    self.time_title_label.setText(_translate("Form", "Find in:"))
    self.paint_time_title_label.setText(_translate("Form", "Rendered in:"))
</t>
<t tx="leo.20231205084740.124">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/structure_synthesis/
# -*- coding: utf-8 -*-

"""Thread of structural synthesis."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Sequence, Dict, List
from qtpy.QtCore import Signal
from qtpy.QtWidgets import QWidget, QTreeWidgetItem
from pyslvs.graph import (
    link_synthesis,
    contracted_link_synthesis,
    contracted_graph,
    conventional_graph,
    Graph,
)
from pyslvs_ui.synthesis.thread import BaseThread

Assortment = Sequence[int]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.125">def assortment_eval(links_expr: str) -&gt; Assortment:
    """Return link assortment from expr."""
    return tuple(int(n.split('=')[-1]) for n in links_expr.split(", "))


</t>
<t tx="leo.20231205084740.126">class LinkThread(BaseThread):
    """Link assortment synthesis thread."""

    progress_update = Signal(int)
    result = Signal(dict)
    size_update = Signal(int)

    @others
</t>
<t tx="leo.20231205084740.127">def __init__(self, nl: int, nj: int, parent: QWidget):
    super(LinkThread, self).__init__(parent)
    self.nl = nl
    self.nj = nj

</t>
<t tx="leo.20231205084740.128">def run(self) -&gt; None:
    """Run and return contracted link assortment."""
    try:
        la_list = link_synthesis(self.nl, self.nj, lambda: self.is_stop)
    except ValueError:
        self.progress_update.emit(1)
        self.result.emit({})
        self.finished.emit()
        return

    self.size_update.emit(len(la_list))
    assortment = {}
    for i, la in enumerate(la_list):
        if self.is_stop:
            break
        assortment[la] = contracted_link_synthesis(la, lambda: self.is_stop)
        self.progress_update.emit(1 + i)
    self.result.emit(assortment)
    self.finished.emit()


</t>
<t tx="leo.20231205084740.129">class GraphThread(BaseThread):
    """Graphs enumeration thread."""
    progress_update = Signal(int)
    count_update = Signal(QTreeWidgetItem, int)
    result = Signal(list)

    @others
</t>
<t tx="leo.20231205084740.13">def current_path(self) -&gt; List[_Coord]:
    """Return the pointer of current target path."""
    item = self.target_points.currentItem()
    if item is None:
        return []
    return self.path[int(item.text().replace('P', ''))]

</t>
<t tx="leo.20231205084740.130">def __init__(self, jobs: Sequence[QTreeWidgetItem], degenerate: int, parent: QWidget):
    super(GraphThread, self).__init__(parent)
    self.jobs = jobs
    self.degenerate = degenerate

</t>
<t tx="leo.20231205084740.131">def run(self) -&gt; None:
    """Run and return conventional graph."""
    cg_list: Dict[Sequence[int], List[Graph]] = {}
    answers = []
    for i, item in enumerate(self.jobs):
        if self.is_stop:
            break

        root = item.parent()
        la = assortment_eval(root.text(0))
        cla = assortment_eval(item.text(0))
        if la not in cg_list:
            cg_list[la] = contracted_graph(la, lambda: self.is_stop)

        answer = conventional_graph(
            cg_list[la],
            cla,
            self.degenerate,
            lambda: self.is_stop
        )
        self.count_update.emit(item, len(answer))
        answers.extend(answer)
        self.progress_update.emit(1 + i)

    self.result.emit(answers)
    self.finished.emit()
</t>
<t tx="leo.20231205084740.132">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/structure_synthesis/
# -*- coding: utf-8 -*-

"""'structure_synthesis' module contains
number and type synthesis functional interfaces.
"""

from __future__ import annotations

__all__ = ['StructureSynthesis']
__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import TYPE_CHECKING, List, Sequence, Dict, Optional
from time import process_time
from qtpy.QtCore import (
    Slot,
    Qt,
    QSize,
    QCoreApplication,
    QPoint,
    QPointF,
)
from qtpy.QtWidgets import (
    QWidget,
    QMenu,
    QAction,
    QProgressDialog,
    QMessageBox,
    QApplication,
    QInputDialog,
    QScrollBar,
    QListWidgetItem,
    QTreeWidgetItem,
    QHeaderView,
)
from qtpy.QtGui import QIcon, QPixmap, QImage, QPainter
from pyslvs.graph import Graph, link_assortment, contracted_link_assortment
from pyslvs_ui.qt_patch import qt_image_format
from pyslvs_ui.graphics import graph2icon, engines
from .thread import assortment_eval, LinkThread, GraphThread
from .structure_widget_ui import Ui_Form

if TYPE_CHECKING:
    from pyslvs_ui.widgets import MainWindowBase

Assortment = Sequence[int]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.133">class SynthesisProgressDialog(QProgressDialog):
    """Progress dialog for structure synthesis."""

    @others
</t>
<t tx="leo.20231205084740.134">def __init__(self, title: str, job_name: str, maximum: int, parent: QWidget):
    super(SynthesisProgressDialog, self).__init__(
        job_name,
        "Interrupt",
        0,
        maximum,
        parent
    )
    self.setWindowTitle(title)
    self.resize(400, self.height())
    self.setModal(True)
    self.setValue(0)

</t>
<t tx="leo.20231205084740.135">def stop_func(self) -&gt; bool:
    """Return dialog status."""
    try:
        QCoreApplication.processEvents()
        return self.wasCanceled()
    except ValueError:
        return False


</t>
<t tx="leo.20231205084740.136">class StructureSynthesis(QWidget, Ui_Form):
    """Number and type synthesis widget.

    Calculate the combinations of mechanism family and show the atlas.
    """
    assortment: Dict[Assortment, List[Assortment]]
    answer: List[Graph]

    @others
</t>
<t tx="leo.20231205084740.137">def __init__(self, parent: MainWindowBase):
    """Reference names:

    + IO functions from main window.
    + Table data from PMKS expression.
    + Graph data function from main window.
    """
    super(StructureSynthesis, self).__init__(parent)
    self.setupUi(self)
    header = self.link_assortment_list.header()
    header.setSectionResizeMode(QHeaderView.ResizeToContents)

    # Function references
    self.output_to = parent.output_to
    self.save_reply_box = parent.save_reply_box
    self.input_from_multiple = parent.input_from_multiple
    self.vpoints = parent.vpoint_list
    self.vlinks = parent.vlink_list
    self.get_graph = parent.get_graph
    self.prefer = parent.prefer
    self.add_collection = parent.collections.structure_widget.add_collection
    # Answer list
    self.assortment = {}
    self.answer = []
    # Signals
    self.nl_input.valueChanged.connect(self.__adjust_structure_data)
    self.nj_input.valueChanged.connect(self.__adjust_structure_data)
    self.graph_engine.addItems(engines)
    self.structure_list.customContextMenuRequested.connect(
        self.__structure_list_context_menu
    )

    # Context menu
    self.pop_menu_topo = QMenu(self)
    self.to_collection = QAction(
        QIcon(QPixmap("icons:collections.png")),
        "Add to collections",
        self
    )
    self.copy_edges = QAction("Copy edges", self)
    self.copy_image = QAction("Copy image", self)
    self.pop_menu_topo.addActions([
        self.to_collection,
        self.copy_edges,
        self.copy_image,
    ])

    self.nl_input_old_value = 0
    self.nj_input_old_value = 0
    self.clear()

</t>
<t tx="leo.20231205084740.138">def clear(self) -&gt; None:
    """Clear all sub-widgets."""
    self.edges_text.clear()
    self.__clear_assortment()
    self.__clear_structure_list()
    self.nl_input.setValue(0)
    self.nj_input.setValue(0)
    self.nl_input_old_value = 0
    self.nj_input_old_value = 0
    self.dof.setValue(1)

</t>
<t tx="leo.20231205084740.139">@Slot(name='on_assortment_clear_btn_clicked')
def __clear_assortment(self) -&gt; None:
    """Clear the number synthesis list."""
    self.link_assortment_list.clear()
    self.assortment.clear()

</t>
<t tx="leo.20231205084740.14">@Slot(str, name='on_target_points_currentTextChanged')
def __set_target(self, _=None) -&gt; None:
    """Switch to the current target path."""
    self.path_list.clear()
    for x, y in self.current_path():
        self.path_list.addItem(f"({x:.04f}, {y:.04f})")
    self.__current_path_changed()

</t>
<t tx="leo.20231205084740.140">@Slot(name='on_structure_list_clear_btn_clicked')
def __clear_structure_list(self) -&gt; None:
    """Clear the structure list."""
    self.answer.clear()
    self.structure_list.clear()
    self.time_label.setText("")

</t>
<t tx="leo.20231205084740.141">@Slot(name='on_from_mechanism_btn_clicked')
def __from_mechanism(self) -&gt; None:
    """From a generalized mechanism of main canvas."""
    if self.vpoints and self.vlinks:
        graph, _, _, _, _, _ = self.get_graph()
    else:
        graph = Graph([])
    if graph.edges:
        self.edges_text.setText(str(list(graph.edges)))
    else:
        self.edges_text.setText("")
    keep_dof_checked = self.keep_dof.isChecked()
    self.keep_dof.setChecked(False)
    self.nl_input.setValue(len(graph.vertices))
    self.nj_input.setValue(len(graph.edges))
    self.keep_dof.setChecked(keep_dof_checked)

    # Show attributes
    QMessageBox.information(
        self,
        "Generalization",
        f"Link assortment:\n{link_assortment(graph)}\n"
        f"Contracted link assortment:\n{contracted_link_assortment(graph)}"
        if graph.edges else
        "Is a empty graph."
    )

</t>
<t tx="leo.20231205084740.142">def __adjust_structure_data(self) -&gt; None:
    """Update NJ and NL values.

    If user don't want to keep the DOF:
    Change the DOF then exit.
    """
    if not self.keep_dof.isChecked():
        self.dof.setValue(
            3 * (self.nl_input.value() - 1)
            - 2 * self.nj_input.value()
        )
        return

    # N2: Get the user's adjusted value.
    # NL_func: Get the another value of parameters (N1) by degrees of freedom formula.
    # is_above: Is value increase or decrease?
    if self.sender() is self.nj_input:
        n2 = self.nj_input.value()

        @others
        is_above = n2 &gt; self.nl_input_old_value
    n1 = nl_func()
    while not n1.is_integer():
        n2 += 1 if is_above else -1
        n1 = nl_func()
        if n1 == 0 or n2 == 0:
            break

    n1 = int(n1)
    n2 = int(n2)
    # Return the result values
    # + Value of widgets.
    # + Setting old value record.
    if self.sender() is self.nl_input:
        self.nj_input.setValue(n1)
        self.nl_input.setValue(n2)
        self.nj_input_old_value = n1
        self.nl_input_old_value = n2
    else:
        self.nj_input.setValue(n2)
        self.nl_input.setValue(n1)
        self.nj_input_old_value = n2
        self.nl_input_old_value = n1

</t>
<t tx="leo.20231205084740.143">def nl_func() -&gt; float:
    return (self.dof.value() + 2 * n2) / 3 + 1

</t>
<t tx="leo.20231205084740.144">is_above = n2 &gt; self.nj_input_old_value
else:
n2 = self.nl_input.value()

</t>
<t tx="leo.20231205084740.145">def nl_func() -&gt; float:
    return (3 * (n2 - 1) - self.dof.value()) / 2

</t>
<t tx="leo.20231205084740.146">@Slot(name='on_number_synthesis_btn_clicked')
def __number_synthesis(self) -&gt; None:
    """Synthesis of link assortment."""
    self.__clear_assortment()
    nl = self.nl_input.value()
    nj = self.nj_input.value()
    dlg = SynthesisProgressDialog(
        "Link assortment",
        f"Number of links: {nl}\n"
        f"Number of joints: {nj}",
        1,
        self
    )

    @Slot(dict)
    def update_result(assortment: Dict[Assortment, List[Assortment]]) -&gt; None:
        """Update results."""
        self.assortment.update(assortment)
        for la, cla_list in assortment.items():
            la_item = QTreeWidgetItem([", ".join(
                f"NL{i + 2} = {a}" for i, a in enumerate(la)
            ), "N/A"])
            for cla in cla_list:
                la_item.addChild(QTreeWidgetItem([", ".join(
                    f"NC{i + 1} = {a}" for i, a in enumerate(cla)
                ), "N/A"]))
            self.link_assortment_list.addTopLevelItem(la_item)
        first_item = self.link_assortment_list.topLevelItem(0)
        self.link_assortment_list.setCurrentItem(first_item)
        dlg.deleteLater()

    work = LinkThread(nl, nj, dlg)
    work.progress_update.connect(dlg.setValue)
    work.size_update.connect(dlg.setMaximum)
    work.result.connect(update_result)
    dlg.show()
    work.start()

</t>
<t tx="leo.20231205084740.147">def __set_time_count(self, t: float, count: int) -&gt; None:
    """Set time and count digit to label."""
    self.time_label.setText(f"{t:.04f} s ({count})")

</t>
<t tx="leo.20231205084740.148">def __set_paint_time(self, t: float) -&gt; None:
    """Set painting time of atlas."""
    self.paint_time_label.setText(f"{t:.04f}s")

</t>
<t tx="leo.20231205084740.149">@Slot(name='on_structure_synthesis_btn_clicked')
def __structure_synthesis(self) -&gt; None:
    """Structural synthesis - find by contracted links."""
    self.__clear_structure_list()
    item = self.link_assortment_list.currentItem()
    if item is None:
        self.__number_synthesis()
        item = self.link_assortment_list.currentItem()
    root = item.parent()
    if root is None:
        # Find by link assortment
        try:
            # Test
            assortment_eval(item.text(0))
        except ValueError:
            return
        jobs = [item.child(i) for i in range(item.childCount())]
    else:
        # Find by contracted link assortment
        jobs = [item]
    self.__structural_combine(jobs)

</t>
<t tx="leo.20231205084740.15">@Slot(name='on_path_clear_clicked')
def clear_path(self, *, ask: bool = True) -&gt; None:
    """Clear the current target path."""
    if ask:
        if QMessageBox.question(
            self,
            "Clear path",
            "Are you sure to clear the current path?"
        ) != QMessageBox.Yes:
            return
    self.current_path().clear()
    self.path_list.clear()
    self.__current_path_changed()

</t>
<t tx="leo.20231205084740.150">@Slot(name='on_structure_synthesis_all_btn_clicked')
def __structure_synthesis_all(self) -&gt; None:
    """Structural synthesis - find all."""
    self.__clear_structure_list()
    jobs = []
    for i in range(self.link_assortment_list.topLevelItemCount()):
        root = self.link_assortment_list.topLevelItem(i)
        for j in range(root.childCount()):
            jobs.append(root.child(j))
    self.__structural_combine(jobs)

</t>
<t tx="leo.20231205084740.151">def __structural_combine(self, jobs: Sequence[QTreeWidgetItem]) -&gt; None:
    """Structural combine by iterator."""
    t0 = process_time()
    dlg = SynthesisProgressDialog(
        "Structural Synthesis",
        f"Number of cases: {len(jobs)}",
        len(jobs),
        self
    )

    @Slot(QTreeWidgetItem, int)
    def update_count(item: QTreeWidgetItem, count: int) -&gt; None:
        """Update the number of graphs."""
        item.setText(1, f"{count}")

    @Slot(list)
    def update_result(answer: List[Graph]) -&gt; None:
        """Update the result of atlas."""
        self.answer = answer
        dlg.deleteLater()
        for i in range(self.link_assortment_list.topLevelItemCount()):
            root = self.link_assortment_list.topLevelItem(i)
            count = 0
            for j in range(root.childCount()):
                item = root.child(j)
                try:
                    count += int(item.text(1))
                except ValueError:
                    pass
            root.setText(1, f"{count}")
        self.__set_time_count(process_time() - t0, len(self.answer))
        self.__reload_atlas()

    work = GraphThread(jobs, self.graph_degenerate.currentIndex(), dlg)
    work.count_update.connect(update_count)
    work.progress_update.connect(dlg.setValue)
    work.result.connect(update_result)
    dlg.show()
    work.start()

</t>
<t tx="leo.20231205084740.152">@Slot(name='on_reload_atlas_clicked')
@Slot(bool, name='on_graph_link_as_node_toggled')
@Slot(bool, name='on_graph_show_label_toggled')
@Slot(int, name='on_graph_engine_currentIndexChanged')
def __reload_atlas(self, *_) -&gt; None:
    """Reload the atlas."""
    scroll_bar: QScrollBar = self.structure_list.verticalScrollBar()
    scroll_pos = scroll_bar.sliderPosition()
    index = self.structure_list.currentRow()
    self.structure_list.clear()

    if not self.answer:
        return

    dlg = SynthesisProgressDialog(
        "Structural Synthesis",
        f"Drawing atlas ({len(self.answer)}) ...",
        len(self.answer),
        self
    )
    dlg.show()
    t0 = process_time()
    for i, G in enumerate(self.answer):
        QCoreApplication.processEvents()
        if dlg.wasCanceled():
            return
        if self.__draw_atlas(i, G):
            dlg.setValue(i + 1)
        else:
            break
    self.__set_paint_time(process_time() - t0)
    dlg.setValue(dlg.maximum())
    dlg.deleteLater()
    scroll_bar.setSliderPosition(scroll_pos)
    self.structure_list.setCurrentRow(index)

</t>
<t tx="leo.20231205084740.153">def __draw_atlas(self, i: int, g: Graph) -&gt; bool:
    """Draw atlas and return True if done."""
    item = QListWidgetItem(f"No. {i + 1}")
    item.setIcon(graph2icon(
        g,
        self.structure_list.iconSize().width(),
        self.graph_link_as_node.isChecked(),
        self.graph_show_label.isChecked(),
        self.prefer.monochrome_option,
        engine=self.graph_engine.currentText()
    ))
    item.setToolTip(
        f"Edge Set: {list(g.edges)}\n"
        f"Link assortment: {link_assortment(g)}\n"
        f"Contracted Link assortment: {contracted_link_assortment(g)}\n"
        f"Degree code: {g.degree_code()}"
    )
    self.structure_list.addItem(item)
    return True

</t>
<t tx="leo.20231205084740.154">def __atlas_image(self, row: Optional[int] = None) -&gt; QImage:
    """Capture a result item icon to image."""
    if row is None:
        item = self.structure_list.currentItem()
    else:
        item = self.structure_list.item(row)
    return item.icon().pixmap(self.structure_list.iconSize()).toImage()

</t>
<t tx="leo.20231205084740.155">@Slot(QPoint)
def __structure_list_context_menu(self, point) -&gt; None:
    """Context menu for the type synthesis results."""
    index = self.structure_list.currentIndex().row()
    self.to_collection.setEnabled(index &gt; -1)
    self.copy_edges.setEnabled(index &gt; -1)
    self.copy_image.setEnabled(index &gt; -1)
    action = self.pop_menu_topo.exec_(self.structure_list.mapToGlobal(point))
    if not action:
        return
    clipboard = QApplication.clipboard()
    if action == self.to_collection:
        self.add_collection(self.answer[index].edges)
    elif action == self.copy_edges:
        clipboard.setText(str(self.answer[index].edges))
    elif action == self.copy_image:
        # Turn the transparent background to white
        image1 = self.__atlas_image()
        image2 = QImage(image1.size(), image1.format())
        image2.fill(Qt.white)
        painter = QPainter(image2)
        painter.drawImage(QPointF(0, 0), image1)
        painter.end()
        clipboard.setPixmap(QPixmap.fromImage(image2))

</t>
<t tx="leo.20231205084740.156">@Slot(name='on_expr_copy_clicked')
def __copy_expr(self) -&gt; None:
    """Copy expression button."""
    string = self.edges_text.text()
    if string:
        QApplication.clipboard().setText(string)
        self.edges_text.selectAll()

</t>
<t tx="leo.20231205084740.157">@Slot(name='on_expr_add_collection_clicked')
def __add_collection(self) -&gt; None:
    """Add this expression to collections widget."""
    string = self.edges_text.text()
    if string:
        self.add_collection(eval(string))

</t>
<t tx="leo.20231205084740.158">@Slot(name='on_save_atlas_clicked')
def __save_atlas(self) -&gt; None:
    """Saving all the atlas to image file.

    We should turn transparent background to white first.
    Then using QImage class to merge into one image.
    """
    count = self.structure_list.count()
    if count &lt; 1:
        return

    lateral = self.__save_atlas_ask()
    if not lateral:
        return

    file_name = self.output_to("atlas image", qt_image_format)
    if not file_name:
        return

    width = self.structure_list.iconSize().width()
    image_main = QImage(QSize(
        lateral * width if count &gt; lateral else count * width,
        ((count // lateral) + bool(count % lateral)) * width
    ), self.__atlas_image(0).format())
    image_main.fill(Qt.transparent)
    painter = QPainter(image_main)
    for row in range(count):
        image = self.__atlas_image(row)
        painter.drawImage(QPointF(row % lateral, row // lateral) * width, image)
    painter.end()
    pixmap = QPixmap.fromImage(image_main)
    pixmap.save(file_name)
    self.save_reply_box("Atlas", file_name)

</t>
<t tx="leo.20231205084740.159">def __save_atlas_ask(self) -&gt; int:
    """Ask when saving the atlas."""
    lateral, ok = QInputDialog.getInt(
        self,
        "Atlas",
        "The number of lateral:",
        5, 1
    )
    if not ok:
        return 0
    return lateral

</t>
<t tx="leo.20231205084740.16">@Slot(name='on_path_copy_clicked')
def __copy_path(self) -&gt; None:
    """Copy the current path coordinates to clipboard."""
    if self.copy_as_csv.isChecked():
        text = '\n'.join(f"{x},{y}" for x, y in self.current_path())
    elif self.copy_as_array.isChecked():
        text = '\n'.join(f"[{x}, {y}]," for x, y in self.current_path())
    else:
        raise ValueError("invalid option")
    QApplication.clipboard().setText(text)

</t>
<t tx="leo.20231205084740.160">@Slot(name='on_save_edges_clicked')
def __save_edges(self) -&gt; None:
    """Saving all the atlas to text file."""
    file_name = ""
    count = self.structure_list.count()
    if count &lt; 1:
        return
    if not file_name:
        file_name = self.output_to("atlas edges expression", ["Text file (*.txt)"])
    if not file_name:
        return
    with open(file_name, 'w+', encoding='utf-8') as f:
        f.write('\n'.join(str(G.edges) for G in self.answer))
    self.save_reply_box("edges expression", file_name)

</t>
<t tx="leo.20231205084740.161">@Slot(name='on_edges2atlas_btn_clicked')
def __edges2atlas(self) -&gt; None:
    """Turn the text files into a atlas image.

    This operation will load all edges to list widget first.
    """
    file_names = self.input_from_multiple(
        "edges data",
        ["Text file (*.txt)"]
    )
    if not file_names:
        return

    read_data = []
    for file_name in file_names:
        with open(file_name, 'r', encoding='utf-8') as f:
            for line in f:
                read_data.append(line)

    answer = []
    for edges in read_data:
        try:
            g = Graph(eval(edges))
        except (SyntaxError, TypeError):
            QMessageBox.warning(
                self,
                "Wrong format",
                "Please check text format."
            )
        else:
            answer.append(g)

    if not answer:
        QMessageBox.information(
            self,
            "No data",
            "The graph data is empty."
        )
        return

    self.answer = answer
    self.__set_time_count(0, len(answer))
    self.__reload_atlas()
    self.__save_atlas()
</t>
<t tx="leo.20231205084740.162"></t>
<t tx="leo.20231205084740.163">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/widgets/
# -*- coding: utf-8 -*-

"""The canvas of main window."""

from __future__ import annotations

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from collections import deque
from typing import (
    cast, TYPE_CHECKING, List, Tuple, Sequence, Union, Mapping,
)
from qtpy.QtCore import Slot, Qt, QRectF, QPoint, QPointF, QSizeF
from qtpy.QtWidgets import QApplication, QToolTip, QWidget
from qtpy.QtGui import QRegion, QCursor, QWheelEvent, QPixmap, QImage
from pyslvs import VJoint
from .canvas_base import MainCanvasBase, FreeMode, SelectMode, ZoomBy

if TYPE_CHECKING:
    from pyslvs_ui.widgets import MainWindowBase

_Coord = Tuple[float, float]
_Paths = Sequence[Sequence[_Coord]]
_SliderPaths = Mapping[int, Sequence[_Coord]]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.164">class MainCanvas(MainCanvasBase):
    """The canvas in main window.

    + Parse and show PMKS expression.
    + Show paths.
    + Show settings of dimensional synthesis widget.
    + Mouse interactions.
    + Zoom to fit function.
    """

    @others
</t>
<t tx="leo.20231205084740.165">def __init__(self, parent: MainWindowBase):
    super(MainCanvas, self).__init__(parent)
    # Dependent functions to set zoom bar
    self.set_zoom_bar = parent.zoom_bar.setValue
    self.zoom_value = parent.zoom_bar.value
    self.prefer = parent.prefer
    # Dependent functions to set selection mode
    self.selection_mode_wheel = parent.entities_tab.setCurrentIndex
    self.selection_mode = parent.entities_tab.currentIndex

</t>
<t tx="leo.20231205084740.166">def update_canvas(
    self,
    exprs: List[Tuple[str, ...]],
    paths: _Paths,
    slider_paths: _SliderPaths
) -&gt; None:
    """Update with Point and Links data."""
    self.vangles = tuple(vpoint.angle for vpoint in self.vpoints)
    self.exprs = exprs
    self.path.path = paths
    self.path.slider_path = slider_paths
    self.update()

</t>
<t tx="leo.20231205084740.167">@Slot(int)
def set_link_width(self, width: int) -&gt; None:
    """Update width of links."""
    self.link_width = width
    self.update()

</t>
<t tx="leo.20231205084740.168">@Slot(int)
def set_path_width(self, width: int) -&gt; None:
    """Update width of links."""
    self.path_width = width
    self.update()

</t>
<t tx="leo.20231205084740.169">@Slot(bool)
def set_point_mark(self, show: bool) -&gt; None:
    """Update show point mark or not."""
    self.show_point_mark = show
    self.update()

</t>
<t tx="leo.20231205084740.17">@Slot(name='on_path_paste_clicked')
def __paste_path(self) -&gt; None:
    """Paste path data from clipboard."""
    self.__read_path_from_csv(QApplication.clipboard().text())

</t>
<t tx="leo.20231205084740.170">@Slot(bool)
def set_show_dimension(self, show: bool) -&gt; None:
    """Update show dimension or not."""
    self.show_dimension = show
    self.update()

</t>
<t tx="leo.20231205084740.171">@Slot(bool)
def set_curve_mode(self, curve: bool) -&gt; None:
    """Update show as curve mode or not."""
    self.path.curve = curve
    self.update()

</t>
<t tx="leo.20231205084740.172">@Slot(int)
def set_font_size(self, font_size: int) -&gt; None:
    """Update font size."""
    self.font_size = font_size
    self.update()

</t>
<t tx="leo.20231205084740.173">@Slot(int)
def set_zoom(self, zoom: int) -&gt; None:
    """Update zoom factor."""
    zoom_old = self.zoom
    self.zoom = zoom / 50.
    zoom_old -= self.zoom
    if self.zoomby == ZoomBy.CANVAS:
        pos = self.mapFromGlobal(QCursor.pos())
    else:
        pos = QPointF(self.width() / 2, self.height() / 2)
    self.ox += (pos.x() - self.ox) / self.zoom * zoom_old
    self.oy += (pos.y() - self.oy) / self.zoom * zoom_old
    self.update()

</t>
<t tx="leo.20231205084740.174">def get_zoom(self) -&gt; float:
    """Return zoom factor."""
    return self.zoom

</t>
<t tx="leo.20231205084740.175">def set_default_zoom(self, zoom: int) -&gt; None:
    """Set default zoom value."""
    self.default_zoom = zoom

</t>
<t tx="leo.20231205084740.176">def set_show_target_path(self, show: bool) -&gt; None:
    """Update show target path or not."""
    self.show_target_path = show
    self.update()

</t>
<t tx="leo.20231205084740.177">def set_free_move(self, free_move: int) -&gt; None:
    """Update free move mode number."""
    self.free_move = FreeMode(free_move + 1)
    self.update()

</t>
<t tx="leo.20231205084740.178">@Slot(int)
def set_selection_radius(self, sr: int) -&gt; None:
    """Update radius of point selector."""
    self.sr = sr

</t>
<t tx="leo.20231205084740.179">@Slot(int)
def set_transparency(self, transparency: int) -&gt; None:
    """Update transparency. (0%: opaque)"""
    self.transparency = (100 - transparency) / 100
    self.update()

</t>
<t tx="leo.20231205084740.18">@Slot(name='on_import_csv_btn_clicked')
def __import_csv(self) -&gt; None:
    """Paste path data from a text file."""
    file_name = self.input_from(
        "path data",
        ["Text file (*.txt)", "Comma-Separated Values (*.csv)"]
    )
    if not file_name:
        return
    with open(file_name, 'r', encoding='utf-8', newline='') as f:
        data = f.read()
    self.__read_path_from_csv(data)

</t>
<t tx="leo.20231205084740.180">@Slot(int)
def set_margin_factor(self, factor: int) -&gt; None:
    """Update margin factor when zoom to fit."""
    self.margin_factor = 1 - factor / 100
    self.update()

</t>
<t tx="leo.20231205084740.181">@Slot(int)
def set_joint_size(self, size: int) -&gt; None:
    """Update size for each joint."""
    self.joint_size = size
    self.update()

</t>
<t tx="leo.20231205084740.182">@Slot(int)
def set_zoom_by(self, zoomby: int) -&gt; None:
    """Update zooming center option.

    + 0: Cursor
    + 1: Canvas center
    """
    self.zoomby = ZoomBy(zoomby + 1)

</t>
<t tx="leo.20231205084740.183">@Slot(float)
def set_snap(self, snap: float) -&gt; None:
    """Update mouse capture value."""
    self.snap = snap

</t>
<t tx="leo.20231205084740.184">@Slot(str)
def set_background(self, path: str) -&gt; None:
    """Set background from file path."""
    self.background.load(path)
    self.update()

</t>
<t tx="leo.20231205084740.185">@Slot(float)
def set_background_opacity(self, opacity: float) -&gt; None:
    """Set opacity of background."""
    self.background_opacity = opacity
    self.update()

</t>
<t tx="leo.20231205084740.186">@Slot(float)
def set_background_scale(self, scale: float) -&gt; None:
    """Set scale value of background."""
    self.background_scale = scale
    self.update()

</t>
<t tx="leo.20231205084740.187">@Slot(float)
def set_background_offset_x(self, x: float) -&gt; None:
    """Set offset x value of background."""
    self.background_offset.setX(x)
    self.update()

</t>
<t tx="leo.20231205084740.188">@Slot(float)
def set_background_offset_y(self, y: float) -&gt; None:
    """Set offset y value of background."""
    self.background_offset.setY(-y)
    self.update()

</t>
<t tx="leo.20231205084740.189">@Slot(int)
def set_selection_mode(self, mode: int) -&gt; None:
    """Update the selection."""
    self.select_mode = SelectMode(mode + 1)
    self.update()

</t>
<t tx="leo.20231205084740.19">def __read_path_from_csv(self, raw: str, *, clear: bool = True) -&gt; None:
    """Turn string to float then add them to current target path."""
    try:
        path = parse_path(raw)
    except LarkError as e:
        QMessageBox.warning(self, "Wrong format", f"{e}")
    else:
        self.set_path(path, clear=clear)

</t>
<t tx="leo.20231205084740.190">@Slot(list)
def set_selection(self, selections: List[int]) -&gt; None:
    """Update the selection."""
    self.selections = selections
    self.update()

</t>
<t tx="leo.20231205084740.191">def set_solving_path(self, path: Mapping[int, Sequence[_Coord]]):
    """Update target path."""
    self.target_path = dict(path)
    self.update()

</t>
<t tx="leo.20231205084740.192">def set_path_show(self, p: int) -&gt; None:
    """Update path present mode.

    -2: Hide all paths.
    -1: Show all paths.
    i: Show path i.
    """
    self.path.show = p
    self.update()

</t>
<t tx="leo.20231205084740.193">def update_ranges(self,
                  ranges: Mapping[str, Tuple[float, float, float]]) -&gt; None:
    """Update the ranges of dimensional synthesis."""
    self.ranges.clear()
    self.ranges.update({tag: QRectF(
        QPointF(values[0] - values[2], values[1] + values[2]),
        QSizeF(values[2], values[2]) * 2
    ) for tag, values in ranges.items()})
    self.update()

</t>
<t tx="leo.20231205084740.194">def record_start(self, limit: int) -&gt; None:
    """Start a limit from main window."""
    self.path_record.clear()
    self.slider_record.clear()
    self.path_record.extend(deque([], limit) for _ in self.vpoints)
    self.slider_record.update((i, deque([], limit))
                              for i, vp in enumerate(self.vpoints)
                              if vp.type in {VJoint.P, VJoint.RP})

</t>
<t tx="leo.20231205084740.195">def record_path(self) -&gt; None:
    """Recording path."""
    for i, vpoint in enumerate(self.vpoints):
        self.path_record[i].append((vpoint.cx, vpoint.cy))
        if vpoint.type in {VJoint.P, VJoint.RP}:
            self.slider_record[i].append((vpoint.c[0, 0], vpoint.c[0, 1]))

</t>
<t tx="leo.20231205084740.196">def get_record_path(self) -&gt; Tuple[Sequence[Sequence[_Coord]],
                                   Mapping[int, Sequence[_Coord]]]:
    """Return paths."""
    paths = tuple(tuple(path) for path in self.path_record)
    paths_slider = {i: tuple(p) for i, p in self.slider_record.items()}
    self.path_record.clear()
    self.slider_record.clear()
    return paths, paths_slider

</t>
<t tx="leo.20231205084740.197">def adjust_link(
    self,
    coords: Sequence[Union[Tuple[_Coord, ...], _Coord]]
):
    """Change points coordinates."""
    for i, c in enumerate(coords):
        if isinstance(c[0], float):
            self.vpoints[i].move(cast(_Coord, c))
        else:
            self.vpoints[i].move(*cast(Tuple[_Coord, _Coord], c))
    self.update_preview_path()

</t>
<t tx="leo.20231205084740.198">def wheelEvent(self, event: QWheelEvent) -&gt; None:
    """Switch function by mouse wheel.

    + Set zoom bar value.
    + Set select mode.
    """
    p = event.angleDelta()
    if QApplication.keyboardModifiers() == Qt.ShiftModifier:
        value = p.y()
    elif p.x() != 0:
        value = p.x()
    elif p.y() != 0:
        value = self.prefer.scale_factor_option * (1 if p.y() &gt; 0 else -1)
        value += self.zoom_value()
        self.set_zoom_bar(value)
        return
    else:
        return
    tags = ("Points", "Links")
    mode = (self.selection_mode() + (-1 if value &gt; 0 else 1)) % len(tags)
    self.selection_mode_wheel(mode)
    QToolTip.showText(event.globalPos(), f"Selection mode: {tags[mode]}",
                      self)
    event.accept()

</t>
<t tx="leo.20231205084740.199">def grab_no_background(self) -&gt; QPixmap:
    """Grab function without background."""
    image = QImage(self.size(), QImage.Format_ARGB32_Premultiplied)
    image.fill(Qt.transparent)
    self.switch_grab()
    self.painter.begin(image)
    self.render(self.painter, QPoint(), QRegion(), QWidget.DrawChildren)
    self.switch_grab()
    return QPixmap.fromImage(image)
</t>
<t tx="leo.20231205084740.2">def setupUi(self, Form):
    Form.setObjectName("Form")
    Form.resize(457, 714)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:dimensional_synthesis.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Form.setWindowIcon(icon)
    self.verticalLayout_4 = QtWidgets.QVBoxLayout(Form)
    self.verticalLayout_4.setObjectName("verticalLayout_4")
    self.main_splitter = QtWidgets.QSplitter(Form)
    self.main_splitter.setOrientation(QtCore.Qt.Vertical)
    self.main_splitter.setObjectName("main_splitter")
    self.verticalGroupBox = QtWidgets.QGroupBox(self.main_splitter)
    self.verticalGroupBox.setObjectName("verticalGroupBox")
    self.horizontalLayout_6 = QtWidgets.QHBoxLayout(self.verticalGroupBox)
    self.horizontalLayout_6.setObjectName("horizontalLayout_6")
    self.verticalLayout_13 = QtWidgets.QVBoxLayout()
    self.verticalLayout_13.setObjectName("verticalLayout_13")
    self.result_list = QtWidgets.QListWidget(self.verticalGroupBox)
    self.result_list.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)
    self.result_list.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
    self.result_list.setObjectName("result_list")
    self.verticalLayout_13.addWidget(self.result_list)
    self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_10.setObjectName("horizontalLayout_10")
    self.result_load_settings = QtWidgets.QPushButton(self.verticalGroupBox)
    self.result_load_settings.setEnabled(False)
    icon1 = QtGui.QIcon()
    icon1.addPixmap(QtGui.QPixmap("icons:data_update.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.result_load_settings.setIcon(icon1)
    self.result_load_settings.setObjectName("result_load_settings")
    self.horizontalLayout_10.addWidget(self.result_load_settings)
    self.result_clipboard = QtWidgets.QPushButton(self.verticalGroupBox)
    self.result_clipboard.setEnabled(False)
    icon2 = QtGui.QIcon()
    icon2.addPixmap(QtGui.QPixmap("icons:copy.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.result_clipboard.setIcon(icon2)
    self.result_clipboard.setObjectName("result_clipboard")
    self.horizontalLayout_10.addWidget(self.result_clipboard)
    spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_10.addItem(spacerItem)
    self.delete_btn = QtWidgets.QPushButton(self.verticalGroupBox)
    self.delete_btn.setEnabled(False)
    icon3 = QtGui.QIcon()
    icon3.addPixmap(QtGui.QPixmap("icons:delete.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.delete_btn.setIcon(icon3)
    self.delete_btn.setObjectName("delete_btn")
    self.horizontalLayout_10.addWidget(self.delete_btn)
    self.merge_btn = QtWidgets.QPushButton(self.verticalGroupBox)
    self.merge_btn.setEnabled(False)
    icon4 = QtGui.QIcon()
    icon4.addPixmap(QtGui.QPixmap("icons:merge.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.merge_btn.setIcon(icon4)
    self.merge_btn.setObjectName("merge_btn")
    self.horizontalLayout_10.addWidget(self.merge_btn)
    self.verticalLayout_13.addLayout(self.horizontalLayout_10)
    self.target_label = QtWidgets.QLabel(self.verticalGroupBox)
    self.target_label.setWordWrap(True)
    self.target_label.setObjectName("target_label")
    self.verticalLayout_13.addWidget(self.target_label)
    self.horizontalLayout_6.addLayout(self.verticalLayout_13)
    self.options_tab = QtWidgets.QTabWidget(self.main_splitter)
    self.options_tab.setObjectName("options_tab")
    self.structure = QtWidgets.QWidget()
    self.structure.setObjectName("structure")
    self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.structure)
    self.verticalLayout_6.setObjectName("verticalLayout_6")
    self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_7.setObjectName("horizontalLayout_7")
    self.load_profile = QtWidgets.QPushButton(self.structure)
    icon5 = QtGui.QIcon()
    icon5.addPixmap(QtGui.QPixmap("icons:collections.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.load_profile.setIcon(icon5)
    self.load_profile.setObjectName("load_profile")
    self.horizontalLayout_7.addWidget(self.load_profile)
    self.save_profile = QtWidgets.QPushButton(self.structure)
    icon6 = QtGui.QIcon()
    icon6.addPixmap(QtGui.QPixmap("icons:save_file.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.save_profile.setIcon(icon6)
    self.save_profile.setObjectName("save_profile")
    self.horizontalLayout_7.addWidget(self.save_profile)
    self.profile_name = QtWidgets.QLineEdit(self.structure)
    self.profile_name.setReadOnly(True)
    self.profile_name.setObjectName("profile_name")
    self.horizontalLayout_7.addWidget(self.profile_name)
    self.clear_btn = QtWidgets.QPushButton(self.structure)
    icon7 = QtGui.QIcon()
    icon7.addPixmap(QtGui.QPixmap("icons:clean.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.clear_btn.setIcon(icon7)
    self.clear_btn.setObjectName("clear_btn")
    self.horizontalLayout_7.addWidget(self.clear_btn)
    self.verticalLayout_6.addLayout(self.horizontalLayout_7)
    self.canvas_splitter = QtWidgets.QSplitter(self.structure)
    self.canvas_splitter.setOrientation(QtCore.Qt.Vertical)
    self.canvas_splitter.setObjectName("canvas_splitter")
    self.preview_box = QtWidgets.QGroupBox(self.canvas_splitter)
    self.preview_box.setObjectName("preview_box")
    self.preview_layout = QtWidgets.QVBoxLayout(self.preview_box)
    self.preview_layout.setObjectName("preview_layout")
    self.parameter_list = QtWidgets.QTableWidget(self.canvas_splitter)
    self.parameter_list.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
    self.parameter_list.setVerticalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
    self.parameter_list.setHorizontalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)
    self.parameter_list.setObjectName("parameter_list")
    self.parameter_list.setColumnCount(5)
    self.parameter_list.setRowCount(0)
    item = QtWidgets.QTableWidgetItem()
    self.parameter_list.setHorizontalHeaderItem(0, item)
    item = QtWidgets.QTableWidgetItem()
    self.parameter_list.setHorizontalHeaderItem(1, item)
    item = QtWidgets.QTableWidgetItem()
    self.parameter_list.setHorizontalHeaderItem(2, item)
    item = QtWidgets.QTableWidgetItem()
    self.parameter_list.setHorizontalHeaderItem(3, item)
    item = QtWidgets.QTableWidgetItem()
    self.parameter_list.setHorizontalHeaderItem(4, item)
    self.verticalLayout_6.addWidget(self.canvas_splitter)
    self.horizontalLayout_17 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_17.setObjectName("horizontalLayout_17")
    self.expression_string = QtWidgets.QLineEdit(self.structure)
    self.expression_string.setReadOnly(True)
    self.expression_string.setObjectName("expression_string")
    self.horizontalLayout_17.addWidget(self.expression_string)
    self.expr_copy = QtWidgets.QPushButton(self.structure)
    self.expr_copy.setIcon(icon2)
    self.expr_copy.setObjectName("expr_copy")
    self.horizontalLayout_17.addWidget(self.expr_copy)
    self.verticalLayout_6.addLayout(self.horizontalLayout_17)
    icon8 = QtGui.QIcon()
    icon8.addPixmap(QtGui.QPixmap("icons:structure.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.options_tab.addTab(self.structure, icon8, "")
    self.target_path = QtWidgets.QWidget()
    self.target_path.setObjectName("target_path")
    self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.target_path)
    self.verticalLayout_5.setObjectName("verticalLayout_5")
    self.down_splitter = QtWidgets.QSplitter(self.target_path)
    self.down_splitter.setOrientation(QtCore.Qt.Horizontal)
    self.down_splitter.setObjectName("down_splitter")
    self.verticalLayoutWidget = QtWidgets.QWidget(self.down_splitter)
    self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")
    self.verticalLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
    self.verticalLayout.setContentsMargins(0, 0, 0, 0)
    self.verticalLayout.setObjectName("verticalLayout")
    self.target_points = QtWidgets.QListWidget(self.verticalLayoutWidget)
    self.target_points.setObjectName("target_points")
    self.verticalLayout.addWidget(self.target_points)
    self.shape_only_option = QtWidgets.QCheckBox(self.verticalLayoutWidget)
    self.shape_only_option.setObjectName("shape_only_option")
    self.verticalLayout.addWidget(self.shape_only_option)
    self.layoutWidget = QtWidgets.QWidget(self.down_splitter)
    self.layoutWidget.setObjectName("layoutWidget")
    self.horizontalLayout_5 = QtWidgets.QHBoxLayout(self.layoutWidget)
    self.horizontalLayout_5.setContentsMargins(0, 0, 0, 0)
    self.horizontalLayout_5.setObjectName("horizontalLayout_5")
    self.verticalLayout_8 = QtWidgets.QVBoxLayout()
    self.verticalLayout_8.setObjectName("verticalLayout_8")
    self.copy_format_groupbox = QtWidgets.QGroupBox(self.layoutWidget)
    self.copy_format_groupbox.setObjectName("copy_format_groupbox")
    self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.copy_format_groupbox)
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.copy_as_csv = QtWidgets.QRadioButton(self.copy_format_groupbox)
    self.copy_as_csv.setChecked(True)
    self.copy_as_csv.setObjectName("copy_as_csv")
    self.verticalLayout_2.addWidget(self.copy_as_csv)
    self.copy_as_array = QtWidgets.QRadioButton(self.copy_format_groupbox)
    self.copy_as_array.setObjectName("copy_as_array")
    self.verticalLayout_2.addWidget(self.copy_as_array)
    self.path_copy = QtWidgets.QPushButton(self.copy_format_groupbox)
    self.path_copy.setIcon(icon2)
    self.path_copy.setObjectName("path_copy")
    self.verticalLayout_2.addWidget(self.path_copy)
    self.verticalLayout_8.addWidget(self.copy_format_groupbox)
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    self.point_num = QtWidgets.QLabel(self.layoutWidget)
    self.point_num.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
    self.point_num.setObjectName("point_num")
    self.horizontalLayout_2.addWidget(self.point_num)
    spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_2.addItem(spacerItem1)
    self.path_paste = QtWidgets.QPushButton(self.layoutWidget)
    icon9 = QtGui.QIcon()
    icon9.addPixmap(QtGui.QPixmap("icons:paste.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.path_paste.setIcon(icon9)
    self.path_paste.setObjectName("path_paste")
    self.horizontalLayout_2.addWidget(self.path_paste)
    self.path_clear = QtWidgets.QPushButton(self.layoutWidget)
    self.path_clear.setIcon(icon7)
    self.path_clear.setAutoDefault(False)
    self.path_clear.setObjectName("path_clear")
    self.horizontalLayout_2.addWidget(self.path_clear)
    self.verticalLayout_8.addLayout(self.horizontalLayout_2)
    self.path_list = QtWidgets.QListWidget(self.layoutWidget)
    self.path_list.setObjectName("path_list")
    self.verticalLayout_8.addWidget(self.path_list)
    self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_8.setObjectName("horizontalLayout_8")
    self.point_up = QtWidgets.QPushButton(self.layoutWidget)
    icon10 = QtGui.QIcon()
    icon10.addPixmap(QtGui.QPixmap("icons:arrow_up.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.point_up.setIcon(icon10)
    self.point_up.setObjectName("point_up")
    self.horizontalLayout_8.addWidget(self.point_up)
    self.point_down = QtWidgets.QPushButton(self.layoutWidget)
    icon11 = QtGui.QIcon()
    icon11.addPixmap(QtGui.QPixmap("icons:arrow_down.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.point_down.setIcon(icon11)
    self.point_down.setObjectName("point_down")
    self.horizontalLayout_8.addWidget(self.point_down)
    spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_8.addItem(spacerItem2)
    self.point_delete = QtWidgets.QPushButton(self.layoutWidget)
    self.point_delete.setIcon(icon3)
    self.point_delete.setObjectName("point_delete")
    self.horizontalLayout_8.addWidget(self.point_delete)
    self.edit_target_point_btn = QtWidgets.QPushButton(self.layoutWidget)
    icon12 = QtGui.QIcon()
    icon12.addPixmap(QtGui.QPixmap("icons:translate.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.edit_target_point_btn.setIcon(icon12)
    self.edit_target_point_btn.setCheckable(True)
    self.edit_target_point_btn.setChecked(True)
    self.edit_target_point_btn.setObjectName("edit_target_point_btn")
    self.horizontalLayout_8.addWidget(self.edit_target_point_btn)
    self.verticalLayout_8.addLayout(self.horizontalLayout_8)
    self.horizontalLayout_5.addLayout(self.verticalLayout_8)
    self.verticalLayout_3 = QtWidgets.QVBoxLayout()
    self.verticalLayout_3.setObjectName("verticalLayout_3")
    self.save_path_btn = QtWidgets.QPushButton(self.layoutWidget)
    self.save_path_btn.setIcon(icon6)
    self.save_path_btn.setIconSize(QtCore.QSize(40, 40))
    self.save_path_btn.setObjectName("save_path_btn")
    self.verticalLayout_3.addWidget(self.save_path_btn)
    self.import_csv_btn = QtWidgets.QPushButton(self.layoutWidget)
    self.import_csv_btn.setText("")
    icon13 = QtGui.QIcon()
    icon13.addPixmap(QtGui.QPixmap("icons:loadfile.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.import_csv_btn.setIcon(icon13)
    self.import_csv_btn.setIconSize(QtCore.QSize(40, 40))
    self.import_csv_btn.setObjectName("import_csv_btn")
    self.verticalLayout_3.addWidget(self.import_csv_btn)
    self.import_xlsx_btn = QtWidgets.QPushButton(self.layoutWidget)
    self.import_xlsx_btn.setText("")
    icon14 = QtGui.QIcon()
    icon14.addPixmap(QtGui.QPixmap("icons:excel.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.import_xlsx_btn.setIcon(icon14)
    self.import_xlsx_btn.setIconSize(QtCore.QSize(40, 40))
    self.import_xlsx_btn.setObjectName("import_xlsx_btn")
    self.verticalLayout_3.addWidget(self.import_xlsx_btn)
    self.append_path_btn = QtWidgets.QPushButton(self.layoutWidget)
    icon15 = QtGui.QIcon()
    icon15.addPixmap(QtGui.QPixmap("icons:properties.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.append_path_btn.setIcon(icon15)
    self.append_path_btn.setIconSize(QtCore.QSize(40, 40))
    self.append_path_btn.setObjectName("append_path_btn")
    self.verticalLayout_3.addWidget(self.append_path_btn)
    self.line = QtWidgets.QFrame(self.layoutWidget)
    self.line.setFrameShape(QtWidgets.QFrame.HLine)
    self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line.setObjectName("line")
    self.verticalLayout_3.addWidget(self.line)
    self.edit_path_btn = QtWidgets.QPushButton(self.layoutWidget)
    icon16 = QtGui.QIcon()
    icon16.addPixmap(QtGui.QPixmap("icons:formula.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.edit_path_btn.setIcon(icon16)
    self.edit_path_btn.setIconSize(QtCore.QSize(40, 40))
    self.edit_path_btn.setObjectName("edit_path_btn")
    self.verticalLayout_3.addWidget(self.edit_path_btn)
    self.norm_path_btn = QtWidgets.QPushButton(self.layoutWidget)
    icon17 = QtGui.QIcon()
    icon17.addPixmap(QtGui.QPixmap("icons:normalization.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.norm_path_btn.setIcon(icon17)
    self.norm_path_btn.setIconSize(QtCore.QSize(40, 40))
    self.norm_path_btn.setObjectName("norm_path_btn")
    self.verticalLayout_3.addWidget(self.norm_path_btn)
    spacerItem3 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_3.addItem(spacerItem3)
    self.horizontalLayout_5.addLayout(self.verticalLayout_3)
    self.verticalLayout_5.addWidget(self.down_splitter)
    self.options_tab.addTab(self.target_path, icon, "")
    self.algorithm = QtWidgets.QWidget()
    self.algorithm.setObjectName("algorithm")
    self.verticalLayout_7 = QtWidgets.QVBoxLayout(self.algorithm)
    self.verticalLayout_7.setObjectName("verticalLayout_7")
    self.algorithm_layout = QtWidgets.QVBoxLayout()
    self.algorithm_layout.setObjectName("algorithm_layout")
    self.verticalLayout_7.addLayout(self.algorithm_layout)
    self.advance_btn = QtWidgets.QPushButton(self.algorithm)
    self.advance_btn.setIcon(icon15)
    self.advance_btn.setObjectName("advance_btn")
    self.verticalLayout_7.addWidget(self.advance_btn)
    spacerItem4 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_7.addItem(spacerItem4)
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.label_7 = QtWidgets.QLabel(self.algorithm)
    self.label_7.setObjectName("label_7")
    self.horizontalLayout.addWidget(self.label_7)
    spacerItem5 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout.addItem(spacerItem5)
    self.timeShow = QtWidgets.QLabel(self.algorithm)
    self.timeShow.setObjectName("timeShow")
    self.horizontalLayout.addWidget(self.timeShow)
    self.verticalLayout_7.addLayout(self.horizontalLayout)
    icon18 = QtGui.QIcon()
    icon18.addPixmap(QtGui.QPixmap("icons:synthesis.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.options_tab.addTab(self.algorithm, icon18, "")
    self.verticalLayout_4.addWidget(self.main_splitter)
    self.synthesis_btn = QtWidgets.QPushButton(Form)
    self.synthesis_btn.setEnabled(False)
    self.synthesis_btn.setMinimumSize(QtCore.QSize(120, 0))
    icon19 = QtGui.QIcon()
    icon19.addPixmap(QtGui.QPixmap("icons:play.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.synthesis_btn.setIcon(icon19)
    self.synthesis_btn.setAutoDefault(True)
    self.synthesis_btn.setObjectName("synthesis_btn")
    self.verticalLayout_4.addWidget(self.synthesis_btn)

    self.retranslateUi(Form)
    QtCore.QMetaObject.connectSlotsByName(Form)

</t>
<t tx="leo.20231205084740.20">@Slot(name='on_append_path_btn_clicked')
def __append_path(self):
    """Append path from text."""
    raw, ok = QInputDialog.getMultiLineText(self, "Append path",
                                            "Path from csv format.")
    if ok and raw:
        self.__read_path_from_csv(raw, clear=False)

</t>
<t tx="leo.20231205084740.200">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/widgets/
# -*- coding: utf-8 -*-

"""This module contains the functions that main canvas needed."""

from __future__ import annotations

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import TYPE_CHECKING, Tuple, List, Deque, Sequence, Dict
from abc import ABC, abstractmethod
from enum import IntEnum, auto, unique
from dataclasses import dataclass, field
from math import degrees, sin, cos, atan2, hypot
from qtpy.QtCore import Signal, Slot, Qt, QRectF, QPoint, QPointF, QLineF
from qtpy.QtWidgets import QApplication
from qtpy.QtGui import QPolygonF, QFont, QPen, QColor, QPaintEvent, QMouseEvent
from pyslvs import VJoint, VPoint, VLink
from pyslvs_ui.graphics import (
    convex_hull, BaseCanvas, color_qt, LINK_COLOR, RangeDetector,
)

if TYPE_CHECKING:
    from pyslvs_ui.widgets import MainWindowBase

_Coord = Tuple[float, float]
_Path = Sequence[_Coord]
_Paths = Sequence[Sequence[_Coord]]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.201">@dataclass(repr=False, eq=False)
class _Selector:
    """Use to record mouse clicked point.

    Attributes:

    + x, y, sx, sy: Four coordinates of selection rectangle.
    + selection_rect: The selection of mouse dragging.
    + selection_old: The selection before mouse dragging.
    + middle_dragged: Is dragged by middle button.
    + left_dragged: Is dragged by left button.
    + picking: Is selecting (for drawing function).
    """
    x: float = 0.
    y: float = 0.
    sx: float = 0.
    sy: float = 0.
    selection_rect: List[int] = field(default_factory=list)
    selection_old: List[int] = field(default_factory=list)
    middle_dragged: bool = False
    left_dragged: bool = False
    picking: bool = False

    @others
</t>
<t tx="leo.20231205084740.202">def release(self) -&gt; None:
    """Release the dragging status."""
    self.selection_rect.clear()
    self.middle_dragged = False
    self.left_dragged = False
    self.picking = False

</t>
<t tx="leo.20231205084740.203">def is_close(self, x: float, y: float, limit: float) -&gt; bool:
    """Return the distance of selector."""
    return hypot(x - self.x, y - self.y) &lt;= limit

</t>
<t tx="leo.20231205084740.204">def in_rect(self, x: float, y: float) -&gt; bool:
    """Return true if input coordinate is in the rectangle."""
    x_right = max(self.x, self.sx)
    x_left = min(self.x, self.sx)
    y_top = max(self.y, self.sy)
    y_btn = min(self.y, self.sy)
    return x_left &lt;= x &lt;= x_right and y_btn &lt;= y &lt;= y_top

</t>
<t tx="leo.20231205084740.205">def to_rect(self, zoom: float) -&gt; QRectF:
    """Return limit as QRectF type."""
    return QRectF(
        QPointF(self.x, -self.y) * zoom,
        QPointF(self.sx, -self.sy) * zoom
    )

</t>
<t tx="leo.20231205084740.206">def current_selection(self) -&gt; Tuple[int, ...]:
    km = QApplication.keyboardModifiers()
    if km == Qt.ControlModifier or km == Qt.ShiftModifier:
        return tuple(set(self.selection_old + self.selection_rect))
    else:
        return tuple(self.selection_rect)


</t>
<t tx="leo.20231205084740.207">@unique
class FreeMode(IntEnum):
    """Free move mode"""
    NO_FREE_MOVE = auto()
    TRANSLATE = auto()
    ROTATE = auto()
    REFLECT = auto()


</t>
<t tx="leo.20231205084740.208">@unique
class SelectMode(IntEnum):
    """Selection mode"""
    JOINT = auto()
    LINK = auto()
    SOLUTION = auto()


</t>
<t tx="leo.20231205084740.209">@unique
class ZoomBy(IntEnum):
    """Zooming center option"""
    CURSOR = auto()
    CANVAS = auto()


</t>
<t tx="leo.20231205084740.21">@Slot(name='on_save_path_btn_clicked')
def __save_path(self):
    """Save current path."""
    path = self.current_path()
    if not path:
        return
    file_name = self.output_to("Path file", ["Text file (*.txt)"])
    if not file_name:
        return
    with open(file_name, 'w+', encoding='utf-8') as f:
        f.write("\n".join(f"{x}, {y}" for x, y in path))
    self.save_reply_box("Path file", file_name)

</t>
<t tx="leo.20231205084740.210">_selection_unit = {
    SelectMode.JOINT: 'point',
    SelectMode.LINK: 'link',
    SelectMode.SOLUTION: 'solution',
}


</t>
<t tx="leo.20231205084740.211">class MainCanvasBase(BaseCanvas, ABC):
    """Abstract class for wrapping main canvas class."""
    vangles: Tuple[float, ...]
    exprs: List[Tuple[str, ...]]
    selections: List[int]
    path_preview: List[List[_Coord]]
    slider_path_preview: Dict[int, List[_Coord]]
    path_record: List[Deque[_Coord]]
    slider_record: Dict[int, Deque[_Coord]]

    tracking = Signal(float, float)
    browse_tracking = Signal(float, float)
    selected = Signal(tuple, bool)
    selected_tips = Signal(QPoint, str)
    selected_tips_hide = Signal()
    free_moved = Signal(tuple)
    no_selected = Signal()
    alt_add = Signal(float, float)
    doubleclick_edit = Signal(int)
    zoom_changed = Signal(int)
    fps_updated = Signal()
    set_target_point = Signal(float, float)

    @others
</t>
<t tx="leo.20231205084740.212">@abstractmethod
def __init__(self, parent: MainWindowBase):
    super(MainCanvasBase, self).__init__(parent)
    self.setStatusTip("Use mouse wheel or middle button to look around.")
    # The current mouse coordinates
    self.selector = _Selector()
    # Entities
    self.vpoints = parent.vpoint_list
    self.vlinks = parent.vlink_list
    self.vangles = ()
    # Solution
    self.exprs = []
    # Select function
    self.select_mode = SelectMode.JOINT
    self.sr = 10
    self.selections = []
    # Link transparency
    self.transparency = 1.
    # Default zoom rate
    self.default_zoom = 400
    # Show dimension
    self.show_dimension = False
    # Free move mode
    self.free_move = FreeMode.NO_FREE_MOVE
    # Path preview
    self.path_preview = []
    self.slider_path_preview = {}
    self.preview_path = parent.preview_path
    # Path record
    self.path_record = []
    self.slider_record = {}
    # Zooming center
    # 0: By cursor
    # 1: By canvas center
    self.zoomby = ZoomBy.CANVAS
    # Mouse snapping value
    self.snap = 5.
    # Default margin factor
    self.margin_factor = 0.95
    # Widget size
    self.width_old = None
    self.height_old = None

</t>
<t tx="leo.20231205084740.213">def __draw_frame(self) -&gt; None:
    """Draw an external frame."""
    pos_x = self.width() - self.ox
    pos_y = -self.oy
    neg_x = -self.ox
    neg_y = self.height() - self.oy
    self.painter.drawLine(QLineF(neg_x, pos_y, pos_x, pos_y))
    self.painter.drawLine(QLineF(neg_x, neg_y, pos_x, neg_y))
    self.painter.drawLine(QLineF(neg_x, pos_y, neg_x, neg_y))
    self.painter.drawLine(QLineF(pos_x, pos_y, pos_x, neg_y))

</t>
<t tx="leo.20231205084740.214">def __draw_point(self, i: int, vpt: VPoint) -&gt; None:
    """Draw a point."""
    connected = len(vpt.links) - 1
    if vpt.type in {VJoint.P, VJoint.RP}:
        pen = QPen(color_qt(vpt.color))
        pen.setWidth(2)
        # Draw slot point and pin point
        for j, (cx, cy) in enumerate(vpt.c):
            # Slot point
            if j == 0 or vpt.type == VJoint.P:
                if self.monochrome:
                    color = Qt.black
                else:
                    color = color_qt(vpt.color)
                pen.setColor(color)
                self.painter.setPen(pen)
                cp = QPointF(cx, -cy) * self.zoom
                jr = self.joint_size * (2 if j == 0 else 1)
                rp = QPointF(jr, -jr)
                self.painter.drawRect(QRectF(cp + rp, cp - rp))
                if self.show_point_mark:
                    pen.setColor(Qt.darkGray)
                    self.painter.setPen(pen)
                    text = f"[Point{i}]"
                    if self.show_dimension:
                        text += f":({cx:.02f}, {cy:.02f})"
                    self.painter.drawText(cp + rp, text)
            else:
                grounded = (len(vpt.c) == len(vpt.links)
                            and vpt.links[j] == VLink.FRAME)
                self.draw_point(i, cx, cy, grounded, vpt.color, connected)
        # Slider line
        pen.setColor(color_qt(vpt.color).darker())
        self.painter.setPen(pen)
        line_m = QLineF(
            QPointF(vpt.c[1, 0], -vpt.c[1, 1]) * self.zoom,
            QPointF(vpt.c[0, 0], -vpt.c[0, 1]) * self.zoom
        )
        nv = line_m.normalVector()
        nv.setLength(self.joint_size)
        nv.setPoints(nv.p2(), nv.p1())
        line1 = nv.normalVector()
        line1.setLength(line_m.length())
        self.painter.drawLine(line1)
        nv.setLength(nv.length() * 2)
        nv.setPoints(nv.p2(), nv.p1())
        line2 = nv.normalVector()
        line2.setLength(line_m.length())
        line2.setAngle(line2.angle() + 180)
        self.painter.drawLine(line2)
    else:
        self.draw_point(i, vpt.cx, vpt.cy, vpt.grounded(), vpt.color,
                        connected)
    # For selects function
    if self.select_mode == SelectMode.JOINT and (i in self.selections):
        pen = QPen(QColor(161, 16, 239))
        pen.setWidth(3)
        self.painter.setPen(pen)
        self.painter.drawRect(QRectF(
            vpt.cx * self.zoom - 12,
            vpt.cy * -self.zoom - 12,
            24, 24
        ))

</t>
<t tx="leo.20231205084740.215">def __draw_link(self, vlink: VLink) -&gt; None:
    """Draw a link."""
    if vlink.name == VLink.FRAME or not vlink.points:
        return
    pen = QPen()
    # Rearrange: Put the nearest point to the next position.
    qpoints = convex_hull(
        [(c.x * self.zoom, c.y * -self.zoom)
         for c in vlink.points_pos(self.vpoints)], as_qpoint=True)
    if (
        self.select_mode == SelectMode.LINK
        and self.vlinks.index(vlink) in self.selections
    ):
        pen.setWidth(self.link_width + 6)
        pen.setColor(Qt.black if self.monochrome else QColor(161, 16, 239))
        self.painter.setPen(pen)
        self.painter.drawPolygon(*qpoints)
    pen.setWidth(self.link_width)
    pen.setColor(Qt.black if self.monochrome else color_qt(vlink.color))
    self.painter.setPen(pen)
    self.painter.drawPolygon(*qpoints)
    if not self.show_point_mark:
        return
    pen.setColor(Qt.darkGray)
    self.painter.setPen(pen)
    p_count = len(qpoints)
    cen_x = sum(p.x() for p in qpoints) / p_count
    cen_y = sum(p.y() for p in qpoints) / p_count
    self.painter.drawText(
        QRectF(cen_x - 50, cen_y - 50, 100, 100),
        Qt.AlignCenter,
        f'[{vlink.name}]'
    )

</t>
<t tx="leo.20231205084740.216">def __draw_path(self) -&gt; None:
    """Draw paths. Recording first."""
    paths: _Paths = self.path_record or self.path.path or self.path_preview
    if len(self.vpoints) != len(paths):
        return
    pen = QPen()
    fmt_paths = [(i, p) for i, p in enumerate(paths)]
    if paths is self.path_preview:
        fmt_paths.extend(self.slider_path_preview.items())
    elif paths is self.path_record:
        fmt_paths.extend(self.slider_record.items())
    else:
        # User paths
        fmt_paths.extend(self.path.slider_path.items())
    for i, path in fmt_paths:
        if self.path.show != i and self.path.show != -1:
            continue
        vpoint = self.vpoints[i]
        if self.monochrome:
            color = color_qt('gray')
        else:
            color = color_qt(vpoint.color)
        pen.setColor(color)
        pen.setWidth(self.path_width)
        self.painter.setPen(pen)
        if self.path.curve:
            self.draw_curve(path)
        else:
            self.draw_dot(path)

</t>
<t tx="leo.20231205084740.217">def __emit_free_move(self, targets: Sequence[int]) -&gt; None:
    """Emit free move targets to edit."""
    self.free_moved.emit(tuple((num, (
        self.vpoints[num].cx,
        self.vpoints[num].cy,
        self.vpoints[num].angle,
    )) for num in targets))

</t>
<t tx="leo.20231205084740.218">def __select_func(self, *, rect: bool = False) -&gt; None:
    """Select function."""
    if self.show_target_path:
        return
    self.selector.selection_rect.clear()
    if self.select_mode == SelectMode.JOINT:
        @others
        for i, expr in enumerate(self.exprs):
            if catch(expr) and i not in self.selector.selection_rect:
                self.selector.selection_rect.append(i)

</t>
<t tx="leo.20231205084740.219">def catch_p(x: float, y: float) -&gt; bool:
    """Detection function for points."""
    if rect:
        return self.selector.in_rect(x, y)
    else:
        return self.selector.is_close(x, y, self.sr / self.zoom)

</t>
<t tx="leo.20231205084740.22">@Slot(name='on_import_xlsx_btn_clicked')
def __import_xlsx(self) -&gt; None:
    """Paste path data from a Excel file."""
    file_name = self.input_from(
        "Excel project",
        ["Microsoft Office Excel (*.xlsx *.xlsm *.xltx *.xltm)"]
    )
    if not file_name:
        return
    wb = load_workbook(file_name)
    sheets = wb.get_sheet_names()
    name, ok = QInputDialog.getItem(self, "Sheets", "Select a sheet:",
                                    sheets, 0)
    if not ok:
        return

    def get_path(sheet: str) -&gt; Iterator[_Coord]:
        """Keep finding until there is no value"""
        ws = wb.get_sheet_by_name(sheets.index(sheet))
        i = 1
        while True:
            sx = ws.cell(i, 1).value
            sy = ws.cell(i, 2).value
            if None in {sx, sy}:
                break
            try:
                yield float(sx), float(sy)
            except Exception as e:
                QMessageBox.warning(self, "File error", f"{e}")
                return
            i += 1

    self.set_path(get_path(name))

</t>
<t tx="leo.20231205084740.220">for i, vpoint in enumerate(self.vpoints):
    if (
        catch_p(vpoint.cx, vpoint.cy)
        and i not in self.selector.selection_rect
    ):
        self.selector.selection_rect.append(i)

elif self.select_mode == SelectMode.LINK:
</t>
<t tx="leo.20231205084740.221">def catch_l(vlink: VLink) -&gt; bool:
    """Detection function for links.

    + Is polygon: Using Qt polygon geometry.
    + If just a line: Create a range for mouse detection.
    """
    points = [(c.x * self.zoom, c.y * -self.zoom)
              for c in vlink.points_pos(self.vpoints)]
    if len(points) &gt; 2:
        polygon = QPolygonF(convex_hull(points, as_qpoint=True))
    else:
        polygon = QPolygonF(convex_hull(
            [(x + self.sr, y + self.sr) for x, y in points]
            + [(x - self.sr, y - self.sr) for x, y in points],
            as_qpoint=True
        ))
    if rect:
        return polygon.intersects(
            QPolygonF(self.selector.to_rect(self.zoom)))
    else:
        return polygon.containsPoint(
            QPointF(self.selector.x, -self.selector.y) * self.zoom,
            Qt.WindingFill
        )

</t>
<t tx="leo.20231205084740.222">for i, vl in enumerate(self.vlinks):
    if (
        i != 0 and catch_l(vl)
        and i not in self.selector.selection_rect
    ):
        self.selector.selection_rect.append(i)

elif self.select_mode == SelectMode.SOLUTION:
</t>
<t tx="leo.20231205084740.223">def catch(exprs: Sequence[str]) -&gt; bool:
    """Detection function for solution polygons."""
    points, _ = self.solution_polygon(
        exprs[0],
        exprs[1:-1],
        exprs[-1],
        self.vpoints
    )
    if len(points) &lt; 3:
        points = convex_hull(
            [(x + self.sr, y + self.sr) for x, y in points]
            + [(x - self.sr, y - self.sr) for x, y in points],
            as_qpoint=True
        )
    else:
        points = [QPointF(x, y) for x, y in points]
    polygon = QPolygonF(points)
    if rect:
        return polygon.intersects(
            QPolygonF(self.selector.to_rect(self.zoom)))
    else:
        return polygon.containsPoint(
            QPointF(self.selector.x, -self.selector.y) * self.zoom,
            Qt.WindingFill
        )

</t>
<t tx="leo.20231205084740.224">def __snap(self, num: float, *, is_zoom: bool = True) -&gt; float:
    """Close to a multiple of coefficient."""
    snap_val = self.snap * self.zoom if is_zoom else self.snap
    if not snap_val:
        return num
    times = num // snap_val
    if num % snap_val &gt;= snap_val / 2:
        times += 1
    return snap_val * times

</t>
<t tx="leo.20231205084740.225">def __zoom_to_fit_size(self) -&gt; Tuple[float, float, float, float]:
    """Limitations of four side."""
    r = RangeDetector()
    # Paths
    if self.path.show != -2:
        paths = self.path_record or self.path.path or self.path_preview
        for i, path in enumerate(self.path_preview + [v for k, v in sorted(
            self.slider_path_preview.items(),
            key=lambda e: e[1]
        )] if paths is self.path_preview else paths):
            if self.path.show != -1 and self.path.show != i:
                continue
            for x, y in path:
                r(x, x, y, y)
    # Points
    for vpoint in self.vpoints:
        r(vpoint.cx, vpoint.cx, vpoint.cy, vpoint.cy)
    # Synthesis page
    if self.show_target_path:
        # Solving paths
        for path in self.target_path.values():
            for x, y in path:
                r(x, x, y, y)
        # Ranges
        for rect in self.ranges.values():
            r(rect.x(), rect.x() + rect.width(), rect.y(),
              rect.y() - rect.height())
    # Background image
    if not self.background.isNull():
        x_r = self.background_offset.x()
        y_t = self.background_offset.y()
        r(
            x_r,
            x_r + self.background.width() * self.background_scale,
            y_t,
            y_t - self.background.height() * self.background_scale
        )
    return r.right, r.left, r.top, r.bottom

</t>
<t tx="leo.20231205084740.226">def emit_free_move_all(self) -&gt; None:
    """Edit all points to edit."""
    self.__emit_free_move(range(len(self.vpoints)))

</t>
<t tx="leo.20231205084740.227">def paintEvent(self, event: QPaintEvent) -&gt; None:
    """Drawing functions."""
    width = self.width()
    height = self.height()
    if self.width_old is None:
        self.width_old = width
    if self.height_old is None:
        self.height_old = height
    if self.width_old != width or self.height_old != height:
        self.ox += (width - self.width_old) / 2
        self.oy += (height - self.height_old) / 2
    # 'self' is the instance of 'DynamicCanvas'.
    BaseCanvas.paintEvent(self, event)
    # Draw links except ground
    brush = color_qt('dark-gray') if self.monochrome else LINK_COLOR
    brush.setAlphaF(self.transparency)
    self.painter.setBrush(brush)
    for vlink in self.vlinks[1:]:
        self.__draw_link(vlink)
    self.painter.setBrush(Qt.NoBrush)
    # Draw path
    if self.path.show != -2:
        self.__draw_path()
    # Draw solving path
    if self.show_target_path:
        self.painter.setFont(QFont("Arial", self.font_size + 5))
        self.draw_ranges()
        self.draw_target_path()
        self.painter.setFont(QFont("Arial", self.font_size))
    # Draw points
    for i, vpoint in enumerate(self.vpoints):
        self.__draw_point(i, vpoint)
    # Draw solutions
    if self.select_mode == SelectMode.SOLUTION:
        for i, expr in enumerate(self.exprs):
            func = expr[0]
            params = expr[1:-1]
            target = expr[-1]
            self.draw_solution(func, params, target, self.vpoints)
            if i in self.selections:
                pos, _ = self.solution_polygon(func, params, target,
                                               self.vpoints)
                pen = QPen()
                pen.setWidth(self.link_width + 3)
                pen.setColor(QColor(161, 16, 239))
                self.painter.setPen(pen)
                self.painter.drawPolygon(QPolygonF([QPointF(x, y)
                                                    for x, y in pos]))
    # Draw a colored frame for free move mode
    if self.free_move != FreeMode.NO_FREE_MOVE:
        pen = QPen()
        if self.free_move == FreeMode.TRANSLATE:
            pen.setColor(QColor(161, 16, 229))
        elif self.free_move == FreeMode.ROTATE:
            pen.setColor(QColor(219, 162, 6))
        elif self.free_move == FreeMode.REFLECT:
            pen.setColor(QColor(79, 249, 193))
        pen.setWidth(8)
        self.painter.setPen(pen)
        self.__draw_frame()
    # Rectangular selection
    if self.selector.picking:
        pen = QPen(Qt.gray)
        pen.setWidth(1)
        self.painter.setPen(pen)
        self.painter.drawRect(self.selector.to_rect(self.zoom))
    # Show FPS
    self.fps_updated.emit()
    self.painter.end()
    # Record the widget size
    self.width_old = width
    self.height_old = height

</t>
<t tx="leo.20231205084740.228">def __mouse_pos(self, event: QMouseEvent) -&gt; Tuple[float, float]:
    """Return the mouse position mapping to main canvas."""
    return (event.x() - self.ox) / self.zoom, (
        event.y() - self.oy) / -self.zoom

</t>
<t tx="leo.20231205084740.229">def mousePressEvent(self, event: QMouseEvent) -&gt; None:
    """Press event.

    Middle button: Move canvas of view.
    Left button: Select the point (only first point will be catch).
    """
    self.selector.x, self.selector.y = self.__mouse_pos(event)
    button = event.buttons()
    if button == Qt.MiddleButton:
        self.selector.middle_dragged = True
        self.browse_tracking.emit(self.selector.x, self.selector.y)
    elif button == Qt.LeftButton:
        self.selector.left_dragged = True
        self.__select_func()
        if self.selector.selection_rect:
            self.selected.emit(tuple(self.selector.selection_rect[:1]),
                               True)

</t>
<t tx="leo.20231205084740.23">@Slot(name='on_edit_path_btn_clicked')
def __adjust_path(self) -&gt; None:
    """Show up path adjust dialog and
    get back the changes of current target path.
    """
    dlg = EditPathDialog(self)
    dlg.show()
    dlg.exec_()
    dlg.deleteLater()
    self.__current_path_changed()

</t>
<t tx="leo.20231205084740.230">def mouseDoubleClickEvent(self, event: QMouseEvent) -&gt; None:
    """Mouse double click.

    + Middle button: Zoom to fit.
    + Left button: Edit point function.
    """
    button = event.buttons()
    if button == Qt.MidButton:
        self.zoom_to_fit()
    elif button == Qt.LeftButton and (not self.show_target_path):
        self.selector.x, self.selector.y = self.__mouse_pos(event)
        self.__select_func()
        if self.selector.selection_rect:
            self.selected.emit(tuple(self.selector.selection_rect[:1]),
                               True)
            if self.free_move == FreeMode.NO_FREE_MOVE:
                self.doubleclick_edit.emit(self.selector.selection_rect[0])

</t>
<t tx="leo.20231205084740.231">def mouseReleaseEvent(self, event: QMouseEvent) -&gt; None:
    """Release mouse button.

    + Alt &amp; Left button: Add a point.
    + Left button: Select a point.
    + Free move mode: Edit the point(s) coordinate.
    """
    if self.selector.left_dragged:
        km = QApplication.keyboardModifiers()
        self.selector.selection_old = list(self.selections)
        if (
            self.select_mode == SelectMode.JOINT
            and self.free_move != FreeMode.NO_FREE_MOVE
        ):
            x, y = self.__mouse_pos(event)
            if self.selector.x != x and self.selector.y != y:
                # Edit point coordinates
                self.__emit_free_move(self.selections)
            elif (
                (not self.selector.selection_rect)
                and km != Qt.ControlModifier
                and km != Qt.ShiftModifier
            ):
                self.no_selected.emit()
        else:
            if km == Qt.AltModifier:
                # Add Point
                self.alt_add.emit(
                    self.__snap(self.selector.x, is_zoom=False),
                    self.__snap(self.selector.y, is_zoom=False)
                )
            elif (
                (not self.selector.selection_rect)
                and km != Qt.ControlModifier
                and km != Qt.ShiftModifier
            ):
                self.no_selected.emit()
    self.selected_tips_hide.emit()
    self.selector.release()
    self.update()

</t>
<t tx="leo.20231205084740.232">def mouseMoveEvent(self, event: QMouseEvent) -&gt; None:
    """Move mouse.

    + Middle button: Translate canvas view.
    + Left button: Free move mode / Rectangular selection.
    """
    x, y = self.__mouse_pos(event)
    if self.selector.middle_dragged:
        self.ox = event.x() - self.selector.x * self.zoom
        self.oy = event.y() + self.selector.y * self.zoom
        self.update()
    elif self.selector.left_dragged:
        if self.free_move == FreeMode.NO_FREE_MOVE:
            if self.show_target_path:
                self.set_target_point.emit(x, y)
            else:
                # Rectangular selection
                self.selector.picking = True
                self.selector.sx = self.__snap(x, is_zoom=False)
                self.selector.sy = self.__snap(y, is_zoom=False)
                self.__select_func(rect=True)
                selection = self.selector.current_selection()
                if selection:
                    self.selected.emit(selection, False)
                else:
                    self.no_selected.emit()
                self.selected_tips.emit(
                    event.globalPos(),
                    f"({self.selector.x:.02f}, {self.selector.y:.02f})\n"
                    f"({self.selector.sx:.02f}, {self.selector.sy:.02f})\n"
                    f"{len(selection)} "
                    f"{_selection_unit[self.select_mode]}(s)"
                )
        elif self.select_mode == SelectMode.JOINT:
            if self.free_move == FreeMode.TRANSLATE:
                # Free move translate function
                mouse_x = self.__snap(x - self.selector.x, is_zoom=False)
                mouse_y = self.__snap(y - self.selector.y, is_zoom=False)
                self.selected_tips.emit(
                    event.globalPos(),
                    f"{mouse_x:+.02f}, {mouse_y:+.02f}"
                )
                for num in self.selections:
                    vpoint = self.vpoints[num]
                    vpoint.move((mouse_x + vpoint.x, mouse_y + vpoint.y))
            elif self.free_move == FreeMode.ROTATE:
                # Free move rotate function
                alpha = atan2(y, x) - atan2(self.selector.y,
                                            self.selector.x)
                self.selected_tips.emit(
                    event.globalPos(),
                    f"{degrees(alpha):+.02f}°"
                )
                for num in self.selections:
                    vpoint = self.vpoints[num]
                    r = hypot(vpoint.x, vpoint.y)
                    beta = atan2(vpoint.y, vpoint.x)
                    vpoint.move(
                        (r * cos(beta + alpha), r * sin(beta + alpha)))
                    if vpoint.type in {VJoint.P, VJoint.RP}:
                        vpoint.rotate(
                            self.vangles[num] + degrees(beta + alpha))
            elif self.free_move == FreeMode.REFLECT:
                # Free move reflect function
                fx = 1 if x &gt; 0 else -1
                fy = 1 if y &gt; 0 else -1
                self.selected_tips.emit(
                    event.globalPos(),
                    f"{fx:+d}, {fy:+d}"
                )
                for num in self.selections:
                    vpoint = self.vpoints[num]
                    if vpoint.type == VJoint.R:
                        vpoint.move((vpoint.x * fx, vpoint.y * fy))
                    else:
                        vpoint.move((vpoint.x * fx, vpoint.y * fy))
                        if (x &gt; 0) != (y &gt; 0):
                            vpoint.rotate(180 - self.vangles[num])
            if self.free_move != FreeMode.NO_FREE_MOVE and self.selections:
                self.update_preview_path()
        self.update()
    self.tracking.emit(x, y)

</t>
<t tx="leo.20231205084740.233">def zoom_to_fit(self) -&gt; None:
    """Zoom to fit function."""
    width = self.width()
    height = self.height()
    width = width if width else 1
    height = height if height else 1
    x_right, x_left, y_top, y_bottom = self.__zoom_to_fit_size()
    inf = float('inf')
    if (inf in {x_right, y_bottom}) or (-inf in {x_left, y_top}):
        # Default scale value
        self.zoom_changed.emit(self.default_zoom)
        self.ox = width / 2
        self.oy = height / 2
        self.update()
        return
    factor = BaseCanvas.zoom_factor(width, height, x_right, x_left, y_top,
                                    y_bottom)
    self.zoom_changed.emit(int(factor * self.margin_factor * 50))
    self.ox = (width - (x_left + x_right) * self.zoom) / 2
    self.oy = (height + (y_top + y_bottom) * self.zoom) / 2
    self.update()

</t>
<t tx="leo.20231205084740.234">@Slot()
def update_preview_path(self) -&gt; None:
    """Update preview path."""
    self.preview_path(self.path_preview, self.slider_path_preview,
                      self.vpoints)
    self.update()
</t>
<t tx="leo.20231205084740.235">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/widgets/
# -*- coding: utf-8 -*-

"""Predefined methods of main window."""

from __future__ import annotations

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Tuple, List, Sequence, Dict, Mapping, Optional, Any
from abc import abstractmethod
from qtpy.QtCore import Qt, QPoint
from qtpy.QtWidgets import QMainWindow
from pyslvs import VPoint
from pyslvs.graph import Graph
from pyslvs_ui.qt_patch import QABCMeta
from .main_ui import Ui_MainWindow

_Coord = Tuple[float, float]
_Phase = Tuple[float, float, float]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.236">class MainWindowABC(QMainWindow, Ui_MainWindow, metaclass=QABCMeta):
    """Main window abstract class."""

    @others
</t>
<t tx="leo.20231205084740.237">@abstractmethod
def __init__(self):
    super(MainWindowABC, self).__init__()
    self.setupUi(self)
    self.setAttribute(Qt.WA_DeleteOnClose)

</t>
<t tx="leo.20231205084740.238">@abstractmethod
def command_reload(self, index: int) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.239">@abstractmethod
def new_point(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.24">@Slot(name='on_norm_path_btn_clicked')
def __norm_path(self) -&gt; None:
    """Normalize current path."""
    scale, ok = QInputDialog.getDouble(
        self,
        "Scale",
        "Length of unit vector:",
        60, 0.01, 1000, 2)
    if ok:
        self.set_path(norm_path(self.current_path(), scale))

</t>
<t tx="leo.20231205084740.240">@abstractmethod
def add_normal_point(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.241">@abstractmethod
def add_fixed_point(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.242">@abstractmethod
def edit_point(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.243">@abstractmethod
def delete_selected_points(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.244">@abstractmethod
def lock_points(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.245">@abstractmethod
def new_link(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.246">@abstractmethod
def edit_link(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.247">@abstractmethod
def delete_selected_links(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.248">@abstractmethod
def deduce_links(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.249">@abstractmethod
def constrain_link(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.25">def add_point(self, x: float, y: float) -&gt; None:
    """Add path data to list widget and current target path."""
    self.current_path().append((x, y))
    self.path_list.addItem(f"({x:.08f}, {y:.08f})")
    self.path_list.setCurrentRow(self.path_list.count() - 1)
    self.__current_path_changed()

</t>
<t tx="leo.20231205084740.250">@abstractmethod
def release_ground(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.251">@abstractmethod
def add_target_point(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.252">@abstractmethod
def set_free_move(self, args: Sequence[Tuple[int, _Phase]]) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.253">@abstractmethod
def add_point_by_pos(self, x: float, y: float) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.254">@abstractmethod
def set_mouse_pos(self, x: float, y: float) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.255">@abstractmethod
def get_back_position(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.256">@abstractmethod
def solve(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.257">@abstractmethod
def resolve(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.258">@abstractmethod
def enable_mechanism_actions(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.259">@abstractmethod
def clone_point(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.26">def set_path(self, path: Iterable[_Coord], *, clear: bool = True) -&gt; None:
    """Set the current path."""
    if clear:
        self.clear_path(ask=False)
    for x, y in path:
        self.add_point(x, y)
    self.__current_path_changed()

</t>
<t tx="leo.20231205084740.260">@abstractmethod
def copy_coord(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.261">@abstractmethod
def copy_points_table(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.262">@abstractmethod
def copy_links_table(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.263">@abstractmethod
def canvas_context_menu(self, point: QPoint) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.264">@abstractmethod
def point_context_menu(self, point: QPoint) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.265">@abstractmethod
def link_context_menu(self, point: QPoint) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.266">@abstractmethod
def preview_path(
    self,
    auto_preview: List[List[_Coord]],
    slider_auto_preview: Dict[int, List[_Coord]],
    vpoints: Sequence[VPoint]
) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.267">@abstractmethod
def reload_canvas(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.268">@abstractmethod
def output_to(self, format_name: str, format_choose: Sequence[str]) -&gt; str:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.269">@abstractmethod
def right_input(self) -&gt; bool:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.27">@Slot(float, float)
def set_point(self, x: float, y: float) -&gt; None:
    """Set the coordinate of current target path."""
    if not self.edit_target_point_btn.isChecked():
        return
    for i, (cx, cy) in enumerate(self.current_path()):
        if hypot(x - cx, y - cy) &lt; 10 / self.get_zoom():
            index = i
            self.path_list.setCurrentRow(index)
            break
    else:
        return
    self.current_path()[index] = (x, y)
    self.path_list.item(index).setText(f"({x:.04f}, {y:.04f})")
    self.__current_path_changed()

</t>
<t tx="leo.20231205084740.270">@abstractmethod
def set_coords_as_current(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.271">@abstractmethod
def dof(self) -&gt; int:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.272">@abstractmethod
def save_reply_box(self, title: str, file_name: str) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.273">@abstractmethod
def input_from(
    self,
    format_name: str,
    format_choose: Sequence[str]
) -&gt; str:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.274">@abstractmethod
def input_from_multiple(
    self,
    format_name: str,
    format_choose: Sequence[str]
) -&gt; List[str]:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.275">@abstractmethod
def get_graph(self) -&gt; Tuple[
    Graph,
    List[int],
    List[Tuple[int, int]],
    Mapping[int, _Coord],
    Mapping[int, int],
    Mapping[int, int]
]:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.276">@abstractmethod
def get_configure(self) -&gt; Mapping[str, Any]:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.277">@abstractmethod
def project_no_save(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.278">@abstractmethod
def project_saved(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.279">@abstractmethod
def merge_result(self, expr: str, path: Sequence[Sequence[_Coord]]) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.28">@Slot(name='on_point_up_clicked')
def __move_up_point(self) -&gt; None:
    """Target point move up."""
    row = self.path_list.currentRow()
    if not (row &gt; 0 and self.path_list.count() &gt; 1):
        return
    path = self.current_path()
    path.insert(row - 1, (path[row][0], path[row][1]))
    path.pop(row + 1)
    c = self.path_list.currentItem().text()[1:-1].split(", ")
    self.path_list.insertItem(row - 1, f"({c[0]}, {c[1]})")
    self.path_list.takeItem(row + 1)
    self.path_list.setCurrentRow(row - 1)
    self.__current_path_changed()

</t>
<t tx="leo.20231205084740.280">@abstractmethod
def check_file_changed(self) -&gt; bool:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.281">@abstractmethod
def get_storage(self) -&gt; Mapping[str, str]:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.282">@abstractmethod
def add_empty_links(self, link_color: Mapping[str, str]) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.283">@abstractmethod
def parse_expression(self, expr: str) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.284">@abstractmethod
def add_multiple_storage(self, exprs: Mapping[str, str]) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.285">@abstractmethod
def clear(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.286">@abstractmethod
def add_points(
    self,
    p_attr: Sequence[Tuple[float, float, str, str, int, float]]
) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.287">@abstractmethod
def add_points_by_graph(
    self,
    graph: Graph,
    pos: Dict[int, Tuple[float, float]],
    ground_link: Optional[int]
) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.288">@abstractmethod
def set_window_title_full_path(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.289">@abstractmethod
def import_pmks_url(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.29">@Slot(name='on_point_down_clicked')
def __move_down_point(self) -&gt; None:
    """Target point move down."""
    row = self.path_list.currentRow()
    if not (
        row &lt; self.path_list.count() - 1
        and self.path_list.count() &gt; 1
    ):
        return
    path = self.current_path()
    path.insert(row + 2, (path[row][0], path[row][1]))
    path.pop(row)
    c = self.path_list.currentItem().text()[1:-1].split(", ")
    self.path_list.insertItem(row + 2, f"{c[0]}, {c[1]}")
    self.path_list.takeItem(row)
    self.path_list.setCurrentRow(row + 1)
    self.__current_path_changed()

</t>
<t tx="leo.20231205084740.290">@abstractmethod
def save_picture_clipboard(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.291">@abstractmethod
def show_expr(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.292">@abstractmethod
def py_script(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.293">@abstractmethod
def export_dxf(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.294">@abstractmethod
def export_slvs(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.295">@abstractmethod
def save_pmks(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.296">@abstractmethod
def export_image(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.297">@abstractmethod
def show_overview(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.298">@staticmethod
@abstractmethod
def new() -&gt; MainWindowABC:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.299">@abstractmethod
def point_alignment(self) -&gt; None:
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.3">def retranslateUi(self, Form):
    _translate = QtCore.QCoreApplication.translate
    self.verticalGroupBox.setTitle(_translate("Form", "Results"))
    self.result_load_settings.setStatusTip(_translate("Form", "Load the setting of this result."))
    self.delete_btn.setStatusTip(_translate("Form", "Delete this result."))
    self.merge_btn.setStatusTip(_translate("Form", "Merge this result to canvas."))
    self.target_label.setText(_translate("Form", "&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=\" color:#ff0000;\"&gt;※ Use &amp;quot;Alt + LF&amp;quot; to add the path points.&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"))
    self.load_profile.setStatusTip(_translate("Form", "Load profile from triangular iteration database."))
    self.save_profile.setStatusTip(_translate("Form", "Save the structure profile back to the database."))
    self.clear_btn.setStatusTip(_translate("Form", "Clear the current profile and settings."))
    self.preview_box.setTitle(_translate("Form", "Preview"))
    self.parameter_list.setStatusTip(_translate("Form", "All the joints of grounded link will show here."))
    item = self.parameter_list.horizontalHeaderItem(0)
    item.setText(_translate("Form", "Name"))
    item = self.parameter_list.horizontalHeaderItem(1)
    item.setText(_translate("Form", "Role"))
    item = self.parameter_list.horizontalHeaderItem(2)
    item.setText(_translate("Form", "p0"))
    item = self.parameter_list.horizontalHeaderItem(3)
    item.setText(_translate("Form", "p1"))
    item = self.parameter_list.horizontalHeaderItem(4)
    item.setText(_translate("Form", "Range"))
    self.options_tab.setTabText(self.options_tab.indexOf(self.structure), _translate("Form", "Structure"))
    self.shape_only_option.setText(_translate("Form", "Compare shape only"))
    self.copy_format_groupbox.setTitle(_translate("Form", "Copy"))
    self.copy_as_csv.setText(_translate("Form", "Comma-Separated Values"))
    self.copy_as_array.setText(_translate("Form", "Array-like"))
    self.path_copy.setStatusTip(_translate("Form", "Copy the path data as a string."))
    self.path_copy.setText(_translate("Form", "Copy Curve Data"))
    self.point_num.setText(_translate("Form", "&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=\" font-size:12pt; color:#00aa00;\"&gt;0&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"))
    self.path_paste.setStatusTip(_translate("Form", "Past path data from string format."))
    self.path_clear.setStatusTip(_translate("Form", "Clear all points."))
    self.point_up.setStatusTip(_translate("Form", "Move the point up."))
    self.point_down.setStatusTip(_translate("Form", "Move the point down."))
    self.point_delete.setStatusTip(_translate("Form", "Remove the point."))
    self.edit_target_point_btn.setStatusTip(_translate("Form", "User can edit target point immediately."))
    self.save_path_btn.setStatusTip(_translate("Form", "Save current path as csv file."))
    self.import_csv_btn.setStatusTip(_translate("Form", "Import path from CSV format."))
    self.import_xlsx_btn.setStatusTip(_translate("Form", "Import path from Microsoft Excel format."))
    self.append_path_btn.setStatusTip(_translate("Form", "Append new points from text."))
    self.edit_path_btn.setStatusTip(_translate("Form", "Edit the target path."))
    self.norm_path_btn.setStatusTip(_translate("Form", "Apply normalization on current path."))
    self.options_tab.setTabText(self.options_tab.indexOf(self.target_path), _translate("Form", "Target path"))
    self.advance_btn.setStatusTip(_translate("Form", "More algorithm settings."))
    self.advance_btn.setText(_translate("Form", "Advance Options"))
    self.label_7.setText(_translate("Form", "Time spent:"))
    self.timeShow.setText(_translate("Form", "&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=\" font-size:16pt;\"&gt;[N/A]&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"))
    self.options_tab.setTabText(self.options_tab.indexOf(self.algorithm), _translate("Form", "Algorithm"))
    self.synthesis_btn.setStatusTip(_translate("Form", "Start dimesional synthesis."))
    self.synthesis_btn.setText(_translate("Form", "Synthesis"))
</t>
<t tx="leo.20231205084740.30">@Slot(name='on_point_delete_clicked')
def __delete_point(self) -&gt; None:
    """Delete a target point."""
    row = self.path_list.currentRow()
    if not row &gt; -1:
        return
    self.current_path().pop(row)
    self.path_list.takeItem(row)
    self.__current_path_changed()

</t>
<t tx="leo.20231205084740.300">@abstractmethod
def get_expression(
    self,
    points: Optional[Sequence[VPoint]] = None,
    indent: int = -1
) -&gt; str:
    raise NotImplementedError
</t>
<t tx="leo.20231205084740.301">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/widgets/
# -*- coding: utf-8 -*-

"""The custom widgets of main window.

+ Sub widgets.
+ Context menus.
"""

from __future__ import annotations

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import (
    cast, TypeVar, Tuple, List, Sequence, Iterator, Callable,
    Union, Optional, Type,
)
from abc import abstractmethod, ABC
from enum import Flag, auto, unique
from dataclasses import dataclass, field, fields, Field, astuple
from qtpy.QtCore import Slot, Qt, QPoint, QDir, QSettings
from qtpy.QtWidgets import (
    QAction,
    QWidget,
    QMenu,
    QLabel,
    QPushButton,
    QUndoStack,
)
from qtpy.QtGui import QIcon, QPixmap
from pyslvs import VPoint, VLink, color_rgb
from pyslvs_ui.info import ARGUMENTS, logger, Kernel
from pyslvs_ui.io import ProjectWidget, ProjectFormat
from pyslvs_ui.synthesis import StructureSynthesis, Collections, Optimizer
from .main_abc import MainWindowABC
from .canvas import MainCanvas
from .tables import (
    BaseTableWidget,
    PointTableWidget,
    LinkTableWidget,
    ExprTableWidget,
    SelectionLabel,
    FPSLabel,
)
from .inputs import InputsWidget

_N = TypeVar('_N')
_Action = Union[List[QAction], QMenu]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.302">def _set_actions(actions: Sequence[QAction], state: bool) -&gt; None:
    """Set actions method."""
    for action in actions:
        action.setVisible(state)


</t>
<t tx="leo.20231205084740.303">@unique
class _Enable(Flag):
    # Conditions
    # No / One / Any / Multiple / Ground / Not ground
    P_NO = auto()
    P_ONE = auto()
    P_ANY = auto()
    P_MUL = auto()
    L_NO = auto()
    L_ONE = auto()
    L_ANY = auto()
    L_MUL = auto()
    L_GND = auto()
    L_N_GND = auto()
    # Menus
    # Table / Context menu
    P_T = auto()
    L_T = auto()
    P_C = auto()
    L_C = auto()
    # Optimizer page
    OPT = auto()


</t>
<t tx="leo.20231205084740.304">@dataclass(repr=False, eq=False)
class _Context:
    """Context menu actions."""
    p_no: List[QAction] = field(default_factory=list)
    p_one: List[QAction] = field(default_factory=list)
    p_any: List[QAction] = field(default_factory=list)
    p_mul: List[QAction] = field(default_factory=list)
    l_no: List[QAction] = field(default_factory=list)
    l_one: List[QAction] = field(default_factory=list)
    l_any: List[QAction] = field(default_factory=list)
    l_mul: List[QAction] = field(default_factory=list)
    l_gnd: List[QAction] = field(default_factory=list)
    l_n_gnd: List[QAction] = field(default_factory=list)
    opt: List[QAction] = field(default_factory=list)

    @others
</t>
<t tx="leo.20231205084740.305">def point_enable(self, count: int) -&gt; None:
    """Point operations settings."""
    for actions, state in (
        (self.p_no, count == 0),
        (self.p_one, count == 1),
        (self.p_any, count &gt; 0),
        (self.p_mul, count &gt; 1),
    ):
        _set_actions(actions, state)

</t>
<t tx="leo.20231205084740.306">def link_enable(self, count: int, current_row: int) -&gt; None:
    """Link operations settings."""
    for actions, state in (
        (self.l_no, count == 0),
        (self.l_one, count == 1),
        (self.l_any, count &gt; 0),
        (self.l_mul, count &gt; 1),
    ):
        _set_actions(actions, state)
    for actions, state in (
        (self.l_gnd, current_row == 0),
        (self.l_n_gnd, current_row != 0),
    ):
        for action in actions:
            action.setVisible(action.isVisible() and state)

</t>
<t tx="leo.20231205084740.307">def __getitem__(self, key: _Enable) -&gt; Tuple[_Action, ...]:
    meta = []
    for enable in _Enable:  # type: _Enable
        if enable in key:
            if enable.name is None:
                raise ValueError("invalid enum")
            meta.append(getattr(self, enable.name.lower()))
    return tuple(meta)

</t>
<t tx="leo.20231205084740.308">def __setitem__(self, key: _Enable, value: _Action) -&gt; None:
    if key.name is None:
        raise ValueError("invalid enum")
    self.__setattr__(key.name.lower(), value)


</t>
<t tx="leo.20231205084740.309">@dataclass(repr=False)
class Preferences:
    """The settings of Pyslvs."""
    line_width_option: int = 3
    font_size_option: int = 14
    path_width_option: int = 3
    scale_factor_option: int = 10
    selection_radius_option: int = 10
    link_trans_option: int = 0
    margin_factor_option: int = 5
    joint_size_option: int = 10
    zoom_by_option: int = 0
    snap_option: float = 1
    tick_mark_option: int = 1
    nav_toolbar_pos_option: int = 1
    default_zoom_option: int = 500
    grab_no_background_option: bool = True
    monochrome_option: bool = False
    undo_limit_option: int = 60
    open_project_actions_option: int = 1
    file_type_option: ProjectFormat = ProjectFormat.YAML
    planar_solver_option: int = 0
    path_preview_option: int = Kernel.SAME_AS_SOLVING
    auto_remove_link_option: bool = True
    title_full_path_option: bool = False
    console_error_option: bool = ARGUMENTS.debug_mode
    # "Do not save the settings" by default
    not_save_option: bool = True

    @others
</t>
<t tx="leo.20231205084740.31">def __able_to_generate(self) -&gt; None:
    """Set button enable if all the data are already."""
    self.point_num.setText(
        "&lt;p&gt;&lt;span style=\"font-size:12pt;"
        f"color:#00aa00;\"&gt;{self.path_list.count()}&lt;/span&gt;&lt;/p&gt;"
    )
    n = bool(
        self.mech
        and self.path_list.count() &gt; 2
        and self.expression_string.text()
    )
    for button in (
        self.save_path_btn,
        self.edit_path_btn,
        self.norm_path_btn,
        self.synthesis_btn,
    ):
        button.setEnabled(n)

</t>
<t tx="leo.20231205084740.310">def diff(self, other: Optional[Preferences]) -&gt; Iterator[str]:
    """Show the fields of differences.
    Pass None to iterate over all names.
    """
    for field_obj in fields(self):  # type: Field
        name: str = field_obj.name
        if other is None or getattr(self, name) != getattr(other, name):
            yield name

</t>
<t tx="leo.20231205084740.311">def reset(self) -&gt; None:
    """Reset the user values."""
    for field_obj in fields(self):  # type: Field
        setattr(self, field_obj.name, field_obj.default)

</t>
<t tx="leo.20231205084740.312">def copy(self):
    """Make a copy of preference data."""
    return Preferences(*astuple(self))


</t>
<t tx="leo.20231205084740.313">class MainWindowBase(MainWindowABC, ABC):
    """External UI settings."""
    vpoint_list: List[VPoint]
    vlink_list: List[VLink]

    __tables: Sequence[BaseTableWidget]

    @others
</t>
<t tx="leo.20231205084740.314">@abstractmethod
def __init__(self):
    super(MainWindowBase, self).__init__()
    # Environment path
    self.env = ""
    # Alignment mode
    self.alignment_mode = 0
    # Entities list
    self.vpoint_list = []
    self.vlink_list = [VLink(VLink.FRAME, 'White', (), color_rgb)]
    # Condition list of context menus
    self.context = _Context()
    # Preference
    self.prefer = Preferences()
    # Set path from command line
    home_dir = QDir.home()
    self.settings = QSettings(
        home_dir.absoluteFilePath(".pyslvs.ini"),
        QSettings.IniFormat,
        self
    )
    if ARGUMENTS.c:
        self.set_locate(QDir(ARGUMENTS.c).absolutePath())
    else:
        home_dir.cd("Desktop")
        env = self.settings.value("ENV", home_dir.absolutePath())
        self.set_locate(str(env))

    # Initialize custom UI
    self.__undo_redo()
    self.__appearance()
    self.__alignment()
    self.__free_move()
    self.__options()
    self.__context_menu()

</t>
<t tx="leo.20231205084740.315">def env_path(self) -&gt; str:
    """Return environment path."""
    return self.env

</t>
<t tx="leo.20231205084740.316">def set_locate(self, locate: str) -&gt; None:
    """Set environment variables."""
    if locate == self.env or not QDir(locate).exists():
        return
    self.env = locate
    logger.debug(f"~Set workplace to: \"{self.env}\"")

</t>
<t tx="leo.20231205084740.317">def __undo_redo(self) -&gt; None:
    """Undo list settings.

    + Undo stack.
    + Undo view widget.
    + Hot keys.
    """
    self.cmd_stack = QUndoStack(self)
    self.cmd_stack.setUndoLimit(self.prefer.undo_limit_option)
    self.cmd_stack.indexChanged.connect(self.command_reload)
    redo = self.cmd_stack.createRedoAction(self, "Redo")
    undo = self.cmd_stack.createUndoAction(self, "Undo")
    redo.setShortcuts(["Ctrl+Shift+Z", "Ctrl+Y"])
    redo.setStatusTip("Backtracking undo action.")
    redo.setIcon(QIcon(QPixmap("icons:redo.png")))
    undo.setShortcut("Ctrl+Z")
    undo.setStatusTip("Recover last action.")
    undo.setIcon(QIcon(QPixmap("icons:undo.png")))
    self.menu_edit.insertActions(self.action_new_point, [undo, redo])
    self.menu_edit.insertSeparator(self.action_new_point)

</t>
<t tx="leo.20231205084740.318">def __appearance(self) -&gt; None:
    """Start up and initialize custom widgets."""
    # Entities tables
    tab_bar = self.entities_tab.tabBar()
    tab_bar.setStatusTip("Switch the tabs to change to another view mode.")
    self.entities_point = PointTableWidget(self.entities_point_widget)
    self.entities_point.cellDoubleClicked.connect(self.edit_point)
    self.entities_point.delete_request.connect(self.delete_selected_points)
    self.entities_point_layout.addWidget(self.entities_point)
    self.entities_link = LinkTableWidget(self.entities_link_widget)
    self.entities_link.cellDoubleClicked.connect(self.edit_link)
    self.entities_link.delete_request.connect(self.delete_selected_links)
    self.entities_link_layout.addWidget(self.entities_link)
    self.entities_expr = ExprTableWidget(self.EntitiesExpr_widget)
    self.entities_expr_layout.insertWidget(0, self.entities_expr)
    self.__tables = (
        self.entities_point,
        self.entities_link,
        self.entities_expr,
    )

    # Select all button on the Point and Link tab as corner widget
    select_all_btn = QPushButton()
    select_all_btn.setIcon(QIcon(QPixmap("icons:select_all.png")))
    select_all_btn.setToolTip("Select all")
    select_all_btn.setStatusTip("Select all item of point table.")

    @Slot()
    def table_select_all() -&gt; None:
        """Distinguish table by tab index."""
        self.__tables[self.entities_tab.currentIndex()].selectAll()

    select_all_btn.clicked.connect(table_select_all)
    self.entities_tab.setCornerWidget(select_all_btn)
    select_all_action = QAction("Select all point", self)
    select_all_action.triggered.connect(table_select_all)
    select_all_action.setShortcut("Ctrl+A")
    select_all_action.setShortcutContext(Qt.WindowShortcut)
    self.addAction(select_all_action)

    # QPainter canvas window
    self.main_canvas = MainCanvas(self)
    self.entities_tab.currentChanged.connect(
        self.main_canvas.set_selection_mode)
    select_tips = QLabel(self, Qt.ToolTip)

    @Slot(QPoint, str)
    def show_select_tips(pos: QPoint, text: str) -&gt; None:
        select_tips.setText(text)
        select_tips.move(pos - QPoint(0, select_tips.height()))
        select_tips.show()

    self.main_canvas.selected_tips.connect(show_select_tips)
    self.main_canvas.selected_tips_hide.connect(select_tips.hide)

    @Slot(tuple, bool)
    def table_selection(selection: Sequence[int], check_key: bool) -&gt; None:
        """Distinguish table by tab index."""
        index = self.entities_tab.currentIndex()
        self.__tables[index].set_selections(selection, check_key)

    self.main_canvas.selected.connect(table_selection)
    self.entities_point.row_selection_changed.connect(
        self.main_canvas.set_selection)

    @Slot()
    def table_clear_selection() -&gt; None:
        """Clear the selection of specific table by tab index."""
        index = self.entities_tab.currentIndex()
        self.__tables[index].clearSelection()

    clean_selection_action = QAction("Clean selection", self)
    clean_selection_action.triggered.connect(table_clear_selection)
    clean_selection_action.setShortcut("Esc")
    clean_selection_action.setShortcutContext(Qt.WindowShortcut)
    self.main_canvas.no_selected.connect(table_clear_selection)
    self.addAction(clean_selection_action)

    self.main_canvas.free_moved.connect(self.set_free_move)
    self.main_canvas.alt_add.connect(self.add_point_by_pos)
    self.main_canvas.doubleclick_edit.connect(self.edit_point)
    self.main_canvas.zoom_changed.connect(self.zoom_bar.setValue)
    self.main_canvas.tracking.connect(self.set_mouse_pos)
    self.canvas_layout.insertWidget(0, self.main_canvas)
    self.canvas_splitter.setSizes([600, 10, 30])

    # Selection label on status bar right side
    selection_label = SelectionLabel(self)
    self.entities_point.selectionLabelUpdate.connect(
        selection_label.update_select_point)
    self.main_canvas.browse_tracking.connect(
        selection_label.update_mouse_position)
    self.status_bar.addPermanentWidget(selection_label)

    # FPS label on status bar right side
    fps_label = FPSLabel(self)
    self.main_canvas.fps_updated.connect(fps_label.update_text)
    self.status_bar.addPermanentWidget(fps_label)

    # Inputs widget
    self.inputs_widget = InputsWidget(self)
    self.inputs_tab_layout.addWidget(self.inputs_widget)
    self.free_move_btn.toggled.connect(
        self.inputs_widget.variable_value_reset)
    self.inputs_widget.about_to_resolve.connect(self.resolve)

    @Slot(tuple, bool)
    def inputs_selection(selections: Sequence[int], _=None) -&gt; None:
        """Distinguish table by tab index."""
        self.inputs_widget.clear_selection()
        if self.entities_tab.currentIndex() == 0:
            self.inputs_widget.set_selection(selections)

    self.main_canvas.selected.connect(inputs_selection)
    self.main_canvas.no_selected.connect(self.inputs_widget.clear_selection)
    self.inputs_widget.update_preview_btn.clicked.connect(
        self.main_canvas.update_preview_path)

    # Synthesis collections
    self.collections = Collections(self)
    # Number and type synthesis
    self.structure_synthesis = StructureSynthesis(self)
    # Dimensional synthesis
    self.optimizer = Optimizer(self)
    self.main_canvas.set_target_point.connect(self.optimizer.set_point)
    for widget, name in [
        (self.structure_synthesis, "Structure"),
        (self.collections, "Collections"),
        (self.optimizer, "Optimizer"),
    ]:  # type: QWidget, str
        self.synthesis_tab_widget.addTab(widget, widget.windowIcon(), name)
    # Same options of structure previews
    as_node1 = self.collections.structure_widget.graph_link_as_node
    as_node2 = self.structure_synthesis.graph_link_as_node
    as_node1.toggled.connect(as_node2.setChecked)
    as_node2.toggled.connect(as_node1.setChecked)
    show_label1 = self.collections.structure_widget.graph_show_label
    show_label2 = self.structure_synthesis.graph_show_label
    show_label1.toggled.connect(show_label2.setChecked)
    show_label2.toggled.connect(show_label1.setChecked)
    # File widget settings
    self.project_widget = ProjectWidget(self)
    self.project_layout.addWidget(self.project_widget)
    # Zooming and console dock will hide when startup
    self.zoom_widget.hide()
    self.console_widget.hide()
    # Connect to GUI button
    debug_mode = ARGUMENTS.debug_mode
    self.console_disconnect_btn.setEnabled(not debug_mode)
    self.console_connect_btn.setEnabled(debug_mode)
    # Splitter stretch factor
    self.main_splitter.setStretchFactor(0, 4)
    self.main_splitter.setStretchFactor(1, 15)
    self.mechanism_panel_splitter.setSizes([500, 200])
    # Enable mechanism menu actions when shows
    self.menu_edit.aboutToShow.connect(self.enable_mechanism_actions)
    # New main window function
    self.action_new_window.triggered.connect(self.new)

</t>
<t tx="leo.20231205084740.319">def __alignment(self) -&gt; None:
    """Menu of alignment function."""

    def switch_icon(m: int, icon_name: str) -&gt; Callable[[], None]:
        @others
        return func

    menu = QMenu(self)
    for i, (text, icon) in enumerate([
        ("Vertical alignment", "vertical_align"),
        ("Horizontal alignment", "horizontal_align"),
    ]):
        icon = f"icons:{icon}.png"
        action = QAction(QIcon(QPixmap(icon)), text, self)
        action.triggered.connect(switch_icon(i, icon))
        menu.addAction(action)
    self.alignment_btn.setMenu(menu)
    self.alignment_btn.clicked.connect(self.point_alignment)

</t>
<t tx="leo.20231205084740.32">@Slot(name='on_synthesis_btn_clicked')
def __synthesis(self) -&gt; None:
    """Start synthesis."""
    # Check if the amount of the target points are same
    length = -1
    for path in self.path.values():
        if length &lt; 0:
            length = len(path)
        if len(path) != length:
            QMessageBox.warning(
                self,
                "Target Error",
                "The length of target paths should be the same."
            )
            return
    # Get the algorithm type
    for option, button in self.algorithm_options.items():
        if button.isChecked():
            algorithm = option
            break
    else:
        raise ValueError("no option")
    mech = deepcopy(self.mech)
    mech['shape_only'] = self.shape_only_option.isChecked()
    if mech['shape_only']:
        if QMessageBox.question(
            self,
            "Elliptical Fourier Descriptor",
            "An even distribution will make the comparison more accurate.\n"
            "Do you make sure yet?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        ) == QMessageBox.No:
            return
    mech['expression'] = parse_vpoints(mech.pop('expression', []))
    mech['target'] = deepcopy(self.path)

    def name_in_table(target_name: str) -&gt; int:
        """Find a target_name and return the row from the table."""
        for r in range(self.parameter_list.rowCount()):
            if self.parameter_list.item(r, 0).text() == target_name:
                return r
        return -1

    placement: Dict[int, Tuple[float, float, float]] = mech['placement']
    for name in placement:
        row = name_in_table(f"P{name}")
        placement[name] = (
            self.parameter_list.cellWidget(row, 2).value(),
            self.parameter_list.cellWidget(row, 3).value(),
            self.parameter_list.cellWidget(row, 4).value(),
        )
    # Start progress dialog
    dlg = ProgressDialog(algorithm, mech, self.alg_options, self)
    dlg.show()
    if not dlg.exec_():
        dlg.deleteLater()
        return
    mechanisms_plot: List[Mapping[str, Any]] = []
    for data in dlg.mechanisms:
        mechanisms_plot.append({
            'time_fitness': data.pop('time_fitness'),
            'algorithm': data['algorithm'],
        })
        self.mechanism_data.append(data)
        self.__add_result(data)
    self.__set_time(dlg.time_spend)
    self.project_no_save()
    dlg.deleteLater()
    dlg = ChartDialog("Convergence Data", mechanisms_plot, self)
    dlg.show()
    dlg.exec_()
    dlg.deleteLater()

</t>
<t tx="leo.20231205084740.320">@Slot()
def func() -&gt; None:
    self.alignment_mode = m
    self.alignment_btn.setIcon(QIcon(QPixmap(icon_name)))

</t>
<t tx="leo.20231205084740.321">def __free_move(self) -&gt; None:
    """Menu of free move mode."""

    def free_move_mode_func(j: int, icon_qt: QIcon) -&gt; Callable[[], None]:
        @others
        return func

    menu = QMenu(self)
    for i, (text, icon, tip) in enumerate([
        ("View mode", "free_move_off", "Disable free move mode."),
        ("Translate mode", "translate", "Edit by 2 DOF moving."),
        ("Rotate mode", "rotate", "Edit by 1 DOF moving."),
        ("Reflect mode", "reflect", "Edit by flip axis."),
    ]):
        action = QAction(QIcon(QPixmap(f"icons:{icon}.png")), text, self)
        action.triggered.connect(free_move_mode_func(i, action.icon()))
        action.setShortcut(f"Ctrl+{i + 1}")
        action.setShortcutContext(Qt.WindowShortcut)
        action.setStatusTip(tip)
        menu.addAction(action)
        if i == 0:
            self.free_move_disable = action
    self.free_move_btn.setMenu(menu)

</t>
<t tx="leo.20231205084740.322">@Slot()
def func() -&gt; None:
    self.free_move_btn.setIcon(icon_qt)
    self.main_canvas.set_free_move(j)
    self.entities_tab.setCurrentIndex(0)
    self.inputs_widget.variable_stop.click()

</t>
<t tx="leo.20231205084740.323">def __options(self) -&gt; None:
    """Signal connection for option widgets.

    + Spin boxes
    + Combo boxes
    + Check boxes
    """
    # While value change, update the canvas widget
    self.zoom_bar.valueChanged.connect(self.main_canvas.set_zoom)
    self.action_show_point_mark.toggled.connect(
        self.main_canvas.set_point_mark)
    self.action_show_dimensions.toggled.connect(
        self.main_canvas.set_show_dimension)

</t>
<t tx="leo.20231205084740.324">def __action(
    self,
    name: Union[str, QAction],
    slot: Optional[Callable[..., None]] = None,
    enable: Optional[_Enable] = None,
    *,
    to: Type[_N]
) -&gt; _N:
    """New action or menu."""
    is_menu = to is QMenu
    if isinstance(name, QAction):
        menu: Optional[QMenu] = None
        action = name
    elif is_menu:
        menu = QMenu(name, self)
        action = menu.menuAction()
    else:
        menu = None
        action = QAction(name, self)
    if slot is not None:
        action.triggered.connect(slot)
    if enable is not None:
        for target in self.context[enable]:
            if isinstance(target, QMenu):
                if is_menu:
                    target.addMenu(menu)
                else:
                    target.addAction(action)
            elif isinstance(target, list):
                target.append(action)
            else:
                raise ValueError("not a list or menu")
    if is_menu:
        return cast(QMenu, menu)
    else:
        return action

</t>
<t tx="leo.20231205084740.325">def __context_menu(self) -&gt; None:
    """Context menu settings."""
    self.entities_point_widget.customContextMenuRequested.connect(
        self.point_context_menu)
    self.pop_point = QMenu(self)
    self.entities_link_widget.customContextMenuRequested.connect(
        self.link_context_menu)
    self.pop_link = QMenu(self)
    self.main_canvas.setContextMenuPolicy(Qt.CustomContextMenu)
    self.main_canvas.customContextMenuRequested.connect(
        self.canvas_context_menu)
    self.pop_canvas_p = QMenu(self)
    self.pop_canvas_l = QMenu(self)
    for enable, menu in (
        (_Enable.P_T, self.pop_point),
        (_Enable.L_T, self.pop_link),
        (_Enable.P_C, self.pop_canvas_p),
        (_Enable.L_C, self.pop_canvas_l),
    ):
        menu.setSeparatorsCollapsible(True)
        self.context[enable] = menu
    # Point table
    two_menus_p = _Enable.P_T | _Enable.P_C
    two_menus_l = _Enable.L_T | _Enable.L_C
    self.__action("&amp;Add", self.new_point, _Enable.P_T | _Enable.P_NO,
                  to=QAction)
    self.__action("&amp;Add", self.add_normal_point, _Enable.P_C | _Enable.P_NO,
                  to=QAction)
    self.__action("Add to [ground]", self.add_fixed_point,
                  _Enable.P_C | _Enable.P_NO, to=QAction)
    self.action_add_target = self.__action(
        "Add &amp;Target Point",
        self.add_target_point,
        _Enable.P_C | _Enable.L_C | _Enable.OPT,
        to=QAction
    )
    self.__action(
        self.action_new_link,
        enable=two_menus_p | two_menus_l | _Enable.P_MUL | _Enable.L_NO,
        to=QAction
    )
    self.__action("&amp;Edit", self.edit_point, two_menus_p | _Enable.P_ONE,
                  to=QAction)
    self.action_p_lock = self.__action("&amp;Grounded", self.lock_points,
                                       two_menus_p | _Enable.P_ANY,
                                       to=QAction)
    self.action_p_lock.setCheckable(True)
    self.pop_point_m = self.__action("Multiple joint",
                                     enable=two_menus_p | _Enable.P_MUL,
                                     to=QMenu)
    self.__action("&amp;Copy Table Data", self.copy_points_table,
                  _Enable.P_T | _Enable.P_ONE, to=QAction)
    self.__action("Copy Coordinate", self.copy_coord,
                  _Enable.P_T | _Enable.P_ONE, to=QAction)
    self.__action("C&amp;lone", self.clone_point, two_menus_p | _Enable.P_ONE,
                  to=QAction)
    self.pop_point.addSeparator()
    self.pop_canvas_p.addSeparator()
    self.__action("&amp;Delete", self.delete_selected_points,
                  two_menus_p | _Enable.P_ANY, to=QAction)
    # EntitiesLink
    self.__action("&amp;Edit", self.edit_link, two_menus_l | _Enable.L_ONE,
                  to=QAction)
    self.pop_link_m = self.__action("Merge Links",
                                    enable=two_menus_l | _Enable.L_MUL,
                                    to=QMenu)
    self.__action("&amp;Copy Table Data", self.copy_links_table,
                  _Enable.L_T | _Enable.L_ONE, to=QAction)
    self.__action("&amp;Release", self.release_ground,
                  two_menus_l | _Enable.L_ONE | _Enable.L_GND, to=QAction)
    self.__action("C&amp;onstrain", self.constrain_link,
                  two_menus_l | _Enable.L_ONE | _Enable.L_N_GND, to=QAction)
    self.pop_link.addSeparator()
    self.pop_canvas_l.addSeparator()
    self.__action(self.action_deduce_links,
                  enable=two_menus_l | _Enable.L_NO, to=QAction)
    self.__action("&amp;Delete", self.delete_selected_links,
                  two_menus_l | _Enable.L_ANY, to=QAction)

</t>
<t tx="leo.20231205084740.326">@Slot(int, name='on_entities_tab_currentChanged')
def __set_selection_mode(self, index: int) -&gt; None:
    """Connect selection signal for main canvas."""
    # Set selection from click table items
    try:
        for table in self.__tables:
            table.row_selection_changed.disconnect()
    except TypeError:
        pass
    self.__tables[index].row_selection_changed.connect(
        self.main_canvas.set_selection)
    # Double click signal
    try:
        self.main_canvas.doubleclick_edit.disconnect()
    except TypeError:
        pass
    if index == 0:
        self.main_canvas.doubleclick_edit.connect(self.edit_point)
    elif index == 1:
        self.main_canvas.doubleclick_edit.connect(self.edit_link)
    # Clear all selections
    for table in self.__tables:
        table.clearSelection()
    self.inputs_widget.clear_selection()
</t>
<t tx="leo.20231205084740.327">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/widgets/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'main.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.328">class Ui_MainWindow(object):
    @others
</t>
<t tx="leo.20231205084740.329">def setupUi(self, MainWindow):
    MainWindow.setObjectName("MainWindow")
    MainWindow.resize(928, 690)
    MainWindow.setMouseTracking(True)
    MainWindow.setAcceptDrops(True)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:main.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    MainWindow.setWindowIcon(icon)
    self.central_widget = QtWidgets.QWidget(MainWindow)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Maximum, QtWidgets.QSizePolicy.Maximum)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.central_widget.sizePolicy().hasHeightForWidth())
    self.central_widget.setSizePolicy(sizePolicy)
    self.central_widget.setObjectName("central_widget")
    self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.central_widget)
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.main_splitter = QtWidgets.QSplitter(self.central_widget)
    self.main_splitter.setOrientation(QtCore.Qt.Horizontal)
    self.main_splitter.setObjectName("main_splitter")
    self.main_panel = QtWidgets.QTabWidget(self.main_splitter)
    self.main_panel.setTabPosition(QtWidgets.QTabWidget.West)
    self.main_panel.setObjectName("main_panel")
    self.mechanism_tab = QtWidgets.QWidget()
    self.mechanism_tab.setObjectName("mechanism_tab")
    self.verticalLayout_27 = QtWidgets.QVBoxLayout(self.mechanism_tab)
    self.verticalLayout_27.setContentsMargins(3, 3, 3, 3)
    self.verticalLayout_27.setObjectName("verticalLayout_27")
    self.mechanism_panel_splitter = QtWidgets.QSplitter(self.mechanism_tab)
    self.mechanism_panel_splitter.setOrientation(QtCore.Qt.Vertical)
    self.mechanism_panel_splitter.setObjectName("mechanism_panel_splitter")
    self.EntitiesTabWidget = QtWidgets.QWidget(self.mechanism_panel_splitter)
    self.EntitiesTabWidget.setObjectName("EntitiesTabWidget")
    self.verticalLayout_29 = QtWidgets.QVBoxLayout(self.EntitiesTabWidget)
    self.verticalLayout_29.setContentsMargins(3, 3, 3, 3)
    self.verticalLayout_29.setObjectName("verticalLayout_29")
    self.entities_tab = QtWidgets.QTabWidget(self.EntitiesTabWidget)
    self.entities_tab.setObjectName("entities_tab")
    self.PointsTab = QtWidgets.QWidget()
    self.PointsTab.setObjectName("PointsTab")
    self.verticalLayout_9 = QtWidgets.QVBoxLayout(self.PointsTab)
    self.verticalLayout_9.setContentsMargins(6, 6, 6, 6)
    self.verticalLayout_9.setObjectName("verticalLayout_9")
    self.entities_point_widget = QtWidgets.QWidget(self.PointsTab)
    self.entities_point_widget.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.entities_point_widget.setObjectName("entities_point_widget")
    self.entities_point_layout = QtWidgets.QVBoxLayout(self.entities_point_widget)
    self.entities_point_layout.setContentsMargins(0, 0, 0, 0)
    self.entities_point_layout.setObjectName("entities_point_layout")
    self.verticalLayout_9.addWidget(self.entities_point_widget)
    icon1 = QtGui.QIcon()
    icon1.addPixmap(QtGui.QPixmap("icons:bearing.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.entities_tab.addTab(self.PointsTab, icon1, "")
    self.LinksTab = QtWidgets.QWidget()
    self.LinksTab.setObjectName("LinksTab")
    self.verticalLayout_19 = QtWidgets.QVBoxLayout(self.LinksTab)
    self.verticalLayout_19.setContentsMargins(6, 6, 6, 6)
    self.verticalLayout_19.setObjectName("verticalLayout_19")
    self.entities_link_widget = QtWidgets.QWidget(self.LinksTab)
    self.entities_link_widget.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.entities_link_widget.setObjectName("entities_link_widget")
    self.entities_link_layout = QtWidgets.QVBoxLayout(self.entities_link_widget)
    self.entities_link_layout.setContentsMargins(0, 0, 0, 0)
    self.entities_link_layout.setObjectName("entities_link_layout")
    self.verticalLayout_19.addWidget(self.entities_link_widget)
    icon2 = QtGui.QIcon()
    icon2.addPixmap(QtGui.QPixmap("icons:link.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.entities_tab.addTab(self.LinksTab, icon2, "")
    self.tab = QtWidgets.QWidget()
    self.tab.setObjectName("tab")
    self.verticalLayout_8 = QtWidgets.QVBoxLayout(self.tab)
    self.verticalLayout_8.setObjectName("verticalLayout_8")
    self.EntitiesExpr_widget = QtWidgets.QWidget(self.tab)
    self.EntitiesExpr_widget.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.EntitiesExpr_widget.setObjectName("EntitiesExpr_widget")
    self.entities_expr_layout = QtWidgets.QVBoxLayout(self.EntitiesExpr_widget)
    self.entities_expr_layout.setContentsMargins(0, 0, 0, 0)
    self.entities_expr_layout.setObjectName("entities_expr_layout")
    self.verticalLayout_8.addWidget(self.EntitiesExpr_widget)
    icon3 = QtGui.QIcon()
    icon3.addPixmap(QtGui.QPixmap("icons:configure.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.entities_tab.addTab(self.tab, icon3, "")
    self.verticalLayout_29.addWidget(self.entities_tab)
    self.MechanismsTabWidget = QtWidgets.QWidget(self.mechanism_panel_splitter)
    self.MechanismsTabWidget.setObjectName("MechanismsTabWidget")
    self.verticalLayout_21 = QtWidgets.QVBoxLayout(self.MechanismsTabWidget)
    self.verticalLayout_21.setContentsMargins(0, 0, 0, 0)
    self.verticalLayout_21.setObjectName("verticalLayout_21")
    self.MechanismPanelSplitterLine = QtWidgets.QFrame(self.MechanismsTabWidget)
    self.MechanismPanelSplitterLine.setLineWidth(3)
    self.MechanismPanelSplitterLine.setFrameShape(QtWidgets.QFrame.HLine)
    self.MechanismPanelSplitterLine.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.MechanismPanelSplitterLine.setObjectName("MechanismPanelSplitterLine")
    self.verticalLayout_21.addWidget(self.MechanismPanelSplitterLine)
    self.horizontalLayout_9 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_9.setObjectName("horizontalLayout_9")
    self.verticalLayout_4 = QtWidgets.QVBoxLayout()
    self.verticalLayout_4.setObjectName("verticalLayout_4")
    self.horizontalLayout_11 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_11.setObjectName("horizontalLayout_11")
    self.mechanism_storage_name_tag_text = QtWidgets.QLabel(self.MechanismsTabWidget)
    self.mechanism_storage_name_tag_text.setObjectName("mechanism_storage_name_tag_text")
    self.horizontalLayout_11.addWidget(self.mechanism_storage_name_tag_text)
    self.mechanism_storage_name_tag = QtWidgets.QLineEdit(self.MechanismsTabWidget)
    self.mechanism_storage_name_tag.setClearButtonEnabled(True)
    self.mechanism_storage_name_tag.setObjectName("mechanism_storage_name_tag")
    self.horizontalLayout_11.addWidget(self.mechanism_storage_name_tag)
    self.verticalLayout_4.addLayout(self.horizontalLayout_11)
    self.mechanism_storage = QtWidgets.QListWidget(self.MechanismsTabWidget)
    self.mechanism_storage.setObjectName("mechanism_storage")
    self.verticalLayout_4.addWidget(self.mechanism_storage)
    self.horizontalLayout_9.addLayout(self.verticalLayout_4)
    self.verticalLayout_20 = QtWidgets.QVBoxLayout()
    self.verticalLayout_20.setObjectName("verticalLayout_20")
    self.mechanism_storage_add = QtWidgets.QPushButton(self.MechanismsTabWidget)
    icon4 = QtGui.QIcon()
    icon4.addPixmap(QtGui.QPixmap("icons:data.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.mechanism_storage_add.setIcon(icon4)
    self.mechanism_storage_add.setObjectName("mechanism_storage_add")
    self.verticalLayout_20.addWidget(self.mechanism_storage_add)
    self.mechanism_storage_restore = QtWidgets.QPushButton(self.MechanismsTabWidget)
    icon5 = QtGui.QIcon()
    icon5.addPixmap(QtGui.QPixmap("icons:data_update.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.mechanism_storage_restore.setIcon(icon5)
    self.mechanism_storage_restore.setObjectName("mechanism_storage_restore")
    self.verticalLayout_20.addWidget(self.mechanism_storage_restore)
    self.line_4 = QtWidgets.QFrame(self.MechanismsTabWidget)
    self.line_4.setFrameShape(QtWidgets.QFrame.HLine)
    self.line_4.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line_4.setObjectName("line_4")
    self.verticalLayout_20.addWidget(self.line_4)
    self.mechanism_storage_copy = QtWidgets.QPushButton(self.MechanismsTabWidget)
    icon6 = QtGui.QIcon()
    icon6.addPixmap(QtGui.QPixmap("icons:copy.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.mechanism_storage_copy.setIcon(icon6)
    self.mechanism_storage_copy.setObjectName("mechanism_storage_copy")
    self.verticalLayout_20.addWidget(self.mechanism_storage_copy)
    self.mechanism_storage_paste = QtWidgets.QPushButton(self.MechanismsTabWidget)
    icon7 = QtGui.QIcon()
    icon7.addPixmap(QtGui.QPixmap("icons:paste.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.mechanism_storage_paste.setIcon(icon7)
    self.mechanism_storage_paste.setObjectName("mechanism_storage_paste")
    self.verticalLayout_20.addWidget(self.mechanism_storage_paste)
    spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_20.addItem(spacerItem)
    self.mechanism_storage_delete = QtWidgets.QPushButton(self.MechanismsTabWidget)
    icon8 = QtGui.QIcon()
    icon8.addPixmap(QtGui.QPixmap("icons:delete.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.mechanism_storage_delete.setIcon(icon8)
    self.mechanism_storage_delete.setObjectName("mechanism_storage_delete")
    self.verticalLayout_20.addWidget(self.mechanism_storage_delete)
    self.horizontalLayout_9.addLayout(self.verticalLayout_20)
    self.verticalLayout_21.addLayout(self.horizontalLayout_9)
    self.verticalLayout_27.addWidget(self.mechanism_panel_splitter)
    icon9 = QtGui.QIcon()
    icon9.addPixmap(QtGui.QPixmap("icons:mechanism.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.main_panel.addTab(self.mechanism_tab, icon9, "")
    self.inputs_tab = QtWidgets.QWidget()
    self.inputs_tab.setObjectName("inputs_tab")
    self.inputs_tab_layout = QtWidgets.QVBoxLayout(self.inputs_tab)
    self.inputs_tab_layout.setObjectName("inputs_tab_layout")
    icon10 = QtGui.QIcon()
    icon10.addPixmap(QtGui.QPixmap("icons:motor.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.main_panel.addTab(self.inputs_tab, icon10, "")
    self.synthesis_tab = QtWidgets.QWidget()
    self.synthesis_tab.setObjectName("synthesis_tab")
    self.verticalLayout_10 = QtWidgets.QVBoxLayout(self.synthesis_tab)
    self.verticalLayout_10.setObjectName("verticalLayout_10")
    self.synthesis_tab_widget = QtWidgets.QTabWidget(self.synthesis_tab)
    self.synthesis_tab_widget.setObjectName("synthesis_tab_widget")
    self.verticalLayout_10.addWidget(self.synthesis_tab_widget)
    icon11 = QtGui.QIcon()
    icon11.addPixmap(QtGui.QPixmap("icons:synthesis.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.main_panel.addTab(self.synthesis_tab, icon11, "")
    self.project_tab = QtWidgets.QWidget()
    self.project_tab.setObjectName("project_tab")
    self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.project_tab)
    self.verticalLayout_5.setContentsMargins(0, 0, 0, 0)
    self.verticalLayout_5.setObjectName("verticalLayout_5")
    self.project_layout = QtWidgets.QVBoxLayout()
    self.project_layout.setObjectName("project_layout")
    self.verticalLayout_5.addLayout(self.project_layout)
    icon12 = QtGui.QIcon()
    icon12.addPixmap(QtGui.QPixmap("icons:id.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.main_panel.addTab(self.project_tab, icon12, "")
    self.horizontalLayoutWidget = QtWidgets.QWidget(self.main_splitter)
    self.horizontalLayoutWidget.setObjectName("horizontalLayoutWidget")
    self.right_layout = QtWidgets.QHBoxLayout(self.horizontalLayoutWidget)
    self.right_layout.setContentsMargins(0, 0, 0, 0)
    self.right_layout.setObjectName("right_layout")
    self.middle_line = QtWidgets.QFrame(self.horizontalLayoutWidget)
    self.middle_line.setLineWidth(5)
    self.middle_line.setFrameShape(QtWidgets.QFrame.VLine)
    self.middle_line.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.middle_line.setObjectName("middle_line")
    self.right_layout.addWidget(self.middle_line)
    self.canvas_splitter = QtWidgets.QSplitter(self.horizontalLayoutWidget)
    self.canvas_splitter.setOrientation(QtCore.Qt.Vertical)
    self.canvas_splitter.setObjectName("canvas_splitter")
    self.verticalLayoutWidget = QtWidgets.QWidget(self.canvas_splitter)
    self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")
    self.canvas_layout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
    self.canvas_layout.setContentsMargins(0, 0, 0, 0)
    self.canvas_layout.setObjectName("canvas_layout")
    self.zoom_widget = QtWidgets.QWidget(self.verticalLayoutWidget)
    self.zoom_widget.setMaximumSize(QtCore.QSize(16777215, 50))
    self.zoom_widget.setObjectName("zoom_widget")
    self.horizontalLayout = QtWidgets.QHBoxLayout(self.zoom_widget)
    self.horizontalLayout.setContentsMargins(3, 3, 3, 3)
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.zoom_cus_btn = QtWidgets.QPushButton(self.zoom_widget)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.zoom_cus_btn.sizePolicy().hasHeightForWidth())
    self.zoom_cus_btn.setSizePolicy(sizePolicy)
    icon13 = QtGui.QIcon()
    icon13.addPixmap(QtGui.QPixmap("icons:example.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.zoom_cus_btn.setIcon(icon13)
    self.zoom_cus_btn.setIconSize(QtCore.QSize(32, 32))
    self.zoom_cus_btn.setObjectName("zoom_cus_btn")
    self.horizontalLayout.addWidget(self.zoom_cus_btn)
    self.zoom_bar = QtWidgets.QSlider(self.zoom_widget)
    self.zoom_bar.setMinimum(50)
    self.zoom_bar.setMaximum(10000)
    self.zoom_bar.setSingleStep(50)
    self.zoom_bar.setPageStep(50)
    self.zoom_bar.setSliderPosition(50)
    self.zoom_bar.setOrientation(QtCore.Qt.Horizontal)
    self.zoom_bar.setInvertedControls(False)
    self.zoom_bar.setTickPosition(QtWidgets.QSlider.TicksBelow)
    self.zoom_bar.setTickInterval(200)
    self.zoom_bar.setObjectName("zoom_bar")
    self.horizontalLayout.addWidget(self.zoom_bar)
    self.canvas_layout.addWidget(self.zoom_widget)
    self.nav_toolbar = QtWidgets.QWidget(self.verticalLayoutWidget)
    self.nav_toolbar.setMaximumSize(QtCore.QSize(16777215, 50))
    self.nav_toolbar.setObjectName("nav_toolbar")
    self.nav_layout = QtWidgets.QHBoxLayout(self.nav_toolbar)
    self.nav_layout.setContentsMargins(3, 3, 3, 3)
    self.nav_layout.setObjectName("nav_layout")
    self.zoom_btn = QtWidgets.QPushButton(self.nav_toolbar)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.zoom_btn.sizePolicy().hasHeightForWidth())
    self.zoom_btn.setSizePolicy(sizePolicy)
    icon14 = QtGui.QIcon()
    icon14.addPixmap(QtGui.QPixmap("icons:fullscreen.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.zoom_btn.setIcon(icon14)
    self.zoom_btn.setIconSize(QtCore.QSize(32, 32))
    self.zoom_btn.setCheckable(True)
    self.zoom_btn.setObjectName("zoom_btn")
    self.nav_layout.addWidget(self.zoom_btn)
    self.reset_canvas_btn = QtWidgets.QPushButton(self.nav_toolbar)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.reset_canvas_btn.sizePolicy().hasHeightForWidth())
    self.reset_canvas_btn.setSizePolicy(sizePolicy)
    icon15 = QtGui.QIcon()
    icon15.addPixmap(QtGui.QPixmap("icons:aim.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.reset_canvas_btn.setIcon(icon15)
    self.reset_canvas_btn.setIconSize(QtCore.QSize(32, 32))
    self.reset_canvas_btn.setObjectName("reset_canvas_btn")
    self.nav_layout.addWidget(self.reset_canvas_btn)
    spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.nav_layout.addItem(spacerItem1)
    self.grid_mode_btn = QtWidgets.QPushButton(self.nav_toolbar)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.grid_mode_btn.sizePolicy().hasHeightForWidth())
    self.grid_mode_btn.setSizePolicy(sizePolicy)
    icon16 = QtGui.QIcon()
    icon16.addPixmap(QtGui.QPixmap("icons:grid.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.grid_mode_btn.setIcon(icon16)
    self.grid_mode_btn.setIconSize(QtCore.QSize(32, 32))
    self.grid_mode_btn.setCheckable(True)
    self.grid_mode_btn.setChecked(True)
    self.grid_mode_btn.setObjectName("grid_mode_btn")
    self.nav_layout.addWidget(self.grid_mode_btn)
    self.alignment_btn = QtWidgets.QToolButton(self.nav_toolbar)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.alignment_btn.sizePolicy().hasHeightForWidth())
    self.alignment_btn.setSizePolicy(sizePolicy)
    icon17 = QtGui.QIcon()
    icon17.addPixmap(QtGui.QPixmap("icons:vertical_align.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.alignment_btn.setIcon(icon17)
    self.alignment_btn.setIconSize(QtCore.QSize(32, 32))
    self.alignment_btn.setPopupMode(QtWidgets.QToolButton.MenuButtonPopup)
    self.alignment_btn.setObjectName("alignment_btn")
    self.nav_layout.addWidget(self.alignment_btn)
    self.free_move_btn = QtWidgets.QPushButton(self.nav_toolbar)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.free_move_btn.sizePolicy().hasHeightForWidth())
    self.free_move_btn.setSizePolicy(sizePolicy)
    icon18 = QtGui.QIcon()
    icon18.addPixmap(QtGui.QPixmap("icons:free_move_off.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.free_move_btn.setIcon(icon18)
    self.free_move_btn.setIconSize(QtCore.QSize(32, 32))
    self.free_move_btn.setObjectName("free_move_btn")
    self.nav_layout.addWidget(self.free_move_btn)
    self.line_3 = QtWidgets.QFrame(self.nav_toolbar)
    self.line_3.setFrameShape(QtWidgets.QFrame.VLine)
    self.line_3.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line_3.setObjectName("line_3")
    self.nav_layout.addWidget(self.line_3)
    self.dof_lable = QtWidgets.QLabel(self.nav_toolbar)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.dof_lable.sizePolicy().hasHeightForWidth())
    self.dof_lable.setSizePolicy(sizePolicy)
    self.dof_lable.setObjectName("dof_lable")
    self.nav_layout.addWidget(self.dof_lable)
    self.dof_view = QtWidgets.QLabel(self.nav_toolbar)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.dof_view.sizePolicy().hasHeightForWidth())
    self.dof_view.setSizePolicy(sizePolicy)
    self.dof_view.setText("")
    self.dof_view.setObjectName("dof_view")
    self.nav_layout.addWidget(self.dof_view)
    self.conflict = QtWidgets.QLabel(self.nav_toolbar)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.conflict.sizePolicy().hasHeightForWidth())
    self.conflict.setSizePolicy(sizePolicy)
    self.conflict.setTextFormat(QtCore.Qt.RichText)
    self.conflict.setObjectName("conflict")
    self.nav_layout.addWidget(self.conflict)
    self.canvas_layout.addWidget(self.nav_toolbar)
    self.console_widget = QtWidgets.QWidget(self.canvas_splitter)
    self.console_widget.setObjectName("console_widget")
    self.verticalLayout_11 = QtWidgets.QVBoxLayout(self.console_widget)
    self.verticalLayout_11.setContentsMargins(3, 3, 3, 3)
    self.verticalLayout_11.setObjectName("verticalLayout_11")
    self.console_toolbar = QtWidgets.QWidget(self.console_widget)
    self.console_toolbar.setObjectName("console_toolbar")
    self.horizontalLayout_5 = QtWidgets.QHBoxLayout(self.console_toolbar)
    self.horizontalLayout_5.setContentsMargins(0, 0, 0, 0)
    self.horizontalLayout_5.setObjectName("horizontalLayout_5")
    self.label_3 = QtWidgets.QLabel(self.console_toolbar)
    self.label_3.setObjectName("label_3")
    self.horizontalLayout_5.addWidget(self.label_3)
    spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_5.addItem(spacerItem2)
    self.console_disconnect_btn = QtWidgets.QPushButton(self.console_toolbar)
    icon19 = QtGui.QIcon()
    icon19.addPixmap(QtGui.QPixmap("icons:disconnect.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.console_disconnect_btn.setIcon(icon19)
    self.console_disconnect_btn.setObjectName("console_disconnect_btn")
    self.horizontalLayout_5.addWidget(self.console_disconnect_btn)
    self.console_connect_btn = QtWidgets.QPushButton(self.console_toolbar)
    icon20 = QtGui.QIcon()
    icon20.addPixmap(QtGui.QPixmap("icons:connect.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.console_connect_btn.setIcon(icon20)
    self.console_connect_btn.setObjectName("console_connect_btn")
    self.horizontalLayout_5.addWidget(self.console_connect_btn)
    self.line_2 = QtWidgets.QFrame(self.console_toolbar)
    self.line_2.setFrameShape(QtWidgets.QFrame.VLine)
    self.line_2.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line_2.setObjectName("line_2")
    self.horizontalLayout_5.addWidget(self.line_2)
    self.clear_console = QtWidgets.QPushButton(self.console_toolbar)
    icon21 = QtGui.QIcon()
    icon21.addPixmap(QtGui.QPixmap("icons:clean.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.clear_console.setIcon(icon21)
    self.clear_console.setObjectName("clear_console")
    self.horizontalLayout_5.addWidget(self.clear_console)
    self.verticalLayout_11.addWidget(self.console_toolbar)
    self.console_widget_browser = QtWidgets.QTextBrowser(self.console_widget)
    self.console_widget_browser.setObjectName("console_widget_browser")
    self.verticalLayout_11.addWidget(self.console_widget_browser)
    self.right_layout.addWidget(self.canvas_splitter)
    self.verticalLayout_2.addWidget(self.main_splitter)
    MainWindow.setCentralWidget(self.central_widget)
    self.menu_bar = QtWidgets.QMenuBar(MainWindow)
    self.menu_bar.setGeometry(QtCore.QRect(0, 0, 928, 34))
    self.menu_bar.setObjectName("menu_bar")
    self.menu_file = QtWidgets.QMenu(self.menu_bar)
    self.menu_file.setStatusTip("")
    self.menu_file.setObjectName("menu_file")
    self.menu_options = QtWidgets.QMenu(self.menu_bar)
    self.menu_options.setObjectName("menu_options")
    self.menu_help = QtWidgets.QMenu(self.menu_bar)
    self.menu_help.setObjectName("menu_help")
    self.menu_edit = QtWidgets.QMenu(self.menu_bar)
    self.menu_edit.setObjectName("menu_edit")
    MainWindow.setMenuBar(self.menu_bar)
    self.status_bar = QtWidgets.QStatusBar(MainWindow)
    self.status_bar.setObjectName("status_bar")
    MainWindow.setStatusBar(self.status_bar)
    self.action_new_project = QtWidgets.QAction(MainWindow)
    icon22 = QtGui.QIcon()
    icon22.addPixmap(QtGui.QPixmap("icons:new_file.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.action_new_project.setIcon(icon22)
    self.action_new_project.setShortcutContext(QtCore.Qt.WindowShortcut)
    self.action_new_project.setObjectName("action_new_project")
    self.action_new_point = QtWidgets.QAction(MainWindow)
    self.action_new_point.setIcon(icon1)
    self.action_new_point.setObjectName("action_new_point")
    self.action_new_link = QtWidgets.QAction(MainWindow)
    self.action_new_link.setIcon(icon2)
    self.action_new_link.setObjectName("action_new_link")
    self.action_exit = QtWidgets.QAction(MainWindow)
    self.action_exit.setCheckable(False)
    icon23 = QtGui.QIcon()
    icon23.addPixmap(QtGui.QPixmap("icons:exit.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.action_exit.setIcon(icon23)
    self.action_exit.setObjectName("action_exit")
    self.action_mde_tw = QtWidgets.QAction(MainWindow)
    icon24 = QtGui.QIcon()
    icon24.addPixmap(QtGui.QPixmap("icons:kmol.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.action_mde_tw.setIcon(icon24)
    self.action_mde_tw.setObjectName("action_mde_tw")
    self.action_github_repository = QtWidgets.QAction(MainWindow)
    icon25 = QtGui.QIcon()
    icon25.addPixmap(QtGui.QPixmap("icons:github.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.action_github_repository.setIcon(icon25)
    self.action_github_repository.setObjectName("action_github_repository")
    self.action_about = QtWidgets.QAction(MainWindow)
    self.action_about.setIcon(icon)
    self.action_about.setObjectName("action_about")
    self.action_full_screen = QtWidgets.QAction(MainWindow)
    self.action_full_screen.setCheckable(True)
    self.action_full_screen.setIcon(icon14)
    self.action_full_screen.setObjectName("action_full_screen")
    self.action_delete_point = QtWidgets.QAction(MainWindow)
    self.action_delete_point.setObjectName("action_delete_point")
    self.action_delete_link = QtWidgets.QAction(MainWindow)
    self.action_delete_link.setObjectName("action_delete_link")
    self.action_edit_point = QtWidgets.QAction(MainWindow)
    self.action_edit_point.setObjectName("action_edit_point")
    self.action_edit_link = QtWidgets.QAction(MainWindow)
    self.action_edit_link.setObjectName("action_edit_link")
    self.action_show_dimensions = QtWidgets.QAction(MainWindow)
    self.action_show_dimensions.setCheckable(True)
    self.action_show_dimensions.setObjectName("action_show_dimensions")
    self.action_show_point_mark = QtWidgets.QAction(MainWindow)
    self.action_show_point_mark.setCheckable(True)
    self.action_show_point_mark.setChecked(True)
    self.action_show_point_mark.setObjectName("action_show_point_mark")
    self.action_about_qt = QtWidgets.QAction(MainWindow)
    icon26 = QtGui.QIcon()
    icon26.addPixmap(QtGui.QPixmap("icons:qt.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.action_about_qt.setIcon(icon26)
    self.action_about_qt.setObjectName("action_about_qt")
    self.action_load_file = QtWidgets.QAction(MainWindow)
    icon27 = QtGui.QIcon()
    icon27.addPixmap(QtGui.QPixmap("icons:loadfile.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.action_load_file.setIcon(icon27)
    self.action_load_file.setObjectName("action_load_file")
    self.action_zoom_to_fit = QtWidgets.QAction(MainWindow)
    self.action_zoom_to_fit.setIcon(icon15)
    self.action_zoom_to_fit.setObjectName("action_zoom_to_fit")
    self.action_path_style = QtWidgets.QAction(MainWindow)
    self.action_path_style.setCheckable(True)
    self.action_path_style.setChecked(True)
    self.action_path_style.setObjectName("action_path_style")
    self.action_pyslvs_com = QtWidgets.QAction(MainWindow)
    self.action_pyslvs_com.setIcon(icon)
    self.action_pyslvs_com.setObjectName("action_pyslvs_com")
    self.action_show_console = QtWidgets.QAction(MainWindow)
    self.action_show_console.setCheckable(True)
    icon28 = QtGui.QIcon()
    icon28.addPixmap(QtGui.QPixmap("icons:konsole.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.action_show_console.setIcon(icon28)
    self.action_show_console.setObjectName("action_show_console")
    self.action_example = QtWidgets.QAction(MainWindow)
    self.action_example.setIcon(icon13)
    self.action_example.setObjectName("action_example")
    self.action_check_update = QtWidgets.QAction(MainWindow)
    self.action_check_update.setIcon(icon25)
    self.action_check_update.setObjectName("action_check_update")
    self.action_new_window = QtWidgets.QAction(MainWindow)
    icon29 = QtGui.QIcon()
    icon29.addPixmap(QtGui.QPixmap("icons:new_window.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.action_new_window.setIcon(icon29)
    self.action_new_window.setObjectName("action_new_window")
    self.action_scale_points = QtWidgets.QAction(MainWindow)
    self.action_scale_points.setObjectName("action_scale_points")
    self.action_new_fourbar = QtWidgets.QAction(MainWindow)
    self.action_new_fourbar.setObjectName("action_new_fourbar")
    self.action_save = QtWidgets.QAction(MainWindow)
    icon30 = QtGui.QIcon()
    icon30.addPixmap(QtGui.QPixmap("icons:yaml.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.action_save.setIcon(icon30)
    self.action_save.setObjectName("action_save")
    self.action_save_as = QtWidgets.QAction(MainWindow)
    self.action_save_as.setIcon(icon30)
    self.action_save_as.setObjectName("action_save_as")
    self.action_documentation = QtWidgets.QAction(MainWindow)
    icon31 = QtGui.QIcon()
    icon31.addPixmap(QtGui.QPixmap("icons:collections.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.action_documentation.setIcon(icon31)
    self.action_documentation.setObjectName("action_documentation")
    self.action_set_link_length = QtWidgets.QAction(MainWindow)
    self.action_set_link_length.setObjectName("action_set_link_length")
    self.action_preference = QtWidgets.QAction(MainWindow)
    icon32 = QtGui.QIcon()
    icon32.addPixmap(QtGui.QPixmap("icons:settings.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.action_preference.setIcon(icon32)
    self.action_preference.setObjectName("action_preference")
    self.action_screenshot = QtWidgets.QAction(MainWindow)
    icon33 = QtGui.QIcon()
    icon33.addPixmap(QtGui.QPixmap("icons:capture.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.action_screenshot.setIcon(icon33)
    self.action_screenshot.setObjectName("action_screenshot")
    self.action_report_issue = QtWidgets.QAction(MainWindow)
    self.action_report_issue.setIcon(icon25)
    self.action_report_issue.setObjectName("action_report_issue")
    self.action_deduce_links = QtWidgets.QAction(MainWindow)
    self.action_deduce_links.setObjectName("action_deduce_links")
    self.menu_file.addAction(self.action_new_project)
    self.menu_file.addAction(self.action_load_file)
    self.menu_file.addAction(self.action_example)
    self.menu_file.addSeparator()
    self.menu_file.addAction(self.action_save)
    self.menu_file.addAction(self.action_save_as)
    self.menu_file.addAction(self.action_screenshot)
    self.menu_file.addSeparator()
    self.menu_file.addAction(self.action_full_screen)
    self.menu_file.addAction(self.action_new_window)
    self.menu_file.addAction(self.action_exit)
    self.menu_options.addAction(self.action_show_console)
    self.menu_options.addSeparator()
    self.menu_options.addAction(self.action_zoom_to_fit)
    self.menu_options.addAction(self.action_show_point_mark)
    self.menu_options.addAction(self.action_show_dimensions)
    self.menu_options.addAction(self.action_path_style)
    self.menu_options.addSeparator()
    self.menu_options.addAction(self.action_preference)
    self.menu_help.addAction(self.action_pyslvs_com)
    self.menu_help.addAction(self.action_github_repository)
    self.menu_help.addAction(self.action_documentation)
    self.menu_help.addAction(self.action_mde_tw)
    self.menu_help.addSeparator()
    self.menu_help.addAction(self.action_check_update)
    self.menu_help.addAction(self.action_report_issue)
    self.menu_help.addSeparator()
    self.menu_help.addAction(self.action_about_qt)
    self.menu_help.addAction(self.action_about)
    self.menu_edit.addAction(self.action_new_point)
    self.menu_edit.addAction(self.action_new_link)
    self.menu_edit.addSeparator()
    self.menu_edit.addAction(self.action_edit_point)
    self.menu_edit.addAction(self.action_edit_link)
    self.menu_edit.addSeparator()
    self.menu_edit.addAction(self.action_delete_point)
    self.menu_edit.addAction(self.action_delete_link)
    self.menu_edit.addAction(self.action_deduce_links)
    self.menu_edit.addSeparator()
    self.menu_edit.addAction(self.action_scale_points)
    self.menu_edit.addAction(self.action_set_link_length)
    self.menu_edit.addSeparator()
    self.menu_edit.addAction(self.action_new_fourbar)
    self.menu_bar.addAction(self.menu_file.menuAction())
    self.menu_bar.addAction(self.menu_edit.menuAction())
    self.menu_bar.addAction(self.menu_options.menuAction())
    self.menu_bar.addAction(self.menu_help.menuAction())

    self.retranslateUi(MainWindow)
    self.synthesis_tab_widget.setCurrentIndex(-1)
    self.action_exit.triggered.connect(MainWindow.close)
    self.action_show_console.toggled['bool'].connect(self.console_widget.setVisible)
    self.clear_console.clicked.connect(self.console_widget_browser.clear)
    self.zoom_btn.toggled['bool'].connect(self.zoom_widget.setVisible)
    QtCore.QMetaObject.connectSlotsByName(MainWindow)

</t>
<t tx="leo.20231205084740.33">def __set_time(self, time: float) -&gt; None:
    """Set the time label."""
    self.timeShow.setText(
        f"&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;span style=\"font-size:16pt\"&gt;"
        f"{int(time // 60):02d}min {time % 60:05.02f}s"
        f"&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"
    )

</t>
<t tx="leo.20231205084740.330">def retranslateUi(self, MainWindow):
    _translate = QtCore.QCoreApplication.translate
    MainWindow.setWindowTitle(_translate("MainWindow", "Pyslvs - Untitled"))
    self.entities_tab.setTabText(self.entities_tab.indexOf(self.PointsTab), _translate("MainWindow", "Points"))
    self.entities_tab.setTabText(self.entities_tab.indexOf(self.LinksTab), _translate("MainWindow", "Links"))
    self.entities_tab.setTabText(self.entities_tab.indexOf(self.tab), _translate("MainWindow", "Calculation"))
    self.mechanism_storage_name_tag_text.setText(_translate("MainWindow", "Mechanism name:"))
    self.mechanism_storage_name_tag.setPlaceholderText(_translate("MainWindow", "Prototype"))
    self.mechanism_storage.setStatusTip(_translate("MainWindow", "All expressions of this project. They will be saving with database."))
    self.mechanism_storage_add.setStatusTip(_translate("MainWindow", "Capture the current expression then save to the list."))
    self.mechanism_storage_add.setText(_translate("MainWindow", "Add"))
    self.mechanism_storage_restore.setStatusTip(_translate("MainWindow", "Restore the selected expression."))
    self.mechanism_storage_restore.setText(_translate("MainWindow", "Restore"))
    self.mechanism_storage_copy.setStatusTip(_translate("MainWindow", "Copy the specified mechanism expression as string format."))
    self.mechanism_storage_copy.setText(_translate("MainWindow", "Copy"))
    self.mechanism_storage_paste.setStatusTip(_translate("MainWindow", "Append a new expression to list by string format."))
    self.mechanism_storage_paste.setText(_translate("MainWindow", "Paste"))
    self.mechanism_storage_delete.setStatusTip(_translate("MainWindow", "Delete the specified mechanism."))
    self.mechanism_storage_delete.setText(_translate("MainWindow", "Delete"))
    self.main_panel.setTabText(self.main_panel.indexOf(self.mechanism_tab), _translate("MainWindow", "Mechanism"))
    self.main_panel.setTabText(self.main_panel.indexOf(self.inputs_tab), _translate("MainWindow", "Inputs"))
    self.main_panel.setTabText(self.main_panel.indexOf(self.synthesis_tab), _translate("MainWindow", "Synthesis"))
    self.main_panel.setTabText(self.main_panel.indexOf(self.project_tab), _translate("MainWindow", "Project"))
    self.zoom_cus_btn.setStatusTip(_translate("MainWindow", "Customize zooming."))
    self.zoom_bar.setStatusTip(_translate("MainWindow", "Adjust the slider to change demo size."))
    self.zoom_btn.setStatusTip(_translate("MainWindow", "Show zooming settings."))
    self.reset_canvas_btn.setStatusTip(_translate("MainWindow", "Zoom to fit."))
    self.grid_mode_btn.setStatusTip(_translate("MainWindow", "Grid mode: Snap the mouse when dragging."))
    self.alignment_btn.setStatusTip(_translate("MainWindow", "Point alignment: Align the selected points with a value of x or y axis."))
    self.free_move_btn.setStatusTip(_translate("MainWindow", "Free mode: Allow selected point coordinates to be edited by dragging."))
    self.dof_lable.setToolTip(_translate("MainWindow", "Degree of Freedom"))
    self.dof_lable.setText(_translate("MainWindow", "DOF"))
    self.conflict.setStatusTip(_translate("MainWindow", "Show Conflict Guide tool tips."))
    self.conflict.setText(_translate("MainWindow", "&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;img width=\'30\' src=\"icons:conflict.png\"/&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"))
    self.label_3.setText(_translate("MainWindow", "&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;&lt;img width=\'30\' src=\"icons:konsole.png\"/&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"))
    self.console_disconnect_btn.setStatusTip(_translate("MainWindow", "Disconnect from GUI console."))
    self.console_connect_btn.setStatusTip(_translate("MainWindow", "Connect to GUI console."))
    self.clear_console.setStatusTip(_translate("MainWindow", "Clear GUI console."))
    self.menu_file.setTitle(_translate("MainWindow", "&amp;File"))
    self.menu_options.setTitle(_translate("MainWindow", "&amp;Options"))
    self.menu_help.setTitle(_translate("MainWindow", "&amp;Help"))
    self.menu_edit.setTitle(_translate("MainWindow", "&amp;Edit"))
    self.action_new_project.setText(_translate("MainWindow", "&amp;New Project"))
    self.action_new_project.setStatusTip(_translate("MainWindow", "Reset to a new wrokbook."))
    self.action_new_project.setShortcut(_translate("MainWindow", "Ctrl+N"))
    self.action_new_point.setText(_translate("MainWindow", "New &amp;Point"))
    self.action_new_point.setStatusTip(_translate("MainWindow", "Add a new point representative of a node on a machine."))
    self.action_new_point.setShortcut(_translate("MainWindow", "P"))
    self.action_new_link.setText(_translate("MainWindow", "New &amp;Link"))
    self.action_new_link.setStatusTip(_translate("MainWindow", "Add  a link between two points."))
    self.action_new_link.setShortcut(_translate("MainWindow", "L"))
    self.action_exit.setText(_translate("MainWindow", "&amp;Quit"))
    self.action_exit.setStatusTip(_translate("MainWindow", "Exit Pyslvs."))
    self.action_mde_tw.setText(_translate("MainWindow", "&amp;MDE.tw"))
    self.action_mde_tw.setStatusTip(_translate("MainWindow", "Goto Kmolab learn about more."))
    self.action_github_repository.setText(_translate("MainWindow", "Git&amp;hub Repository"))
    self.action_github_repository.setStatusTip(_translate("MainWindow", "Goto Github storage of Pyslvs."))
    self.action_about.setText(_translate("MainWindow", "&amp;About Pyslvs"))
    self.action_about.setStatusTip(_translate("MainWindow", "Version and introduction of Pyslvs."))
    self.action_about.setShortcut(_translate("MainWindow", "F1"))
    self.action_full_screen.setText(_translate("MainWindow", "&amp;Full Screen"))
    self.action_full_screen.setStatusTip(_translate("MainWindow", "Let the window truns to full screen."))
    self.action_full_screen.setShortcut(_translate("MainWindow", "Shift+F1"))
    self.action_delete_point.setText(_translate("MainWindow", "&amp;Delete Point"))
    self.action_delete_point.setStatusTip(_translate("MainWindow", "Delete an existing point."))
    self.action_delete_link.setText(_translate("MainWindow", "Delete Li&amp;nk"))
    self.action_delete_link.setStatusTip(_translate("MainWindow", "Delete an existing link."))
    self.action_edit_point.setText(_translate("MainWindow", "&amp;Edit Point"))
    self.action_edit_point.setStatusTip(_translate("MainWindow", "Edit an existing point."))
    self.action_edit_link.setText(_translate("MainWindow", "Ed&amp;it Link"))
    self.action_edit_link.setStatusTip(_translate("MainWindow", "Edit an existing link."))
    self.action_show_dimensions.setText(_translate("MainWindow", "Display &amp;Dimensions"))
    self.action_show_dimensions.setStatusTip(_translate("MainWindow", "Display dimensions in the canvas."))
    self.action_show_dimensions.setShortcut(_translate("MainWindow", "F11"))
    self.action_show_point_mark.setText(_translate("MainWindow", "Display Point &amp;Mark"))
    self.action_show_point_mark.setStatusTip(_translate("MainWindow", "Display point mark in canvas."))
    self.action_show_point_mark.setShortcut(_translate("MainWindow", "F10"))
    self.action_about_qt.setText(_translate("MainWindow", "About &amp;Qt"))
    self.action_about_qt.setStatusTip(_translate("MainWindow", "Show Qt about."))
    self.action_load_file.setText(_translate("MainWindow", "L&amp;oad File"))
    self.action_load_file.setStatusTip(_translate("MainWindow", "Load Project from *.pyslvs project or *.slvs file."))
    self.action_load_file.setShortcut(_translate("MainWindow", "Ctrl+O"))
    self.action_zoom_to_fit.setText(_translate("MainWindow", "&amp;Zoom to Fit"))
    self.action_zoom_to_fit.setStatusTip(_translate("MainWindow", "Zoom in as mechanism size."))
    self.action_zoom_to_fit.setShortcut(_translate("MainWindow", "Home"))
    self.action_path_style.setText(_translate("MainWindow", "Solid Style &amp;Path"))
    self.action_path_style.setStatusTip(_translate("MainWindow", "Show path in solid line style, otherwise will be isolated dots."))
    self.action_pyslvs_com.setText(_translate("MainWindow", "&amp;Pyslvs.com"))
    self.action_pyslvs_com.setStatusTip(_translate("MainWindow", "Goto Pyslvs home page."))
    self.action_show_console.setText(_translate("MainWindow", "&amp;Show GUI Console"))
    self.action_show_console.setStatusTip(_translate("MainWindow", "Open a widget to show console output."))
    self.action_show_console.setShortcut(_translate("MainWindow", "F12"))
    self.action_example.setText(_translate("MainWindow", "&amp;Example ..."))
    self.action_example.setStatusTip(_translate("MainWindow", "Load a example."))
    self.action_example.setShortcut(_translate("MainWindow", "Ctrl+E"))
    self.action_check_update.setText(_translate("MainWindow", "&amp;Check for Updates"))
    self.action_check_update.setStatusTip(_translate("MainWindow", "Check the lastest version of Pyslvs from Github."))
    self.action_new_window.setText(_translate("MainWindow", "New &amp;Window"))
    self.action_new_window.setStatusTip(_translate("MainWindow", "Open a new Pyslvs window."))
    self.action_scale_points.setText(_translate("MainWindow", "&amp;Scale Mechanism"))
    self.action_scale_points.setStatusTip(_translate("MainWindow", "Scale the mechanism by specified factor."))
    self.action_new_fourbar.setText(_translate("MainWindow", "Four-bar Mechanism"))
    self.action_new_fourbar.setStatusTip(_translate("MainWindow", "Create a four-bar linkage by parameters."))
    self.action_save.setText(_translate("MainWindow", "&amp;Save"))
    self.action_save.setStatusTip(_translate("MainWindow", "Save to a YAML-based format."))
    self.action_save.setShortcut(_translate("MainWindow", "Ctrl+S"))
    self.action_save_as.setText(_translate("MainWindow", "Save &amp;As ..."))
    self.action_save_as.setStatusTip(_translate("MainWindow", "Save to another YAML file."))
    self.action_save_as.setShortcut(_translate("MainWindow", "Ctrl+Shift+S"))
    self.action_documentation.setText(_translate("MainWindow", "&amp;Documentation"))
    self.action_documentation.setStatusTip(_translate("MainWindow", "See the documentation on Readthedocs."))
    self.action_set_link_length.setText(_translate("MainWindow", "Se&amp;t Link Length"))
    self.action_preference.setText(_translate("MainWindow", "P&amp;references"))
    self.action_preference.setShortcut(_translate("MainWindow", "F2"))
    self.action_screenshot.setText(_translate("MainWindow", "S&amp;creenshot"))
    self.action_screenshot.setShortcut(_translate("MainWindow", "Ctrl+P"))
    self.action_report_issue.setText(_translate("MainWindow", "&amp;Report Issue"))
    self.action_report_issue.setStatusTip(_translate("MainWindow", "Report an issue or see the current issues on GitHub."))
    self.action_deduce_links.setText(_translate("MainWindow", "Ded&amp;uce Links"))
    self.action_deduce_links.setStatusTip(_translate("MainWindow", "Remove redundant links."))
</t>
<t tx="leo.20231205084740.331">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/widgets/
# -*- coding: utf-8 -*-

"""Custom table of Points and Links.
Also contains selection status label.
"""

from __future__ import annotations

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from abc import abstractmethod
from dataclasses import astuple
from time import process_time
from typing import (
    TYPE_CHECKING, Tuple, List, Iterator, Sequence, Union, Optional,
    TypeVar, Generic,
)
from qtpy.QtCore import Signal, Qt, QTimer, Slot
from qtpy.QtWidgets import (
    QTableWidget,
    QSizePolicy,
    QAbstractItemView,
    QTableWidgetItem,
    QApplication,
    QTableWidgetSelectionRange,
    QHeaderView,
    QLabel,
    QWidget,
)
from qtpy.QtGui import QKeyEvent
from pyslvs import EStack, VPoint, VLink, PointArgs, LinkArgs
from pyslvs_ui.qt_patch import QABCMeta
from pyslvs_ui.graphics import color_icon

if TYPE_CHECKING:
    from pyslvs_ui.widgets import MainWindowBase

_Data = TypeVar('_Data', VPoint, VLink)
_Coord = Tuple[float, float]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.332">class BaseTableWidget(QTableWidget, Generic[_Data], metaclass=QABCMeta):
    """Two tables has some shared function."""
    headers: Sequence[str] = ()

    row_selection_changed = Signal(list)
    delete_request = Signal()

    @others
</t>
<t tx="leo.20231205084740.333">@abstractmethod
def __init__(self, row: int, parent: QWidget):
    super(BaseTableWidget, self).__init__(parent)
    self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
    self.setStatusTip("This table will show about the entities items in "
                      "current view mode.")
    self.setEditTriggers(QAbstractItemView.NoEditTriggers)
    self.setSelectionBehavior(QAbstractItemView.SelectRows)
    self.setVerticalScrollMode(QAbstractItemView.ScrollPerPixel)
    self.setHorizontalScrollMode(QAbstractItemView.ScrollPerPixel)

    self.setRowCount(row)
    self.setColumnCount(len(self.headers))
    for i, e in enumerate(self.headers):
        self.setHorizontalHeaderItem(i, QTableWidgetItem(e))

    # Table widget column width
    header = self.horizontalHeader()
    header.setSectionResizeMode(QHeaderView.ResizeToContents)

    @Slot()
    def emit_selection_changed() -&gt; None:
        self.row_selection_changed.emit(self.selected_rows())

    self.itemSelectionChanged.connect(emit_selection_changed)

</t>
<t tx="leo.20231205084740.334">def row_text(self, row: int, *, has_name: bool) -&gt; List[str]:
    """Get the whole row of texts.

    + Edit point: has_name = False
    + Edit link: has_name = True
    """
    texts = []
    for column in self.effective_range(has_name):
        item = self.item(row, column)
        if item is None:
            texts.append('')
        else:
            texts.append(item.text())
    return texts

</t>
<t tx="leo.20231205084740.335">@abstractmethod
def effective_range(self, has_name: bool) -&gt; Iterator[int]:
    """Return valid column range for row text."""
    raise NotImplementedError

</t>
<t tx="leo.20231205084740.336">def selected_rows(self) -&gt; List[int]:
    """Get what row is been selected."""
    return [row for row in range(self.rowCount())
            if self.item(row, 0).isSelected()]

</t>
<t tx="leo.20231205084740.337">def selectAll(self) -&gt; None:
    """Override method of select all function."""
    self.setFocus(Qt.ShortcutFocusReason)
    super(BaseTableWidget, self).selectAll()

</t>
<t tx="leo.20231205084740.338">def set_selections(self, selections: Sequence[int],
                   key_detect: bool = False) -&gt; None:
    """Auto select function, get the signal from canvas."""
    self.setFocus()
    keyboard_modifiers = QApplication.keyboardModifiers()
    if key_detect:
        if keyboard_modifiers == Qt.ShiftModifier:
            continue_select = True
            not_select = False
        elif keyboard_modifiers == Qt.ControlModifier:
            continue_select = True
            not_select = True
        else:
            continue_select = False
            not_select = False
        self.__set_selected_ranges(
            selections,
            is_continue=continue_select,
            un_select=not_select
        )
    else:
        self.__set_selected_ranges(
            selections,
            is_continue=(keyboard_modifiers == Qt.ShiftModifier),
            un_select=False
        )

</t>
<t tx="leo.20231205084740.339">def __set_selected_ranges(
    self,
    selections: Sequence[int],
    *,
    is_continue: bool,
    un_select: bool
):
    """Different mode of select function."""
    selected_rows = self.selected_rows()
    if not is_continue:
        self.clearSelection()
    self.setCurrentCell(selections[-1], 0)
    for row in selections:
        is_selected = (row not in selected_rows) if un_select else True
        self.setRangeSelected(
            QTableWidgetSelectionRange(row, 0, row, self.columnCount() - 1),
            is_selected
        )
        self.scrollToItem(self.item(row, 0))

</t>
<t tx="leo.20231205084740.34">def __add_result(self, result: Mapping[str, Any]) -&gt; None:
    """Add result items, except add to the list."""
    item = QListWidgetItem(result['algorithm'])
    interrupt = result['interrupted']
    if interrupt == 'False':
        interrupt_icon = "task_completed.png"
    elif interrupt == 'N/A':
        interrupt_icon = "question.png"
    else:
        interrupt_icon = "interrupted.png"
    item.setIcon(QIcon(QPixmap(f"icons:{interrupt_icon}")))
    if interrupt == 'False':
        interrupt_text = "No interrupt."
    else:
        interrupt_text = f"Interrupt at: {interrupt}"
    text = f"{result['algorithm']} ({interrupt_text})"
    if interrupt == 'N/A':
        text += "\n※Completeness is unknown."
    item.setToolTip(text)
    self.result_list.addItem(item)

</t>
<t tx="leo.20231205084740.340">def keyPressEvent(self, event: QKeyEvent) -&gt; None:
    """Hit the delete key,
    will emit delete signal from this table.
    """
    if event.key() == Qt.Key_Delete:
        self.delete_request.emit()

</t>
<t tx="leo.20231205084740.341">def clear(self) -&gt; None:
    """Overridden the clear function, just removed all items."""
    for row in range(self.rowCount()):
        self.removeRow(0)

</t>
<t tx="leo.20231205084740.342">@Slot()
def clearSelection(self) -&gt; None:
    """Overridden the 'clear_selection' slot to emit
    'row_selection_changed'"""
    super(BaseTableWidget, self).clearSelection()
    self.row_selection_changed.emit([])


</t>
<t tx="leo.20231205084740.343">class PointTableWidget(BaseTableWidget[VPoint]):
    """Custom table widget for points."""
    headers = ('Number', 'Links', 'Type', 'Color', 'X', 'Y', 'Current')
    selectionLabelUpdate = Signal(list)

    @others
</t>
<t tx="leo.20231205084740.344">def __init__(self, parent: QWidget):
    super(PointTableWidget, self).__init__(0, parent)

</t>
<t tx="leo.20231205084740.345">def edit_point(self, row: int, arg: PointArgs) -&gt; None:
    """Edit a point."""
    for i, e in enumerate((f'Point{row}',)
                          + astuple(arg)
                          + (f"({arg.x}, {arg.y})",)):
        item = QTableWidgetItem(str(e))
        item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
        if i == 3:
            item.setIcon(color_icon(e))
        self.setItem(row, i, item)

</t>
<t tx="leo.20231205084740.346">def row_data(self, row: int) -&gt; PointArgs:
    """Return row data for 'edit_point' method."""
    args = self.row_text(row, has_name=False)
    x = float(args[3]) if args[3] else 0.
    y = float(args[4]) if args[4] else 0.
    return PointArgs(args[0], args[1], args[2], x, y)

</t>
<t tx="leo.20231205084740.347">def rename(self, row: int) -&gt; None:
    """When index changed, the points need to rename."""
    for j in range(row, self.rowCount()):
        self.setItem(j, 0, QTableWidgetItem(f'Point{j}'))

</t>
<t tx="leo.20231205084740.348">def current_position(self, row: int) -&gt; List[_Coord]:
    """Get the current coordinate from a point."""
    type_str = self.item(row, 2).text().split(':')
    coords_text = self.item(row, 6).text().replace(';', ',')
    coords = eval(f"[{coords_text}]")
    if (type_str[0] in {'P', 'RP'}) and len(coords) == 1:
        x, y = coords[0]
        self.item(row, 6).setText("; ".join([f"({x:.06f}, {y:.06f})"] * 2))
        coords.append(coords[0])
    return coords

</t>
<t tx="leo.20231205084740.349">def update_current_position(
    self,
    coords: Sequence[Union[_Coord, Tuple[_Coord, _Coord]]]
) -&gt; None:
    """Update the current coordinate for a point."""
    for i, c in enumerate(coords):
        if isinstance(c[0], float):
            x, y = c
            text = f"({x:.06f}, {y:.06f})"
        else:
            (x1, y1), (x2, y2) = c
            text = f"({x1:.06f}, {y1:.06f}); ({x2:.06f}, {y2:.06f})"
        item = QTableWidgetItem(text)
        item.setToolTip(text)
        self.setItem(i, 6, item)

</t>
<t tx="leo.20231205084740.35">@Slot(name='on_delete_btn_clicked')
def __delete_result(self) -&gt; None:
    """Delete a result."""
    row = self.result_list.currentRow()
    if not row &gt; -1:
        return
    if QMessageBox.question(
        self,
        "Delete",
        "Delete this result from list?"
    ) != QMessageBox.Yes:
        return
    self.mechanism_data.pop(row)
    self.result_list.takeItem(row)
    self.project_no_save()
    self.__has_result()

</t>
<t tx="leo.20231205084740.350">def get_back_position(self) -&gt; None:
    """Let all the points go back to origin coordinate."""
    self.update_current_position(tuple(
        (float(self.item(row, 4).text()), float(self.item(row, 5).text()))
        for row in range(self.rowCount())
    ))

</t>
<t tx="leo.20231205084740.351">def get_links(self, row: int) -&gt; List[str]:
    item = self.item(row, 1)
    if not item:
        return []
    return [s for s in item.text().split(',') if s]

</t>
<t tx="leo.20231205084740.352">def set_selections(self, selections: Sequence[int],
                   key_detect: bool = False) -&gt; None:
    """Need to update selection label on status bar."""
    super(PointTableWidget, self).set_selections(selections, key_detect)
    self.selectionLabelUpdate.emit(self.selected_rows())

</t>
<t tx="leo.20231205084740.353">def effective_range(self, has_name: bool) -&gt; Iterator[int]:
    """Row range that can be delete."""
    if has_name:
        yield from range(self.columnCount())
    else:
        yield from range(1, self.columnCount() - 1)

</t>
<t tx="leo.20231205084740.354">@Slot()
def clearSelection(self) -&gt; None:
    """Overridden the 'clear_selection' slot,
    so it will emit signal to clean the selection.
    """
    super(PointTableWidget, self).clearSelection()
    self.selectionLabelUpdate.emit([])


</t>
<t tx="leo.20231205084740.355">class LinkTableWidget(BaseTableWidget[VLink]):
    """Custom table widget for link."""
    headers = ('Name', 'Color', 'Points')

    @others
</t>
<t tx="leo.20231205084740.356">def __init__(self, parent: QWidget):
    super(LinkTableWidget, self).__init__(1, parent)
    self.setDragDropMode(QAbstractItemView.DropOnly)
    self.setAcceptDrops(True)
    self.edit_link(0, LinkArgs(VLink.FRAME, 'White', ''))

</t>
<t tx="leo.20231205084740.357">def edit_link(self, row: int, arg: LinkArgs):
    """Edit a link."""
    for i, e in enumerate(astuple(arg)):
        item = QTableWidgetItem(e)
        item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
        if i == 1:
            item.setIcon(color_icon(e))
        self.setItem(row, i, item)

</t>
<t tx="leo.20231205084740.358">def row_data(self, row: int) -&gt; LinkArgs:
    """Return row data for 'edit_link' method."""
    return LinkArgs(*self.row_text(row, has_name=True))

</t>
<t tx="leo.20231205084740.359">def find_name(self, name: str) -&gt; int:
    """Return row index by input name."""
    for row in range(self.rowCount()):
        item = self.item(row, 0)
        if not item:
            continue
        if name == item.text():
            return row
    return -1

</t>
<t tx="leo.20231205084740.36">@Slot(QModelIndex, name='on_result_list_clicked')
def __has_result(self, *_) -&gt; None:
    """Set enable if there has any result."""
    enable = self.result_list.currentRow() &gt; -1
    for button in (
        self.merge_btn,
        self.delete_btn,
        self.result_load_settings,
        self.result_clipboard
    ):
        button.setEnabled(enable)

</t>
<t tx="leo.20231205084740.360">def get_points(self, row: int) -&gt; List[int]:
    """Get all point names."""
    item = self.item(row, 2)
    if not item:
        return []
    link_str = item.text()
    return [int(s.replace('Point', '')) for s in link_str.split(',') if s]

</t>
<t tx="leo.20231205084740.361">def effective_range(self, has_name: bool) -&gt; Iterator[int]:
    """Row range that can be delete."""
    yield from range(self.columnCount())

</t>
<t tx="leo.20231205084740.362">def clear(self) -&gt; None:
    """We should keep the frame left."""
    super(LinkTableWidget, self).clear()
    self.setRowCount(1)
    self.edit_link(0, LinkArgs(VLink.FRAME, 'White', ''))


</t>
<t tx="leo.20231205084740.363">class ExprTableWidget(BaseTableWidget):
    """Expression table.

    + Free move request: link name, length
    """
    exprs: List[Tuple[str, ...]]

    headers = ('Function', 'p0', 'p1', 'p2', 'p3', 'p4', 'target')

    @others
</t>
<t tx="leo.20231205084740.364">def __init__(self, parent: QWidget):
    super(ExprTableWidget, self).__init__(0, parent)
    self.exprs = []

</t>
<t tx="leo.20231205084740.365">def set_expr(self, es: EStack, unsolved: Sequence[int]):
    """Set the table items for new coming expression."""
    exprs = es.as_list()
    if exprs != self.exprs:
        self.clear()
        self.setRowCount(len(exprs) + len(unsolved))
    row = 0
    for expr in exprs:
        # Target
        self.setItem(row, self.columnCount() - 1,
                     QTableWidgetItem(expr[-1]))
        # Parameters
        for column, text in enumerate(expr[:-1]):
            item = QTableWidgetItem(text)
            item.setToolTip(text)
            self.setItem(row, column, item)
        row += 1
    for p in unsolved:
        # Declaration
        self.setItem(row, 0, QTableWidgetItem("Unsolved"))
        # Target
        self.setItem(row, self.columnCount() - 1, QTableWidgetItem(f"P{p}"))
        row += 1
    self.exprs = exprs

</t>
<t tx="leo.20231205084740.366">def effective_range(self, has_name: bool) -&gt; Iterator[int]:
    """Return column count."""
    yield from range(self.columnCount())

</t>
<t tx="leo.20231205084740.367">def clear(self) -&gt; None:
    """Emit to close the link free move widget."""
    super(ExprTableWidget, self).clear()


</t>
<t tx="leo.20231205084740.368">class SelectionLabel(QLabel):
    """This QLabel can show distance in status bar."""

    @others
</t>
<t tx="leo.20231205084740.369">def __init__(self, parent: MainWindowBase):
    super(SelectionLabel, self).__init__(parent)
    self.update_select_point()
    self.vpoints = parent.vpoint_list

</t>
<t tx="leo.20231205084740.37">@Slot(QModelIndex, name='on_result_list_doubleClicked')
def __show_result(self, _=None) -&gt; None:
    """Double click result item can show up preview dialog."""
    row = self.result_list.currentRow()
    if not row &gt; -1:
        return
    dlg = PreviewDialog(self.mechanism_data[row], self.__get_path(row),
                        self.preview_canvas.monochrome, self)
    dlg.show()
    dlg.exec_()
    dlg.deleteLater()

</t>
<t tx="leo.20231205084740.370">@Slot()
@Slot(list)
def update_select_point(self, points: Optional[List[int]] = None) -&gt; None:
    """Get points and distance from Point table widget."""
    if points is None:
        points = []
    p_count = len(points)
    if not p_count:
        self.setText("No selection.")
        return
    text = "Selected: "
    text += " - ".join(str(p) for p in points)
    if p_count &gt; 1:
        distances = []
        angles = []
        for i in range(min(p_count, 3)):
            if i == 0:
                continue
            vpoint0 = self.vpoints[points[i - 1]]
            vpoint1 = self.vpoints[points[i]]
            distances.append(f"{vpoint1.distance(vpoint0):.06}")
            angles.append(f"{vpoint0.slope_angle(vpoint1):.06}°")
        ds_t = ", ".join(distances)
        as_t = ", ".join(angles)
        text += f" | {ds_t} | {as_t}"
    self.setText(text)

</t>
<t tx="leo.20231205084740.371">@Slot(float, float)
def update_mouse_position(self, x: float, y: float) -&gt; None:
    """Get the mouse position from canvas when press the middle button."""
    self.setText(f"Mouse at: ({x:.04f}, {y:.04f})")


</t>
<t tx="leo.20231205084740.372">class FPSLabel(QLabel):
    """This QLabel can show FPS of main canvas in status bar."""

    @others
</t>
<t tx="leo.20231205084740.373">def __init__(self, parent: QWidget):
    super(FPSLabel, self).__init__(parent)
    self.__t0 = process_time()
    self.__frame_timer = QTimer()
    self.__frame_timer.timeout.connect(self.__update_text)
    self.__frame_timer.start(1000)

</t>
<t tx="leo.20231205084740.374">@Slot()
def __update_text(self) -&gt; None:
    """Update FPS with timer."""
    t1 = process_time() - self.__t0
    fps = 1 / t1 if t1 else 1
    self.setText(f"FPS: {fps:6.02f}")

</t>
<t tx="leo.20231205084740.375">@Slot()
def update_text(self) -&gt; None:
    """Update FPS with timer."""
    self.__update_text()
    self.__t0 = process_time()
</t>
<t tx="leo.20231205084740.376">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/widgets/
# -*- coding: utf-8 -*-

"""All of undoable commands in Pyslvs.

+ The add and delete commands has only add and delete.
+ The add commands need to edit Points or Links list
  after it added to table.
+ The delete commands need to clear Points or Links list
  before it deleted from table.

+ The edit command need to know who is included by the VPoint or VLink.

Put the pointer under 'self' when the classes are initialize.
'redo' method will be called when pushing into the stack.
"""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import (
    cast, Type, Sequence, List, Dict, Mapping, Tuple, Iterator, Iterable,
    Generic, Optional, TypeVar,
)
from abc import abstractmethod
from qtpy.QtCore import Qt
from qtpy.QtWidgets import (
    QUndoCommand,
    QTableWidgetItem,
    QListWidget,
    QListWidgetItem,
    QLineEdit,
    QWidget,
)
from qtpy.QtGui import QIcon, QPixmap
from pyslvs import VJoint, VPoint, VLink, color_rgb, PointArgs, LinkArgs
from pyslvs_ui.qt_patch import QABCMeta
from .tables import BaseTableWidget, PointTableWidget, LinkTableWidget

_Coord = Tuple[float, float]
_Paths = Sequence[Sequence[_Coord]]
_SliderPaths = Mapping[int, Sequence[_Coord]]
_ITEM_FLAGS = Qt.ItemIsSelectable | Qt.ItemIsEnabled
_Data = TypeVar('_Data', VPoint, VLink)
_Args = TypeVar('_Args', PointArgs, LinkArgs)


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.377">def _no_empty(str_list: Iterable[str]) -&gt; Iterator[str]:
    """Filter to exclude empty string."""
    yield from (s for s in str_list if s)


</t>
<t tx="leo.20231205084740.378">def _args2vpoint(args: PointArgs) -&gt; VPoint:
    """Make arguments as a VPoint object."""
    link = _no_empty(args.links.split(','))
    if args.type == '':
        return VPoint.HOLDER
    elif args.type == 'R':
        type_int = VJoint.R
        angle = 0.
    else:
        angle_pair = args.type.split(':')
        angle = float(angle_pair[1])
        type_int = VJoint.P if angle_pair[0] == 'P' else VJoint.RP
    return VPoint(link, type_int, angle, args.color, args.x, args.y, color_rgb)


</t>
<t tx="leo.20231205084740.379">def _args2vlink(args: LinkArgs) -&gt; VLink:
    """Make arguments as a VLink object."""
    if args.name == '':
        return VLink.HOLDER
    return VLink(args.name, args.color, [
        int(p.replace('Point', ''))
        for p in _no_empty(args.points.split(','))
    ], color_rgb)


</t>
<t tx="leo.20231205084740.38">@Slot(name='on_merge_btn_clicked')
def __merge_result(self) -&gt; None:
    """Merge mechanism into main canvas."""
    row = self.result_list.currentRow()
    if not row &gt; -1:
        return
    if QMessageBox.question(
        self,
        "Merge",
        "Add the result expression into storage?"
    ) == QMessageBox.Yes:
        expression: str = self.mechanism_data[row]['expression']
        self.merge_result(expression, self.__get_path(row))

</t>
<t tx="leo.20231205084740.380">class _FusedTable(QUndoCommand, Generic[_Data], metaclass=QABCMeta):
    """Table command of fused type."""
    entities_list: List[_Data]
    table: BaseTableWidget
    table_type: Type[BaseTableWidget]

    @others
</t>
<t tx="leo.20231205084740.381">@abstractmethod
def __init__(
    self,
    entities_list: List[_Data],
    table: BaseTableWidget,
    parent: Optional[QWidget] = None
):
    super(_FusedTable, self).__init__(parent)
    self.entities_list = entities_list
    self.table = table
    self.table_type = type(table)


</t>
<t tx="leo.20231205084740.382">class AddTable(_FusedTable[_Data]):
    """Add a row at last of the table."""

    @others
</t>
<t tx="leo.20231205084740.383">def __init__(
    self,
    entities_list: List[_Data],
    table: BaseTableWidget,
    parent: Optional[QWidget] = None
):
    super(AddTable, self).__init__(entities_list, table, parent)

</t>
<t tx="leo.20231205084740.384">def redo(self) -&gt; None:
    """Add a empty row and add empty text strings into table items."""
    self.entities_list.append(cast(
        _Data,
        VPoint.HOLDER
        if self.table_type is PointTableWidget else
        VLink.HOLDER
    ))
    row = self.table.rowCount()
    self.table.insertRow(row)
    for column in range(row):
        self.table.setItem(row, column, QTableWidgetItem(''))

</t>
<t tx="leo.20231205084740.385">def undo(self) -&gt; None:
    """Remove the last row directly."""
    self.table.removeRow(self.table.rowCount() - 1)
    self.entities_list.pop()


</t>
<t tx="leo.20231205084740.386">class DeleteTable(_FusedTable[_Data]):
    """Delete the specified row of table.

    When this class has been called, the item must be empty.
    """

    @others
</t>
<t tx="leo.20231205084740.387">def __init__(
    self,
    row: int,
    entities_list: List[_Data],
    table: BaseTableWidget,
    is_rename: bool,
    parent: Optional[QWidget] = None
):
    super(DeleteTable, self).__init__(entities_list, table, parent)
    self.row = row
    self.is_rename = is_rename

</t>
<t tx="leo.20231205084740.388">def redo(self) -&gt; None:
    """Remove the row and rename sequence."""
    self.entities_list.pop(self.row)
    self.table.removeRow(self.row)
    if self.is_rename:
        self.table.rename(self.row)

</t>
<t tx="leo.20231205084740.389">def undo(self) -&gt; None:
    """Rename again then insert a empty row."""
    if self.is_rename:
        self.table.rename(self.row)
    self.entities_list.insert(self.row, cast(
        _Data,
        VPoint.HOLDER
        if self.table_type is PointTableWidget else
        VLink.HOLDER
    ))
    self.table.insertRow(self.row)
    for column in range(self.table.columnCount()):
        self.table.setItem(self.row, column, QTableWidgetItem(''))


</t>
<t tx="leo.20231205084740.39">def __get_path(self, row: int) -&gt; List[List[_Coord]]:
    """Using result data to generate paths of mechanism."""
    result = self.mechanism_data[row]
    expression: str = result['expression']
    same: Mapping[int, int] = result['same']
    inputs: List[Tuple[_Pair, _Coord]] = result['input']
    input_list = []
    for (b, d), _ in inputs:
        for i in range(b):
            if i in same:
                b -= 1
        for i in range(d):
            if i in same:
                d -= 1
        input_list.append((b, d))
    vpoints = parse_vpoints(expression)
    expr = t_config(vpoints, input_list)
    b, d = input_list[0]
    base_angle = vpoints[b].slope_angle(vpoints[d])
    path: List[List[_Coord]] = [[] for _ in range(len(vpoints))]
    input_pair = {(b, d): 0. for b, d in input_list}
    for angle in range(360 + 1):
        input_pair[b, d] = base_angle + angle
        try:
            result_list = expr_solving(expr, vpoints, input_pair)
        except ValueError:
            nan = float('nan')
            for i in range(len(vpoints)):
                path[i].append((nan, nan))
        else:
            for i in range(len(vpoints)):
                coord = result_list[i]
                if isinstance(coord[0], tuple):
                    path[i].append(coord[1])
                else:
                    path[i].append(coord)
    return path

</t>
<t tx="leo.20231205084740.390">class FixSequenceNumber(QUndoCommand):
    """Fix sequence number when deleting a point."""

    @others
</t>
<t tx="leo.20231205084740.391">def __init__(
    self,
    vlink_list: List[VLink],
    link_table: LinkTableWidget,
    row: int,
    benchmark: int,
    parent: Optional[QWidget] = None
):
    super(FixSequenceNumber, self).__init__(parent)
    self.link_table = link_table
    self.vlink_list = vlink_list
    self.row = row
    self.benchmark = benchmark

</t>
<t tx="leo.20231205084740.392">def redo(self) -&gt; None:
    self.__sorting(True)

</t>
<t tx="leo.20231205084740.393">def undo(self) -&gt; None:
    self.__sorting(False)

</t>
<t tx="leo.20231205084740.394">def __sorting(self, benchmark: bool) -&gt; None:
    """Sorting point number by benchmark."""
    vlink = self.vlink_list[self.row]
    if not vlink.points:
        return
    points = list(vlink.points)
    if benchmark:
        points = [p - 1 if p &gt; self.benchmark else p for p in points]
    else:
        points = [p + 1 if p &gt;= self.benchmark else p for p in points]
    vlink.set_points(points)
    item = self.link_table.item(self.row, 2)
    item.setText(','.join([f'Point{p}' for p in points]))


</t>
<t tx="leo.20231205084740.395">class _EditFusedTable(QUndoCommand, Generic[_Args], metaclass=QABCMeta):
    """Edit table command of fused type."""
    args: _Args

    @others
</t>
<t tx="leo.20231205084740.396">@abstractmethod
def __init__(
    self,
    row: int,
    vpoint_list: List[VPoint],
    vlink_list: List[VLink],
    point_table: PointTableWidget,
    link_table: LinkTableWidget,
    args_list: _Args,
    parent: Optional[QWidget] = None
):
    super(_EditFusedTable, self).__init__(parent)
    self.row = row
    self.vpoint_list = vpoint_list
    self.vlink_list = vlink_list
    self.point_table = point_table
    self.link_table = link_table
    self.args = args_list


</t>
<t tx="leo.20231205084740.397">class EditPointTable(_EditFusedTable[PointArgs]):
    """Edit Point table.

    Copy old data and put it back when called undo.
    """

    @others
</t>
<t tx="leo.20231205084740.398">def __init__(
    self,
    row: int,
    vpoint_list: List[VPoint],
    vlink_list: List[VLink],
    point_table: PointTableWidget,
    link_table: LinkTableWidget,
    args_list: PointArgs,
    parent: Optional[QWidget] = None
):
    super(EditPointTable, self).__init__(
        row,
        vpoint_list,
        vlink_list,
        point_table,
        link_table,
        args_list,
        parent
    )
    self.old_args = self.point_table.row_data(row)
    # Links: Set[str]
    new_links = set(self.args.links.split(','))
    old_links = set(self.old_args.links.split(','))
    new_link_items = []
    old_link_items = []
    for row, vlink in enumerate(self.vlink_list):
        name = vlink.name
        if name in (new_links - old_links):
            new_link_items.append(row)
        if name in (old_links - new_links):
            old_link_items.append(row)
    self.new_link_items = tuple(new_link_items)
    self.old_link_items = tuple(old_link_items)

</t>
<t tx="leo.20231205084740.399">def redo(self) -&gt; None:
    """Write arguments then rewrite the dependents."""
    self.vpoint_list[self.row] = _args2vpoint(self.args)
    self.point_table.edit_point(self.row, self.args)
    self.__write_links(self.new_link_items, self.old_link_items)

</t>
<t tx="leo.20231205084740.4">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/dimensional_synthesis/
# -*- coding: utf-8 -*-

"""'dimensional_synthesis' module contains
dimensional synthesis functional interfaces.
"""

from __future__ import annotations

__all__ = ['Optimizer']
__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from pprint import pformat
from copy import deepcopy
from math import hypot
from typing import (
    Any, Callable, Dict, Mapping, Iterable, Iterator, List, Optional,
    Sequence, TYPE_CHECKING, Tuple, Union, cast,
)
from lark.exceptions import LarkError
from openpyxl import load_workbook
from pyslvs import expr_solving, parse_pos, parse_vpoints, t_config
from pyslvs.optimization import norm_path
from pyslvs.metaheuristics import AlgorithmType, default
from qtpy.QtCore import QModelIndex, Slot
from qtpy.QtGui import QIcon, QPixmap
from qtpy.QtWidgets import (
    QApplication,
    QDoubleSpinBox,
    QHeaderView,
    QInputDialog,
    QListWidgetItem,
    QMessageBox,
    QRadioButton,
    QTableWidgetItem,
    QWidget,
)
from pyslvs_ui.graphics import PreviewCanvas, parse_path
from pyslvs_ui.synthesis import CollectionsDialog
from .dialogs import (
    AlgorithmOptionDialog,
    ChartDialog,
    EditPathDialog,
    PreviewDialog,
    ProgressDialog,
)
from .dimension_widget_ui import Ui_Form

if TYPE_CHECKING:
    from pyslvs_ui.widgets import MainWindowBase

_Pair = Tuple[int, int]
_Coord = Tuple[float, float]
_Range = Tuple[float, float, float]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.40">@Slot(name='on_result_clipboard_clicked')
def __copy_result_text(self) -&gt; None:
    """Copy pretty print result as text."""
    QApplication.clipboard().setText(
        pformat(self.mechanism_data[self.result_list.currentRow()])
    )

</t>
<t tx="leo.20231205084740.400">def undo(self) -&gt; None:
    """Rewrite the dependents then write arguments."""
    self.__write_links(self.old_link_items, self.new_link_items)
    self.point_table.edit_point(self.row, self.old_args)
    self.vpoint_list[self.row] = _args2vpoint(self.old_args)

</t>
<t tx="leo.20231205084740.401">def __write_links(self, add: Sequence[int], sub: Sequence[int]) -&gt; None:
    """Write table function.

    + Append the point that relate with these links.
    + Remove the point that irrelevant with these links.
    """
    for row in add:
        new_points = list(self.vlink_list[row].points)
        new_points.append(self.row)
        self.__set_cell(row, new_points)
    for row in sub:
        new_points = list(self.vlink_list[row].points)
        new_points.remove(self.row)
        self.__set_cell(row, new_points)

</t>
<t tx="leo.20231205084740.402">def __set_cell(self, row: int, points: Iterable[int]) -&gt; None:
    item = QTableWidgetItem(','.join(f'Point{p}' for p in points))
    item.setFlags(_ITEM_FLAGS)
    self.link_table.setItem(row, 2, item)
    self.vlink_list[row].set_points(points)


</t>
<t tx="leo.20231205084740.403">class EditLinkTable(_EditFusedTable[LinkArgs]):
    """Edit Link table.

    Copy old data and put it back when called undo.
    """

    @others
</t>
<t tx="leo.20231205084740.404">def __init__(
    self,
    row: int,
    vpoint_list: List[VPoint],
    vlink_list: List[VLink],
    point_table: PointTableWidget,
    link_table: LinkTableWidget,
    args_list: LinkArgs,
    parent: Optional[QWidget] = None
):
    super(EditLinkTable, self).__init__(
        row,
        vpoint_list,
        vlink_list,
        point_table,
        link_table,
        args_list,
        parent
    )
    self.old_args = self.link_table.row_data(row)
    # Points: Set[int]
    new_points = {
        int(index.replace('Point', ''))
        for index in _no_empty(self.args.points.split(','))
    }
    old_points = {
        int(index.replace('Point', ''))
        for index in _no_empty(self.old_args.points.split(','))
    }
    self.new_point_items = tuple(new_points - old_points)
    self.old_point_items = tuple(old_points - new_points)

</t>
<t tx="leo.20231205084740.405">def redo(self) -&gt; None:
    """Write arguments then rewrite the dependents."""
    self.vlink_list[self.row] = _args2vlink(self.args)
    self.link_table.edit_link(self.row, self.args)
    self.__rename(self.args.name, self.old_args)
    self.__write_points(self.args.name, self.new_point_items,
                        self.old_point_items)

</t>
<t tx="leo.20231205084740.406">def undo(self) -&gt; None:
    """Rewrite the dependents then write arguments."""
    self.__write_points(self.old_args.name, self.old_point_items,
                        self.new_point_items)
    self.__rename(self.old_args.name, self.args)
    self.link_table.edit_link(self.row, self.old_args)
    self.vlink_list[self.row] = _args2vlink(self.old_args)

</t>
<t tx="leo.20231205084740.407">def __rename(self, new_name: str, args: LinkArgs) -&gt; None:
    """Adjust link name in all dependents, if link name are changed."""
    if args.name == new_name:
        return
    for index in _no_empty(args.points.split(',')):
        row = int(index.replace('Point', ''))
        item = QTableWidgetItem(','.join(_no_empty(
            link.replace(args.name, new_name)
            for link in self.vpoint_list[row].links
        )))
        item.setFlags(_ITEM_FLAGS)
        self.point_table.setItem(row, 1, item)
        self.vpoint_list[row].replace_link(args.name, new_name)

</t>
<t tx="leo.20231205084740.408">def __write_points(self, name: str, add: Sequence[int],
                   sub: Sequence[int]) -&gt; None:
    """Write table function.

    + Append the link that relate with these points.
    + Remove the link that irrelevant with these points.
    """
    for row in add:
        new_links = list(self.vpoint_list[row].links)
        new_links.append(name)
        self.__set_cell(row, new_links)
    for row in sub:
        new_links = list(self.vpoint_list[row].links)
        if name:
            new_links.remove(name)
        self.__set_cell(row, new_links)

</t>
<t tx="leo.20231205084740.409">def __set_cell(self, row: int, links: Iterable[str]) -&gt; None:
    item = QTableWidgetItem(','.join(links))
    item.setFlags(_ITEM_FLAGS)
    self.point_table.setItem(row, 1, item)
    self.vpoint_list[row].set_links(links)


</t>
<t tx="leo.20231205084740.41">@Slot(name='on_save_profile_clicked')
def __save_profile(self) -&gt; None:
    """Save as new profile to collection widget."""
    if not self.mech:
        return
    name, ok = QInputDialog.getText(
        self,
        "Profile name",
        "Please enter the profile name:"
    )
    if not ok:
        return
    i = 0
    while (not name) and (name not in self.collections):
        name = f"Structure_{i}"
        i += 1
    mech = deepcopy(self.mech)
    for key in ('placement', 'target'):
        for mp in mech[key]:
            mech[key][mp] = None
    self.collections[name] = mech
    self.project_no_save()

</t>
<t tx="leo.20231205084740.410">class AddPath(QUndoCommand):
    """Append a new path."""

    @others
</t>
<t tx="leo.20231205084740.411">def __init__(
    self,
    widget: QListWidget,
    name: str,
    paths: Dict[str, _Paths],
    slider_paths: Dict[str, _SliderPaths],
    path: _Paths,
    slider_path: _SliderPaths,
    parent: Optional[QWidget] = None
):
    super(AddPath, self).__init__(parent)
    self.setText(f"Add {{Path: {name}}}")
    self.widget = widget
    self.name = name
    self.paths = paths
    self.slider_paths = slider_paths
    self.path = path
    self.slider_path = slider_path
    self.targets = [i for i, p in enumerate(self.path) if len(set(p)) &gt; 1]

</t>
<t tx="leo.20231205084740.412">def redo(self) -&gt; None:
    """Add new path data."""
    self.paths[self.name] = self.path
    self.slider_paths[self.name] = self.slider_path
    self.widget.addItem(
        f"{self.name}: " + ", ".join(f"[{i}]" for i in self.targets))

</t>
<t tx="leo.20231205084740.413">def undo(self) -&gt; None:
    """Remove the last item."""
    self.widget.takeItem(self.widget.count() - 1)
    self.paths.pop(self.name)
    self.slider_paths.pop(self.name)


</t>
<t tx="leo.20231205084740.414">class DeletePath(QUndoCommand):
    """"Delete the specified row of path."""

    @others
</t>
<t tx="leo.20231205084740.415">def __init__(
    self,
    row: int,
    widget: QListWidget,
    paths: Dict[str, _Paths],
    slider_paths: Dict[str, _SliderPaths],
    parent: Optional[QWidget] = None
):
    super(DeletePath, self).__init__(parent)
    self.setText(f"Delete {{Path: {widget.item(row).text()}}}")
    self.row = row
    self.widget = widget
    self.paths = paths
    self.slider_paths = slider_paths
    self.old_item = self.widget.item(self.row)
    self.name = self.old_item.text().split(':')[0]
    self.old_path = self.paths[self.name]
    self.old_slider_path = self.slider_paths[self.name]

</t>
<t tx="leo.20231205084740.416">def redo(self) -&gt; None:
    """Delete the path."""
    self.widget.takeItem(self.row)
    self.paths.pop(self.name)
    self.slider_paths.pop(self.name)

</t>
<t tx="leo.20231205084740.417">def undo(self) -&gt; None:
    """Append back the path."""
    self.paths[self.name] = self.old_path
    self.slider_paths[self.name] = self.old_slider_path
    self.widget.addItem(self.old_item)
    self.widget.setCurrentRow(self.widget.row(self.old_item))


</t>
<t tx="leo.20231205084740.418">class AddStorage(QUndoCommand):
    """Append a new storage."""

    @others
</t>
<t tx="leo.20231205084740.419">def __init__(
    self,
    name: str,
    widget: QListWidget,
    mechanism: str,
    parent: Optional[QWidget] = None
):
    super(AddStorage, self).__init__(parent)
    self.setText(f"Add {{Mechanism: {name}}}")
    self.name = name
    self.widget = widget
    self.mechanism = mechanism

</t>
<t tx="leo.20231205084740.42">@Slot(name='on_load_profile_clicked')
def __load_profile(self) -&gt; None:
    """Load profile from collections dialog."""
    dlg = CollectionsDialog(
        self.collections,
        self.get_collection,
        self.project_no_save,
        self.prefer.tick_mark_option,
        self.preview_canvas.monochrome,
        self
    )
    dlg.show()
    if not dlg.exec_():
        dlg.deleteLater()
        return
    params = dlg.params
    name = dlg.name
    dlg.deleteLater()
    del dlg
    # Check the profile
    if not (params['target'] and params['input'] and params['placement']):
        QMessageBox.warning(
            self,
            "Invalid profile",
            "The profile is not configured yet."
        )
        return
    self.__set_profile(name, params)

</t>
<t tx="leo.20231205084740.420">def redo(self) -&gt; None:
    """Add mechanism expression to 'expr' attribute."""
    item = QListWidgetItem(self.name)
    item.expr = self.mechanism
    item.setIcon(QIcon(QPixmap("icons:mechanism.png")))
    self.widget.addItem(item)

</t>
<t tx="leo.20231205084740.421">def undo(self) -&gt; None:
    """Remove the last item."""
    self.widget.takeItem(self.widget.count() - 1)


</t>
<t tx="leo.20231205084740.422">class DeleteStorage(QUndoCommand):
    """Delete the specified row of storage."""

    @others
</t>
<t tx="leo.20231205084740.423">def __init__(
    self,
    row: int,
    widget: QListWidget,
    parent: Optional[QWidget] = None
):
    super(DeleteStorage, self).__init__(parent)
    self.setText(f"Delete {{Mechanism: {widget.item(row).text()}}}")
    self.row = row
    self.widget = widget
    self.name = widget.item(row).text()
    self.mechanism = widget.item(row).expr

</t>
<t tx="leo.20231205084740.424">def redo(self) -&gt; None:
    """Remove the row directly."""
    self.widget.takeItem(self.row)

</t>
<t tx="leo.20231205084740.425">def undo(self) -&gt; None:
    """Create a new item and recover expression."""
    item = QListWidgetItem(self.name)
    item.expr = self.mechanism
    item.setIcon(QIcon(QPixmap("icons:mechanism.png")))
    self.widget.insertItem(self.row, item)


</t>
<t tx="leo.20231205084740.426">class AddStorageName(QUndoCommand):
    """Update name of storage name."""

    @others
</t>
<t tx="leo.20231205084740.427">def __init__(
    self,
    name: str,
    widget: QLineEdit,
    parent: Optional[QWidget] = None
):
    super(AddStorageName, self).__init__(parent)
    self.name = name
    self.widget = widget

</t>
<t tx="leo.20231205084740.428">def redo(self) -&gt; None:
    """Set the name text."""
    self.widget.setText(self.name)

</t>
<t tx="leo.20231205084740.429">def undo(self) -&gt; None:
    """Clear the name text."""
    self.widget.clear()


</t>
<t tx="leo.20231205084740.43">def __set_profile(self, profile_name: str,
                  params: Mapping[str, Any]) -&gt; None:
    """Set profile to sub-widgets."""
    self.__clear_settings()
    self.mech = dict(deepcopy(params))
    expression: str = self.mech['expression']
    self.expression_string.setText(expression)
    target: Mapping[int, List[_Coord]] = self.mech['target']
    for p in sorted(target):
        self.target_points.addItem(f"P{p}")
        if target[p]:
            self.path[p] = target[p].copy()
        else:
            self.path[p] = []
    if self.has_target():
        self.target_points.setCurrentRow(0)
    self.target_label.setVisible(self.has_target())
    inputs: List[Tuple[_Pair, List[float]]] = self.mech.get('input', [])
    self.mech['input'] = inputs
    placement: Mapping[int, Optional[_Range]] = self.mech.get('placement',
                                                              {})
    self.mech['placement'] = placement
    # Table settings
    self.parameter_list.setRowCount(0)
    self.parameter_list.setRowCount(len(inputs) + len(placement) + 1)
    row = 0

    def spinbox(
        v: float = 0.,
        *,
        minimum: float = 0.,
        maximum: float = 9999.,
        prefix: bool = False
    ) -&gt; QDoubleSpinBox:
        double_spinbox = QDoubleSpinBox()
        double_spinbox.setMinimum(minimum)
        double_spinbox.setMaximum(maximum)
        double_spinbox.setValue(v)
        if prefix:
            double_spinbox.setPrefix("±")
        return double_spinbox

    def set_angle(index1: int, index2: int) -&gt; Callable[[float], None]:
        """Return a slot function use to set angle value."""

        @others
        return func

    self.parameter_list.setItem(row, 0, QTableWidgetItem("L"))
    self.parameter_list.setItem(row, 1, QTableWidgetItem('link'))
    for i, (s, tag) in enumerate([
        (spinbox(), 'upper'),
        (spinbox(), 'lower'),
    ]):
        s.setValue(self.mech[tag])
        s.valueChanged.connect(set_link(tag))
        self.parameter_list.setCellWidget(row, i + 2, s)
    # Update previews
    self.update_range()
    self.profile_name.setText(profile_name)
    # Default value of algorithm option
    if 'settings' in self.mech:
        self.alg_options.update(self.mech['settings'])
    else:
        self.__set_algorithm_default()
    self.__able_to_generate()

</t>
<t tx="leo.20231205084740.430">class ClearStorageName(QUndoCommand):
    """Clear the storage name"""

    @others
</t>
<t tx="leo.20231205084740.431">def __init__(self, widget: QLineEdit, parent: Optional[QWidget] = None):
    super(ClearStorageName, self).__init__(parent)
    self.name = widget.text() or widget.placeholderText()
    self.widget = widget

</t>
<t tx="leo.20231205084740.432">def redo(self) -&gt; None:
    """Clear name text."""
    self.widget.clear()

</t>
<t tx="leo.20231205084740.433">def undo(self) -&gt; None:
    """Set the name text."""
    self.widget.setText(self.name)


</t>
<t tx="leo.20231205084740.434">class AddInput(QUndoCommand):
    """Add a variable to list widget."""

    @others
</t>
<t tx="leo.20231205084740.435">def __init__(
    self,
    name: str,
    widget: QListWidget,
    parent: Optional[QWidget] = None
):
    super(AddInput, self).__init__(parent)
    self.setText(f"Add variable of {name}")
    self.item = QListWidgetItem(name)
    self.item.setToolTip(name)
    self.widget = widget

</t>
<t tx="leo.20231205084740.436">def redo(self) -&gt; None:
    """Add to widget."""
    self.widget.addItem(self.item)

</t>
<t tx="leo.20231205084740.437">def undo(self) -&gt; None:
    """Take out the item."""
    self.widget.takeItem(self.widget.row(self.item))


</t>
<t tx="leo.20231205084740.438">class DeleteInput(QUndoCommand):
    """Remove the variable item."""

    @others
</t>
<t tx="leo.20231205084740.439">def __init__(
    self,
    row: int,
    widget: QListWidget,
    parent: Optional[QWidget] = None
):
    super(DeleteInput, self).__init__(parent)
    self.setText(f"Remove variable of {{Point{row}}}")
    self.item = widget.item(row)
    self.widget = widget

</t>
<t tx="leo.20231205084740.44">@Slot(float)
def func(value: float) -&gt; None:
    inputs[index1][1][index2] = value

</t>
<t tx="leo.20231205084740.440">def redo(self) -&gt; None:
    """Take out the item."""
    self.widget.takeItem(self.widget.row(self.item))

</t>
<t tx="leo.20231205084740.441">def undo(self) -&gt; None:
    """Add to widget."""
    self.widget.addItem(self.item)
</t>
<t tx="leo.20231205084740.442">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/widgets/
# -*- coding: utf-8 -*-

"""'widgets' module contains the custom widgets
that design without Qt designer.
"""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from .main_base import MainWindowBase, Preferences
from .inputs import QRotatableView
from .undo_redo import (
    AddTable,
    AddPath,
    AddStorage,
    AddStorageName,
    AddInput,
    ClearStorageName,
    DeletePath,
    DeleteStorage,
    DeleteTable,
    DeleteInput,
    EditPointTable,
    EditLinkTable,
    FixSequenceNumber,
)
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.45">return func

# Angles
for i, ((b, d), se) in enumerate(inputs):
self.parameter_list.setItem(row, 0, QTableWidgetItem(f"P{b}-&gt;P{d}"))
self.parameter_list.setItem(row, 1, QTableWidgetItem('input'))
s1 = spinbox(se[0], maximum=360.)
s2 = spinbox(se[1], maximum=360.)
self.parameter_list.setCellWidget(row, 2, s1)
self.parameter_list.setCellWidget(row, 3, s2)
s1.valueChanged.connect(set_angle(i, 0))
s2.valueChanged.connect(set_angle(i, 1))
row += 1
# Grounded joints
self.preview_canvas.from_profile(self.mech)
pos_list = parse_pos(expression)
for node, ref in sorted(self.preview_canvas.same.items()):
pos_list.insert(node, pos_list[ref])
for p in sorted(placement):
coord = placement[p]
self.parameter_list.setItem(row, 0, QTableWidgetItem(f"P{p}"))
self.parameter_list.setItem(row, 1, QTableWidgetItem('placement'))
x, y = self.preview_canvas.pos[p]
for i, s in enumerate([
    spinbox(coord[0] if coord else x, minimum=-9999.),
    spinbox(coord[1] if coord else y, minimum=-9999.),
    spinbox(coord[2] if coord else 5., prefix=True),
]):
    s.valueChanged.connect(self.update_range)
    self.parameter_list.setCellWidget(row, i + 2, s)
row += 1
# Default value of upper and lower
self.mech['upper'] = self.mech.get('upper', 100)
self.mech['lower'] = self.mech.get('lower', 0)

def set_link(opt: str) -&gt; Callable[[float], None]:
"""Set link length."""

</t>
<t tx="leo.20231205084740.46">@Slot(float)
def func(value: float) -&gt; None:
    self.mech[opt] = value

</t>
<t tx="leo.20231205084740.47">@Slot(name='on_result_load_settings_clicked')
def __load_result_settings(self) -&gt; None:
    """Load settings from a result."""
    self.__has_result()
    row = self.result_list.currentRow()
    if not row &gt; -1:
        return
    self.__clear_settings()
    result = self.mechanism_data[row]
    for option, button in self.algorithm_options.items():
        if result.get('algorithm', "") == option.value:
            button.setChecked(True)
            break
    else:
        raise ValueError("no option")
    # Copy to mechanism params
    self.__set_profile("External setting", result)
    self.__set_time(result.get('time', 0))
    # Load settings
    self.alg_options.clear()
    self.alg_options.update(result.get('settings', {}))
    self.shape_only_option.setChecked(result.get('shape_only', False))

</t>
<t tx="leo.20231205084740.48">@Slot()
def __set_algorithm_default(self) -&gt; None:
    """Set the algorithm settings to default."""
    self.alg_options.clear()
    for opt, button in self.algorithm_options.items():
        if button.isChecked():
            self.alg_options.update(default(opt))

</t>
<t tx="leo.20231205084740.49">@Slot(name='on_advance_btn_clicked')
def __show_advance(self) -&gt; None:
    """Get the settings from advance dialog."""
    for option, button in self.algorithm_options.items():
        if button.isChecked():
            algorithm = option
            break
    else:
        raise ValueError("no option")
    dlg = AlgorithmOptionDialog(algorithm, self.alg_options, self)
    dlg.show()
    if not dlg.exec_():
        dlg.deleteLater()
        return
    self.alg_options['report'] = dlg.report.value()
    self.alg_options.pop('max_gen', None)
    self.alg_options.pop('min_fit', None)
    self.alg_options.pop('max_time', None)
    if dlg.max_gen_option.isChecked():
        self.alg_options['max_gen'] = dlg.max_gen.value()
    elif dlg.min_fit_option.isChecked():
        self.alg_options['min_fit'] = dlg.min_fit.value()
    elif dlg.max_time_option.isChecked():
        # Three spinbox value translate to second
        self.alg_options['max_time'] = (
            dlg.max_time_h.value() * 3600
            + dlg.max_time_m.value() * 60
            + dlg.max_time_s.value()
        )
    else:
        raise ValueError("invalid option")
    self.alg_options['pop_num'] = dlg.pop_size.value()
    for row in range(dlg.alg_table.rowCount()):
        option = dlg.alg_table.item(row, 0).text()
        self.alg_options[option] = dlg.alg_table.cellWidget(row, 1).value()
    dlg.deleteLater()

</t>
<t tx="leo.20231205084740.5">class Optimizer(QWidget, Ui_Form):
    """Dimensional synthesis widget.

    User can run the dimensional synthesis here.
    """
    mech: Dict[str, Any]
    path: Dict[int, List[_Coord]]
    mechanism_data: List[Dict[str, Any]]
    alg_options: Dict[str, Union[int, float]]
    algorithm_options: Dict[AlgorithmType, QRadioButton]

    @others
</t>
<t tx="leo.20231205084740.50">@Slot()
def update_range(self) -&gt; None:
    """Update range values to main canvas."""

    def t(row: int, col: int) -&gt; Union[str, float]:
        item = self.parameter_list.item(row, col)
        if item is None:
            w: QDoubleSpinBox = self.parameter_list.cellWidget(row, col)
            return w.value()
        else:
            return item.text()

    self.update_ranges({
        cast(str, t(row, 0)): (
            cast(float, t(row, 2)),
            cast(float, t(row, 3)),
            cast(float, t(row, 4)),
        ) for row in range(self.parameter_list.rowCount())
        if t(row, 1) == 'placement'
    })

</t>
<t tx="leo.20231205084740.51">@Slot(name='on_expr_copy_clicked')
def __copy_expr(self) -&gt; None:
    """Copy profile expression."""
    text = self.expression_string.text()
    if text:
        QApplication.clipboard().setText(text)
</t>
<t tx="leo.20231205084740.52"></t>
<t tx="leo.20231205084740.53">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/dimensional_synthesis/dialogs/
# -*- coding: utf-8 -*-

"""The chart dialog of dimensional synthesis result."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Sequence, Mapping, Any
from numpy import array
from qtpy.QtCore import Qt, QSize
from qtpy.QtWidgets import QDialog, QVBoxLayout, QTabWidget, QWidget
from pyslvs_ui.graphics import DataChart


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.54">class ChartDialog(QDialog):
    """There are three charts in the dialog.

    + Fitness / Generation Chart.
    + Generation / Time Chart.
    + Fitness / Time Chart.
    """

    @others
</t>
<t tx="leo.20231205084740.55">def __init__(
    self,
    title: str,
    algorithm_data: Sequence[Mapping[str, Any]],
    parent: QWidget
):
    """Add three tabs of chart."""
    super(ChartDialog, self).__init__(parent)
    self.setWindowTitle("Fitness-Generation-Time Charts")
    self.setWindowFlags(self.windowFlags() | Qt.WindowMaximizeButtonHint)
    self.setSizeGripEnabled(True)
    self.setModal(True)
    self.setMinimumSize(QSize(800, 600))
    self.title = title
    self.algorithm_data = algorithm_data
    # Widgets
    main_layout = QVBoxLayout(self)
    main_layout.setContentsMargins(6, 6, 6, 6)
    self.tab_widget = QTabWidget(self)
    self.__set_chart("F-G Plot", 0, 1, 'Generation', 'Fitness')
    self.__set_chart("G-T Plot", 2, 0, 'Time', 'Generation')
    self.__set_chart("F-T Plot", 2, 1, 'Time', 'Fitness')
    main_layout.addWidget(self.tab_widget)

</t>
<t tx="leo.20231205084740.56">def __set_chart(self, name: str, x_i: int, y_i: int,
                x_l: str, y_l: str) -&gt; None:
    """Setting charts by data index.

    pos_x / pos_y: [0], [1], [2]
    time_fitness: List[List[Tuple[gen, fitness, time]]]
    """
    chart = DataChart(self)
    ax = chart.ax()
    for i, data in enumerate(self.algorithm_data):
        a = array(data['time_fitness'], dtype=float)
        ax[0].plot(a[:, x_i], a[:, y_i], 'bs-', label=f"Task {i + 1}")
        ax[0].set_xlabel(x_l)
        ax[0].set_ylabel(y_l)
        ax[0].legend()
    self.tab_widget.addTab(chart, name)
</t>
<t tx="leo.20231205084740.57">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/dimensional_synthesis/dialogs/
# -*- coding: utf-8 -*-

"""The option dialog use to adjust target path."""

from __future__ import annotations

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import TYPE_CHECKING
from math import cos, sin, atan2, radians, hypot
from numpy import ndarray, array, linspace, concatenate, full_like
from qtpy.QtCore import Slot, Qt
from qtpy.QtWidgets import QDialog
from pyslvs import efd_fitting
from pyslvs_ui.graphics import DataChartDialog
from pyslvs_ui.info import HAS_SCIPY
from .edit_path_ui import Ui_Dialog

if TYPE_CHECKING:
    from pyslvs_ui.synthesis import Optimizer
if HAS_SCIPY:
    from scipy.interpolate import splprep, splev


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.58">class EditPathDialog(QDialog, Ui_Dialog):
    """Option dialog.

    Only edit the target path after closed.
    """

    @others
</t>
<t tx="leo.20231205084740.59">def __init__(self, parent: Optimizer):
    """Just load in path data."""
    super(EditPathDialog, self).__init__(parent)
    self.setupUi(self)
    self.setWindowFlags(self.windowFlags()
                        &amp; ~Qt.WindowContextHelpButtonHint)
    # Get the current path from parent widget
    self.path = array(parent.current_path(), dtype=float)
    self.set_path = parent.set_path
    # GUI settings
    self.bspline_option.setEnabled(HAS_SCIPY)
    self.efd_option.clicked.connect(self.close_path_option.setChecked)
    self.efd_option.toggled.connect(self.close_path_option.setDisabled)
    self.num_points.setValue(len(self.path))

</t>
<t tx="leo.20231205084740.6">def __init__(self, parent: MainWindowBase):
    """Reference names:

    + Iteration collections.
    + Result data.
    + Main window function references.
    """
    super(Optimizer, self).__init__(parent)
    self.setupUi(self)
    self.mech = {}
    self.path = {}
    # Some reference of 'collections'
    self.collections = parent.collections.configure_widget.collections
    self.get_collection = parent.get_configure
    self.input_from = parent.input_from
    self.output_to = parent.output_to
    self.save_reply_box = parent.save_reply_box
    self.project_no_save = parent.project_no_save
    self.merge_result = parent.merge_result
    self.update_ranges = parent.main_canvas.update_ranges
    self.set_solving_path = parent.main_canvas.set_solving_path
    self.get_zoom = parent.main_canvas.get_zoom
    self.prefer = parent.prefer
    # Data and functions
    self.mechanism_data = []
    self.alg_options = default(AlgorithmType.DE)
    # Canvas
    self.preview_canvas = PreviewCanvas(self)
    self.preview_layout.addWidget(self.preview_canvas)
    # Splitter
    self.main_splitter.setStretchFactor(0, 10)
    self.main_splitter.setStretchFactor(1, 100)
    self.canvas_splitter.setSizes([80, 100])
    self.down_splitter.setSizes([20, 80])
    # Table widget column width
    header = self.parameter_list.horizontalHeader()
    header.setSectionResizeMode(QHeaderView.ResizeToContents)
    self.algorithm_options = {}
    for opt in AlgorithmType:
        button = QRadioButton(opt.value, self)
        button.clicked.connect(self.__set_algorithm_default)
        self.algorithm_options[opt] = button
        self.algorithm_layout.addWidget(button)
    self.clear()

</t>
<t tx="leo.20231205084740.60">def __gen_fitting(self) -&gt; ndarray:
    """Generate the fitted curve."""
    num = self.num_points.value()
    is_close = self.close_path_option.isChecked()
    if is_close:
        num += 1
    if self.bspline_option.isChecked():
        if is_close:
            path = concatenate((self.path, self.path[:1, :]))
        else:
            path = self.path
        tck = splprep((path[:, 0], path[:, 1]), per=is_close)
        path = array(splev(linspace(0, 1, num, endpoint=True), tck[0])).T
    else:
        path = efd_fitting(self.path, num)
    if is_close:
        path = path[:-1]
    return path

</t>
<t tx="leo.20231205084740.61">@Slot(name='on_fitting_preview_btn_clicked')
def __fitting_preview(self) -&gt; None:
    """Curve fitting preview."""
    dlg = DataChartDialog(self, "Preview")
    ax = dlg.ax()[0]
    ax.plot(self.path[:, 0], self.path[:, 1], 'ro')
    path = self.__gen_fitting()
    ax.plot(path[:, 0], path[:, 1], 'b--')
    dlg.set_margin(0.2)
    dlg.show()
    dlg.exec()
    dlg.deleteLater()

</t>
<t tx="leo.20231205084740.62">@Slot(name='on_fitting_btn_clicked')
def __fitting(self) -&gt; None:
    """Curve fitting function."""
    path = self.__gen_fitting()
    self.set_path(path)
    self.accept()

</t>
<t tx="leo.20231205084740.63">@Slot(name='on_move_btn_clicked')
def __move(self) -&gt; None:
    """Translate function."""
    mx = self.move_x.value()
    my = self.move_y.value()
    offset = full_like(self.path, mx)
    offset[:, 1] = my
    self.set_path(self.path + offset)
    self.accept()

</t>
<t tx="leo.20231205084740.64">@Slot(name='on_rotate_btn_clicked')
def __rotate(self) -&gt; None:
    """Rotate by origin."""
    angle = radians(self.rotate_angle.value())
    path = []
    for x, y in self.path:
        h = hypot(x, y)
        a = atan2(y, x) + angle
        path.append((h * cos(a), h * sin(a)))
    self.set_path(path)
    self.accept()

</t>
<t tx="leo.20231205084740.65">@Slot(name='on_scale_btn_clicked')
def __scale(self) -&gt; None:
    """Scale function."""
    ox = self.scale_rx.value()
    oy = self.scale_ry.value()
    rx = self.scale_rx.value()
    ry = self.scale_ry.value()
    sh = self.scale_h.value()
    sv = self.scale_v.value()
    self.set_path((ox + (x - rx) * sh, oy + (y - ry) * sv)
                  for x, y in self.path)
    self.accept()
</t>
<t tx="leo.20231205084740.66">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/dimensional_synthesis/dialogs/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'edit_path.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.67">class Ui_Dialog(object):
    @others
</t>
<t tx="leo.20231205084740.68">def setupUi(self, Dialog):
    Dialog.setObjectName("Dialog")
    Dialog.resize(385, 251)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:formula.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Dialog.setWindowIcon(icon)
    Dialog.setSizeGripEnabled(True)
    Dialog.setModal(True)
    self.verticalLayout = QtWidgets.QVBoxLayout(Dialog)
    self.verticalLayout.setObjectName("verticalLayout")
    self.tabWidget = QtWidgets.QTabWidget(Dialog)
    self.tabWidget.setObjectName("tabWidget")
    self.fitting = QtWidgets.QWidget()
    self.fitting.setObjectName("fitting")
    self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.fitting)
    self.verticalLayout_6.setObjectName("verticalLayout_6")
    self.gridLayout_3 = QtWidgets.QGridLayout()
    self.gridLayout_3.setObjectName("gridLayout_3")
    self.num_points_label = QtWidgets.QLabel(self.fitting)
    self.num_points_label.setObjectName("num_points_label")
    self.gridLayout_3.addWidget(self.num_points_label, 1, 0, 1, 1)
    spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.gridLayout_3.addItem(spacerItem, 0, 3, 1, 1)
    self.verticalLayout_4 = QtWidgets.QVBoxLayout()
    self.verticalLayout_4.setObjectName("verticalLayout_4")
    self.efd_option = QtWidgets.QRadioButton(self.fitting)
    self.efd_option.setChecked(True)
    self.efd_option.setObjectName("efd_option")
    self.verticalLayout_4.addWidget(self.efd_option)
    self.bspline_option = QtWidgets.QRadioButton(self.fitting)
    self.bspline_option.setObjectName("bspline_option")
    self.verticalLayout_4.addWidget(self.bspline_option)
    self.gridLayout_3.addLayout(self.verticalLayout_4, 0, 1, 1, 1)
    self.fitting_method_label = QtWidgets.QLabel(self.fitting)
    self.fitting_method_label.setObjectName("fitting_method_label")
    self.gridLayout_3.addWidget(self.fitting_method_label, 0, 0, 1, 1)
    self.num_points = QtWidgets.QSpinBox(self.fitting)
    self.num_points.setMinimum(3)
    self.num_points.setMaximum(9999)
    self.num_points.setObjectName("num_points")
    self.gridLayout_3.addWidget(self.num_points, 1, 1, 1, 1)
    spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.gridLayout_3.addItem(spacerItem1, 1, 3, 1, 1)
    self.close_path_option = QtWidgets.QCheckBox(self.fitting)
    self.close_path_option.setEnabled(False)
    self.close_path_option.setChecked(True)
    self.close_path_option.setObjectName("close_path_option")
    self.gridLayout_3.addWidget(self.close_path_option, 0, 2, 1, 1)
    self.verticalLayout_6.addLayout(self.gridLayout_3)
    self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_6.setObjectName("horizontalLayout_6")
    spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_6.addItem(spacerItem2)
    self.fitting_preview_btn = QtWidgets.QPushButton(self.fitting)
    self.fitting_preview_btn.setObjectName("fitting_preview_btn")
    self.horizontalLayout_6.addWidget(self.fitting_preview_btn)
    spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_6.addItem(spacerItem3)
    self.verticalLayout_6.addLayout(self.horizontalLayout_6)
    spacerItem4 = QtWidgets.QSpacerItem(20, 171, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_6.addItem(spacerItem4)
    self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_5.setObjectName("horizontalLayout_5")
    spacerItem5 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_5.addItem(spacerItem5)
    self.fitting_btn = QtWidgets.QPushButton(self.fitting)
    icon1 = QtGui.QIcon()
    icon1.addPixmap(QtGui.QPixmap("icons:fitting.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.fitting_btn.setIcon(icon1)
    self.fitting_btn.setObjectName("fitting_btn")
    self.horizontalLayout_5.addWidget(self.fitting_btn)
    spacerItem6 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_5.addItem(spacerItem6)
    self.verticalLayout_6.addLayout(self.horizontalLayout_5)
    self.tabWidget.addTab(self.fitting, icon1, "")
    self.move_tab = QtWidgets.QWidget()
    self.move_tab.setObjectName("move_tab")
    self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.move_tab)
    self.verticalLayout_2.setContentsMargins(6, 6, 6, 6)
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.gridLayout = QtWidgets.QGridLayout()
    self.gridLayout.setObjectName("gridLayout")
    self.move_x_label = QtWidgets.QLabel(self.move_tab)
    self.move_x_label.setObjectName("move_x_label")
    self.gridLayout.addWidget(self.move_x_label, 0, 0, 1, 1)
    spacerItem7 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.gridLayout.addItem(spacerItem7, 0, 2, 1, 1)
    self.move_y_label = QtWidgets.QLabel(self.move_tab)
    self.move_y_label.setObjectName("move_y_label")
    self.gridLayout.addWidget(self.move_y_label, 1, 0, 1, 1)
    self.move_y = QtWidgets.QDoubleSpinBox(self.move_tab)
    self.move_y.setMinimum(-1000000.0)
    self.move_y.setMaximum(1000000.0)
    self.move_y.setObjectName("move_y")
    self.gridLayout.addWidget(self.move_y, 1, 1, 1, 1)
    spacerItem8 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.gridLayout.addItem(spacerItem8, 1, 2, 1, 1)
    self.move_x = QtWidgets.QDoubleSpinBox(self.move_tab)
    self.move_x.setMinimum(-1000000.0)
    self.move_x.setMaximum(1000000.0)
    self.move_x.setObjectName("move_x")
    self.gridLayout.addWidget(self.move_x, 0, 1, 1, 1)
    self.verticalLayout_2.addLayout(self.gridLayout)
    spacerItem9 = QtWidgets.QSpacerItem(20, 99, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_2.addItem(spacerItem9)
    self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_3.setObjectName("horizontalLayout_3")
    spacerItem10 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_3.addItem(spacerItem10)
    self.move_btn = QtWidgets.QPushButton(self.move_tab)
    icon2 = QtGui.QIcon()
    icon2.addPixmap(QtGui.QPixmap("icons:translate.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.move_btn.setIcon(icon2)
    self.move_btn.setDefault(True)
    self.move_btn.setObjectName("move_btn")
    self.horizontalLayout_3.addWidget(self.move_btn)
    spacerItem11 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_3.addItem(spacerItem11)
    self.verticalLayout_2.addLayout(self.horizontalLayout_3)
    self.tabWidget.addTab(self.move_tab, icon2, "")
    self.rotate_tab = QtWidgets.QWidget()
    self.rotate_tab.setObjectName("rotate_tab")
    self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.rotate_tab)
    self.verticalLayout_5.setObjectName("verticalLayout_5")
    self.gridLayout_5 = QtWidgets.QGridLayout()
    self.gridLayout_5.setObjectName("gridLayout_5")
    self.rotate_angle = QtWidgets.QDoubleSpinBox(self.rotate_tab)
    self.rotate_angle.setMaximum(360.0)
    self.rotate_angle.setObjectName("rotate_angle")
    self.gridLayout_5.addWidget(self.rotate_angle, 0, 1, 1, 1)
    self.rotate_angle_label = QtWidgets.QLabel(self.rotate_tab)
    self.rotate_angle_label.setObjectName("rotate_angle_label")
    self.gridLayout_5.addWidget(self.rotate_angle_label, 0, 0, 1, 1)
    spacerItem12 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.gridLayout_5.addItem(spacerItem12, 0, 2, 1, 1)
    self.verticalLayout_5.addLayout(self.gridLayout_5)
    spacerItem13 = QtWidgets.QSpacerItem(20, 158, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_5.addItem(spacerItem13)
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    spacerItem14 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_2.addItem(spacerItem14)
    self.rotate_btn = QtWidgets.QPushButton(self.rotate_tab)
    icon3 = QtGui.QIcon()
    icon3.addPixmap(QtGui.QPixmap("icons:rotate.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.rotate_btn.setIcon(icon3)
    self.rotate_btn.setObjectName("rotate_btn")
    self.horizontalLayout_2.addWidget(self.rotate_btn)
    spacerItem15 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_2.addItem(spacerItem15)
    self.verticalLayout_5.addLayout(self.horizontalLayout_2)
    self.tabWidget.addTab(self.rotate_tab, icon3, "")
    self.scale_tab = QtWidgets.QWidget()
    self.scale_tab.setObjectName("scale_tab")
    self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.scale_tab)
    self.verticalLayout_3.setContentsMargins(6, 6, 6, 6)
    self.verticalLayout_3.setObjectName("verticalLayout_3")
    self.gridLayout_2 = QtWidgets.QGridLayout()
    self.gridLayout_2.setObjectName("gridLayout_2")
    self.scale_h_label = QtWidgets.QLabel(self.scale_tab)
    self.scale_h_label.setObjectName("scale_h_label")
    self.gridLayout_2.addWidget(self.scale_h_label, 0, 0, 1, 1)
    spacerItem16 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.gridLayout_2.addItem(spacerItem16, 0, 3, 1, 1)
    self.scale_v_label = QtWidgets.QLabel(self.scale_tab)
    self.scale_v_label.setObjectName("scale_v_label")
    self.gridLayout_2.addWidget(self.scale_v_label, 1, 0, 1, 1)
    self.scale_h = QtWidgets.QDoubleSpinBox(self.scale_tab)
    self.scale_h.setMinimum(1.0)
    self.scale_h.setMaximum(10000.0)
    self.scale_h.setObjectName("scale_h")
    self.gridLayout_2.addWidget(self.scale_h, 0, 1, 1, 1)
    self.scale_v = QtWidgets.QDoubleSpinBox(self.scale_tab)
    self.scale_v.setMinimum(1.0)
    self.scale_v.setMaximum(10000.0)
    self.scale_v.setObjectName("scale_v")
    self.gridLayout_2.addWidget(self.scale_v, 1, 1, 1, 1)
    spacerItem17 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.gridLayout_2.addItem(spacerItem17, 1, 3, 1, 1)
    self.scale_r_label = QtWidgets.QLabel(self.scale_tab)
    self.scale_r_label.setObjectName("scale_r_label")
    self.gridLayout_2.addWidget(self.scale_r_label, 2, 0, 1, 1)
    self.scale_rx = QtWidgets.QDoubleSpinBox(self.scale_tab)
    self.scale_rx.setMinimum(-1000000.0)
    self.scale_rx.setMaximum(1000000.0)
    self.scale_rx.setObjectName("scale_rx")
    self.gridLayout_2.addWidget(self.scale_rx, 2, 1, 1, 1)
    self.scale_ry = QtWidgets.QDoubleSpinBox(self.scale_tab)
    self.scale_ry.setMinimum(-1000000.0)
    self.scale_ry.setMaximum(1000000.0)
    self.scale_ry.setObjectName("scale_ry")
    self.gridLayout_2.addWidget(self.scale_ry, 2, 2, 1, 1)
    spacerItem18 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.gridLayout_2.addItem(spacerItem18, 2, 3, 1, 1)
    self.verticalLayout_3.addLayout(self.gridLayout_2)
    spacerItem19 = QtWidgets.QSpacerItem(20, 52, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_3.addItem(spacerItem19)
    self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_4.setObjectName("horizontalLayout_4")
    spacerItem20 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_4.addItem(spacerItem20)
    self.scale_btn = QtWidgets.QPushButton(self.scale_tab)
    icon4 = QtGui.QIcon()
    icon4.addPixmap(QtGui.QPixmap("icons:aim.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.scale_btn.setIcon(icon4)
    self.scale_btn.setDefault(True)
    self.scale_btn.setObjectName("scale_btn")
    self.horizontalLayout_4.addWidget(self.scale_btn)
    spacerItem21 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_4.addItem(spacerItem21)
    self.verticalLayout_3.addLayout(self.horizontalLayout_4)
    self.tabWidget.addTab(self.scale_tab, icon4, "")
    self.verticalLayout.addWidget(self.tabWidget)
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    spacerItem22 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout.addItem(spacerItem22)
    self.btn_box = QtWidgets.QDialogButtonBox(Dialog)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.btn_box.sizePolicy().hasHeightForWidth())
    self.btn_box.setSizePolicy(sizePolicy)
    self.btn_box.setStandardButtons(QtWidgets.QDialogButtonBox.Close)
    self.btn_box.setObjectName("btn_box")
    self.horizontalLayout.addWidget(self.btn_box)
    self.verticalLayout.addLayout(self.horizontalLayout)

    self.retranslateUi(Dialog)
    self.btn_box.rejected.connect(Dialog.reject)
    QtCore.QMetaObject.connectSlotsByName(Dialog)

</t>
<t tx="leo.20231205084740.69">def retranslateUi(self, Dialog):
    _translate = QtCore.QCoreApplication.translate
    Dialog.setWindowTitle(_translate("Dialog", "Path process"))
    self.num_points_label.setText(_translate("Dialog", "Number of points:"))
    self.efd_option.setText(_translate("Dialog", "Elliptical Fourier Descriptor"))
    self.bspline_option.setText(_translate("Dialog", "B-Spline"))
    self.fitting_method_label.setText(_translate("Dialog", "Method:"))
    self.close_path_option.setText(_translate("Dialog", "Is close path"))
    self.fitting_preview_btn.setText(_translate("Dialog", "Preview"))
    self.fitting_btn.setText(_translate("Dialog", "Curve Fitting"))
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.fitting), _translate("Dialog", "Curve Fitting"))
    self.move_x_label.setText(_translate("Dialog", "X coordinate: "))
    self.move_y_label.setText(_translate("Dialog", "Y coordinate: "))
    self.move_btn.setText(_translate("Dialog", "Move"))
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.move_tab), _translate("Dialog", "Move"))
    self.rotate_angle_label.setText(_translate("Dialog", "Angle:"))
    self.rotate_btn.setText(_translate("Dialog", "Rotate"))
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.rotate_tab), _translate("Dialog", "Rotate"))
    self.scale_h_label.setText(_translate("Dialog", "Horizontal: "))
    self.scale_v_label.setText(_translate("Dialog", "Vertical: "))
    self.scale_r_label.setText(_translate("Dialog", "Reference point: "))
    self.scale_btn.setText(_translate("Dialog", "Scale"))
    self.tabWidget.setTabText(self.tabWidget.indexOf(self.scale_tab), _translate("Dialog", "Scale"))
</t>
<t tx="leo.20231205084740.7">def clear(self) -&gt; None:
    """Clear all sub-widgets."""
    self.mechanism_data.clear()
    self.result_list.clear()
    self.__clear_settings()
    self.__has_result()

</t>
<t tx="leo.20231205084740.70">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/dimensional_synthesis/dialogs/
# -*- coding: utf-8 -*-

"""The option dialog use to adjust the setting of algorithm."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import cast, Mapping, Union
from qtpy.QtCore import Slot, Qt
from qtpy.QtWidgets import (
    QDialog,
    QTableWidgetItem,
    QDoubleSpinBox,
    QSpinBox,
    QWidget,
)
from pyslvs.metaheuristics import default, AlgorithmType
from .options_ui import Ui_Dialog

_Value = Union[int, float]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.71">class AlgorithmOptionDialog(QDialog, Ui_Dialog):
    """Option dialog.

    Only edit the settings after closed.
    """

    @others
</t>
<t tx="leo.20231205084740.72">def __init__(
    self,
    opt: AlgorithmType,
    settings: Mapping[str, _Value],
    parent: QWidget
):
    """Load the settings to user interface."""
    super(AlgorithmOptionDialog, self).__init__(parent)
    self.setupUi(self)
    self.setWindowFlags(self.windowFlags()
                        &amp; ~Qt.WindowContextHelpButtonHint)
    self.setWindowTitle(f"{opt.value} Options")
    self.opt = opt
    self.dft = {tag: value for tag, value in default(self.opt).items()
                if tag not in {'pop_num', 'report', 'max_gen', 'min_fit',
                               'max_time', 'slow_down'}}
    self.__init_alg_table()
    self.alg_table.setColumnWidth(0, 200)
    self.alg_table.setColumnWidth(1, 90)
    self.__set_args(settings)

</t>
<t tx="leo.20231205084740.73">def __init_alg_table(self) -&gt; None:
    """Initialize the algorithm table widgets."""
    self.alg_table.setRowCount(len(self.dft))
    for i, (tag, value) in enumerate(self.dft.items()):
        self.alg_table.setItem(i, 0, QTableWidgetItem(tag))
        if isinstance(value, int):
            w = QSpinBox()
            w.setMaximum(1e5)
        else:
            w = QDoubleSpinBox()
        w.setValue(value)
        self.alg_table.setCellWidget(i, 1, w)

</t>
<t tx="leo.20231205084740.74">def __set_args(self, settings: Mapping[str, _Value]) -&gt; None:
    """Set arguments by settings dict."""
    if 'max_gen' in settings:
        self.max_gen.setValue(settings['max_gen'])
    elif 'min_fit' in settings:
        self.min_fit_option.setChecked(True)
        self.min_fit.setValue(settings['min_fit'])
    elif 'max_time' in settings:
        self.max_time_option.setChecked(True)
        # In second (int)
        max_time = cast(int, settings['max_time'])
        self.max_time_h.setValue(max_time // 3600)
        self.max_time_m.setValue((max_time % 3600) // 60)
        self.max_time_s.setValue(max_time % 3600 % 60)
    self.pop_size.setValue(settings['pop_num'])
    self.report.setValue(settings['report'])
    for i, tag in enumerate(self.dft):
        self.alg_table.cellWidget(i, 1).setValue(settings.get(tag, self.dft[tag]))

</t>
<t tx="leo.20231205084740.75">@Slot(name='on_reset_btn_clicked')
def __reset(self) -&gt; None:
    """Reset the settings to default."""
    self.__set_args(default(self.opt))
</t>
<t tx="leo.20231205084740.76">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/dimensional_synthesis/dialogs/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'options.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.77">class Ui_Dialog(object):
    @others
</t>
<t tx="leo.20231205084740.78">def setupUi(self, Dialog):
    Dialog.setObjectName("Dialog")
    Dialog.resize(461, 559)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:synthesis.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Dialog.setWindowIcon(icon)
    Dialog.setSizeGripEnabled(True)
    Dialog.setModal(True)
    self.verticalLayout = QtWidgets.QVBoxLayout(Dialog)
    self.verticalLayout.setObjectName("verticalLayout")
    self.formLayout = QtWidgets.QFormLayout()
    self.formLayout.setObjectName("formLayout")
    self.max_gen_option = QtWidgets.QRadioButton(Dialog)
    self.max_gen_option.setChecked(True)
    self.max_gen_option.setObjectName("max_gen_option")
    self.formLayout.setWidget(2, QtWidgets.QFormLayout.LabelRole, self.max_gen_option)
    self.max_gen = QtWidgets.QSpinBox(Dialog)
    self.max_gen.setMinimum(0)
    self.max_gen.setMaximum(5000)
    self.max_gen.setSingleStep(100)
    self.max_gen.setProperty("value", 1000)
    self.max_gen.setObjectName("max_gen")
    self.formLayout.setWidget(2, QtWidgets.QFormLayout.FieldRole, self.max_gen)
    self.min_fit_option = QtWidgets.QRadioButton(Dialog)
    self.min_fit_option.setObjectName("min_fit_option")
    self.formLayout.setWidget(3, QtWidgets.QFormLayout.LabelRole, self.min_fit_option)
    self.min_fit = QtWidgets.QDoubleSpinBox(Dialog)
    self.min_fit.setEnabled(False)
    self.min_fit.setMaximum(2000.0)
    self.min_fit.setProperty("value", 25.0)
    self.min_fit.setObjectName("min_fit")
    self.formLayout.setWidget(3, QtWidgets.QFormLayout.FieldRole, self.min_fit)
    self.report_label = QtWidgets.QLabel(Dialog)
    self.report_label.setObjectName("report_label")
    self.formLayout.setWidget(5, QtWidgets.QFormLayout.LabelRole, self.report_label)
    self.report = QtWidgets.QSpinBox(Dialog)
    self.report.setProperty("value", 10)
    self.report.setObjectName("report")
    self.formLayout.setWidget(5, QtWidgets.QFormLayout.FieldRole, self.report)
    self.max_time_option = QtWidgets.QRadioButton(Dialog)
    self.max_time_option.setObjectName("max_time_option")
    self.formLayout.setWidget(4, QtWidgets.QFormLayout.LabelRole, self.max_time_option)
    self.max_time = QtWidgets.QWidget(Dialog)
    self.max_time.setEnabled(False)
    self.max_time.setObjectName("max_time")
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.max_time)
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    self.max_time_h = QtWidgets.QSpinBox(self.max_time)
    self.max_time_h.setObjectName("max_time_h")
    self.horizontalLayout_2.addWidget(self.max_time_h)
    self.label_2 = QtWidgets.QLabel(self.max_time)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.label_2.sizePolicy().hasHeightForWidth())
    self.label_2.setSizePolicy(sizePolicy)
    self.label_2.setObjectName("label_2")
    self.horizontalLayout_2.addWidget(self.label_2)
    self.max_time_m = QtWidgets.QSpinBox(self.max_time)
    self.max_time_m.setMaximum(59)
    self.max_time_m.setProperty("value", 15)
    self.max_time_m.setObjectName("max_time_m")
    self.horizontalLayout_2.addWidget(self.max_time_m)
    self.label_3 = QtWidgets.QLabel(self.max_time)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.label_3.sizePolicy().hasHeightForWidth())
    self.label_3.setSizePolicy(sizePolicy)
    self.label_3.setObjectName("label_3")
    self.horizontalLayout_2.addWidget(self.label_3)
    self.max_time_s = QtWidgets.QSpinBox(self.max_time)
    self.max_time_s.setMaximum(59)
    self.max_time_s.setSingleStep(10)
    self.max_time_s.setObjectName("max_time_s")
    self.horizontalLayout_2.addWidget(self.max_time_s)
    self.formLayout.setWidget(4, QtWidgets.QFormLayout.FieldRole, self.max_time)
    self.label = QtWidgets.QLabel(Dialog)
    self.label.setObjectName("label")
    self.formLayout.setWidget(1, QtWidgets.QFormLayout.LabelRole, self.label)
    self.pop_size = QtWidgets.QSpinBox(Dialog)
    self.pop_size.setMinimum(10)
    self.pop_size.setMaximum(10000)
    self.pop_size.setSingleStep(10)
    self.pop_size.setObjectName("pop_size")
    self.formLayout.setWidget(1, QtWidgets.QFormLayout.FieldRole, self.pop_size)
    self.verticalLayout.addLayout(self.formLayout)
    self.splitter = QtWidgets.QSplitter(Dialog)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Expanding)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.splitter.sizePolicy().hasHeightForWidth())
    self.splitter.setSizePolicy(sizePolicy)
    self.splitter.setOrientation(QtCore.Qt.Horizontal)
    self.splitter.setObjectName("splitter")
    self.alg_table = QtWidgets.QTableWidget(self.splitter)
    self.alg_table.setObjectName("alg_table")
    self.alg_table.setColumnCount(2)
    self.alg_table.setRowCount(0)
    item = QtWidgets.QTableWidgetItem()
    self.alg_table.setHorizontalHeaderItem(0, item)
    item = QtWidgets.QTableWidgetItem()
    self.alg_table.setHorizontalHeaderItem(1, item)
    self.alg_table.horizontalHeader().setDefaultSectionSize(150)
    self.alg_table.horizontalHeader().setMinimumSectionSize(150)
    self.verticalLayout.addWidget(self.splitter)
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.reset_btn = QtWidgets.QPushButton(Dialog)
    self.reset_btn.setObjectName("reset_btn")
    self.horizontalLayout.addWidget(self.reset_btn)
    spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout.addItem(spacerItem)
    self.btn_box = QtWidgets.QDialogButtonBox(Dialog)
    self.btn_box.setOrientation(QtCore.Qt.Horizontal)
    self.btn_box.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok)
    self.btn_box.setObjectName("btn_box")
    self.horizontalLayout.addWidget(self.btn_box)
    self.verticalLayout.addLayout(self.horizontalLayout)

    self.retranslateUi(Dialog)
    self.btn_box.accepted.connect(Dialog.accept)
    self.btn_box.rejected.connect(Dialog.reject)
    self.max_gen_option.toggled['bool'].connect(self.max_gen.setEnabled)
    self.min_fit_option.toggled['bool'].connect(self.min_fit.setEnabled)
    self.max_time_option.toggled['bool'].connect(self.max_time.setEnabled)
    QtCore.QMetaObject.connectSlotsByName(Dialog)

</t>
<t tx="leo.20231205084740.79">def retranslateUi(self, Dialog):
    _translate = QtCore.QCoreApplication.translate
    self.max_gen_option.setToolTip(_translate("Dialog", "&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;This parameter determines the generations of evolution.&lt;/p&gt;&lt;p&gt;If the value set to 0, algorithm will stop only when you clicked the interrupt button.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"))
    self.max_gen_option.setText(_translate("Dialog", "Max generation: (?)"))
    self.min_fit_option.setToolTip(_translate("Dialog", "&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;This parameter determines the last fitness of evolution.&lt;/p&gt;&lt;p&gt;If the value set to 0, algorithm will stop only when you clicked the interrupt button.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"))
    self.min_fit_option.setText(_translate("Dialog", "Minimum fitness: (?)"))
    self.report_label.setToolTip(_translate("Dialog", "&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;If the value set to 0, algorithm will report in every 10 generations.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"))
    self.report_label.setText(_translate("Dialog", "Report in every: (?)"))
    self.max_time_option.setToolTip(_translate("Dialog", "&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;This parameter determines the times of evolution.&lt;/p&gt;&lt;p&gt;If the value set to 0, algorithm will stop only when you clicked the interrupt button.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"))
    self.max_time_option.setText(_translate("Dialog", "Max time: (?)"))
    self.label_2.setText(_translate("Dialog", ":"))
    self.label_3.setText(_translate("Dialog", ":"))
    self.label.setToolTip(_translate("Dialog", "&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;The greater the number will make possibilities more available, but will result in longer selection times.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"))
    self.label.setText(_translate("Dialog", "Initial population: (?)"))
    item = self.alg_table.horizontalHeaderItem(0)
    item.setText(_translate("Dialog", "Parameter"))
    item = self.alg_table.horizontalHeaderItem(1)
    item.setText(_translate("Dialog", "Value"))
    self.reset_btn.setText(_translate("Dialog", "Reset to Default"))
</t>
<t tx="leo.20231205084740.8">def __clear_settings(self) -&gt; None:
    """Clear sub-widgets that contain the setting."""
    self.clear_path(ask=False)
    self.path.clear()
    self.mech.clear()
    self.preview_canvas.clear()
    self.profile_name.clear()
    self.algorithm_options[AlgorithmType.DE].setChecked(True)
    self.__set_algorithm_default()
    self.parameter_list.setRowCount(0)
    self.target_points.clear()
    self.target_label.setVisible(self.has_target())
    self.expression_string.clear()
    self.update_range()
    self.__able_to_generate()

</t>
<t tx="leo.20231205084740.80">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/dimensional_synthesis/dialogs/
# -*- coding: utf-8 -*-

"""The preview dialog of dimensional synthesis result."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from math import isnan
from itertools import chain
from typing import Tuple, List, Dict, Sequence, Any
from numpy import linspace, concatenate
from qtpy.QtCore import Slot, Qt, QTimer, QPointF, QRectF, QSizeF
from qtpy.QtWidgets import QDialog, QWidget
from qtpy.QtGui import QPen, QFont, QPaintEvent
from pyslvs import (
    color_rgb, get_vlinks, VPoint, VLink, parse_vpoints, efd_fitting,
)
from pyslvs.optimization import (
    norm_path, curvature, cross_correlation, path_signature,
)
from pyslvs_ui.graphics import (
    AnimationCanvas, color_qt, LINK_COLOR, DataChartDialog,
)
from .preview_ui import Ui_Dialog

_Coord = Tuple[float, float]
_Range = Tuple[float, float, float]
_TargetPath = Dict[int, Sequence[_Coord]]
_U = 0.1


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.81">class _DynamicCanvas(AnimationCanvas):
    """Custom canvas for preview algorithm result."""
    pos: List[_Coord]

    @others
</t>
<t tx="leo.20231205084740.82">def __init__(
    self,
    mechanism: Dict[str, Any],
    path: Sequence[Sequence[_Coord]],
    vpoints: List[VPoint] = None,
    vlinks: List[VLink] = None,
    parent: QWidget = None
):
    """Input link and path data."""
    super(_DynamicCanvas, self).__init__(parent)
    self.mechanism = mechanism
    self.vpoints = vpoints or []
    self.vlinks = vlinks or []
    self.no_mechanism = not self.vpoints or not self.vlinks
    use_norm = self.no_mechanism and self.mechanism.get('shape_only', False)
    # Target path
    same: Dict[int, int] = self.mechanism['same']
    target_path: _TargetPath = self.mechanism['target']
    for i, p in target_path.items():
        for j in range(i):
            if j in same:
                i -= 1
        if use_norm:
            self.target_path[i] = [(x, y) for x, y in norm_path(p)]
        else:
            self.target_path[i] = p
    self.path.path = []
    for i, p in enumerate(path):
        if i in self.target_path and use_norm:
            self.path.path.append([(x, y)
                                   for x, y in norm_path(efd_fitting(p))])
        else:
            self.path.path.append(p)
    self.__index = 0
    self.__interval = 1
    self.__path_count = max(len(path) for path in self.path.path) - 1
    self.pos = []
    # Error
    self.error = False
    self.__no_error = 0
    if self.no_mechanism:
        return
    # Ranges
    ranges: Dict[int, _Range] = self.mechanism['placement']
    self.ranges.update({f"P{i}": QRectF(
        QPointF(values[0] - values[2], values[1] + values[2]),
        QSizeF(values[2] * 2, values[2] * 2)
    ) for i, values in ranges.items()})
    # Timer
    self.__timer = QTimer()
    self.__timer.timeout.connect(self.__change_index)
    self.__timer.start(18)

</t>
<t tx="leo.20231205084740.83">def paintEvent(self, event: QPaintEvent) -&gt; None:
    """Drawing function."""
    super(_DynamicCanvas, self).paintEvent(event)
    # First check
    for path in self.path.path:
        if not path:
            continue
        x, y = path[self.__index]
        if not isnan(x):
            continue
        self.__index, self.__no_error = self.__no_error, self.__index
        self.error = True
        self.__interval = -self.__interval
    # Points that in the current angle section
    self.pos.clear()
    for i in range(len(self.vpoints)):
        if i in self.mechanism['placement']:
            vpoint = self.vpoints[i]
            x = vpoint.c[0, 0]
            y = vpoint.c[0, 1]
            self.pos.append((x, y))
        else:
            x, y = self.path.path[i][self.__index]
            self.pos.append((x, y))
    # Draw links
    for vlink in self.vlinks:
        if vlink.name == VLink.FRAME:
            continue
        self.__draw_link(vlink.name, vlink.points)
    # Draw path
    self.__draw_path()
    # Draw solving path
    self.draw_target_path()
    self.draw_ranges()
    # Draw points
    for i in range(len(self.vpoints)):
        self.__draw_point(i)

    self.painter.end()

    if self.error:
        self.error = False
        self.__index, self.__no_error = self.__no_error, self.__index
    else:
        self.__no_error = self.__index

</t>
<t tx="leo.20231205084740.84">def __draw_point(self, i: int) -&gt; None:
    """Draw point function."""
    k = i
    for j in range(i):
        if j in self.mechanism['same']:
            k += 1
    x, y = self.pos[i]
    color = color_rgb('green')
    fixed = False
    if i in self.target_path:
        color = color_rgb('dark-orange')
    elif k in self.mechanism['placement']:
        color = color_rgb('blue')
        fixed = True
    self.draw_point(i, x, y, fixed, color)

</t>
<t tx="leo.20231205084740.85">def __draw_link(self, name: str, points: Sequence[int]) -&gt; None:
    """Draw link function.

    The link color will be the default color.
    """
    pen = QPen(Qt.black if self.monochrome else color_qt('blue'))
    pen.setWidth(self.link_width)
    self.painter.setPen(pen)
    brush = color_qt('dark-gray') if self.monochrome else LINK_COLOR
    brush.setAlphaF(0.70)
    self.painter.setBrush(brush)
    qpoints = tuple(
        QPointF(self.pos[i][0], -self.pos[i][1]) * self.zoom
        for i in points if self.pos[i] and (not isnan(self.pos[i][0]))
    )
    if len(qpoints) == len(points):
        self.painter.drawPolygon(*qpoints)
    self.painter.setBrush(Qt.NoBrush)
    if self.show_point_mark and name != VLink.FRAME and qpoints:
        pen.setColor(Qt.darkGray)
        self.painter.setPen(pen)
        self.painter.setFont(QFont('Arial', self.font_size))
        cen_x = sum(self.pos[i][0] for i in points if self.pos[i])
        cen_y = sum(self.pos[i][1] for i in points if self.pos[i])
        self.painter.drawText(
            QPointF(cen_x, -cen_y) * self.zoom / len(points),
            f"[{name}]"
        )

</t>
<t tx="leo.20231205084740.86">def __draw_path(self) -&gt; None:
    """Draw a path.

    A simple function than main canvas.
    """
    pen = QPen()
    pen.setWidth(self.path_width)
    for i, path in enumerate(self.path.path):
        if self.no_mechanism and i not in self.target_path:
            continue
        if i in self.target_path:
            if self.monochrome:
                color = color_qt('black')
            else:
                color = color_qt('dark-orange')
        else:
            if self.monochrome:
                color = color_qt('gray')
            else:
                color = color_qt('green')
        pen.setColor(color)
        self.painter.setPen(pen)
        self.draw_curve(path)

</t>
<t tx="leo.20231205084740.87">@Slot()
def __change_index(self) -&gt; None:
    """A slot to change the path index."""
    self.__index += self.__interval
    if self.__index &gt; self.__path_count:
        self.__index = 0
    self.update()

</t>
<t tx="leo.20231205084740.88">def get_target(self) -&gt; _TargetPath:
    """Return target paths."""
    return self.target_path

</t>
<t tx="leo.20231205084740.89">def get_path(self) -&gt; _TargetPath:
    """Return ans path."""
    return {i: self.path.path[i] for i in self.target_path}


</t>
<t tx="leo.20231205084740.9">def has_target(self) -&gt; bool:
    """Return true if the panel is no target settings."""
    return self.target_points.count() &gt; 0

</t>
<t tx="leo.20231205084740.90">class PreviewDialog(QDialog, Ui_Dialog):
    """Preview dialog has some information.

    We will not be able to change result settings here.
    """

    @others
</t>
<t tx="leo.20231205084740.91">def __init__(
    self,
    mechanism: Dict[str, Any],
    path: Sequence[Sequence[_Coord]],
    monochrome: bool,
    parent: QWidget
):
    """Show the information of results, and setup the preview canvas."""
    super(PreviewDialog, self).__init__(parent)
    self.setupUi(self)
    self.setWindowTitle(
        f"Preview: {mechanism['algorithm']} "
        f"(max {mechanism['last_gen']} generations)"
    )
    self.setWindowFlags(self.windowFlags() | Qt.WindowMaximizeButtonHint)
    for splitter in (self.geo_splitter, self.path_cmp_splitter):
        splitter.setSizes([400, 150])
    self.splitter.setSizes([100, 100, 100])
    vpoints = parse_vpoints(mechanism['expression'])
    vlinks = get_vlinks(vpoints)
    self.canvas1 = _DynamicCanvas(mechanism, path, vpoints, vlinks, self)
    self.canvas2 = _DynamicCanvas(mechanism, path, parent=self)
    for c in (self.canvas1, self.canvas2):
        c.update_pos.connect(self.__set_mouse_pos)
        c.set_monochrome_mode(monochrome)
    self.left_layout.insertWidget(0, self.canvas1)
    self.path_cmp_layout.addWidget(self.canvas2)
    self.plot_joint.addItems(f"P{i}" for i in self.canvas2.get_target())
    labels = []
    for tag, data in chain(
        [(tag, mechanism.get(tag, 'N/A')) for tag in (
            'algorithm', 'time', 'shape_only', 'callback')],
        [(f"P{i}", (vpoints[i].c[0, 0], vpoints[i].c[0, 1]))
         for i in mechanism['placement']]
    ):
        if isinstance(data, tuple):
            label = f"({data[0]:.02f}, {data[1]:.02f})"
        elif isinstance(data, float):
            label = f"{data:.02f}"
        else:
            label = f"{data}"
        labels.append(f"{tag}: {label}")
    self.basic_label.setText("\n".join(labels))
    # Algorithm information
    inter = mechanism.get('interrupted', 'N/A')
    if inter == 'False':
        inter_icon = "task_completed.png"
    elif inter == 'N/A':
        inter_icon = "question.png"
    else:
        inter_icon = "interrupted.png"
    if 'last_fitness' in mechanism:
        fitness = f"{mechanism['last_fitness']:.06f}"
    else:
        fitness = 'N/A'
    text_list = [
        f"Max generation: {mechanism.get('last_gen', 'N/A')}",
        f"Fitness: {fitness}",
        f"&lt;img src=\"icons:{inter_icon}\" width=\"15\"/&gt;"
        f"Interrupted at: {inter}"
    ]
    for k, v in mechanism['settings'].items():
        text_list.append(f"{k}: {v}")
    text = "&lt;br/&gt;".join(text_list)
    self.algorithm_label.setText(f"&lt;html&gt;&lt;p&gt;{text}&lt;/p&gt;&lt;/html&gt;")
    # Hardware information
    self.hardware_label.setText("\n".join([
        f"{tag}: {mechanism['hardware_info'][tag]}"
        for tag in ('os', 'cpu')
    ]))

</t>
<t tx="leo.20231205084740.92">@Slot(float, float)
def __set_mouse_pos(self, x: float, y: float) -&gt; None:
    """Set mouse position."""
    self.mouse_pos.setText(f"({x:.04f}, {y:.04f})")

</t>
<t tx="leo.20231205084740.93">@Slot(name='on_cc_plot_btn_clicked')
def __cc_plot(self):
    """Plot cross correlation."""
    p = int(self.plot_joint.currentText().replace('P', ''))
    target = self.canvas2.get_target()
    c1 = curvature(self.canvas2.get_path()[p])
    c2 = curvature(target[p])
    p1 = path_signature(c1)
    p2 = path_signature(c2, 100 - 100 / (len(target[p]) + 1))
    cc = cross_correlation(p1, p2, _U)
    cc_argmax = cc.argmax()
    p2[:, 0] += cc_argmax * _U
    m_p1 = p1.copy()
    m_p1[:, 0] += p1.max()
    p1 = concatenate((p1, m_p1), axis=0)
    del m_p1
    dlg = DataChartDialog(self, "Cross Correlation", 3)
    ax = dlg.ax()
    ax[0].set_title("Curvature")
    ax[0].plot(c1, label=f"Point{p}")
    ax[0].plot(c2, label="Target Path")
    ax[0].legend()
    ax[1].set_title("Path Signature")
    ax[1].plot(p1[:, 0], p1[:, 1], label=f"Point{p}")
    ax[1].plot(p2[:, 0], p2[:, 1], label="Target Path")
    ax[1].plot(cc_argmax * _U, p2[0, 1], 'ro', label="Shift Origin")
    ax[1].legend()
    ax[2].set_title(f"Cross Correlation of Point{p}")
    ax[2].plot(linspace(0, len(cc) * _U, len(cc)), cc)
    ax[2].plot(cc_argmax * _U, cc[cc_argmax], 'ro')
    dlg.set_margin(0.2)
    dlg.show()
    dlg.exec_()
    dlg.deleteLater()
</t>
<t tx="leo.20231205084740.94">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/dimensional_synthesis/dialogs/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'preview.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.95">class Ui_Dialog(object):
    @others
</t>
<t tx="leo.20231205084740.96">def setupUi(self, Dialog):
    Dialog.setObjectName("Dialog")
    Dialog.resize(811, 659)
    Dialog.setSizeGripEnabled(True)
    Dialog.setModal(True)
    self.verticalLayout_2 = QtWidgets.QVBoxLayout(Dialog)
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.information_tab = QtWidgets.QTabWidget(Dialog)
    self.information_tab.setObjectName("information_tab")
    self.geometry_tab = QtWidgets.QWidget()
    self.geometry_tab.setObjectName("geometry_tab")
    self.verticalLayout = QtWidgets.QVBoxLayout(self.geometry_tab)
    self.verticalLayout.setObjectName("verticalLayout")
    self.geo_splitter = QtWidgets.QSplitter(self.geometry_tab)
    self.geo_splitter.setOrientation(QtCore.Qt.Horizontal)
    self.geo_splitter.setObjectName("geo_splitter")
    self.leftWidget = QtWidgets.QWidget(self.geo_splitter)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.leftWidget.sizePolicy().hasHeightForWidth())
    self.leftWidget.setSizePolicy(sizePolicy)
    self.leftWidget.setObjectName("leftWidget")
    self.left_layout = QtWidgets.QHBoxLayout(self.leftWidget)
    self.left_layout.setContentsMargins(0, 0, 0, 0)
    self.left_layout.setObjectName("left_layout")
    self.line = QtWidgets.QFrame(self.leftWidget)
    self.line.setFrameShape(QtWidgets.QFrame.VLine)
    self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line.setObjectName("line")
    self.left_layout.addWidget(self.line)
    self.splitter = QtWidgets.QSplitter(self.geo_splitter)
    self.splitter.setOrientation(QtCore.Qt.Vertical)
    self.splitter.setObjectName("splitter")
    self.basic_groupbox = QtWidgets.QGroupBox(self.splitter)
    self.basic_groupbox.setObjectName("basic_groupbox")
    self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.basic_groupbox)
    self.verticalLayout_4.setContentsMargins(6, 6, 6, 6)
    self.verticalLayout_4.setObjectName("verticalLayout_4")
    self.scrollArea = QtWidgets.QScrollArea(self.basic_groupbox)
    self.scrollArea.setWidgetResizable(True)
    self.scrollArea.setObjectName("scrollArea")
    self.scrollAreaWidgetContents = QtWidgets.QWidget()
    self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 738, 80))
    self.scrollAreaWidgetContents.setObjectName("scrollAreaWidgetContents")
    self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.scrollAreaWidgetContents)
    self.verticalLayout_6.setObjectName("verticalLayout_6")
    self.basic_label = QtWidgets.QLabel(self.scrollAreaWidgetContents)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.basic_label.sizePolicy().hasHeightForWidth())
    self.basic_label.setSizePolicy(sizePolicy)
    self.basic_label.setObjectName("basic_label")
    self.verticalLayout_6.addWidget(self.basic_label)
    spacerItem = QtWidgets.QSpacerItem(20, 47, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_6.addItem(spacerItem)
    self.scrollArea.setWidget(self.scrollAreaWidgetContents)
    self.verticalLayout_4.addWidget(self.scrollArea)
    self.algorithm_groupbox = QtWidgets.QGroupBox(self.splitter)
    self.algorithm_groupbox.setObjectName("algorithm_groupbox")
    self.verticalLayout_7 = QtWidgets.QVBoxLayout(self.algorithm_groupbox)
    self.verticalLayout_7.setContentsMargins(6, 6, 6, 6)
    self.verticalLayout_7.setObjectName("verticalLayout_7")
    self.scrollArea_2 = QtWidgets.QScrollArea(self.algorithm_groupbox)
    self.scrollArea_2.setWidgetResizable(True)
    self.scrollArea_2.setObjectName("scrollArea_2")
    self.scrollAreaWidgetContents_2 = QtWidgets.QWidget()
    self.scrollAreaWidgetContents_2.setGeometry(QtCore.QRect(0, 0, 738, 158))
    self.scrollAreaWidgetContents_2.setObjectName("scrollAreaWidgetContents_2")
    self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.scrollAreaWidgetContents_2)
    self.verticalLayout_5.setObjectName("verticalLayout_5")
    self.algorithm_label = QtWidgets.QLabel(self.scrollAreaWidgetContents_2)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.algorithm_label.sizePolicy().hasHeightForWidth())
    self.algorithm_label.setSizePolicy(sizePolicy)
    self.algorithm_label.setObjectName("algorithm_label")
    self.verticalLayout_5.addWidget(self.algorithm_label)
    spacerItem1 = QtWidgets.QSpacerItem(20, 201, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_5.addItem(spacerItem1)
    self.scrollArea_2.setWidget(self.scrollAreaWidgetContents_2)
    self.verticalLayout_7.addWidget(self.scrollArea_2)
    self.hardware_groupbox = QtWidgets.QGroupBox(self.splitter)
    self.hardware_groupbox.setObjectName("hardware_groupbox")
    self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.hardware_groupbox)
    self.verticalLayout_3.setContentsMargins(6, 6, 6, 6)
    self.verticalLayout_3.setObjectName("verticalLayout_3")
    self.scrollArea_3 = QtWidgets.QScrollArea(self.hardware_groupbox)
    self.scrollArea_3.setWidgetResizable(True)
    self.scrollArea_3.setObjectName("scrollArea_3")
    self.scrollAreaWidgetContents_3 = QtWidgets.QWidget()
    self.scrollAreaWidgetContents_3.setGeometry(QtCore.QRect(0, 0, 738, 158))
    self.scrollAreaWidgetContents_3.setObjectName("scrollAreaWidgetContents_3")
    self.verticalLayout_8 = QtWidgets.QVBoxLayout(self.scrollAreaWidgetContents_3)
    self.verticalLayout_8.setObjectName("verticalLayout_8")
    self.hardware_label = QtWidgets.QLabel(self.scrollAreaWidgetContents_3)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.hardware_label.sizePolicy().hasHeightForWidth())
    self.hardware_label.setSizePolicy(sizePolicy)
    self.hardware_label.setObjectName("hardware_label")
    self.verticalLayout_8.addWidget(self.hardware_label)
    spacerItem2 = QtWidgets.QSpacerItem(20, 201, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_8.addItem(spacerItem2)
    self.scrollArea_3.setWidget(self.scrollAreaWidgetContents_3)
    self.verticalLayout_3.addWidget(self.scrollArea_3)
    self.verticalLayout.addWidget(self.geo_splitter)
    self.information_tab.addTab(self.geometry_tab, "")
    self.path_cmp_tab = QtWidgets.QWidget()
    self.path_cmp_tab.setObjectName("path_cmp_tab")
    self.verticalLayout_10 = QtWidgets.QVBoxLayout(self.path_cmp_tab)
    self.verticalLayout_10.setObjectName("verticalLayout_10")
    self.path_cmp_splitter = QtWidgets.QSplitter(self.path_cmp_tab)
    self.path_cmp_splitter.setOrientation(QtCore.Qt.Horizontal)
    self.path_cmp_splitter.setObjectName("path_cmp_splitter")
    self.verticalLayoutWidget = QtWidgets.QWidget(self.path_cmp_splitter)
    self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")
    self.path_cmp_layout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
    self.path_cmp_layout.setContentsMargins(0, 0, 0, 0)
    self.path_cmp_layout.setObjectName("path_cmp_layout")
    self.verticalLayoutWidget_2 = QtWidgets.QWidget(self.path_cmp_splitter)
    self.verticalLayoutWidget_2.setObjectName("verticalLayoutWidget_2")
    self.verticalLayout_9 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_2)
    self.verticalLayout_9.setContentsMargins(0, 0, 0, 0)
    self.verticalLayout_9.setObjectName("verticalLayout_9")
    self.plot_joint_label = QtWidgets.QLabel(self.verticalLayoutWidget_2)
    self.plot_joint_label.setObjectName("plot_joint_label")
    self.verticalLayout_9.addWidget(self.plot_joint_label)
    self.plot_joint = QtWidgets.QComboBox(self.verticalLayoutWidget_2)
    self.plot_joint.setObjectName("plot_joint")
    self.verticalLayout_9.addWidget(self.plot_joint)
    self.cc_plot_label = QtWidgets.QLabel(self.verticalLayoutWidget_2)
    self.cc_plot_label.setObjectName("cc_plot_label")
    self.verticalLayout_9.addWidget(self.cc_plot_label)
    self.cc_plot_btn = QtWidgets.QPushButton(self.verticalLayoutWidget_2)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:formula.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.cc_plot_btn.setIcon(icon)
    self.cc_plot_btn.setObjectName("cc_plot_btn")
    self.verticalLayout_9.addWidget(self.cc_plot_btn)
    spacerItem3 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_9.addItem(spacerItem3)
    self.verticalLayout_10.addWidget(self.path_cmp_splitter)
    self.information_tab.addTab(self.path_cmp_tab, "")
    self.verticalLayout_2.addWidget(self.information_tab)
    self.horizontalLayout = QtWidgets.QHBoxLayout()
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.mouse_pos_label = QtWidgets.QLabel(Dialog)
    self.mouse_pos_label.setObjectName("mouse_pos_label")
    self.horizontalLayout.addWidget(self.mouse_pos_label)
    self.mouse_pos = QtWidgets.QLabel(Dialog)
    self.mouse_pos.setObjectName("mouse_pos")
    self.horizontalLayout.addWidget(self.mouse_pos)
    spacerItem4 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout.addItem(spacerItem4)
    self.verticalLayout_2.addLayout(self.horizontalLayout)

    self.retranslateUi(Dialog)
    QtCore.QMetaObject.connectSlotsByName(Dialog)

</t>
<t tx="leo.20231205084740.97">def retranslateUi(self, Dialog):
    _translate = QtCore.QCoreApplication.translate
    Dialog.setWindowTitle(_translate("Dialog", "Dialog"))
    self.basic_groupbox.setTitle(_translate("Dialog", "Basic information"))
    self.basic_label.setText(_translate("Dialog", "TextLabel"))
    self.algorithm_groupbox.setTitle(_translate("Dialog", "Algorithm information"))
    self.algorithm_label.setText(_translate("Dialog", "TextLabel"))
    self.hardware_groupbox.setTitle(_translate("Dialog", "Hardware information"))
    self.hardware_label.setText(_translate("Dialog", "TextLabel"))
    self.information_tab.setTabText(self.information_tab.indexOf(self.geometry_tab), _translate("Dialog", "Geometry"))
    self.plot_joint_label.setText(_translate("Dialog", "Joint:"))
    self.cc_plot_label.setText(_translate("Dialog", "Cross correlation:"))
    self.cc_plot_btn.setText(_translate("Dialog", "Plot"))
    self.information_tab.setTabText(self.information_tab.indexOf(self.path_cmp_tab), _translate("Dialog", "Path Comparison"))
    self.mouse_pos_label.setText(_translate("Dialog", "mouse position:"))
</t>
<t tx="leo.20231205084740.98">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/synthesis/dimensional_synthesis/dialogs/
# -*- coding: utf-8 -*-

"""The progress dialog of dimensional synthesis algorithm."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import List, Dict, Any
from qtpy.QtCore import Qt, QTimer, Signal, Slot
from qtpy.QtWidgets import QDialog
from pyslvs.metaheuristics import AlgorithmType
from pyslvs_ui.info import logger
from .progress_ui import Ui_Dialog
from .thread import DimensionalThread


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084740.99">class ProgressDialog(QDialog, Ui_Dialog):
    """Progress dialog.

    + Batch execute function.
    + Interrupt function.
    """
    mechanisms: List[Dict[str, Any]]

    stop_signal = Signal()

    @others
</t>
<t tx="leo.20231205084741.1"></t>
<t tx="leo.20231205084741.10">class AnimateDialog(QDialog):

    @others
</t>
<t tx="leo.20231205084741.100">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/
# -*- coding: utf-8 -*-

"""All collections of Pyslvs."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Tuple, Sequence, Dict, TypedDict, Iterator, Optional
from copy import deepcopy


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.101">class Collection(TypedDict, total=False):
    expression: str
    input: Sequence[Tuple[Tuple[int, int], Sequence[float]]]
    graph: Sequence[Tuple[int, int]]
    placement: Dict[int, Optional[Tuple[float, float, float]]]
    target: Dict[int, Optional[Sequence[Tuple[float, float]]]]
    cus: Dict[int, int]
    same: Dict[int, int]


</t>
<t tx="leo.20231205084741.102">_collection_list: Dict[str, Collection] = {
    "Four bar linkage mechanism": {
        'expression':
            "M["
            "J[R, P[0.0, 0.0], L[ground, L1]],"
            "J[R, P[90.0, 0.0], L[ground, L2]],"
            "J[R, P[12.92, 32.53], L[L1, L3]],"
            "J[R, P[73.28, 67.97], L[L2, L3]],"
            "J[R, P[33.3, 66.95], L[L3]],"
            "]",
        'input': [((0, 2), [0, 360])],
        'graph': ((0, 1), (0, 2), (1, 3), (2, 3)),
        'placement': {0: None, 1: None},
        'target': {4: None},
        'cus': {4: 3},
        'same': {},
    },
    "Six bar linkage mechanism": {
        'expression':
            "M["
            "J[R, P[5.8511, -103.2831], L[ground, L2]],"
            "J[R, P[-71.3292, -109.7644], L[ground, L3]],"
            "J[R, P[77.8903, -110.263], L[ground, L5]],"
            "J[R, P[23.7994, 20.3606], L[L1, L2]],"
            "J[R, P[-33.1974, 90.658], L[L1, L4]],"
            "J[R, P[112.2951, 18.3663], L[L1, L5]],"
            "J[R, P[-117.0519, -18.5671], L[L3, L4]]"
            "]",
        'graph': ((0, 2), (2, 1), (0, 3), (3, 4), (4, 1), (0, 5), (5, 1)),
        'placement': {0: None, 1: None, 2: None},
        'target': {4: None},
        'cus': {},
        'input': [((1, 6), [0, 360])],
        'same': {},
    },
    "Eight bar linkage mechanism": {
        'expression':
            "M["
            "J[R, P[30.5, 10.5], L[ground, L1]],"
            "J[R, P[-14.5, 10.5], L[ground, L4, L5]],"
            "J[R, P[81.5, 60.5], L[L1, L2, L3]],"
            "J[R, P[-31.5, 86.5], L[L2, L4]],"
            "J[R, P[41.5, -38.5], L[L3, L5, L7]],"
            "J[R, P[-85.5, 9.5], L[L4, L6]],"
            "J[R, P[-37.5, -48.5], L[L6, L7]],"
            "J[R, P[35.5, -107.5], L[L7]]"
            "]",
        'input': [((0, 3), [0, 360])],
        'graph': ((0, 1), (0, 4), (0, 5), (1, 2), (1, 3), (2, 4), (3, 5),
                  (3, 7), (4, 6), (6, 7)),
        'placement': {0: None, 1: None},
        'target': {10: None},
        'cus': {10: 7},
        'same': {2: 1, 4: 3, 7: 6},
    },
    "Ball lifter linkage mechanism": {
        'expression':
            "M["
            "J[R, P[36.5, -59.5], L[ground, L1]],"
            "J[R, P[10, -94.12], L[ground, L4]],"
            "J[R, P[-28.5, -93.5], L[ground, L6]],"
            "J[R, P[102.5, -43.5], L[ground, L7]],"
            "J[R, P[77.5, -74.5], L[ground, L9]],"
            "J[R, P[28.82, -22.35], L[L1, L2, L3]],"
            "J[R, P[-18.5, -44.5], L[L2, L4]],"
            "J[R, P[-75.5, -59.5], L[L2, L5]],"
            "J[R, P[56.5, 29.5], L[L3, L7]],"
            "J[R, P[68.5, 71.5], L[L8, L3]],"
            "J[R, P[-47.06, -28.24], L[L5, L6]],"
            "J[R, P[107.5, 42.5], L[L8, L9]],"
            "J[R, P[-109.41, -49.41], L[L5]],"
            "J[R, P[44.12, 107.65], L[L8]]"
            "]",
        'input': [((0, 5), [0, 360])],
        'graph': ((0, 1), (0, 4), (0, 6), (0, 7), (0, 9), (1, 2), (1, 3),
                  (2, 4), (2, 5), (3, 7), (3, 8), (5, 6), (8, 9)),
        'placement': {0: None, 1: None, 2: None, 3: None, 4: None},
        'target': {13: None, 14: None},
        'cus': {13: 5, 14: 8},
        'same': {6: 5},
    },
}


</t>
<t tx="leo.20231205084741.103">def collection_list(key: str) -&gt; Collection:
    """The example data of collections.

    The format of each configuration is:

    + `expression`: Mechanism expression of the structure.
        + type: str
    + `input`: Input pairs.
        + type: Sequence[Tuple[int, int]]
    + `graph`: The generalized chain graph in edge set.
        + type: Sequence[Tuple[int, int]]
    + `placement`: The grounded joints setting. (`x`, `y`, `r`)
        + type: Dict[int, Optional[Tuple[float, float, float]]]
    + `target`: The target joints settings.
        + type: Dict[int, Optional[Sequence[Tuple[float, float]]]]
    + `cus`: The custom joints on specific link. (link number correspond to
        the graph expression.)
        + type: Dict[int, int]
    + `same`: The multiple joints setting.
        + type: Dict[int, int]
    """
    return deepcopy(_collection_list[key])


</t>
<t tx="leo.20231205084741.104">def all_collections() -&gt; Iterator[str]:
    """Get all collection names."""
    yield from sorted(_collection_list)
</t>
<t tx="leo.20231205084741.105">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/
# -*- coding: utf-8 -*-

"""The source code refer from "spatial_efd" module."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Tuple, Sized, Sequence, Union, Optional
from numpy import (
    pi, sqrt, abs, cos, sin, arctan2, array, ndarray, linspace, zeros, ones,
    asarray, diff, concatenate, cumsum,
)

_Path = Union[Sequence[Tuple[float, float]], ndarray]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.106">def efd_fitting(path: _Path, n: int = 0,
                harmonic: Optional[int] = None) -&gt; ndarray:
    """Curve fitting using Elliptical Fourier Descriptor.

    The path `path` will be translated to Fourier descriptor coefficients,
    then regenerate a new path as a `n` x 4 NumPy array.
    """
    contour = asarray(path, dtype=float)
    if n &lt; 3:
        n = len(contour)
    if harmonic is None:
        harmonic = fourier_power(
            calculate_efd(contour, _nyquist(contour)),
            _nyquist(contour)
        )
    coeffs, rot = normalize_efd(calculate_efd(contour, harmonic), norm=False)
    locus_v = locus(contour)
    # New path
    contour = inverse_transform(coeffs, locus_v, n, harmonic)
    return rotate_contour(contour, -rot, locus_v)


</t>
<t tx="leo.20231205084741.107">def normalize_efd(
    coeffs: ndarray,
    norm: bool = True
) -&gt; Tuple[ndarray, float]:
    """
    Normalize the Elliptical Fourier Descriptor coefficients for a polygon.

    Implements Kuhl and Giardina method of normalizing the coefficients
    An, Bn, Cn, Dn. Performs 3 separate normalizations. First, it makes the
    data location invariant by re-scaling the data to a common origin.
    Secondly, the data is rotated with respect to the major axis. Thirdly,
    the coefficients are normalized with regard to the absolute value of A_1.
    This code is adapted from the pyefd module. See the original paper for
    more detail:

    Kuhl, FP and Giardina, CR (1982). Elliptic Fourier features of a closed
    contour. Computer graphics and image procesnp_sing, 18(3), 236-258.

    Args:
        coeffs: A numpy array of shape (n, 4) representing the
            four coefficients for each harmonic computed.
        norm: Set to True (the default) to perform the third
            normalization and false to return the data withot this procesnp_sing
            step. Set this to False when plotting a comparison between the
            input data and the Fourier ellipse.
    Returns:
        A tuple consisting of a numpy.ndarray of shape (harmonics, 4)
        representing the four coefficients for each harmonic computed and
        the rotation in radians applied to the normalized contour.
    """
    # Make the coefficients have a zero phase shift from
    # the first major axis. Theta_1 is that shift angle.
    theta1 = 0.5 * arctan2(
        2 * (coeffs[0, 0] * coeffs[0, 1] + coeffs[0, 2] * coeffs[0, 3]),
        coeffs[0, 0] ** 2 - coeffs[0, 1] ** 2
        + coeffs[0, 2] ** 2 - coeffs[0, 3] ** 2
    )
    coeffs = coeffs.copy()
    # Rotate all coefficients by theta_1
    for n in range(coeffs.shape[0]):
        angle = (n + 1) * theta1
        coeffs[n, :] = (array([
            [coeffs[n, 0], coeffs[n, 1]],
            [coeffs[n, 2], coeffs[n, 3]],
        ]) @ array([
            [cos(angle), -sin(angle)],
            [sin(angle), cos(angle)],
        ])).flat
    # Make the coefficients rotation invariant by rotating so that
    # the semi-major axis is parallel to the x-axis.
    psi1 = arctan2(coeffs[0, 2], coeffs[0, 0])
    psi2 = array([
        [cos(psi1), sin(psi1)],
        [-sin(psi1), cos(psi1)],
    ])
    # Rotate all coefficients by -psi_1.
    for n in range(coeffs.shape[0]):
        coeffs[n, :] = (psi2 @ array([
            [coeffs[n, 0], coeffs[n, 1]],
            [coeffs[n, 2], coeffs[n, 3]],
        ])).flat
    if norm:
        # Obtain size-invariance by normalizing.
        coeffs /= abs(coeffs[0, 0])
    return coeffs, psi1


</t>
<t tx="leo.20231205084741.108">def locus(contour: ndarray) -&gt; Tuple[float, float]:
    """
    Compute the dc coefficients, used as the locus when calling
    inverse_transform().

    This code is adapted from the pyefd module. See the original paper for
    more detail:

    Kuhl, FP and Giardina, CR (1982). Elliptic Fourier features of a closed
    contour. Computer graphics and image procesnp_sing, 18(3), 236-258.

    Args:
        contour: A n x 2 numpy array represents a path.
    Returns:
        A tuple containing the c and d coefficients.
    """
    dxy = diff(contour, axis=0)
    dt = sqrt((dxy ** 2).sum(axis=1))
    t = concatenate((array([0]), cumsum(dt)))
    zt = t[-1]
    xi = cumsum(dxy[:, 0]) - dxy[:, 0] / dt * t[1:]
    c = diff(t ** 2) / (dt * 2)
    a0 = sum(dxy[:, 0] * c + xi * dt) / (zt + 1e-20)
    delta = cumsum(dxy[:, 1]) - dxy[:, 1] / dt * t[1:]
    c0 = sum(dxy[:, 1] * c + delta * dt) / (zt + 1e-20)
    # A0 and CO relate to the first point of the contour array as origin
    # Adding those values to the coefficients to make them relate to true origin
    return contour[0, 0] + a0, contour[0, 1] + c0


</t>
<t tx="leo.20231205084741.109">def calculate_efd(contour: ndarray, harmonic: int = 10) -&gt; ndarray:
    """
    Compute the Elliptical Fourier Descriptors for a polygon.

    Implements Kuhl and Giardina method of computing the coefficients
    An, Bn, Cn, Dn for a specified number of harmonics. This code is adapted
    from the pyefd module. See the original paper for more detail:

    Kuhl, FP and Giardina, CR (1982). Elliptic Fourier features of a closed
    contour. Computer graphics and image processing, 18(3), 236-258.

    Args:
        contour: A n x 2 numpy array represents a path.
        harmonic: The number of harmonics to compute for the given
            shape, defaults to 10.
    Returns:
        A numpy array of shape (harmonics, 4) representing the
        four coefficients for each harmonic computed.
    """
    dxy = diff(contour, axis=0)
    dt = sqrt((dxy ** 2).sum(axis=1))
    t = concatenate((array([0]), cumsum(dt)))
    zt = t[-1]
    phi = (2. * pi * t) / (zt + 1e-20)
    coeffs = zeros((harmonic, 4))
    for n in range(1, harmonic + 1):
        c = zt / (2 * n * n * pi * pi)
        phi_n = phi * n
        cos_phi_n = (cos(phi_n[1:]) - cos(phi_n[:-1])) / dt
        sin_phi_n = (sin(phi_n[1:]) - sin(phi_n[:-1])) / dt
        coeffs[n - 1, :] = (
            c * (dxy[:, 1] * cos_phi_n).sum(),
            c * (dxy[:, 1] * sin_phi_n).sum(),
            c * (dxy[:, 0] * cos_phi_n).sum(),
            c * (dxy[:, 0] * sin_phi_n).sum(),
        )
    return coeffs


</t>
<t tx="leo.20231205084741.11">def __init__(
    self,
    vpoints: Sequence[VPoint],
    vlinks: Sequence[VLink],
    path: _Paths,
    slider_path: _SliderPaths,
    monochrome: bool,
    parent: QWidget
):
    super(AnimateDialog, self).__init__(parent)
    self.setWindowTitle("Vector Animation")
    self.setWindowFlags(self.windowFlags() | Qt.WindowMaximizeButtonHint
                        &amp; ~Qt.WindowContextHelpButtonHint)
    self.setMinimumSize(800, 600)
    self.setModal(True)
    main_layout = QVBoxLayout(self)
    self.canvas = _DynamicCanvas(vpoints, vlinks, path, slider_path, self)
    self.canvas.set_monochrome_mode(monochrome)
    self.canvas.update_pos.connect(self.__set_pos)
    layout = QHBoxLayout(self)
    pt_option = QComboBox(self)
    pt_option.addItems([f"P{p}" for p in range(len(vpoints))])
    layout.addWidget(pt_option)
    value_label = QLabel(self)

    @Slot(int)
    def show_values(ind: int):
        vel, vel_deg = self.canvas.get_vel(ind)
        acc, acc_deg = self.canvas.get_acc(ind)
        value_label.setText(f"Velocity: {vel:.04f} ({vel_deg:.04f}deg) | "
                            f"Acceleration: {acc:.04f} ({acc_deg:.04f}deg)")

    pt_option.currentIndexChanged.connect(show_values)
    layout.addWidget(value_label)
    self.pos_label = QLabel(self)
    layout.addItem(QSpacerItem(40, 20, QSizePolicy.Expanding,
                               QSizePolicy.Minimum))
    layout.addWidget(self.pos_label)
    main_layout.addLayout(layout)
    main_layout.addWidget(self.canvas)
    layout = QHBoxLayout(self)
    self.play = QPushButton(QIcon(QPixmap("icons:play.png")), "", self)
    self.play.setCheckable(True)
    self.play.clicked.connect(self.__play)
    layout.addWidget(self.play)
    self.slider = QSlider(Qt.Horizontal, self)
    self.slider.setMaximum(max(len(p) for p in path) - 1)
    self.slider.valueChanged.connect(self.canvas.set_index)
    layout.addWidget(self.slider)
    layout.addWidget(QLabel("Total times:", self))
    factor = QDoubleSpinBox(self)
    factor.valueChanged.connect(self.canvas.set_factor)
    factor.setSuffix('s')
    factor.setRange(0.01, 999999)
    factor.setValue(10)
    layout.addWidget(factor)
    main_layout.addLayout(layout)
    self.timer = QTimer()
    self.timer.setInterval(10)
    self.timer.timeout.connect(self.__move_ind)

</t>
<t tx="leo.20231205084741.110">def inverse_transform(
    coeffs: ndarray,
    locus_v: Tuple[float, float],
    n: int,
    harmonic: int
) -&gt; ndarray:
    """
    Perform an inverse fourier transform to convert the coefficients back into
    spatial coordinates.

    Implements Kuhl and Giardina method of computing the performing the
    transform for a specified number of harmonics. This code is adapted
    from the pyefd module. See the original paper for more detail:

    Kuhl, FP and Giardina, CR (1982). Elliptic Fourier features of a closed
    contour. Computer graphics and image procesnp_sing, 18(3), 236-258.

    Args:
        coeffs: A numpy array of shape (n, 4) representing the
            four coefficients for each harmonic computed.
        locus_v: The x,y coordinates of the centroid of the contour being
            generated. Use calculate_dc_coefficients() to generate the correct
            locus for a shape.
        n: The number of coordinate pairs to compute. A larger value will
            result in a more complex shape at the expense of increased
            computational time.
        harmonic: The number of harmonics to be used to generate
            coordinates. Must be &lt;= coeffs.shape[0]. Supply a
            smaller value to produce coordinates for a more generalized shape.
    Returns:
        A n x 2 numpy array represents a contour.
    """
    t = linspace(0, 1, n)
    contour = ones((n, 2), dtype=float)
    contour[:, 0] *= locus_v[0]
    contour[:, 1] *= locus_v[1]
    for n in range(harmonic):
        angle = t * (n + 1) * 2 * pi
        cosine = cos(angle)
        sine = sin(angle)
        contour[:, 0] += coeffs[n, 2] * cosine + coeffs[n, 3] * sine
        contour[:, 1] += coeffs[n, 0] * cosine + coeffs[n, 1] * sine
    return contour


</t>
<t tx="leo.20231205084741.111">def _nyquist(zx: Sized) -&gt; int:
    """
    Returns the maximum number of harmonics that can be computed for a given
    contour, the Nyquist Frequency.

    See this paper for details:
    C. np_costa et al. / Postharvest Biology and Technology 54 (2009) 38-47

    Args:
        zx (list): A list (or numpy array) of x coordinate values.
    Returns:
        int: The nyquist frequency, expressed as a number of harmonics.
    """
    return len(zx) // 2


</t>
<t tx="leo.20231205084741.112">def fourier_power(
    coeffs: ndarray,
    nyq: int,
    threshold: float = 1.
) -&gt; int:
    """
    Compute the total Fourier power and find the minimum number of harmonics
    required to exceed the threshold fraction of the total power.

    This is a good method for identifying the number of harmonics to use to
    describe a polygon. For more details see:

    C. np_costa et al. / Postharvest Biology and Technology 54 (2009) 38-47

    Warning:
        The number of coefficients must be &gt;= the Nyquist Frequency.
    Args:
        coeffs: A numpy array of shape (n, 4) representing the
            four coefficients for each harmonic computed.
        nyq: The Nyquist Frequency.
        threshold: The threshold fraction of the total Fourier power,
            the default is 1.
    Returns:
        The number of harmonics required to represent the contour above
        the threshold Fourier power.
    """
    total_power = 0
    current_power = 0
    for i in range(nyq):
        total_power += 0.5 * (coeffs[i, :] ** 2).sum()
    for i in range(nyq):
        current_power += 0.5 * (coeffs[i, :] ** 2).sum()
        if current_power / total_power &gt;= threshold:
            return i + 1
    return nyq


</t>
<t tx="leo.20231205084741.113">def rotate_contour(
    contour: ndarray,
    angle: float,
    centroid: Tuple[float, float]
) -&gt; ndarray:
    """
    Rotates a contour about a point by a given amount expressed in degrees.

    Operates by calling rotatePoint() on each x,y pair in turn. X and Y must
    have the same dimensions.

    Args:
        contour: A n x 2 numpy array represents a path.
        angle: The angle in radians for the contour to be rotated by.
        centroid: A tuple containing the x,y coordinates of the centroid to
            rotate the contour about.
    Returns:
        A n x 2 numpy array represents a contour.
    """
    cpx, cpy = centroid
    out = zeros(contour.shape, dtype=contour.dtype)
    for i in range(len(contour)):
        dx = contour[i, 0] - cpx
        dy = contour[i, 1] - cpy
        out[i, :] = (
            cpx + dx * cos(angle) - dy * sin(angle),
            cpy + dx * sin(angle) + dy * cos(angle)
        )
    return out
</t>
<t tx="leo.20231205084741.114">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/
# -*- coding: utf-8 -*-

"""All examples of Pyslvs."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Tuple, Sequence, Dict, Iterator

_example_list: Dict[str, Tuple[str, Sequence[Tuple[int, int]]]] = {
    "Arm": (
        "M["
        "J[R, color[Green], P[-34.25, -20.625], L[ground, L1, L2]],"
        "J[R, color[Green], P[29.75, 77.375], L[L2, L5, L6]],"
        "J[R, color[Green], P[-54.0, 10.875], L[L1, L3]],"
        "J[R, color[Green], P[-86.25, -3.125], L[ground, L4]],"
        "J[R, color[Green], P[-7.25, 94.625], L[L4, L5]],"
        "J[R, color[Green], P[57.0, 110.875], L[L5, L8]],"
        "J[R, color[Green], P[126.5, 56.125], L[L7, L8]],"
        "J[R, color[Green], P[114.5, 35.625], L[L6, L7]],"
        "J[R, color[Green], P[7.0, 131.125], L[L3, L6]],"
        "J[R, color[Green], P[163.5, 47.875], L[L7]]"
        "]", ((0, 1), (0, 2))),
    "Ball lifter (Double)": (
        "M["
        "J[R, color[Green], P[10.2, 10.4], L[ground, L1]],"
        "J[R, color[Green], P[7.44, 20.01], L[L1, L2, L6]],"
        "J[R, color[Green], P[-10.52, 11.21], L[L2, L3]],"
        "J[R, color[Green], P[-28.48, 2.42], L[L2, L4]],"
        "J[R, color[Green], P[-6.6, 0.0], L[ground, L3]],"
        "J[R, color[Green], P[-12.8, 0.0], L[ground, L5]],"
        "J[R, color[Green], P[-22.61, 12.64], L[L4, L5]],"
        "J[R, color[Green], P[-56.1, 6.78], L[L4]],"
        "J[R, color[Green], P[43.78, 20.17], L[ground, L7]],"
        "J[R, color[Green], P[15.02, 40.85], L[L6, L7]],"
        "J[R, color[Green], P[22.0284, 59.8421], L[L6, L8]],"
        "J[R, color[Green], P[23.8, 0.0], L[ground, L9]],"
        "J[R, color[Green], P[35.64, 40.55], L[L8, L9]],"
        "J[R, color[Green], P[8.73, 80.39], L[L8]]"
        "]", ((0, 1),)),
    "Ball lifter (Triple)": (
        "M["
        "J[R, color[Green], P[10.2, 10.4], L[ground, L1]],"
        "J[R, color[Green], P[7.44, 20.01], L[L1, L2, L6, L10]],"
        "J[R, color[Green], P[-10.52, 11.21], L[L2, L3]],"
        "J[R, color[Green], P[-28.48, 2.42], L[L2, L4]],"
        "J[R, color[Green], P[-6.6, 0.0], L[ground, L3]],"
        "J[R, color[Green], P[-12.8, 0.0], L[ground, L5]],"
        "J[R, color[Green], P[-19.11, 32.24], L[L4, L5]],"
        "J[R, color[Green], P[-64.12, 4.61], L[L4]],"
        "J[R, color[Green], P[43.78, 20.17], L[ground, L7]],"
        "J[R, color[Green], P[13.9, 38.46], L[L6, L7]],"
        "J[R, color[Green], P[21.05, 62.93], L[L6, L8]],"
        "J[R, color[Green], P[23.8, 0.0], L[ground, L9]],"
        "J[R, color[Green], P[39.15, 41.95], L[L8, L9]],"
        "J[R, color[Green], P[10.29, 92.17], L[L8]],"
        "J[R, color[Green], P[73.44, 61.74], L[L10, L11]],"
        "J[R, color[Green], P[63.67, 0.0], L[ground, L11]],"
        "J[R, color[Green], P[101.58, 72.34], L[L10, L12]],"
        "J[R, color[Green], P[92.30, -1.63], L[L13, ground]],"
        "J[R, color[Green], P[111.74, 70.43], L[L12, L13]],"
        "J[R, color[Green], P[7.50, 93.44], L[L12]]"
        "]", ((0, 1),)),
    "Crank lifter": (
        "M["
        "J[R, color[Green], P[-67.38, 36.13], L[ground, L1]],"
        "J[R, color[Green], P[-68.925, 55.925], L[L1, L2]],"
        "J[RP, A[0.0], color[Green], P[11.88, 0.0], L[ground, L2, L3]],"
        "J[R, color[Green], P[50.775, 24.7908], L[L3, L4]],"
        "J[R, color[Green], P[80.375, 8.625], L[ground, L4]],"
        "J[R, color[Green], P[109.1972, 63.8805], L[L3, L5]],"
        "J[RP, A[0.0], color[Green], P[0.82, 64.42], L[L5, L4]]"
        "]", ((0, 1),)),
    "Crank rocker": (
        "M["
        "J[R, color[Green], P[0.0, 0.0], L[ground, L1]],"
        "J[R, color[Green], P[12.92, 32.53], L[L1, L2]],"
        "J[R, color[Green], P[73.28, 67.97], L[L2, L3]],"
        "J[R, color[Green], P[33.3, 66.95], L[L2]],"
        "J[R, color[Green], P[90.0, 0.0], L[ground, L3]]"
        "]", ((0, 1),)),
    "Crank slider (P joint)": (
        "M["
        "J[R, color[Green], P[-33.625, -19.625], L[ground, L1]],"
        "J[R, color[Green], P[-48.375, 12.125], L[L1, L3]],"
        "J[R, color[Green], P[17.125, 33.875], L[L2, L3]],"
        "J[P, A[30.0], color[Green], P[51.38, -12.63], L[ground, L2]],"
        "J[R, color[Green], P[50.35, 53.117], L[L2, L5]],"
        "J[R, color[Green], P[143.455, 65.967], L[L4, L5]],"
        "J[R, color[Green], P[99.244, 20.447], L[ground, L4]]"
        "]", ((0, 1),)),
    "Crank slider (RP joint)": (
        "M["
        "J[R, color[Green], P[-67.38, 36.13], L[ground, L1]],"
        "J[R, color[Green], P[-68.925, 55.925], L[L1, L2]],"
        "J[RP, A[0.0], color[Green], P[11.88, 0.0], L[ground, L2, L3]],"
        "J[R, color[Green], P[50.775, 24.7908], L[L3, L4]],"
        "J[R, color[Green], P[74.375, 7.625], L[ground, L4]],"
        "J[R, color[Green], P[95.1972, 52.8805], L[L3]]"
        "]", ((0, 1),)),
    "Crank slider (Three bar)": (
        "M["
        "J[R, color[Green], P[-30.0, -10.0], L[ground, L1]],"
        "J[R, color[Green], P[-9.9986, 4.999], L[L1, L2]],"
        "J[RP, A[0.0], color[Green], P[65.0, -45.0], L[L2, ground]]"
        "]", ((0, 1),)),
    "Horse leg": (
        "M["
        "J[R, color[Green], P[49, -75], L[ground, link_1]],"
        "J[R, color[Green], P[100, -69], L[ground, link_2]],"
        "J[R, color[Green], P[139, -63], L[link_5, ground]],"
        "J[R, color[Green], P[52, -97], L[link_1, link_3]],"
        "J[R, color[Green], P[108, -81], L[link_3, link_4]],"
        "J[R, color[Green], P[108, -107], L[link_2, link_3]],"
        "J[R, color[Green], P[156, -114], L[link_4, link_5]],"
        "J[R, color[Green], P[193, -149], L[link_5, link_7]],"
        "J[R, color[Green], P[109, -127], L[link_2, link_6]],"
        "J[R, color[Green], P[204, -169], L[link_6, link_7]],"
        "J[R, color[Green], P[230, -219], L[link_7]]"
        "]", ((0, 3),)),
    "Inverted slider": (
        "M["
        "J[R, color[Green], P[0, 0], L[ground, L1]],"
        "J[R, color[Green], P[56, 0], L[ground, L3]],"
        "J[R, color[Green], P[7, 25], L[L1, L2]],"
        "J[P, A[0.0], color[Green], P[59, 41], L[L3, L2]]"
        "]", ((0, 2),)),
    "Jansen's linkage (Single)": (
        "M["
        "J[R, color[Green], P[0.0, 0.0], L[ground, L1]],"
        "J[R, color[Green], P[9.61, 11.52], L[L1, L2, L4]],"
        "J[R, color[Blue], P[-38.0, -7.8], L[ground, L3, L5]],"
        "J[R, color[Green], P[-35.24, 33.61], L[L2, L3]],"
        "J[R, color[Green], P[-77.75, -2.54], L[L3, L6]],"
        "J[R, color[Green], P[-20.1, -42.79], L[L4, L5, L7]],"
        "J[R, color[Green], P[-56.05, -35.42], L[L6, L7]],"
        "J[R, color[Green], P[-22.22, -91.74], L[L7]]"
        "]", ((0, 1),)),
    "Jansen's linkage (Double)": (
        "M["
        "J[R, color[Green], P[0.0, 0.0], L[ground, L1]],"
        "J[R, color[Green], P[9.61, 11.52], L[L1, L2, L4, L8, L10]],"
        "J[R, color[Blue], P[-38.0, -7.8], L[ground, L3, L5]],"
        "J[R, color[Green], P[-35.24, 33.61], L[L2, L3]],"
        "J[R, color[Green], P[-77.75, -2.54], L[L3, L6]],"
        "J[R, color[Green], P[-20.1, -42.79], L[L4, L5, L7]],"
        "J[R, color[Green], P[-56.05, -35.42], L[L6, L7]],"
        "J[R, color[Green], P[-22.22, -91.74], L[L7]],"
        "J[R, color[Blue], P[38.0, -7.8], L[ground, L9, L11]],"
        "J[R, color[Green], P[56.28, 29.46], L[L8, L9]],"
        "J[R, color[Green], P[75.07, -23.09], L[L9, L12]],"
        "J[R, color[Green], P[31.18, -46.5], L[L10, L11, L13]],"
        "J[R, color[Green], P[64.84, -61.13], L[L12, L13]],"
        "J[R, color[Green], P[4.79, -87.79], L[L13]]"
        "]", ((0, 1),)),
    "Parallel Linkage": (
        "M["
        "J[R, color[Green], P[0, 0], L[ground, link_1]],"
        "J[R, color[Green], P[100, 0], L[ground, link_3]],"
        "J[R, color[Green], P[0, 100], L[link_1, link_2]],"
        "J[R, color[Green], P[100, 100], L[link_2, link_3]]"
        "]", ((0, 2),)),
    "Slider lifter": (
        "M["
        "J[RP, A[0.0], color[Green], P[0.0, 0.0], L[ground, L2]],"
        "J[R, color[Green], P[50.0, 0.0], L[ground, L1]],"
        "J[R, color[Green], P[25.0, 27.0], L[L1, L2]],"
        "J[R, color[Green], P[1.0, 54.0], L[L1]],"
        "J[R, color[Green], P[50.0, 53.0], L[L2]]"
        "]", ((0, 0),)),
    "Stephenson I": (
        "M["
        "J[R, color[Green], P[0.0, 0.0], L[ground, L1]],"
        "J[R, color[Green], P[29.4258, 46.6507], L[L1, L5]],"
        "J[R, color[Green], P[10.7895, 114.378], L[L1, L2]],"
        "J[R, color[Green], P[73.75, 202.8125], L[L2, L3]],"
        "J[R, color[Green], P[146.25, 146.5625], L[L3, L4]],"
        "J[R, color[Green], P[105.25, 87.5625], L[L4, L5]],"
        "J[R, color[Green], P[113.75, 0.0], L[ground, L4]]"
        "]", ((0, 1),)),
    "Stephenson II": (
        "M["
        "J[R, color[Green], P[-45.0, -15.5], L[ground, L1]],"
        "J[R, color[Green], P[-52.0, 25.5], L[L1, L2]],"
        "J[R, color[Green], P[-36.0, 76.25], L[L2, L5]],"
        "J[R, color[Green], P[-4.0, 3.0], L[L2, L4]],"
        "J[R, color[Green], P[29.0, 27.5], L[L3, L4]],"
        "J[R, color[Green], P[85.25, -27.25], L[ground, L3]],"
        "J[R, color[Green], P[57.5, 77.0], L[L3, L5]]"
        "]", ((0, 1),)),
    "Stephenson III": (
        "M["
        "J[R, color[Green], P[0.25, -0.625], L[ground, L1]],"
        "J[R, color[Green], P[15.375, 41.125], L[L1, L2]],"
        "J[R, color[Green], P[61.375, 95.125], L[L2, L3]],"
        "J[R, color[Green], P[102.875, 84.375], L[L3, L4]],"
        "J[R, color[Green], P[117.125, 23.375], L[ground, L4]],"
        "J[R, color[Green], P[134.625, 119.875], L[L3, L5]],"
        "J[R, color[Green], P[138.875, 33.125], L[ground, L5]]"
        "]", ((0, 1),)),
    "Stephenson III (slider)": (
        "M["
        "J[R, color[Green], P[0, 0], L[ground, link_1]],"
        "J[R, color[Green], P[-24, 20], L[link_1, link_3]],"
        "J[R, color[Green], P[80, -58], L[ground, link_2]],"
        "J[R, color[Green], P[44, 16], L[link_2, link_3]],"
        "J[R, color[Green], P[68, 36], L[link_3, link_4]],"
        "J[RP, A[0.0], color[Green], P[136, 28], L[ground, link_4]]"
        "]", ((0, 1),)),
    "Ten Fold's levers": (
        "M["
        "J[R, color[Green], P[17.0, -19.0], L[ground, L2]],"
        "J[R, color[Green], P[17.0, -107.0833], L[ground, L3, L4]],"
        "J[R, color[Green], P[42.0, -45.25], L[L1, L2]],"
        "J[R, color[Green], P[75.5, -45.0], L[L1, L3, L7, L9]],"
        "J[R, color[Green], P[108.8819, -45.0], L[L8, L9]],"
        "J[R, color[Green], P[160.5, -44.75], L[L9, L11]],"
        "J[R, color[Green], P[75.25, -80.0], L[L2, L6, L8]],"
        "J[R, color[Green], P[132.8819, -21.5972], L[L8, L10]],"
        "J[R, color[Green], P[185.4653, -21.1736], L[L10, L11]],"
        "J[R, color[Green], P[108.7917, -80.2917], L[L6, L7]],"
        "J[R, color[Green], P[76.3043, -104.3817], L[L4, L5]],"
        "J[R, color[Green], P[132.026, -104.8377], L[L5, L7]],"
        "J[R, color[Green], P[221.6968, -20.8773], L[L10]]"
        "]", ((0, 2),)),
    "Watt I": (
        "M["
        "J[R, color[Green], P[0.0, 0.0], L[ground, L1]],"
        "J[R, color[Green], P[-18.6154, 41.3846], L[L1, L2]],"
        "J[R, color[Green], P[29.0, 116.5], L[L2, L3]],"
        "J[R, color[Green], P[38.0, 69.0], L[L2, L5]],"
        "J[R, color[Green], P[95.0, 143.0], L[L3, L4]],"
        "J[R, color[Green], P[122.0, 76.5], L[L4, L5]],"
        "J[R, color[Green], P[64.0, 0.0], L[ground, L5]]"
        "]", ((0, 1),)),
    "Watt II": (
        "M["
        "J[R, color[Green], P[0.0, 0.0], L[ground, L1]],"
        "J[R, color[Green], P[-5.3333, 36.0], L[L1, L2]],"
        "J[R, color[Green], P[42.6667, 48.3333], L[L2, L3]],"
        "J[R, color[Green], P[60.0, 1.3333], L[ground, L3]],"
        "J[R, color[Green], P[79.0, 71.3333], L[L3, L4]],"
        "J[R, color[Green], P[113.6667, 36.0], L[L4, L5]],"
        "J[R, color[Green], P[87.0, -17.0], L[ground, L5]]"
        "]", ((0, 1),)),
    "Watt II (slider)": (
        "M["
        "J[R, color[Blue], P[0, 0], L[ground, link_3]],"
        "J[R, color[Green], P[-4.1011, -49.6944], L[link_1, link_3]],"
        "J[R, color[Green], P[-151.1537, -50.2107], L[link_1, link_2]],"
        "J[RP, A[45.0], color[Blue], P[-139.0458, 20.2296], L[ground, link_2]],"
        "J[P, A[45.0], color[Green], P[-47.356, -102.562], L[link_1, link_4]],"
        "J[R, color[Blue], P[15.3065, -161.8204], L[ground, link_4]]"
        "]", ((0, 1),)),
}


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.115">def example_list(key: str) -&gt; Tuple[str, Sequence[Tuple[int, int]]]:
    """The example data of mechanisms.

    The format of each mechanism is:

    + `[0]`: Mechanism expression.
        + type: str
    + `[1]`: Input pairs.
        + type: Tuple[Tuple[int, int], ...]]
    """
    return _example_list[key]


</t>
<t tx="leo.20231205084741.116">def all_examples() -&gt; Iterator[str]:
    """Get all example names."""
    yield from sorted(_example_list)
</t>
<t tx="leo.20231205084741.117">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/
# -*- coding: utf-8 -*-

"""Lark parser to parse the expression."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from abc import abstractmethod
from typing import (
    cast, Tuple, List, Dict, Iterator, Optional, Union, TypeVar, Generic,
)
from dataclasses import dataclass
from lark import Lark, Transformer, LexError
from .expression import get_vlinks, VJoint, VPoint, VLink
from .graph import Graph

_T1 = TypeVar('_T1')
_T2 = TypeVar('_T2')
_Coord = Tuple[float, float]
_JointArgs = List[Union[str, VJoint, float, _Coord, Tuple[str, ...]]]

# Color dictionary
_color_list: Dict[str, Tuple[int, int, int]] = {
    'red': (172, 68, 68),
    'green': (110, 190, 30),
    'blue': (68, 120, 172),
    'cyan': (0, 255, 255),
    'magenta': (255, 0, 255),
    'brick-red': (255, 130, 130),
    'yellow': (255, 255, 0),
    'gray': (160, 160, 160),
    'orange': (225, 165, 0),
    'pink': (225, 192, 230),
    'black': (0, 0, 0),
    'white': (255, 255, 255),
    'dark-red': (128, 0, 0),
    'dark-green': (0, 128, 0),
    'dark-blue': (0, 0, 128),
    'dark-cyan': (128, 0, 128),
    'dark-magenta': (255, 0, 255),
    'dark-yellow': (128, 128, 0),
    'dark-gray': (128, 128, 128),
    'dark-orange': (225, 140, 0),
    'dark-pink': (225, 20, 147),
}
color_names = tuple(sorted(_color_list.keys()))


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.118">def color_rgb(name: str) -&gt; Tuple[int, int, int]:
    """Get color by name.

    Get RGB color data by name, return `(0, 0, 0)` if it is invalid.
    Also support `"(R, G, B)"` string format.
    """
    name = name.lower()
    if name in _color_list:
        return _color_list[name]
    else:
        try:
            # Input RGB as a "(255, 255, 255)" string
            rgb = (
                name.replace('(', '')
                .replace(')', '')
                .replace(" ", '')
                .split(',', maxsplit=3)
            )
            color_text = (int(rgb[0]), int(rgb[1]), int(rgb[2]))
        except ValueError:
            return 0, 0, 0
        else:
            return color_text


</t>
<t tx="leo.20231205084741.119">@dataclass(repr=False, eq=False)
class PointArgs:
    """Point table argument."""
    links: str
    type: str
    color: str
    x: float
    y: float


</t>
<t tx="leo.20231205084741.12">@Slot()
def __move_ind(self):
    """Move indicator."""
    value = self.slider.value() + 1
    self.slider.setValue(value)
    if value &gt; self.slider.maximum():
        self.slider.setValue(0)

</t>
<t tx="leo.20231205084741.120">@dataclass(repr=False, eq=False)
class LinkArgs:
    """Link table argument."""
    name: str
    color: str
    points: str


</t>
<t tx="leo.20231205084741.121">_GRAMMAR = Lark(r"""
// Number
DIGIT: "0".."9"
INT: DIGIT+
SIGNED_INT: ["+" | "-"] INT
DECIMAL: INT "." INT? | "." INT
_EXP: ("e" | "E") SIGNED_INT
FLOAT: INT _EXP | DECIMAL _EXP?
NUMBER: FLOAT | INT
SIGNED_NUMBER: ["+" | "-"] NUMBER

// Letters
LCASE_LETTER: "a".."z"
UCASE_LETTER: "A".."Z"
LETTER: UCASE_LETTER | LCASE_LETTER | "_"
CNAME: LETTER (LETTER | DIGIT)*

// White space and new line
WS: /\s+/
CR: /\r/
LF: /\n/
NEWLINE: (CR? LF)+
%ignore WS
%ignore NEWLINE

// Comment
LINE_COMMENT: /#[^\n]*/
MULTILINE_COMMENT: /#\[[\s\S]*#\][^\n]*/
%ignore LINE_COMMENT
%ignore MULTILINE_COMMENT

// Custom data type
JOINT_TYPE: "RP" | "R" | "P"
COLOR: """ + "|".join(f'"{color}"i' for color in color_names) + r"""
type: JOINT_TYPE
name: CNAME
number: SIGNED_NUMBER
color_value: INT

// Main grammar
joint: "J[" type ["," angle] ["," color] "," point "," link "]"
link: "L[" [name ("," name)* ","?] "]"
point: "P[" number "," number "]"
angle: "A[" number "]"
color: "color[" (("(" color_value ("," color_value) ~ 2 ")") | COLOR) "]"
mechanism: "M[" [joint ("," joint)* ","?] "]"
?start: mechanism
""", parser='lalr')


</t>
<t tx="leo.20231205084741.122">class _Transformer(Transformer, Generic[_T1, _T2]):
    """Base transformer implementation."""

    @others
</t>
<t tx="leo.20231205084741.123">@staticmethod
@abstractmethod
def type(n: List[str]) -&gt; _T1:
    raise NotImplementedError

</t>
<t tx="leo.20231205084741.124">@staticmethod
def name(n: List[str]) -&gt; str:
    return str(n[0])

</t>
<t tx="leo.20231205084741.125">@staticmethod
def color(n: List[str]) -&gt; str:
    return str(n[0]) if len(n) == 1 else str(tuple(n))

</t>
<t tx="leo.20231205084741.126">@staticmethod
def color_value(n: List[str]) -&gt; int:
    return int(n[0])

</t>
<t tx="leo.20231205084741.127">@staticmethod
def number(n: List[str]) -&gt; float:
    return float(n[0])

</t>
<t tx="leo.20231205084741.128">angle = number

</t>
<t tx="leo.20231205084741.129">@staticmethod
def point(c: List[float]) -&gt; _Coord:
    return c[0], c[1]

</t>
<t tx="leo.20231205084741.13">@Slot(float, float)
def __set_pos(self, x: float, y: float) -&gt; None:
    """Set mouse position."""
    self.pos_label.setText(f"({x:.04f}, {y:.04f})")

</t>
<t tx="leo.20231205084741.130">@staticmethod
def link(a: List[str]) -&gt; Tuple[str, ...]:
    return tuple(a)

</t>
<t tx="leo.20231205084741.131">@staticmethod
@abstractmethod
def joint(args: _JointArgs) -&gt; _T2:
    raise NotImplementedError

</t>
<t tx="leo.20231205084741.132">@staticmethod
def mechanism(joints: List[_T2]) -&gt; List[_T2]:
    return joints


</t>
<t tx="leo.20231205084741.133">class _ParamsTrans(_Transformer[str, PointArgs]):
    """Transformer will parse into a list of VPoint data."""

    @others
</t>
<t tx="leo.20231205084741.134">@staticmethod
def type(n: List[str]) -&gt; str:
    return str(n[0])

</t>
<t tx="leo.20231205084741.135">@staticmethod
def joint(args: _JointArgs) -&gt; PointArgs:
    """Sort the argument list.

    [0]: type
    ([1]: angle)
    ([2]: color)
    [-2]: point (coordinate)
    [-1]: link
    """
    type_str = cast(str, args[0])
    x, y = cast(_Coord, args[-2])
    links = ','.join(cast(Tuple[str, ...], args[-1]))
    if type_str == 'R':
        if len(args) == 3:
            return PointArgs(links, 'R', 'Green', x, y)
        elif len(args) == 4:
            color = cast(str, args[-3])
            return PointArgs(links, 'R', color, x, y)
    else:
        angle = cast(float, args[1])
        type_angle = f'{type_str}:{angle}'
        if len(args) == 4:
            return PointArgs(links, type_angle, 'Green', x, y)
        elif len(args) == 5:
            color = cast(str, args[-3])
            return PointArgs(links, type_angle, color, x, y)

    raise LexError(f"invalid options: {args}")


</t>
<t tx="leo.20231205084741.136">class _PositionTrans(_Transformer[str, _Coord]):
    """Transformer will parse into a list of position data."""

    @others
</t>
<t tx="leo.20231205084741.137">@staticmethod
def type(n: List[str]) -&gt; str:
    return str(n[0])

</t>
<t tx="leo.20231205084741.138">@staticmethod
def joint(args: _JointArgs) -&gt; _Coord:
    x, y = cast(_Coord, args[-2])
    return x, y


</t>
<t tx="leo.20231205084741.139">class _VPointsTrans(_Transformer[VJoint, VPoint]):
    """Using same grammar return as VPoints."""

    @others
</t>
<t tx="leo.20231205084741.14">@Slot()
def __play(self):
    """Start playing."""
    if self.play.isChecked():
        self.timer.start()
    else:
        self.timer.stop()
</t>
<t tx="leo.20231205084741.140">@staticmethod
def type(n: List[str]) -&gt; VJoint:
    """Return as int type."""
    type_str = str(n[0])
    if type_str == 'R':
        return VJoint.R
    elif type_str == 'P':
        return VJoint.P
    elif type_str == 'RP':
        return VJoint.RP
    else:
        raise ValueError(f"invalid joint type: {type_str}")

</t>
<t tx="leo.20231205084741.141">@staticmethod
def joint(args: _JointArgs) -&gt; VPoint:
    """Sort the argument list.

    [0]: type
    ([1]: angle)
    ([2]: color)
    [-2]: point (coordinate)
    [-1]: link
    """
    type_int = cast(VJoint, args[0])
    x, y = cast(_Coord, args[-2])
    links = cast(Tuple[str, ...], args[-1])
    if type_int == VJoint.R:
        if len(args) == 3:
            return VPoint.r_joint(links, x, y)
        elif len(args) == 4:
            color = cast(str, args[-3])
            return VPoint(links, VJoint.R, 0., color, x, y, color_rgb)
    else:
        angle = cast(float, args[1])
        if len(args) == 4:
            return VPoint.slider_joint(links, type_int, angle, x, y)
        elif len(args) == 5:
            color = cast(str, args[-3])
            return VPoint(links, type_int, angle, color, x, y, color_rgb)

    raise LexError(f"invalid options: {args}")


</t>
<t tx="leo.20231205084741.142">_params_translator = _ParamsTrans()
_pos_translator = _PositionTrans()
_vpoint_translator = _VPointsTrans()


</t>
<t tx="leo.20231205084741.143">def parse_params(expr: str) -&gt; List[PointArgs]:
    """Parse mechanism expression into VPoint constructor arguments."""
    return _params_translator.transform(_GRAMMAR.parse(expr))


</t>
<t tx="leo.20231205084741.144">def parse_pos(expr: str) -&gt; List[_Coord]:
    """Parse mechanism expression into coordinates."""
    return _pos_translator.transform(_GRAMMAR.parse(expr))


</t>
<t tx="leo.20231205084741.145">def parse_vpoints(expr: str) -&gt; List[VPoint]:
    """Parse mechanism expression into VPoint objects."""
    return _vpoint_translator.transform(_GRAMMAR.parse(expr))


</t>
<t tx="leo.20231205084741.146">def parse_vlinks(expr: str) -&gt; List[VLink]:
    """Parse mechanism expression into VLink objects."""
    return get_vlinks(parse_vpoints(expr))


</t>
<t tx="leo.20231205084741.147">def _sorted_pair(a: int, b: int) -&gt; Tuple[int, int]:
    return (a, b) if a &lt; b else (b, a)


</t>
<t tx="leo.20231205084741.148">def edges_view(graph: Graph) -&gt; Iterator[Tuple[int, Tuple[int, int]]]:
    """The iterator will yield the sorted edges from `graph`."""
    yield from enumerate(sorted(_sorted_pair(n1, n2) for n1, n2 in graph.edges))


</t>
<t tx="leo.20231205084741.149">def graph2vpoints(
    graph: Graph,
    pos: Dict[int, _Coord],
    cus: Optional[Dict[int, int]] = None,
    same: Optional[Dict[int, int]] = None,
    grounded: Optional[int] = None
) -&gt; List[VPoint]:
    """Transform `graph` into [VPoint] objects. The vertices are mapped to links.

    + `pos`: Position for each vertices.
    + `cus`: Extra points on the specific links.
    + `same`: Multiple joint setting. The joints are according to [`edges_view`](#edges_view).
    + `grounded`: The ground link of vertices.
    """
    if cus is None:
        cus = {}
    if same is None:
        same = {}
    same_r: Dict[int, List[int]] = {}
    for k, v in same.items():
        if v in same_r:
            same_r[v].append(k)
        else:
            same_r[v] = [k]
    tmp_list = []
    ev = dict(edges_view(graph))
    for i, edge in ev.items():
        if i in same:
            # Do not connect to anyone!
            continue
        edges = set(edge)
        if i in same_r:
            for j in same_r[i]:
                edges.update(set(ev[j]))
        x, y = pos[i]
        links = [
            f"L{link}" if link != grounded else VLink.FRAME for link in edges
        ]
        tmp_list.append(VPoint.r_joint(links, x, y))
    for name in sorted(cus):
        link = f"L{cus[name]}" if cus[name] != grounded else VLink.FRAME
        x, y = pos[name]
        tmp_list.append(VPoint.r_joint((link,), x, y))
    return tmp_list
</t>
<t tx="leo.20231205084741.15">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/widgets/inputs/
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'inputs.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from qtpy import QtCore, QtGui, QtWidgets


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.150">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/
# -*- coding: utf-8 -*-

"""Kernel of Pyslvs."""

__version__ = "22.07.0"
__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from .expression import get_vlinks, VJoint, VPoint, VLink, Coord
from .bfgs import SolverSystem
from .topo_config import t_config, EStack
from .tinycadlib import (
    pxy, ppp, plap, pllp, plpp, palp, vpoint_dof, expr_solving, uniform_path,
    uniform_four_bar, uniform_expr,
)
from .expression_parser import (
    color_names, color_rgb, parse_params, parse_pos, parse_vpoints,
    parse_vlinks, edges_view, graph2vpoints, PointArgs, LinkArgs,
)
from .example import example_list, all_examples
from .collection import collection_list, all_collections, Collection
from .efd import efd_fitting


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.151">def get_include() -&gt; str:
    """Get include directory."""
    from os.path import dirname
    return dirname(__file__)
</t>
<t tx="leo.20231205084741.153"></t>
<t tx="leo.20231205084741.154">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/graph/
# -*- coding: utf-8 -*-

"""Pyslvs graph functions."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from .graph import (
    link_assortment, contracted_link_assortment, labeled_enumerate, Graph,
)
from .planar import is_planar
from .layout import external_loop_layout
from .structural import (
    conventional_graph, contracted_graph, link_synthesis,
    contracted_link_synthesis,
)
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.155"></t>
<t tx="leo.20231205084741.156">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/optimization/
# -*- coding: utf-8 -*-

"""Optimization utilities."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import TypedDict, Sequence, Tuple, Dict
from pyslvs.expression import VPoint

_Path = Sequence[Tuple[float, float]]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.157">class FConfig(TypedDict, total=False):
    expression: Sequence[VPoint]
    input: Sequence[Tuple[Tuple[int, int], Sequence[float]]]
    placement: Dict[int, Tuple[float, float, float]]
    target: Dict[int, _Path]
    same: Dict[int, int]
    upper: float
    lower: float
    shape_only: bool


</t>
<t tx="leo.20231205084741.158">class NConfig(TypedDict, total=False):
    target: _Path
</t>
<t tx="leo.20231205084741.159">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/optimization/
# -*- coding: utf-8 -*-

"""Pyslvs optimization targets."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from .f_planar import (
    FPlanar, norm_path, curvature, derivative, path_signature,
    cross_correlation,
)
from .n_planar import NPlanar, norm_pca
from .utility import FConfig, NConfig
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.16">class Ui_Form(object):
    @others
</t>
<t tx="leo.20231205084741.161"></t>
<t tx="leo.20231205084741.162">@path Y:/tmp/metapyslvs/pyslvs/test/
# -*- coding: utf-8 -*-

"""Pyslvs core module test."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from math import sqrt, radians
from pyslvs import (
    Coord, SolverSystem, pxy, ppp, plap, pllp, plpp, palp, expr_solving,
    t_config, parse_vpoints, example_list,
)
from . import TestBase


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.163">class CoreTest(TestBase):

    @others
</t>
<t tx="leo.20231205084741.164">def test_pxy(self):
    """Test for pxy function."""
    coord = pxy(Coord(80, 90), 40, -20)
    self.assertAlmostEqual(120, coord.x)
    self.assertAlmostEqual(70, coord.y)

</t>
<t tx="leo.20231205084741.165">def test_ppp(self):
    """Test for ppp function."""
    coord = ppp(Coord(0, 0), Coord(0, 90), Coord(90, 0))
    self.assertAlmostEqual(90, coord.x)
    self.assertAlmostEqual(90, coord.y)

</t>
<t tx="leo.20231205084741.166">def test_plap(self):
    """Test for plap function."""
    coord = plap(Coord(0, 0), 50 * sqrt(2), radians(45), Coord(50, 0))
    self.assertAlmostEqual(50, coord.x)
    self.assertAlmostEqual(50, coord.y)

</t>
<t tx="leo.20231205084741.167">def test_pllp(self):
    """Test for pllp function."""
    c1 = Coord(-30, 0)
    c2 = Coord(30, 0)
    coord = pllp(c1, 50, 50, c2)
    self.assertAlmostEqual(0, coord.x)
    self.assertAlmostEqual(40, coord.y)
    coord = pllp(c1, 30, 30, c2)
    self.assertAlmostEqual(coord.x, 0)
    self.assertAlmostEqual(coord.y, 0)
    coord = pllp(c1, 90, 30, c2)
    self.assertAlmostEqual(60, coord.x)
    self.assertAlmostEqual(0, coord.y)

</t>
<t tx="leo.20231205084741.168">def test_plpp(self):
    """Test for plpp function."""
    coord = plpp(Coord(0, 0), sqrt(5), Coord(0, -3), Coord(3 / 2, 0))
    self.assertAlmostEqual(2, coord.x)
    self.assertAlmostEqual(1, coord.y)

</t>
<t tx="leo.20231205084741.169">def test_palp(self):
    """Test for palp function."""
    coord = palp(Coord(0, 0), radians(15), 20, Coord(60, 10))
    self.assertAlmostEqual(42.253221, coord.x, 6)
    self.assertAlmostEqual(19.222356, coord.y, 6)

</t>
<t tx="leo.20231205084741.17">def setupUi(self, Form):
    Form.setObjectName("Form")
    Form.resize(445, 622)
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap("icons:motor.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    Form.setWindowIcon(icon)
    self.verticalLayout_7 = QtWidgets.QVBoxLayout(Form)
    self.verticalLayout_7.setContentsMargins(0, 0, 0, 0)
    self.verticalLayout_7.setObjectName("verticalLayout_7")
    self.tab_widget = QtWidgets.QTabWidget(Form)
    self.tab_widget.setObjectName("tab_widget")
    self.inputs_tab = QtWidgets.QWidget()
    self.inputs_tab.setObjectName("inputs_tab")
    self.verticalLayout = QtWidgets.QVBoxLayout(self.inputs_tab)
    self.verticalLayout.setObjectName("verticalLayout")
    self.joint_groupbox = QtWidgets.QGroupBox(self.inputs_tab)
    self.joint_groupbox.setObjectName("joint_groupbox")
    self.horizontalLayout = QtWidgets.QHBoxLayout(self.joint_groupbox)
    self.horizontalLayout.setContentsMargins(6, 6, 6, 6)
    self.horizontalLayout.setObjectName("horizontalLayout")
    self.verticalLayout_13 = QtWidgets.QVBoxLayout()
    self.verticalLayout_13.setObjectName("verticalLayout_13")
    self.joint_list_lable = QtWidgets.QLabel(self.joint_groupbox)
    self.joint_list_lable.setObjectName("joint_list_lable")
    self.verticalLayout_13.addWidget(self.joint_list_lable)
    self.joint_list = QtWidgets.QListWidget(self.joint_groupbox)
    self.joint_list.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
    self.joint_list.setObjectName("joint_list")
    self.verticalLayout_13.addWidget(self.joint_list)
    self.horizontalLayout.addLayout(self.verticalLayout_13)
    self.inputs_label_right2 = QtWidgets.QLabel(self.joint_groupbox)
    self.inputs_label_right2.setObjectName("inputs_label_right2")
    self.horizontalLayout.addWidget(self.inputs_label_right2)
    self.verticalLayout_16 = QtWidgets.QVBoxLayout()
    self.verticalLayout_16.setObjectName("verticalLayout_16")
    self.driver_list_lable = QtWidgets.QLabel(self.joint_groupbox)
    self.driver_list_lable.setObjectName("driver_list_lable")
    self.verticalLayout_16.addWidget(self.driver_list_lable)
    self.driver_list = QtWidgets.QListWidget(self.joint_groupbox)
    self.driver_list.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
    self.driver_list.setObjectName("driver_list")
    self.verticalLayout_16.addWidget(self.driver_list)
    self.variable_add = QtWidgets.QPushButton(self.joint_groupbox)
    self.variable_add.setEnabled(False)
    icon1 = QtGui.QIcon()
    icon1.addPixmap(QtGui.QPixmap("icons:arrow_down.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.variable_add.setIcon(icon1)
    self.variable_add.setObjectName("variable_add")
    self.verticalLayout_16.addWidget(self.variable_add)
    self.horizontalLayout.addLayout(self.verticalLayout_16)
    self.verticalLayout.addWidget(self.joint_groupbox)
    self.variable_groupbox = QtWidgets.QGroupBox(self.inputs_tab)
    self.variable_groupbox.setObjectName("variable_groupbox")
    self.horizontalLayout_7 = QtWidgets.QHBoxLayout(self.variable_groupbox)
    self.horizontalLayout_7.setObjectName("horizontalLayout_7")
    self.verticalLayout_5 = QtWidgets.QVBoxLayout()
    self.verticalLayout_5.setObjectName("verticalLayout_5")
    self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_2.setObjectName("horizontalLayout_2")
    self.variable_up = QtWidgets.QPushButton(self.variable_groupbox)
    icon2 = QtGui.QIcon()
    icon2.addPixmap(QtGui.QPixmap("icons:arrow_up.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.variable_up.setIcon(icon2)
    self.variable_up.setObjectName("variable_up")
    self.horizontalLayout_2.addWidget(self.variable_up)
    self.variable_down = QtWidgets.QPushButton(self.variable_groupbox)
    self.variable_down.setIcon(icon1)
    self.variable_down.setObjectName("variable_down")
    self.horizontalLayout_2.addWidget(self.variable_down)
    spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_2.addItem(spacerItem)
    self.variable_remove = QtWidgets.QPushButton(self.variable_groupbox)
    icon3 = QtGui.QIcon()
    icon3.addPixmap(QtGui.QPixmap("icons:delete.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.variable_remove.setIcon(icon3)
    self.variable_remove.setObjectName("variable_remove")
    self.horizontalLayout_2.addWidget(self.variable_remove)
    self.verticalLayout_5.addLayout(self.horizontalLayout_2)
    self.variable_list = QtWidgets.QListWidget(self.variable_groupbox)
    self.variable_list.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
    self.variable_list.setObjectName("variable_list")
    self.verticalLayout_5.addWidget(self.variable_list)
    self.horizontalLayout_7.addLayout(self.verticalLayout_5)
    self.line_5 = QtWidgets.QFrame(self.variable_groupbox)
    self.line_5.setFrameShape(QtWidgets.QFrame.VLine)
    self.line_5.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line_5.setObjectName("line_5")
    self.horizontalLayout_7.addWidget(self.line_5)
    self.inputs_dial_layout = QtWidgets.QVBoxLayout()
    self.inputs_dial_layout.setObjectName("inputs_dial_layout")
    self.dial_spinbox = QtWidgets.QDoubleSpinBox(self.variable_groupbox)
    self.dial_spinbox.setEnabled(False)
    self.dial_spinbox.setMaximum(360.0)
    self.dial_spinbox.setObjectName("dial_spinbox")
    self.inputs_dial_layout.addWidget(self.dial_spinbox)
    self.horizontalLayout_7.addLayout(self.inputs_dial_layout)
    self.verticalLayout.addWidget(self.variable_groupbox)
    self.groupBox = QtWidgets.QGroupBox(self.inputs_tab)
    self.groupBox.setObjectName("groupBox")
    self.horizontalLayout_3 = QtWidgets.QHBoxLayout(self.groupBox)
    self.horizontalLayout_3.setObjectName("horizontalLayout_3")
    self.verticalLayout_18 = QtWidgets.QVBoxLayout()
    self.verticalLayout_18.setObjectName("verticalLayout_18")
    self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_4.setObjectName("horizontalLayout_4")
    self.variable_speed_label = QtWidgets.QLabel(self.groupBox)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.variable_speed_label.sizePolicy().hasHeightForWidth())
    self.variable_speed_label.setSizePolicy(sizePolicy)
    self.variable_speed_label.setObjectName("variable_speed_label")
    self.horizontalLayout_4.addWidget(self.variable_speed_label)
    self.variable_speed = QtWidgets.QSpinBox(self.groupBox)
    self.variable_speed.setEnabled(False)
    self.variable_speed.setMinimum(-100)
    self.variable_speed.setMaximum(100)
    self.variable_speed.setSingleStep(5)
    self.variable_speed.setProperty("value", -10)
    self.variable_speed.setObjectName("variable_speed")
    self.horizontalLayout_4.addWidget(self.variable_speed)
    self.verticalLayout_18.addLayout(self.horizontalLayout_4)
    self.extremeRebound = QtWidgets.QCheckBox(self.groupBox)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.extremeRebound.sizePolicy().hasHeightForWidth())
    self.extremeRebound.setSizePolicy(sizePolicy)
    self.extremeRebound.setChecked(True)
    self.extremeRebound.setObjectName("extremeRebound")
    self.verticalLayout_18.addWidget(self.extremeRebound)
    self.horizontalLayout_3.addLayout(self.verticalLayout_18)
    spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_3.addItem(spacerItem1)
    self.verticalLayout_3 = QtWidgets.QVBoxLayout()
    self.verticalLayout_3.setObjectName("verticalLayout_3")
    self.variable_play = QtWidgets.QPushButton(self.groupBox)
    self.variable_play.setEnabled(False)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.variable_play.sizePolicy().hasHeightForWidth())
    self.variable_play.setSizePolicy(sizePolicy)
    icon4 = QtGui.QIcon()
    icon4.addPixmap(QtGui.QPixmap("icons:play.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    icon4.addPixmap(QtGui.QPixmap("icons:pause.png"), QtGui.QIcon.Active, QtGui.QIcon.On)
    self.variable_play.setIcon(icon4)
    self.variable_play.setCheckable(True)
    self.variable_play.setObjectName("variable_play")
    self.verticalLayout_3.addWidget(self.variable_play)
    self.variable_stop = QtWidgets.QPushButton(self.groupBox)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.variable_stop.sizePolicy().hasHeightForWidth())
    self.variable_stop.setSizePolicy(sizePolicy)
    icon5 = QtGui.QIcon()
    icon5.addPixmap(QtGui.QPixmap("icons:interrupted.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.variable_stop.setIcon(icon5)
    self.variable_stop.setObjectName("variable_stop")
    self.verticalLayout_3.addWidget(self.variable_stop)
    self.record_start = QtWidgets.QPushButton(self.groupBox)
    icon6 = QtGui.QIcon()
    icon6.addPixmap(QtGui.QPixmap("icons:record.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.record_start.setIcon(icon6)
    self.record_start.setCheckable(True)
    self.record_start.setObjectName("record_start")
    self.verticalLayout_3.addWidget(self.record_start)
    self.update_pos = QtWidgets.QPushButton(self.groupBox)
    icon7 = QtGui.QIcon()
    icon7.addPixmap(QtGui.QPixmap("icons:merge.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.update_pos.setIcon(icon7)
    self.update_pos.setObjectName("update_pos")
    self.verticalLayout_3.addWidget(self.update_pos)
    self.horizontalLayout_3.addLayout(self.verticalLayout_3)
    self.verticalLayout.addWidget(self.groupBox)
    self.tab_widget.addTab(self.inputs_tab, icon, "")
    self.analysis_tab = QtWidgets.QWidget()
    self.analysis_tab.setObjectName("analysis_tab")
    self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.analysis_tab)
    self.verticalLayout_6.setObjectName("verticalLayout_6")
    self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_6.setObjectName("horizontalLayout_6")
    self.record_show = QtWidgets.QCheckBox(self.analysis_tab)
    self.record_show.setChecked(True)
    self.record_show.setObjectName("record_show")
    self.horizontalLayout_6.addWidget(self.record_show)
    spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    self.horizontalLayout_6.addItem(spacerItem2)
    self.record_interval_label = QtWidgets.QLabel(self.analysis_tab)
    self.record_interval_label.setObjectName("record_interval_label")
    self.horizontalLayout_6.addWidget(self.record_interval_label)
    self.record_interval = QtWidgets.QDoubleSpinBox(self.analysis_tab)
    self.record_interval.setDecimals(2)
    self.record_interval.setMinimum(0.01)
    self.record_interval.setMaximum(20.0)
    self.record_interval.setProperty("value", 1.0)
    self.record_interval.setObjectName("record_interval")
    self.horizontalLayout_6.addWidget(self.record_interval)
    self.verticalLayout_6.addLayout(self.horizontalLayout_6)
    self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_8.setObjectName("horizontalLayout_8")
    self.record_list = QtWidgets.QListWidget(self.analysis_tab)
    self.record_list.setObjectName("record_list")
    self.horizontalLayout_8.addWidget(self.record_list)
    self.verticalLayout_2 = QtWidgets.QVBoxLayout()
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.update_preview_btn = QtWidgets.QPushButton(self.analysis_tab)
    icon8 = QtGui.QIcon()
    icon8.addPixmap(QtGui.QPixmap("icons:data_update.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.update_preview_btn.setIcon(icon8)
    self.update_preview_btn.setObjectName("update_preview_btn")
    self.verticalLayout_2.addWidget(self.update_preview_btn)
    self.copy_path = QtWidgets.QPushButton(self.analysis_tab)
    icon9 = QtGui.QIcon()
    icon9.addPixmap(QtGui.QPixmap("icons:copy.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.copy_path.setIcon(icon9)
    self.copy_path.setObjectName("copy_path")
    self.verticalLayout_2.addWidget(self.copy_path)
    spacerItem3 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    self.verticalLayout_2.addItem(spacerItem3)
    self.record_remove = QtWidgets.QPushButton(self.analysis_tab)
    self.record_remove.setIcon(icon3)
    self.record_remove.setObjectName("record_remove")
    self.verticalLayout_2.addWidget(self.record_remove)
    self.horizontalLayout_8.addLayout(self.verticalLayout_2)
    self.verticalLayout_6.addLayout(self.horizontalLayout_8)
    self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_5.setObjectName("horizontalLayout_5")
    self.plot_joint = QtWidgets.QComboBox(self.analysis_tab)
    self.plot_joint.setObjectName("plot_joint")
    self.horizontalLayout_5.addWidget(self.plot_joint)
    self.plot_joint_slot = QtWidgets.QCheckBox(self.analysis_tab)
    self.plot_joint_slot.setEnabled(False)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.plot_joint_slot.sizePolicy().hasHeightForWidth())
    self.plot_joint_slot.setSizePolicy(sizePolicy)
    self.plot_joint_slot.setObjectName("plot_joint_slot")
    self.horizontalLayout_5.addWidget(self.plot_joint_slot)
    self.show_btn = QtWidgets.QPushButton(self.analysis_tab)
    self.show_btn.setIcon(icon7)
    self.show_btn.setObjectName("show_btn")
    self.horizontalLayout_5.addWidget(self.show_btn)
    self.show_all_btn = QtWidgets.QPushButton(self.analysis_tab)
    self.show_all_btn.setIcon(icon7)
    self.show_all_btn.setObjectName("show_all_btn")
    self.horizontalLayout_5.addWidget(self.show_all_btn)
    self.verticalLayout_6.addLayout(self.horizontalLayout_5)
    self.copy_format_groupbox = QtWidgets.QGroupBox(self.analysis_tab)
    self.copy_format_groupbox.setObjectName("copy_format_groupbox")
    self.verticalLayout_8 = QtWidgets.QVBoxLayout(self.copy_format_groupbox)
    self.verticalLayout_8.setObjectName("verticalLayout_8")
    self.copy_as_csv = QtWidgets.QRadioButton(self.copy_format_groupbox)
    self.copy_as_csv.setChecked(True)
    self.copy_as_csv.setObjectName("copy_as_csv")
    self.verticalLayout_8.addWidget(self.copy_as_csv)
    self.copy_as_array = QtWidgets.QRadioButton(self.copy_format_groupbox)
    self.copy_as_array.setObjectName("copy_as_array")
    self.verticalLayout_8.addWidget(self.copy_as_array)
    self.cp_data_btn = QtWidgets.QPushButton(self.copy_format_groupbox)
    self.cp_data_btn.setIcon(icon9)
    self.cp_data_btn.setObjectName("cp_data_btn")
    self.verticalLayout_8.addWidget(self.cp_data_btn)
    self.verticalLayout_6.addWidget(self.copy_format_groupbox)
    self.plot_groupbox = QtWidgets.QGroupBox(self.analysis_tab)
    self.plot_groupbox.setObjectName("plot_groupbox")
    self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.plot_groupbox)
    self.verticalLayout_4.setObjectName("verticalLayout_4")
    self.horizontalLayout_11 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_11.setObjectName("horizontalLayout_11")
    self.c_coord_sys = QtWidgets.QRadioButton(self.plot_groupbox)
    self.c_coord_sys.setChecked(True)
    self.c_coord_sys.setObjectName("c_coord_sys")
    self.horizontalLayout_11.addWidget(self.c_coord_sys)
    self.p_coord_sys = QtWidgets.QRadioButton(self.plot_groupbox)
    self.p_coord_sys.setObjectName("p_coord_sys")
    self.horizontalLayout_11.addWidget(self.p_coord_sys)
    self.verticalLayout_4.addLayout(self.horizontalLayout_11)
    self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
    self.horizontalLayout_10.setObjectName("horizontalLayout_10")
    self.wrt_label = QtWidgets.QCheckBox(self.plot_groupbox)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.wrt_label.sizePolicy().hasHeightForWidth())
    self.wrt_label.setSizePolicy(sizePolicy)
    self.wrt_label.setObjectName("wrt_label")
    self.horizontalLayout_10.addWidget(self.wrt_label)
    self.wrt_joint = QtWidgets.QComboBox(self.plot_groupbox)
    self.wrt_joint.setEnabled(False)
    self.wrt_joint.setObjectName("wrt_joint")
    self.horizontalLayout_10.addWidget(self.wrt_joint)
    self.wrt_joint_slot = QtWidgets.QCheckBox(self.plot_groupbox)
    self.wrt_joint_slot.setEnabled(False)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.wrt_joint_slot.sizePolicy().hasHeightForWidth())
    self.wrt_joint_slot.setSizePolicy(sizePolicy)
    self.wrt_joint_slot.setObjectName("wrt_joint_slot")
    self.horizontalLayout_10.addWidget(self.wrt_joint_slot)
    self.verticalLayout_4.addLayout(self.horizontalLayout_10)
    self.line = QtWidgets.QFrame(self.plot_groupbox)
    self.line.setFrameShape(QtWidgets.QFrame.HLine)
    self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line.setObjectName("line")
    self.verticalLayout_4.addWidget(self.line)
    self.gridLayout = QtWidgets.QGridLayout()
    self.gridLayout.setObjectName("gridLayout")
    self.plot_norm_pca = QtWidgets.QCheckBox(self.plot_groupbox)
    self.plot_norm_pca.setObjectName("plot_norm_pca")
    self.gridLayout.addWidget(self.plot_norm_pca, 1, 2, 1, 1)
    self.plot_vel = QtWidgets.QCheckBox(self.plot_groupbox)
    self.plot_vel.setObjectName("plot_vel")
    self.gridLayout.addWidget(self.plot_vel, 1, 0, 1, 1)
    self.plot_fourier = QtWidgets.QCheckBox(self.plot_groupbox)
    self.plot_fourier.setObjectName("plot_fourier")
    self.gridLayout.addWidget(self.plot_fourier, 2, 2, 1, 1)
    self.plot_jerk = QtWidgets.QCheckBox(self.plot_groupbox)
    self.plot_jerk.setObjectName("plot_jerk")
    self.gridLayout.addWidget(self.plot_jerk, 3, 0, 1, 1)
    self.plot_norm = QtWidgets.QCheckBox(self.plot_groupbox)
    self.plot_norm.setObjectName("plot_norm")
    self.gridLayout.addWidget(self.plot_norm, 0, 2, 1, 1)
    self.plot_pos = QtWidgets.QCheckBox(self.plot_groupbox)
    self.plot_pos.setChecked(True)
    self.plot_pos.setObjectName("plot_pos")
    self.gridLayout.addWidget(self.plot_pos, 0, 0, 1, 1)
    self.plot_acc = QtWidgets.QCheckBox(self.plot_groupbox)
    self.plot_acc.setObjectName("plot_acc")
    self.gridLayout.addWidget(self.plot_acc, 2, 0, 1, 1)
    self.plot_signature = QtWidgets.QCheckBox(self.plot_groupbox)
    self.plot_signature.setObjectName("plot_signature")
    self.gridLayout.addWidget(self.plot_signature, 0, 1, 1, 1)
    self.plot_curvature = QtWidgets.QCheckBox(self.plot_groupbox)
    self.plot_curvature.setObjectName("plot_curvature")
    self.gridLayout.addWidget(self.plot_curvature, 1, 1, 1, 1)
    self.plot_btn = QtWidgets.QPushButton(self.plot_groupbox)
    icon10 = QtGui.QIcon()
    icon10.addPixmap(QtGui.QPixmap("icons:formula.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    self.plot_btn.setIcon(icon10)
    self.plot_btn.setObjectName("plot_btn")
    self.gridLayout.addWidget(self.plot_btn, 3, 1, 1, 1)
    self.animate_btn = QtWidgets.QPushButton(self.plot_groupbox)
    self.animate_btn.setIcon(icon)
    self.animate_btn.setObjectName("animate_btn")
    self.gridLayout.addWidget(self.animate_btn, 3, 2, 1, 1)
    self.verticalLayout_4.addLayout(self.gridLayout)
    self.verticalLayout_6.addWidget(self.plot_groupbox)
    self.tab_widget.addTab(self.analysis_tab, icon10, "")
    self.verticalLayout_7.addWidget(self.tab_widget)

    self.retranslateUi(Form)
    self.record_list.setCurrentRow(-1)
    self.wrt_label.toggled['bool'].connect(self.wrt_joint.setEnabled)
    QtCore.QMetaObject.connectSlotsByName(Form)

</t>
<t tx="leo.20231205084741.170">def test_solving(self):
    """Test triangular formula solving.

    + Test for PMKS parser.
    + Test data collecting function.
    + Test expression solving function.
    """

    def test_case(name: str):
        expr, inputs = example_list(name)
        vpoints = parse_vpoints(expr)
        exprs = t_config(vpoints, inputs)
        result = expr_solving(exprs, vpoints, {pair: 0. for pair in inputs})
        return result[-1]

    x, y = test_case("Jansen's linkage (Single)")
    self.assertAlmostEqual(-43.170055, x, 6)
    self.assertAlmostEqual(-91.753226, y, 6)
    x, y = test_case("Crank slider (RP joint)")
    self.assertAlmostEqual(103.801126, x, 6)
    self.assertAlmostEqual(78.393173, y, 6)
    x, y = test_case("Parallel Linkage")
    self.assertAlmostEqual(200, x, 6)
    self.assertAlmostEqual(0, y, 6)
    # TODO: New test case for Inverted slider

</t>
<t tx="leo.20231205084741.171">def test_solving_bfgs(self):
    """Test Sketch Solve kernel."""
    expr, _ = example_list("Jansen's linkage (Single)")
    system = SolverSystem(parse_vpoints(expr), {(0, 1): 0.})
    result = system.solve()
    x, y = result[7]
    self.assertAlmostEqual(-43.170055, x, 6)
    self.assertAlmostEqual(-91.753226, y, 6)
    # Test if angle value changed
    system.set_inputs({(0, 1): 45.})
    result = system.solve()
    x, y = result[7]
    self.assertAlmostEqual(-24.406394, x, 6)
    self.assertAlmostEqual(-91.789596, y, 6)
    # Test if link length changed
    system.set_data({(0, 1): 16.})
    result = system.solve()
    x, y = result[7]
    self.assertAlmostEqual(-24.117994, x, 6)
    self.assertAlmostEqual(-91.198072, y, 6)
</t>
<t tx="leo.20231205084741.172">@path Y:/tmp/metapyslvs/pyslvs/test/
# -*- coding: utf-8 -*-

"""Pyslvs EFD module test."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from pyslvs import efd_fitting
from numpy import array, isclose
from . import TestBase

PATH = array([
    [14.928108089437242, 90.01002059789568],
    [-3.25371009238094, 85.46456605244113],
    [-16.763462931659024, 76.52439024390245],
    [-39.6173464560173, 57.055475143350215],
    [-49.46583130450215, 35.085778173653246],
    [-27.739072687756586, 14.939024390243903],
    [-2.117346456017304, 19.17668726456234],
    [17.958411119740273, 37.7372933251684],
    [26.291744453073605, 57.81305090092597],
    [43.71598687731603, 68.41911150698658],
    [47.12507778640693, 80.5403236281987],
    [38.41295657428572, 90.38880847668355],
    [27.80689596822512, 91.1463842342593],
])
TARGET = array([
    [39.35863965131904, 83.29742588206082],
    [28.06426978660421, 90.17530230145958],
    [14.322369428735222, 89.31456476623697],
    [1.644141648731889, 84.80316243236997],
    [-10.594878257867837, 78.05523268450065],
    [-21.481011313772758, 69.6418738549989],
    [-31.51422384342044, 60.88040361398968],
    [-40.927190098600846, 50.42944632397454],
    [-45.28855318333383, 38.500182501760776],
    [-41.441192886353605, 27.955187648838773],
    [-32.07610003945156, 19.668006412715144],
    [-20.786321365878784, 15.481233369294323],
    [-9.16297124779308, 17.901961900785633],
    [1.8680500961438629, 24.16562879325819],
    [11.095844581723647, 32.082393132610164],
    [17.236398712404707, 43.47293538379268],
    [22.444136258469218, 55.055717188525996],
    [31.20682510176712, 62.82443436686037],
    [40.133214266242625, 71.61536010397093],
    [39.35863965131904, 83.29742588206082],
])


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.173">class EFDTest(TestBase):

    def test_fitting(self):
        ans = efd_fitting(PATH, 20)
        self.assertTrue(isclose(ans, TARGET).all())
</t>
<t tx="leo.20231205084741.174">@path Y:/tmp/metapyslvs/pyslvs/test/
# -*- coding: utf-8 -*-

"""Pyslvs graph module test."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from pyslvs.graph import (
    link_assortment,
    contracted_link_assortment,
    Graph,
    is_planar,
    external_loop_layout,
    conventional_graph,
    contracted_graph,
    link_synthesis,
    contracted_link_synthesis,
)
from . import TestBase

DEGREE_CODE_TABLE = [
    (7, [(0, 1), (1, 2), (0, 2)]),
    (51, [(0, 1), (1, 2), (2, 3), (0, 3)]),
    (62, [(0, 1), (1, 2), (2, 3), (0, 3), (0, 2)]),
    (63, [(0, 1), (1, 2), (2, 3), (0, 3), (0, 2), (1, 3)]),
    (787, [(0, 1), (1, 2), (2, 3), (3, 4), (0, 4)]),
    (937, [(0, 1), (1, 2), (2, 3), (3, 4), (0, 4), (0, 2)]),
    (504, [(0, 1), (1, 2), (2, 3), (0, 3), (0, 4), (4, 2)]),
    (947, [(0, 1), (1, 2), (2, 3), (0, 3), (0, 4), (4, 2), (1, 4)]),
    (1010, [(0, 1), (1, 2), (2, 3), (3, 4), (0, 4), (0, 2), (0, 3)]),
    (1016, [(0, 1), (1, 2), (2, 3), (0, 3), (0, 4), (4, 2), (0, 2)]),
    (1011, [(0, 1), (1, 2), (2, 3), (3, 4), (0, 4), (0, 2), (0, 3), (1, 4)]),
    (1020, [(0, 1), (1, 2), (2, 3), (0, 3), (0, 4), (4, 2), (0, 2), (1, 4)]),
    (1022,
     [(0, 1), (1, 2), (2, 3), (0, 3), (0, 4), (4, 2), (0, 2), (1, 4), (1, 3)]),
    (24851, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (0, 5)]),
    (15169, [(0, 1), (1, 2), (2, 3), (3, 4), (0, 4), (0, 5), (3, 5)]),
    (27050, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (0, 5), (0, 2), (3, 5)]),
    (29459, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (0, 5), (0, 2), (1, 3)]),
    (29326, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (0, 5), (0, 3), (1, 5)]),
    (31497, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (0, 5), (0, 3), (0, 4)]),
    (31064, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (0, 5), (0, 2), (0, 4)]),
    (24344, [(0, 1), (1, 2), (2, 3), (3, 4), (0, 4), (0, 3), (0, 5), (2, 5)]),
    (31553, [(0, 1), (1, 2), (2, 3), (3, 4), (0, 4), (0, 2), (0, 5), (2, 5)]),
    (16320, [(0, 1), (1, 2), (2, 3), (0, 3), (0, 4), (2, 4), (0, 5), (2, 5)]),
    (29327, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (0, 5), (0, 3), (1, 5),
             (2, 4)]),
    (30358, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (0, 5), (0, 4), (1, 5),
             (2, 4)]),
    (31507, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (0, 5), (0, 4), (1, 5),
             (3, 5)]),
    (30485, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (0, 5), (0, 3), (2, 5),
             (2, 4)]),
]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.175">class GraphTest(TestBase):

    @others
</t>
<t tx="leo.20231205084741.176">def test_graph_basic(self):
    """Test 'graph' libraries."""
    g1 = Graph([(0, 1), (0, 4), (1, 5), (2, 3), (2, 4), (3, 5), (4, 5)])
    self.assertFalse(g1.is_degenerate())
    self.assertTrue(g1.is_connected())
    self.assertEqual(1, g1.dof())

</t>
<t tx="leo.20231205084741.177">def test_graph_isomorphic(self):
    g1 = Graph([(0, 1), (0, 4), (1, 5), (2, 3), (2, 4), (3, 5), (4, 5)])
    g2 = Graph([(0, 2), (0, 4), (1, 3), (1, 4), (2, 5), (3, 5), (4, 5)])
    g3 = Graph([(0, 1), (0, 2), (1, 4), (2, 5), (3, 4), (3, 5), (4, 5)])
    self.assertTrue(g1.is_isomorphic(g2))
    self.assertFalse(g1.is_isomorphic(g3))

</t>
<t tx="leo.20231205084741.178">def test_graph_planar(self):
    g1 = Graph([
        (0, 1), (2, 7), (1, 5), (1, 6), (3, 6), (0, 4), (3, 7), (2, 5),
        (3, 4), (0, 2),
    ])
    self.assertTrue(is_planar(g1))
    self.assertEqual([4, 4], link_assortment(g1))
    self.assertEqual([4, 0, 0, 0], contracted_link_assortment(g1))

</t>
<t tx="leo.20231205084741.179">def test_graph_degenerate(self):
    g1 = Graph([(0, 1), (0, 2), (2, 1), (0, 3), (3, 4), (4, 5), (5, 1)])
    self.assertTrue(g1.is_degenerate())

</t>
<t tx="leo.20231205084741.18">def retranslateUi(self, Form):
    _translate = QtCore.QCoreApplication.translate
    Form.setWindowTitle(_translate("Form", "Form"))
    self.joint_groupbox.setTitle(_translate("Form", "Inputs"))
    self.joint_list_lable.setText(_translate("Form", "Base points"))
    self.joint_list.setStatusTip(_translate("Form", "Choose a point to be a revolute joint."))
    self.inputs_label_right2.setText(_translate("Form", "&gt;&gt;"))
    self.driver_list_lable.setText(_translate("Form", "Driver points"))
    self.driver_list.setStatusTip(_translate("Form", "Coordinate movement reference."))
    self.variable_add.setStatusTip(_translate("Form", "Add to variable list with above settings."))
    self.variable_groupbox.setTitle(_translate("Form", "Variables"))
    self.variable_up.setStatusTip(_translate("Form", "Upgrade priority of the variable."))
    self.variable_down.setStatusTip(_translate("Form", "Downgrade priority of the variable."))
    self.variable_remove.setStatusTip(_translate("Form", "Delete the specified variable."))
    self.variable_list.setStatusTip(_translate("Form", "All the variable of this mechanism."))
    self.dial_spinbox.setStatusTip(_translate("Form", "Current position of the variable."))
    self.dial_spinbox.setSuffix(_translate("Form", "°"))
    self.groupBox.setTitle(_translate("Form", "Control"))
    self.variable_speed_label.setText(_translate("Form", "Speed:"))
    self.variable_speed.setStatusTip(_translate("Form", "Speed value of the auto driver."))
    self.variable_speed.setSuffix(_translate("Form", " rpm"))
    self.extremeRebound.setStatusTip(_translate("Form", "When solver calls error, auto driver will change the direction."))
    self.extremeRebound.setText(_translate("Form", "Extreme rebound"))
    self.variable_play.setStatusTip(_translate("Form", "Start / Pause the auto driver of this variables."))
    self.variable_stop.setStatusTip(_translate("Form", "Stop the auto driver and return to original place."))
    self.record_start.setStatusTip(_translate("Form", "Start / Stop record."))
    self.update_pos.setStatusTip(_translate("Form", "Update current position as point coordinates."))
    self.tab_widget.setTabText(self.tab_widget.indexOf(self.inputs_tab), _translate("Form", "Inputs"))
    self.record_show.setStatusTip(_translate("Form", "Show path data on the canvas."))
    self.record_show.setText(_translate("Form", "Show path data"))
    self.record_interval_label.setText(_translate("Form", "Interval:"))
    self.record_interval.setStatusTip(_translate("Form", "Each coordinate will be recorded after this angle value."))
    self.record_interval.setSuffix(_translate("Form", "°"))
    self.record_list.setStatusTip(_translate("Form", "All recorded path data of this project."))
    self.update_preview_btn.setStatusTip(_translate("Form", "Refresh preview path data."))
    self.copy_path.setStatusTip(_translate("Form", "Duplicate the current paths with a new name."))
    self.record_remove.setStatusTip(_translate("Form", "Delete the specified path data."))
    self.plot_joint_slot.setText(_translate("Form", "Slot"))
    self.show_btn.setStatusTip(_translate("Form", "Show this joint only."))
    self.show_btn.setText(_translate("Form", "Show only"))
    self.show_all_btn.setText(_translate("Form", "Show all"))
    self.copy_format_groupbox.setTitle(_translate("Form", "Copy"))
    self.copy_as_csv.setText(_translate("Form", "Comma-Separated Values"))
    self.copy_as_array.setText(_translate("Form", "Array-like"))
    self.cp_data_btn.setStatusTip(_translate("Form", "Copy the data of this joint to clipboard."))
    self.cp_data_btn.setText(_translate("Form", "Copy Curve Data"))
    self.plot_groupbox.setTitle(_translate("Form", "Plot"))
    self.c_coord_sys.setText(_translate("Form", "&amp;Cartesian coordinates"))
    self.p_coord_sys.setText(_translate("Form", "&amp;Polar coordinates"))
    self.wrt_label.setText(_translate("Form", "With respect to:"))
    self.wrt_joint_slot.setText(_translate("Form", "Slot"))
    self.plot_norm_pca.setText(_translate("Form", "Normalization (PCA)"))
    self.plot_vel.setText(_translate("Form", "Velocity"))
    self.plot_fourier.setText(_translate("Form", "Fourier Transform"))
    self.plot_jerk.setText(_translate("Form", "Jerk"))
    self.plot_norm.setText(_translate("Form", "Normalization"))
    self.plot_pos.setText(_translate("Form", "Position"))
    self.plot_acc.setText(_translate("Form", "Acceleration"))
    self.plot_signature.setText(_translate("Form", "Path Signature"))
    self.plot_curvature.setText(_translate("Form", "Curvature"))
    self.plot_btn.setStatusTip(_translate("Form", "Plot the data of this joint."))
    self.plot_btn.setText(_translate("Form", "Plot"))
    self.animate_btn.setText(_translate("Form", "Vector Animation"))
    self.tab_widget.setTabText(self.tab_widget.indexOf(self.analysis_tab), _translate("Form", "Analysis"))
</t>
<t tx="leo.20231205084741.180">def test_graph_duplicate(self):
    g1 = Graph([(0, 1), (1, 2), (2, 3), (0, 3)])
    g2 = g1.duplicate([2, 3], 1)
    self.assertEqual(set(g2.edges), {
        (0, 1), (1, 2), (4, 5), (1, 4), (2, 3), (0, 5), (0, 3),
    })

</t>
<t tx="leo.20231205084741.181">def test_graph_loop(self):
    g1 = Graph([
        (0, 1), (4, 10), (1, 3), (2, 9), (5, 6), (4, 5), (5, 7), (8, 10),
        (1, 8), (9, 11), (3, 6), (0, 4), (3, 7), (2, 5), (0, 2), (4, 11),
    ])
    pos = external_loop_layout(g1, True)
    self.assertEqual(set(g1.vertices), set(pos))

</t>
<t tx="leo.20231205084741.182">def test_graph_degree_code(self):
    g1 = Graph([
        (0, 1), (0, 2), (0, 3), (0, 5), (2, 3), (3, 4), (2, 5), (3, 5),
        (4, 6), (3, 6),
    ])
    g2 = Graph([
        (0, 1), (0, 4), (0, 2), (0, 6), (0, 3), (1, 4), (2, 6), (2, 5),
        (3, 6), (2, 3),
    ])
    self.assertTrue(g1.is_isomorphic(g2))
    self.assertEqual(2057732, g1.degree_code())
    self.assertEqual(g1.degree_code(), g2.degree_code())
    for code, edges in DEGREE_CODE_TABLE:
        self.assertEqual(code, Graph(edges).degree_code())

</t>
<t tx="leo.20231205084741.183">def test_atlas(self):
    """Test 'atlas' libraries."""
    answers = []
    # Test assortment [4]
    type_0 = [4]
    cg_list = contracted_graph(type_0)
    for c_j in contracted_link_synthesis(type_0):
        answer = conventional_graph(cg_list, c_j)
        answers.extend(answer)
    self.assertEqual(1, len(answers))
    answers.clear()
    # Test assortment [4, 2]
    type_1 = [4, 2]
    cg_list = contracted_graph(type_1)
    for c_j in contracted_link_synthesis(type_1):
        answer = conventional_graph(cg_list, c_j)
        answers.extend(answer)
    self.assertEqual(2, len(answers))
    answers.clear()
    # Test assortment [4, 4, 0], [5, 2, 1], [6, 0, 2]
    answers_degenerated = []
    for type_2 in ([4, 4, 0], [5, 2, 1], [6, 0, 2]):
        cg_list = contracted_graph(type_2)
        for c_j in contracted_link_synthesis(type_2):
            answer = conventional_graph(cg_list, c_j)
            answers.extend(answer)
            answer = conventional_graph(cg_list, c_j, 2)
            answers_degenerated.extend(answer)
    self.assertEqual(16, len(answers))
    self.assertEqual(40, len(answers_degenerated))

</t>
<t tx="leo.20231205084741.184">def test_number_synthesis(self):
    """Test Number Synthesis function."""
    for nl, nj in [(4, 4), (6, 7), (8, 9), (10, 12)]:
        for factors in link_synthesis(nl, nj):
            count = 0
            for i, factor in enumerate(factors):
                count += factor * (i + 2)
            self.assertEqual(nj, int(count / 2))
</t>
<t tx="leo.20231205084741.185">@path Y:/tmp/metapyslvs/pyslvs/test/
# -*- coding: utf-8 -*-

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from pyslvs.metaheuristics import algorithm, default, AlgorithmType
from pyslvs.metaheuristics.test import TestObj
from . import TestBase


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.186">class AlgorithmTest(TestBase):

    @others
</t>
<t tx="leo.20231205084741.187">def case(self, alg: AlgorithmType):
    """Test with an objective function."""
    settings = {'min_fit': 1e-20, 'report': 10}
    obj = TestObj()
    s = default(alg)
    s.update(settings)
    a = algorithm(alg)(obj, s)
    ans = a.run()
    _, y = a.result()
    self.assertTrue(ans &lt; 1e-10, f"{ans}")
    self.assertEqual(y, ans)

</t>
<t tx="leo.20231205084741.188">def test_rga(self):
    self.case(AlgorithmType.RGA)

</t>
<t tx="leo.20231205084741.189">def test_de(self):
    self.case(AlgorithmType.DE)

</t>
<t tx="leo.20231205084741.19">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/widgets/inputs/
# -*- coding: utf-8 -*-

"""A QGraphics widget to rotate the QDial widget."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from qtpy.QtCore import Qt, Signal, Slot, QSize
from qtpy.QtWidgets import QWidget, QDial, QGraphicsView, QGraphicsScene


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.190">def test_pso(self):
    self.case(AlgorithmType.PSO)

</t>
<t tx="leo.20231205084741.191">def test_fa(self):
    self.case(AlgorithmType.FA)

</t>
<t tx="leo.20231205084741.192">def test_tlbo(self):
    self.case(AlgorithmType.TLBO)
</t>
<t tx="leo.20231205084741.193">@path Y:/tmp/metapyslvs/pyslvs/test/
# -*- coding: utf-8 -*-

"""Pyslvs planar linkage module test."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import cast
from random import random
from math import pi, hypot, sin, cos
from numpy import array
from pyslvs import parse_vpoints, collection_list
from pyslvs.optimization import norm_path, norm_pca, FPlanar, NPlanar
from pyslvs.metaheuristics import (
    algorithm, default, AlgorithmType, Setting,
)
from . import TestBase

_FOUR_BAR = collection_list("Four bar linkage mechanism")
F_PLANAR = FPlanar({
    'expression': parse_vpoints(_FOUR_BAR['expression']),
    'input': list(_FOUR_BAR['input']),
    'same': _FOUR_BAR['same'],
    'placement': {0: (-70, -70, 10), 1: (70, -70, 10)},
    'target': {
        4: [
            (60.3, 118.12),
            (31.02, 115.62),
            (3.52, 110.62),
            (-25.77, 104.91),
            (-81.49, 69.19),
            (-96.47, 54.906),
            (-109.34, 35.98),
            (-121.84, 13.83),
            (-127.56, -20.09),
            (-128.63, -49.74),
            (-117.56, -65.45),
        ]
    },
    'upper': 100.,
    'lower': 0.,
})
N_PLANAR = NPlanar({'target': [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]})
PATH = [
    (6.7700907146387586, 24.644877369732),
    (3.9327689792658944, 26.12795413801081),
    (-0.907462683602656, 26.05153570209126),
    (-6.24548864186997, 24.8225463940994),
    (-11.133346308106713, 23.18479875363321),
    (-15.520041274243832, 21.57064857277561),
    (-19.801999741184225, 19.85946369468313),
    (-24.175969350603772, 17.70314933508058),
    (-28.438413573857005, 14.9864798961492),
    (-32.292254757096046, 11.90810680124495),
    (-35.67126221930281, 8.6512747009891),
    (-38.64892957450998, 5.10259170466386),
    (-41.047776013814655, 1.021821684545207),
    (-42.2630865594439, -3.473263961136975),
    (-41.608226040938476, -7.65939066663121),
    (-38.904742969958264, -10.5580841883062),
    (-34.73026075172416, -11.62017315187812),
    (-30.055836486064223, -11.09019975630983),
    (-25.618933599062636, -9.68103804133981),
    (-21.627062086461947, -7.87802719739308),
    (-18.00286942796385, -5.56985492705963),
    (-14.787669532074853, -2.3636449904643),
    (-12.175023083437713, 1.772565914254553),
    (-10.11835329911016, 6.2409254685245),
    (-8.025279517469247, 10.22777039213621),
    (-5.057922208547721, 13.38647752586898),
    (-0.9343218889706311, 16.0769324633211),
    (3.4945236042052983, 18.8944943173922),
    (6.54573633651432, 21.9527700520141),
    (6.770090714638762, 24.64487736973219),
]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.194">class PlanarTest(TestBase):

    @others
</t>
<t tx="leo.20231205084741.195">def test_norm(self):
    """Test path normalization function."""
    for f in [norm_path, norm_pca]:
        p1 = f(PATH)
        alpha = 2 * pi * random()
        c = cos(alpha)
        s = sin(alpha)
        p2 = f(array(p1) @ array([[c, -s], [s, c]]))
        for i in range(len(PATH)):
            h = hypot(p1[i][0] - p2[i][0], p1[i][1] - p2[i][1])
            self.assertAlmostEqual(0, h, 6)

</t>
<t tx="leo.20231205084741.196">def planar(self, t: AlgorithmType):
    """Algorithm setup for FPlanar."""
    s = default(t)
    s.update({'max_gen': 10, 'report': 10})
    for p in [F_PLANAR, N_PLANAR]:
        alg = algorithm(t)(p, cast(Setting, s))
        alg.run()
        t_f = alg.history()
        self.assertEqual(10, t_f[1][0] - t_f[0][0])

</t>
<t tx="leo.20231205084741.197">def test_case(self):
    self.assertFalse(F_PLANAR.is_two_kernel())

</t>
<t tx="leo.20231205084741.198">def test_rga(self):
    self.planar(AlgorithmType.RGA)

</t>
<t tx="leo.20231205084741.199">def test_de(self):
    self.planar(AlgorithmType.DE)

</t>
<t tx="leo.20231205084741.2">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/widgets/inputs/
# -*- coding: utf-8 -*-

"""The vector animation dialog."""

from typing import Sequence, Tuple, Mapping
from math import cos, sin, atan2, hypot, degrees
from qtpy.QtCore import Qt, Slot, QTimer
from qtpy.QtWidgets import (
    QWidget, QDialog, QVBoxLayout, QHBoxLayout, QSlider, QPushButton, QLabel,
    QSpacerItem, QSizePolicy, QDoubleSpinBox, QComboBox,
)
from qtpy.QtGui import QPaintEvent, QPen, QPixmap, QIcon
from numpy import array, ndarray, isclose, isnan
from pyslvs import VPoint, VLink, VJoint
from pyslvs.optimization import derivative
from pyslvs_ui.graphics import (
    AnimationCanvas, color_qt, convex_hull, LINK_COLOR,
)

_Coord = Tuple[float, float]
_Paths = Sequence[Sequence[_Coord]]
_SliderPaths = Mapping[int, Sequence[_Coord]]
_Vecs = Mapping[int, ndarray]


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.20">class QRotatableView(QGraphicsView):
    """Rotate QDial widget."""
    value_changed = Signal(float)

    @others
</t>
<t tx="leo.20231205084741.200">def test_pso(self):
    self.planar(AlgorithmType.PSO)

</t>
<t tx="leo.20231205084741.201">def test_fa(self):
    self.planar(AlgorithmType.FA)

</t>
<t tx="leo.20231205084741.202">def test_tlbo(self):
    self.planar(AlgorithmType.TLBO)
</t>
<t tx="leo.20231205084741.203">@path Y:/tmp/metapyslvs/pyslvs/test/
# -*- coding: utf-8 -*-

from unittest import TestCase
from time import time


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.204">class TestBase(TestCase):

    def setUp(self) -&gt; None:
        self.t0 = time()

    def tearDown(self) -&gt; None:
        t = time() - self.t0
        print(f"{self.id()} {t * 1000:.04f}ms")
</t>
<t tx="leo.20231205084741.205"></t>
<t tx="leo.20231205084741.21">def __init__(self, parent: QWidget):
    super(QRotatableView, self).__init__(parent)
    scene = QGraphicsScene(self)
    self.setScene(scene)
    self.dial = QDial()
    self.dial.setMinimumSize(QSize(150, 150))
    self.dial.setSingleStep(100)
    self.dial.setPageStep(100)
    self.dial.setInvertedAppearance(True)
    self.dial.setWrapping(True)
    self.dial.setNotchTarget(0.1)
    self.dial.setNotchesVisible(True)
    self.dial.valueChanged.connect(self.__value_changed)
    self.set_maximum(360)
    graphics_item = scene.addWidget(self.dial)
    graphics_item.setRotation(-90)
    # Make the QGraphicsView invisible
    self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
    self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
    self.setFixedHeight(self.dial.height())
    self.setFixedWidth(self.dial.width())
    self.setStyleSheet("border: 0px;")

</t>
<t tx="leo.20231205084741.22">@Slot(int)
def __value_changed(self, value: int) -&gt; None:
    """Value changed signal."""
    self.value_changed.emit(value / 100)

</t>
<t tx="leo.20231205084741.23">def value(self) -&gt; float:
    """Get value method."""
    return self.dial.value() / 100

</t>
<t tx="leo.20231205084741.24">@Slot(float)
def set_value(self, value: float) -&gt; None:
    """Set value method."""
    self.dial.setValue(int(value % 360 * 100))

</t>
<t tx="leo.20231205084741.25">def minimum(self) -&gt; float:
    """Set maximum method."""
    return self.dial.minimum() / 100

</t>
<t tx="leo.20231205084741.26">@Slot(float)
def set_minimum(self, value: float) -&gt; None:
    """Set minimum."""
    self.dial.setMinimum(int(value * 100))

</t>
<t tx="leo.20231205084741.27">def maximum(self) -&gt; float:
    """Set maximum method."""
    return self.dial.maximum() / 100

</t>
<t tx="leo.20231205084741.28">@Slot(float)
def set_maximum(self, value: float) -&gt; None:
    """Set minimum."""
    self.dial.setMaximum(int(value * 100))

</t>
<t tx="leo.20231205084741.29">def setEnabled(self, enabled: bool) -&gt; None:
    """Set enabled."""
    super(QRotatableView, self).setEnabled(enabled)
    self.dial.setEnabled(enabled)
</t>
<t tx="leo.20231205084741.3">class _DynamicCanvas(AnimationCanvas):
    vel: _Vecs
    vel_slider: _Vecs
    acc: _Vecs
    acc_slider: _Vecs

    @others
</t>
<t tx="leo.20231205084741.30">@path Y:/tmp/metapyslvs/Pyslvs-UI/pyslvs_ui/widgets/inputs/
# -*- coding: utf-8 -*-

"""The widget of 'Inputs' tab."""

from __future__ import annotations

__all__ = ['InputsWidget', 'QRotatableView']
__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import (
    TYPE_CHECKING, TypeVar, Tuple, Dict, Mapping, Sequence, Iterator, Optional,
    Callable,
)
from csv import writer
from copy import copy
from numpy import array, ndarray, hypot, arctan2, vstack, hstack
from numpy.fft import fft
from qtpy.QtCore import Signal, Slot, QTimer
from qtpy.QtWidgets import (
    QWidget, QMessageBox, QInputDialog, QListWidgetItem, QApplication,
    QCheckBox,
)
from qtpy.QtGui import QIcon, QPixmap
from pyslvs import VJoint
from pyslvs.optimization import (
    curvature, derivative, path_signature, norm_path, norm_pca,
)
from pyslvs_ui.info import logger
from pyslvs_ui.graphics import DataChartDialog
from pyslvs_ui.widgets.undo_redo import (
    AddInput, DeleteInput, AddPath, DeletePath,
)
from .rotatable import QRotatableView
from .animation import AnimateDialog
from .inputs_ui import Ui_Form

if TYPE_CHECKING:
    from pyslvs_ui.widgets import MainWindowBase

_T = TypeVar('_T')
_Coord = Tuple[float, float]
_Vars = Sequence[Tuple[int, int]]
_Paths = Sequence[Sequence[_Coord]]
_SliderPaths = Mapping[int, Sequence[_Coord]]
_AUTO_PATH = "Auto preview"  # Unified name


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.31">def _no_auto_path(path: Mapping[str, _T]) -&gt; Mapping[str, _T]:
    """Copy paths without auto preview paths."""
    return {name: path for name, path in path.items() if name != _AUTO_PATH}


</t>
<t tx="leo.20231205084741.32">def _variable_int(text: str) -&gt; int:
    """Change variable text to index."""
    return int(text.split()[-1].replace("Point", ""))


</t>
<t tx="leo.20231205084741.33">def _fourier(pos: ndarray) -&gt; ndarray:
    """Fourier Transformation function."""
    c = pos[:, 0] + pos[:, 1] * 1j
    v = fft(hstack([c, c, c]))[len(c):len(c) * 2]
    return vstack([v.real, v.imag]).T


</t>
<t tx="leo.20231205084741.34">class InputsWidget(QWidget, Ui_Form):
    """There has following functions:

    + Function of mechanism variables settings.
    + Path recording.
    """
    __paths: Dict[str, _Paths]
    __slider_paths: Dict[str, _SliderPaths]

    about_to_resolve = Signal()

    @others
</t>
<t tx="leo.20231205084741.35">def __init__(self, parent: MainWindowBase):
    super(InputsWidget, self).__init__(parent)
    self.setupUi(self)
    # parent's function pointer
    self.free_move_btn = parent.free_move_btn
    self.entities_point = parent.entities_point
    self.entities_link = parent.entities_link
    self.vpoints = parent.vpoint_list
    self.vlinks = parent.vlink_list
    self.main_canvas = parent.main_canvas
    self.solve = parent.solve
    self.reload_canvas = parent.reload_canvas
    self.output_to = parent.output_to
    self.conflict = parent.conflict
    self.dof = parent.dof
    self.right_input = parent.right_input
    self.command_stack = parent.cmd_stack
    self.set_coords_as_current = parent.set_coords_as_current
    self.get_back_position = parent.get_back_position
    # Angle panel
    self.dial = QRotatableView(self)
    self.dial.setStatusTip("Input widget of rotatable joint.")
    self.dial.setEnabled(False)
    self.dial.value_changed.connect(self.__update_var)
    self.dial_spinbox.valueChanged.connect(self.__set_var)
    self.inputs_dial_layout.insertWidget(0, self.dial)
    # Play button
    self.variable_stop.clicked.connect(self.variable_value_reset)
    # Timer for play button
    self.inputs_play_shaft = QTimer()
    self.inputs_play_shaft.setInterval(10)
    self.inputs_play_shaft.timeout.connect(self.__change_index)
    # Change the point coordinates with current position
    self.update_pos.clicked.connect(self.set_coords_as_current)
    # Record list
    self.record_list.blockSignals(True)
    self.record_list.addItem(_AUTO_PATH)
    self.record_list.setCurrentRow(0)
    self.record_list.blockSignals(False)
    self.__paths = {_AUTO_PATH: self.main_canvas.path_preview}
    self.__slider_paths = {_AUTO_PATH: self.main_canvas.slider_path_preview}

    def slot(widget: QCheckBox) -&gt; Callable[[int], None]:
        @others
        return func

    # Slot option
    self.plot_joint.currentIndexChanged.connect(slot(self.plot_joint_slot))
    self.wrt_joint.currentIndexChanged.connect(slot(self.wrt_joint_slot))

</t>
<t tx="leo.20231205084741.36">@Slot(int)
def func(ind: int) -&gt; None:
    widget.setEnabled(ind &gt;= 0
                      and self.vpoints[ind].type != VJoint.R)

</t>
<t tx="leo.20231205084741.37">def clear(self) -&gt; None:
    """Clear function to reset widget status."""
    self.__paths = {_AUTO_PATH: self.__paths[_AUTO_PATH]}
    for _ in range(self.record_list.count() - 1):
        self.record_list.takeItem(1)
    self.variable_list.clear()

</t>
<t tx="leo.20231205084741.38">def __set_angle_mode(self) -&gt; None:
    """Change to angle input."""
    self.dial.set_minimum(0)
    self.dial.set_maximum(360)
    self.dial_spinbox.setMinimum(0)
    self.dial_spinbox.setMaximum(360)

</t>
<t tx="leo.20231205084741.39">def __set_unit_mode(self) -&gt; None:
    """Change to unit input."""
    self.dial.set_minimum(-500)
    self.dial.set_maximum(500)
    self.dial_spinbox.setMinimum(-500)
    self.dial_spinbox.setMaximum(500)

</t>
<t tx="leo.20231205084741.4">def __init__(
    self,
    vpoints: Sequence[VPoint],
    vlinks: Sequence[VLink],
    path: _Paths,
    slider_path: _SliderPaths,
    parent: QWidget
):
    super(_DynamicCanvas, self).__init__(parent)
    self.ind = 0
    self.vpoints = vpoints
    self.vlinks = vlinks
    self.path.path = path
    self.path.slider_path = slider_path
    self.vel = {i: derivative(array(path))
                for i, path in enumerate(self.path.path)}
    self.vel_slider = {i: derivative(array(p))
                       for i, p in self.path.slider_path.items()}
    self.acc = {i: derivative(p) for i, p in self.vel.items()}
    self.acc_slider = {i: derivative(p)
                       for i, p in self.vel_slider.items()}
    self.max_ind = max(len(p) for p in self.path.path)
    self.factor = 1.

</t>
<t tx="leo.20231205084741.40">def paths(self) -&gt; Mapping[str, _Paths]:
    """Return current path data."""
    return _no_auto_path(self.__paths)

</t>
<t tx="leo.20231205084741.41">def slider_paths(self) -&gt; Mapping[str, _SliderPaths]:
    """Return current path data."""
    return _no_auto_path(self.__slider_paths)

</t>
<t tx="leo.20231205084741.42">@Slot(tuple)
def set_selection(self, selections: Sequence[int]) -&gt; None:
    """Set one selection from canvas."""
    self.joint_list.setCurrentRow(selections[0])

</t>
<t tx="leo.20231205084741.43">@Slot()
def clear_selection(self) -&gt; None:
    """Clear the points selection."""
    self.driver_list.clear()
    self.joint_list.setCurrentRow(-1)

</t>
<t tx="leo.20231205084741.44">@Slot(int, name='on_joint_list_currentRowChanged')
def __update_relate_points(self, _=None) -&gt; None:
    """Change the point row from input widget."""
    self.driver_list.clear()
    item: Optional[QListWidgetItem] = self.joint_list.currentItem()
    if item is None:
        return
    p0 = _variable_int(item.text())
    base_point = self.vpoints[p0]
    type_int = base_point.type
    if type_int == VJoint.R:
        for i, vpoint in enumerate(self.vpoints):
            if i == p0:
                continue
            if base_point.same_link(vpoint):
                if base_point.grounded() and vpoint.grounded():
                    continue
                self.driver_list.addItem(f"[{vpoint.type_str}] Point{i}")
    elif type_int in {VJoint.P, VJoint.RP}:
        self.driver_list.addItem(f"[{base_point.type_str}] Point{p0}")

</t>
<t tx="leo.20231205084741.45">@Slot(int, name='on_driver_list_currentRowChanged')
def __set_add_var_enabled(self, _=None) -&gt; None:
    """Set enable of 'add variable' button."""
    driver = self.driver_list.currentIndex()
    self.variable_add.setEnabled(driver != -1)

</t>
<t tx="leo.20231205084741.46">@Slot(name='on_variable_add_clicked')
def __add_inputs_variable(
    self,
    p0: Optional[int] = None,
    p1: Optional[int] = None
) -&gt; None:
    """Add variable with '-&gt;' sign."""
    if p0 is None:
        item: Optional[QListWidgetItem] = self.joint_list.currentItem()
        if item is None:
            return
        p0 = _variable_int(item.text())
    if p1 is None:
        item = self.driver_list.currentItem()
        if item is None:
            return
        p1 = _variable_int(item.text())
    # Check DOF
    if self.dof() &lt;= self.input_count():
        QMessageBox.warning(
            self,
            "Wrong DOF",
            "The number of variable must no more than degrees of freedom."
        )
        return
    # Check same link
    if not self.vpoints[p0].same_link(self.vpoints[p1]):
        QMessageBox.warning(
            self,
            "Wrong pair",
            "The base point and driver point should at the same link."
        )
        return
    # Check repeated pairs
    for p0_, p1_, _ in self.input_pairs():
        if {p0, p1} == {p0_, p1_} and self.vpoints[p0].type == VJoint.R:
            QMessageBox.warning(
                self,
                "Wrong pair",
                "There already have a same pair."
            )
            return
    if p0 == p1:
        # One joint by offset
        value = self.vpoints[p0].true_offset()
    else:
        # Two joints by angle
        value = self.vpoints[p0].slope_angle(self.vpoints[p1])
    self.command_stack.push(AddInput('-&gt;'.join((
        f'Point{p0}',
        f"Point{p1}",
        f"{value:.02f}",
    )), self.variable_list))

</t>
<t tx="leo.20231205084741.47">def add_inputs_variables(self, variables: _Vars) -&gt; None:
    """Add from database."""
    for p0, p1 in variables:
        self.__add_inputs_variable(p0, p1)

</t>
<t tx="leo.20231205084741.48">@Slot(QListWidgetItem, name='on_variable_list_itemClicked')
def __dial_ok(self, _=None) -&gt; None:
    """Set the angle of base link and drive link."""
    if self.inputs_play_shaft.isActive():
        return
    row = self.variable_list.currentRow()
    enabled = row &gt; -1
    is_rotatable = (
        enabled
        and not self.free_move_btn.isChecked()
        and self.right_input()
    )
    self.dial.setEnabled(is_rotatable)
    self.dial_spinbox.setEnabled(is_rotatable)
    self.oldVar = self.dial.value()
    self.variable_play.setEnabled(is_rotatable)
    self.variable_speed.setEnabled(is_rotatable)
    item: Optional[QListWidgetItem] = self.variable_list.currentItem()
    if item is None:
        return
    expr = item.text().split('-&gt;')
    p0 = int(expr[0].replace('Point', ''))
    p1 = int(expr[1].replace('Point', ''))
    value = float(expr[2])
    if p0 == p1:
        self.__set_unit_mode()
    else:
        self.__set_angle_mode()
    self.dial.set_value(value if enabled else 0)

</t>
<t tx="leo.20231205084741.49">def variable_excluding(self, row: Optional[int] = None) -&gt; None:
    """Remove variable if the point was been deleted. Default: all."""
    one_row: bool = row is not None
    for i, (b, d, _) in enumerate(self.input_pairs()):
        # If this is not origin point any more
        if one_row and row != b:
            continue
        self.command_stack.push(DeleteInput(i, self.variable_list))

</t>
<t tx="leo.20231205084741.5">@Slot(int)
def set_index(self, ind: int):
    """Set current index."""
    self.ind = ind
    self.update()

</t>
<t tx="leo.20231205084741.50">@Slot(name='on_variable_remove_clicked')
def remove_var(self, row: int = -1) -&gt; None:
    """Remove and reset angle."""
    if row == -1:
        row = self.variable_list.currentRow()
    if not row &gt; -1:
        return
    self.variable_stop.click()
    self.command_stack.push(DeleteInput(row, self.variable_list))
    self.get_back_position()
    self.solve()

</t>
<t tx="leo.20231205084741.51">def interval(self) -&gt; float:
    """Return interval value."""
    return self.record_interval.value()

</t>
<t tx="leo.20231205084741.52">def input_count(self) -&gt; int:
    """Use to show input variable count."""
    return self.variable_list.count()

</t>
<t tx="leo.20231205084741.53">def input_pairs(self) -&gt; Iterator[Tuple[int, int, float]]:
    """Back as point number code."""
    for row in range(self.variable_list.count()):
        var = self.variable_list.item(row).text().split('-&gt;')
        p0 = int(var[0].replace('Point', ''))
        p1 = int(var[1].replace('Point', ''))
        angle = float(var[2])
        yield p0, p1, angle

</t>
<t tx="leo.20231205084741.54">def variable_reload(self) -&gt; None:
    """Auto check the points and type."""
    self.joint_list.clear()
    self.plot_joint.clear()
    self.wrt_joint.clear()
    for i in range(self.entities_point.rowCount()):
        type_text = self.entities_point.item(i, 2).text()
        for w in [self.joint_list, self.plot_joint, self.wrt_joint]:
            w.addItem(f"[{type_text}] Point{i}")
    self.variable_value_reset()

</t>
<t tx="leo.20231205084741.55">@Slot(float)
def __set_var(self, value: float) -&gt; None:
    self.dial.set_value(value)

</t>
<t tx="leo.20231205084741.56">@Slot(float)
def __update_var(self, value: float) -&gt; None:
    """Update the value when rotating QDial."""
    item = self.variable_list.currentItem()
    self.dial_spinbox.blockSignals(True)
    self.dial_spinbox.setValue(value)
    self.dial_spinbox.blockSignals(False)
    if item:
        item_text = item.text().split('-&gt;')
        item_text[-1] = f"{value:.02f}"
        item.setText('-&gt;'.join(item_text))
        self.about_to_resolve.emit()
    if (
        self.record_start.isChecked()
        and abs(self.oldVar - value) &gt; self.record_interval.value()
    ):
        self.main_canvas.record_path()
        self.oldVar = value

</t>
<t tx="leo.20231205084741.57">def variable_value_reset(self) -&gt; None:
    """Reset the value of QDial."""
    if self.inputs_play_shaft.isActive():
        self.variable_play.setChecked(False)
        self.inputs_play_shaft.stop()
    self.get_back_position()
    for i, (p0, p1, _) in enumerate(self.input_pairs()):
        self.variable_list.item(i).setText('-&gt;'.join([
            f'Point{p0}',
            f'Point{p1}',
            f"{self.vpoints[p0].slope_angle(self.vpoints[p1]):.02f}",
        ]))
    self.__dial_ok()
    self.solve()

</t>
<t tx="leo.20231205084741.58">@Slot(bool, name='on_variable_play_toggled')
def __play(self, toggled: bool) -&gt; None:
    """Triggered when play button was changed."""
    self.dial.setEnabled(not toggled)
    self.dial_spinbox.setEnabled(not toggled)
    if toggled:
        self.inputs_play_shaft.start()
    else:
        self.inputs_play_shaft.stop()

</t>
<t tx="leo.20231205084741.59">@Slot()
def __change_index(self) -&gt; None:
    """QTimer change index."""
    index = self.dial.value()
    speed = self.variable_speed.value()
    extreme_rebound = (
        self.conflict.isVisible()
        and self.extremeRebound.isChecked()
    )
    if extreme_rebound:
        speed = -speed
        self.variable_speed.setValue(speed)
    index += speed * 0.06 * (3 if extreme_rebound else 1)
    self.dial.set_value(index)

</t>
<t tx="leo.20231205084741.6">@Slot(float)
def set_factor(self, scalar: float):
    """Set the size of the derived value."""
    self.factor = scalar / self.max_ind
    self.update()

</t>
<t tx="leo.20231205084741.60">@Slot(bool, name='on_record_start_toggled')
def __start_record(self, toggled: bool) -&gt; None:
    """Save to file path data."""
    if toggled:
        self.main_canvas.record_start(int(
            self.dial_spinbox.maximum() / self.record_interval.value()
        ))
        return
    path, path_slider = self.main_canvas.get_record_path()
    name, ok = QInputDialog.getText(
        self,
        "Recording completed!",
        "Please input name tag:"
    )
    i = 0
    name = name or f"Record_{i}"
    while name in self.__paths:
        name = f"Record_{i}"
        i += 1
    QMessageBox.information(self, "Record",
                            "The name tag is being used or empty.")
    self.add_path(name, path, path_slider)

</t>
<t tx="leo.20231205084741.61">def add_path(self, name: str, path: _Paths, slider: _SliderPaths) -&gt; None:
    """Add path function."""
    self.command_stack.push(AddPath(
        self.record_list,
        name,
        self.__paths,
        self.__slider_paths,
        path,
        slider
    ))
    self.record_list.setCurrentRow(self.record_list.count() - 1)

</t>
<t tx="leo.20231205084741.62">def load_paths(self, paths: Mapping[str, _Paths],
               slider_paths: Mapping[str, _SliderPaths]) -&gt; None:
    """Add multiple paths."""
    for name, path in paths.items():
        self.add_path(name, path, slider_paths.get(name, {}))

</t>
<t tx="leo.20231205084741.63">@Slot(name='on_record_remove_clicked')
def __remove_path(self) -&gt; None:
    """Remove path data."""
    row = self.record_list.currentRow()
    if not row &gt; 0:
        return
    self.command_stack.push(DeletePath(
        row,
        self.record_list,
        self.__paths,
        self.__slider_paths
    ))
    self.record_list.setCurrentRow(self.record_list.count() - 1)
    self.reload_canvas()

</t>
<t tx="leo.20231205084741.64">@Slot(QListWidgetItem, name='on_record_list_itemDoubleClicked')
def __path_dlg(self, item: QListWidgetItem) -&gt; None:
    """View path data."""
    name = item.text().split(":", maxsplit=1)[0]
    if name not in self.__paths:
        return
    paths = self.__paths[name]
    if paths:
        points_text = ", ".join(f"Point{i}" for i in range(len(paths)))
    else:
        points_text = "nothing"
    if QMessageBox.question(
        self,
        "Path data",
        f"This path data includes {points_text}.",
        (QMessageBox.Save | QMessageBox.Close),
        QMessageBox.Close
    ) != QMessageBox.Save:
        return
    file_name = self.output_to(
        "path data",
        ["Comma-Separated Values (*.csv)", "Text file (*.txt)"]
    )
    if not file_name:
        return
    with open(file_name, 'w+', encoding='utf-8', newline='') as stream:
        w = writer(stream)
        for path in paths:
            for point in path:
                w.writerow(point)
            w.writerow(())
    logger.info(f"Output path data: {file_name}")

</t>
<t tx="leo.20231205084741.65">def __current_path_name(self) -&gt; str:
    """Return the current path name."""
    return self.record_list.currentItem().text().split(':', maxsplit=1)[0]

</t>
<t tx="leo.20231205084741.66">@Slot(name='on_copy_path_clicked')
def __copy_path(self):
    """Copy path from record list."""
    name = self.__current_path_name()
    num = 0
    name_copy = f"{name}_{num}"
    while name_copy in self.__paths:
        name_copy = f"{name}_{num}"
        num += 1
    self.add_path(name_copy, copy(self.__paths[name]), {})

</t>
<t tx="leo.20231205084741.67">@Slot(name='on_cp_data_btn_clicked')
def __copy_path_data(self) -&gt; None:
    """Copy current path data to clipboard."""
    data = self.__paths[self.__current_path_name()]
    if not data:
        return
    index = self.plot_joint.currentIndex()
    if self.copy_as_csv.isChecked():
        text = '\n'.join(f"{x},{y}" for x, y in data[index])
    elif self.copy_as_array.isChecked():
        text = '\n'.join(f"[{x}, {y}]," for x, y in data[index])
    else:
        raise ValueError("invalid option")
    QApplication.clipboard().setText(text)

</t>
<t tx="leo.20231205084741.68">@Slot(name='on_show_btn_clicked')
def __show_path(self) -&gt; None:
    """Show specified path."""
    self.main_canvas.set_path_show(self.plot_joint.currentIndex())

</t>
<t tx="leo.20231205084741.69">@Slot(name='on_show_all_btn_clicked')
def __show_all_path(self) -&gt; None:
    """Show all paths."""
    self.record_show.setChecked(True)
    self.main_canvas.set_path_show(-1)

</t>
<t tx="leo.20231205084741.7">def get_vel(self, ind: int) -&gt; Tuple[float, float]:
    """Get the magnitude and angle from velocity."""
    vx, vy = self.vel[ind][self.ind]
    return hypot(vx, vy), degrees(atan2(vy, vx))

</t>
<t tx="leo.20231205084741.70">@Slot(bool, name='on_record_show_toggled')
def __set_path_show(self, toggled: bool) -&gt; None:
    """Show all paths or hide."""
    self.main_canvas.set_path_show(-1 if toggled else -2)

</t>
<t tx="leo.20231205084741.71">@Slot(int, name='on_record_list_currentRowChanged')
def __set_path(self, _=None) -&gt; None:
    """Reload the canvas when switch the path."""
    if not self.record_show.isChecked():
        self.record_show.setChecked(True)
    self.reload_canvas()

</t>
<t tx="leo.20231205084741.72">def current_path(self) -&gt; Tuple[_Paths, _SliderPaths]:
    """Return current path data to main canvas.

    + No path.
    + Show path data.
    + Auto preview.
    """
    row = self.record_list.currentRow()
    if row in {0, -1}:
        return (), {}
    name = self.record_list.item(row).text().split(':')[0]
    return self.__paths.get(name, ()), self.__slider_paths.get(name, {})

</t>
<t tx="leo.20231205084741.73">@Slot(name='on_variable_up_clicked')
@Slot(name='on_variable_down_clicked')
def __set_variable_priority(self) -&gt; None:
    row = self.variable_list.currentRow()
    if not row &gt; -1:
        return
    item = self.variable_list.currentItem()
    self.variable_list.insertItem(
        row + (-1 if self.sender() == self.variable_up else 1),
        self.variable_list.takeItem(row)
    )
    self.variable_list.setCurrentItem(item)

</t>
<t tx="leo.20231205084741.74">@Slot(name='on_animate_btn_clicked')
def __animate(self) -&gt; None:
    """Make a motion animation."""
    name = self.__current_path_name()
    data = self.__paths.get(name, [])
    if not data:
        return
    dlg = AnimateDialog(self.vpoints, self.vlinks, data,
                        self.__slider_paths.get(name, {}),
                        self.main_canvas.monochrome, self)
    dlg.show()
    dlg.exec_()
    dlg.deleteLater()

</t>
<t tx="leo.20231205084741.75">@Slot(name='on_plot_btn_clicked')
def __plot(self) -&gt; None:
    """Plot the data. Show the X and Y axes as two line."""
    joint = self.plot_joint.currentIndex()
    name = self.__current_path_name()
    data = self.__paths.get(name, [])
    slider_data = self.__slider_paths.get(name, {})
    if not data:
        return
    if self.plot_joint_slot.isChecked():
        pos = array(slider_data.get(joint, []))
    else:
        pos = array(data[joint])
    if self.wrt_label.isChecked():
        joint_wrt = self.wrt_joint.currentIndex()
        if self.wrt_joint_slot.isChecked():
            pos[:] -= array(slider_data.get(joint_wrt, []))
        else:
            pos[:] -= array(data[joint_wrt])
    plot = {}
    row = 0
    for button, value in [
        (self.plot_pos, lambda: pos),
        (self.plot_vel, vel := lambda: derivative(pos)),
        (self.plot_acc, acc := lambda: derivative(vel())),
        (self.plot_jerk, lambda: derivative(acc())),
        (self.plot_curvature, cur := lambda: curvature(data[joint])),
        (self.plot_signature, lambda: path_signature(cur())),
        (self.plot_norm, lambda: norm_path(pos)),
        (self.plot_norm_pca, lambda: norm_pca(pos)),
        (self.plot_fourier, lambda: _fourier(pos)),
    ]:  # type: QCheckBox, Callable[[], ndarray]
        if button.isChecked():
            row += 1
            plot[button.text()] = value()
    if row &lt; 1:
        QMessageBox.warning(self, "No target", "No any plotting target.")
        return
    polar = self.p_coord_sys.isChecked()
    col = 1
    if polar:
        row, col = col, row
    dlg = DataChartDialog(self, "Analysis", row, col, polar)
    dlg.setWindowIcon(QIcon(QPixmap("icons:formula.png")))
    ax = dlg.ax()
    for p, (title, xy) in enumerate(plot.items()):
        ax_i = ax[p]
        ax_i.set_title(title)
        if title == "Path Signature":
            ax_i.plot(xy[:, 0], xy[:, 1])
            ax_i.set_ylabel(r"$\kappa$")
            ax_i.set_xlabel(r"$\int|\kappa|dt$")
        elif xy.ndim == 2:
            x = xy[:, 0]
            y = xy[:, 1]
            if self.c_coord_sys.isChecked():
                ax_i.plot(x, label='x')
                ax_i.plot(y, label='y')
                ax_i.legend()
            else:
                r = hypot(x, y)
                theta = arctan2(y, x)
                ax_i.plot(theta, r, linewidth=5)
        else:
            ax_i.plot(xy)
    dlg.set_margin(0.2)
    dlg.show()
    dlg.exec_()
    dlg.deleteLater()
</t>
<t tx="leo.20231205084741.76"></t>
<t tx="leo.20231205084741.77">@path Y:/tmp/metapyslvs/Pyslvs-UI/scripts/
# -*- coding: utf-8 -*-
from pyslvs_ui.__main__ import main

main()
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.78">@path Y:/tmp/metapyslvs/Pyslvs-UI/scripts/
# -*- coding: utf-8 -*-

from PyInstaller.utils.hooks import copy_metadata

datas = copy_metadata('PyQt5')
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.79">@path Y:/tmp/metapyslvs/Pyslvs-UI/scripts/
# -*- coding: utf-8 -*-

"""Compile source code files from UI files. PyQt5 required."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from os import walk
from os.path import join
from re import sub
from qtpy import PYQT5

if PYQT5:
    from PyQt5.uic import compileUi
else:
    raise ModuleNotFoundError("no compiler found")


@others
if __name__ == '__main__':
    gen_ui()
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.8">def get_acc(self, ind: int) -&gt; Tuple[float, float]:
    """Get the magnitude and angle from acceleration."""
    vx, vy = self.acc[ind][self.ind]
    return hypot(vx, vy), degrees(atan2(vy, vx))

</t>
<t tx="leo.20231205084741.80">def gen_ui():
    """Compile GUIs."""
    count = 0
    for root, _, files in walk("pyslvs_ui"):
        for file in files:
            if not file.endswith('.ui'):
                continue
            target_name = sub(r"([\w ]+)\.ui", r"\1_ui.py", file)
            with open(join(root, target_name), 'w+', encoding='utf-8') as f:
                compileUi(
                    join(root, file).replace('\\', '/'),
                    f,
                    from_imports='pyslvs_ui',
                    import_from='pyslvs_ui'
                )
                f.seek(0)
                script_new = sub(r"from [\w.]+ import [\w]+_rc\n", "",
                                 f.read()
                                 .replace("from PyQt5", "from qtpy")
                                 .replace("from PySide2", "from qtpy")
                                 .replace(root + "/", ""))
                f.seek(0)
                f.truncate()
                f.write(script_new)
            count += 1
    print(f"Compiled {count} UI file(s)")


</t>
<t tx="leo.20231205084741.81"></t>
<t tx="leo.20231205084741.82">@path Y:/tmp/metapyslvs/metaheuristics/
# -*- coding: utf-8 -*-

from typing import TypedDict
from .de import Strategy


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.83">class Setting(TypedDict, total=False):
    pop_num: int
    max_gen: int
    min_fit: float
    max_time: float
    slow_down: float
    report: int
    parallel: bool


</t>
<t tx="leo.20231205084741.84">class DESetting(Setting):
    strategy: Strategy
    f: float
    cr: float


</t>
<t tx="leo.20231205084741.85">class RGASetting(Setting):
    cross: float
    mutate: float
    win: float
    delta: float


</t>
<t tx="leo.20231205084741.86">class PSOSetting(Setting):
    cognition: float
    social: float
    velocity: float


</t>
<t tx="leo.20231205084741.87">class FASetting(Setting):
    alpha: float
    beta_min: float
    beta0: float
    gamma: float


</t>
<t tx="leo.20231205084741.88">class TOBLSetting(Setting):
    pass
</t>
<t tx="leo.20231205084741.89">@path Y:/tmp/metapyslvs/metaheuristics/
# -*- coding: utf-8 -*-

"""Kernel of Metaheuristic Algorithm."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2022"
__license__ = "AGPL"
__email__ = "pyslvs@gmail.com"

from typing import Mapping, Dict, Union, Type
from enum import unique, Enum
from .utility import ObjFunc, Algorithm
from .config_types import (
    Setting, DESetting, FASetting, RGASetting, TOBLSetting,
)
from .rga import RGA
from .de import DE
from .pso import PSO
from .fa import FA
from .tlbo import TLBO


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.9">def paintEvent(self, event: QPaintEvent) -&gt; None:
    """Drawing function."""
    super(_DynamicCanvas, self).paintEvent(event)
    pen = QPen()
    pen.setWidth(self.link_width)
    brush = color_qt('dark-gray') if self.monochrome else LINK_COLOR
    self.painter.setBrush(brush)
    for vlink in self.vlinks:
        if vlink.name == VLink.FRAME or not vlink.points:
            continue
        points = []
        for i in vlink.points:
            vpoint = self.vpoints[i]
            if (vpoint.type == VJoint.R
                    or not vpoint.is_slot_link(vlink.name)):
                x, y = self.path.path[i][self.ind]
            else:
                x, y = self.path.slider_path[i][self.ind]
            points.append((x * self.zoom, y * -self.zoom))
        qpoints = convex_hull(points, as_qpoint=True)
        pen.setColor(Qt.black if self.monochrome else color_qt(vlink.color))
        self.painter.setPen(pen)
        self.painter.drawPolygon(*qpoints)
    self.painter.setBrush(Qt.NoBrush)
    pen.setWidth(self.path_width)
    for paths, vel, acc in [
        (enumerate(self.path.path), self.vel, self.acc),
        (self.path.slider_path.items(), self.vel_slider, self.acc_slider),
    ]:
        for i, path in paths:
            vpoint = self.vpoints[i]
            if self.monochrome:
                color = color_qt('gray')
            else:
                color = color_qt(vpoint.color)
            pen.setColor(color)
            self.painter.setPen(pen)
            self.draw_curve(path)
            x, y = path[self.ind]
            zoom = 1.
            for vec, color in [(vel[i], Qt.blue), (acc[i], Qt.red)]:
                if self.ind &gt;= len(vec):
                    break
                vx, vy = vec[self.ind]
                if isnan(vx) or isnan(vy):
                    break
                zoom /= self.factor
                r = hypot(vx, vy) * zoom
                if isclose(r, 0):
                    break
                th = atan2(vy, vx)
                pen.setColor(color)
                self.painter.setPen(pen)
                self.draw_arrow(x, y, x + r * cos(th), y + r * sin(th))
            self.draw_point(i, x, y, vpoint.grounded(), vpoint.color)
    self.painter.end()


</t>
<t tx="leo.20231205084741.90">@unique
class AlgorithmType(str, Enum):
    """Enum type of algorithms."""
    RGA = "Real-coded Genetic Algorithm"
    DE = "Differential Evolution"
    PSO = "Particle Swarm Optimization"
    FA = "Firefly Algorithm"
    TLBO = "Teaching Learning Based Optimization"


</t>
<t tx="leo.20231205084741.91">_ALGORITHM: Mapping[AlgorithmType, Type[Algorithm]] = {
    AlgorithmType.RGA: RGA,
    AlgorithmType.DE: DE,
    AlgorithmType.PSO: PSO,
    AlgorithmType.FA: FA,
    AlgorithmType.TLBO: TLBO,
}
_DEFAULT_PARAMS = {'max_gen': 1000, 'report': 50}
_PARAMS: Mapping[AlgorithmType, Dict[str, Union[int, float]]] = {
    AlgorithmType.RGA: {
        'pop_num': 500,
        'cross': 0.95,
        'mutate': 0.05,
        'win': 0.95,
        'delta': 5.,
    },
    AlgorithmType.DE: {
        'pop_num': 400,
        'strategy': 1,
        'f': 0.6,
        'cr': 0.9,
    },
    AlgorithmType.PSO: {
        'pop_num': 200,
        'cognition': 2.05,
        'social': 2.05,
        'velocity': 1.3,
    },
    AlgorithmType.FA: {
        'pop_num': 80,
        'alpha': 1.,
        'beta_min': 1.,
        'gamma': 0.01,
    },
    AlgorithmType.TLBO: {
        'pop_num': 50,
    },
}


</t>
<t tx="leo.20231205084741.92">def algorithm(opt: AlgorithmType) -&gt; Type[Algorithm]:
    """Return the class of the algorithms."""
    return _ALGORITHM[opt]


</t>
<t tx="leo.20231205084741.93">def default(opt: AlgorithmType) -&gt; Dict[str, Union[int, float]]:
    """Return the default settings of the algorithms."""
    config = _PARAMS[opt].copy()
    config.update(_DEFAULT_PARAMS.copy())
    return config
</t>
<t tx="leo.20231205084741.94"></t>
<t tx="leo.20231205084741.95">@path Y:/tmp/metapyslvs/pyslvs/
# -*- coding: utf-8 -*-

from os import walk
from os.path import sep, join as pth_join
from setuptools import setup, Extension
from setuptools.command.build_ext import build_ext
from platform import system

root_path = 'pyslvs'
bfgs_path = pth_join(root_path, 'bfgs_solver')
tinycadlib_path = pth_join(root_path, 'tinycadlib')
macros = [('_USE_MATH_DEFINES', None)]
compile_args_msvc = ['/O2', '/std:c++17']
compile_args = ['-Wno-cpp', '-std=c++17']
link_args = []
link_args_msvc = []
link_args_static = [
    '-static-libgcc',
    '-static-libstdc++',
    '-Wl,-Bstatic,--whole-archive',
    '-lwinpthread',
    '-Wl,--no-whole-archive',
]
if system() == 'Windows':
    # Disable format warning
    compile_args.append('-Wno-format')
# Disable NumPy warning
macros.append(('NPY_NO_DEPRECATED_API', 'NPY_1_7_API_VERSION'))
# Special modules mixed with C++ (language must be unified)
ext_modules = [
    Extension(root_path.replace(sep, '.') + '.bfgs', [
        pth_join(root_path, 'bfgs.pyx'),
        pth_join(bfgs_path, 'constraints.cpp'),
        pth_join(bfgs_path, 'solve.cpp'),
        pth_join(bfgs_path, 'calc.cpp'),
    ], language="c++", include_dirs=[bfgs_path]),
    Extension(root_path.replace(sep, '.') + '.tinycadlib', [
        pth_join(root_path, 'tinycadlib.pyx'),
        pth_join(tinycadlib_path, 'solver.cpp'),
    ], language="c++", include_dirs=[tinycadlib_path]),
]
# To find other sources recursively
for root, _, files in walk(root_path):
    for source in files:
        if not source.endswith('.pyx'):
            continue
        if root == root_path and source in {'bfgs.pyx', 'tinycadlib.pyx'}:
            continue
        f_name = pth_join(root, source)
        ext_modules.append(Extension(
            f_name.replace(sep, '.').rsplit('.', maxsplit=1)[0],  # Name
            [f_name],
            language="c++", include_dirs=list({root_path, root})
        ))
for ext in ext_modules:
    ext.cython_directives = {'binding': True, 'cdivision': True}


@others
setup(ext_modules=ext_modules, cmdclass={'build_ext': Build})
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084741.96">class Build(build_ext):

    @others
</t>
<t tx="leo.20231205084741.97">def build_extensions(self):
    compiler = self.compiler.compiler_type
    if compiler in {'mingw32', 'unix'}:
        for e in self.extensions:
            e.define_macros = macros
            e.extra_compile_args = compile_args
            if compiler == 'mingw32':
                e.extra_link_args = link_args_static
            else:
                e.extra_link_args = link_args
    elif compiler == 'msvc':
        for e in self.extensions:
            e.define_macros = macros[:1]
            e.extra_compile_args = compile_args_msvc
            e.extra_link_args = link_args_msvc
    super(Build, self).build_extensions()


</t>
<t tx="leo.20231205084741.99"></t>
<t tx="leo.20231205084742.10">def run(self):
    copy_source(self.dry_run)
    super(PackSource, self).run()
    if not self.keep_temp:
        dir_util.remove_tree(include_path, dry_run=self.dry_run)
        dir_util.remove_tree(src_path, dry_run=self.dry_run)
        dir_util.remove_tree(extlib_path, dry_run=self.dry_run)


</t>
<t tx="leo.20231205084742.12"></t>
<t tx="leo.20231205084742.13">@path Y:/tmp/metapyslvs/solvespace/cython/python_solvespace/
# -*- coding: utf-8 -*-

"""'python_solvespace' module is a wrapper of
Python binding Solvespace solver libraries.
"""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2019"
__license__ = "GPLv3+"
__email__ = "pyslvs@gmail.com"
__version__ = "3.0.8"

from .slvs import (
    quaternion_u,
    quaternion_v,
    quaternion_n,
    make_quaternion,
    Constraint,
    ResultFlag,
    Params,
    Entity,
    SolverSystem,
)

__all__ = [
    'quaternion_u',
    'quaternion_v',
    'quaternion_n',
    'make_quaternion',
    'Constraint',
    'ResultFlag',
    'Params',
    'Entity',
    'SolverSystem',
]
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084742.14"></t>
<t tx="leo.20231205084742.15">@path Y:/tmp/metapyslvs/solvespace/cython/test/
# -*- coding: utf-8 -*-

"""This module will test the functions of Python-Solvespace."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2019"
__license__ = "GPLv3+"
__email__ = "pyslvs@gmail.com"

from unittest import TestCase
from math import radians
from python_solvespace import ResultFlag, SolverSystem, make_quaternion


@others
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084742.16">class CoreTest(TestCase):

    @others
</t>
<t tx="leo.20231205084742.17">def test_crank_rocker(self):
    """Crank rocker example."""
    sys = SolverSystem()
    wp = sys.create_2d_base()
    p0 = sys.add_point_2d(0, 0, wp)
    sys.dragged(p0, wp)
    p1 = sys.add_point_2d(90, 0, wp)
    sys.dragged(p1, wp)
    line0 = sys.add_line_2d(p0, p1, wp)
    p2 = sys.add_point_2d(20, 20, wp)
    p3 = sys.add_point_2d(0, 10, wp)
    p4 = sys.add_point_2d(30, 20, wp)
    sys.distance(p2, p3, 40, wp)
    sys.distance(p2, p4, 40, wp)
    sys.distance(p3, p4, 70, wp)
    sys.distance(p0, p3, 35, wp)
    sys.distance(p1, p4, 70, wp)
    line1 = sys.add_line_2d(p0, p3, wp)
    sys.angle(line0, line1, 45, wp)

    sys_new = sys.copy()  # solver copy test

    result_flag = sys.solve()
    self.assertEqual(result_flag, ResultFlag.OKAY)
    x, y = sys.params(p2.params)
    self.assertAlmostEqual(39.54852, x, 4)
    self.assertAlmostEqual(61.91009, y, 4)

    result_flag = sys_new.solve()
    self.assertEqual(result_flag, ResultFlag.OKAY)
    x, y = sys_new.params(p2.params)
    self.assertAlmostEqual(39.54852, x, 4)
    self.assertAlmostEqual(61.91009, y, 4)

</t>
<t tx="leo.20231205084742.18">def test_involute(self):
    """Involute example."""
    r = 10
    angle = 45

    sys = SolverSystem()
    wp = sys.create_2d_base()
    p0 = sys.add_point_2d(0, 0, wp)
    sys.dragged(p0, wp)

    p1 = sys.add_point_2d(0, 10, wp)
    sys.distance(p0, p1, r, wp)
    line0 = sys.add_line_2d(p0, p1, wp)

    p2 = sys.add_point_2d(10, 10, wp)
    line1 = sys.add_line_2d(p1, p2, wp)
    sys.distance(p1, p2, r * radians(angle), wp)
    sys.perpendicular(line0, line1, wp, False)

    p3 = sys.add_point_2d(10, 0, wp)
    sys.dragged(p3, wp)
    line_base = sys.add_line_2d(p0, p3, wp)
    sys.angle(line0, line_base, angle, wp)

    result_flag = sys.solve()
    self.assertEqual(result_flag, ResultFlag.OKAY)
    x, y = sys.params(p2.params)
    self.assertAlmostEqual(12.62467, x, 4)
    self.assertAlmostEqual(1.51746, y, 4)

</t>
<t tx="leo.20231205084742.19">def test_jansen_linkage(self):
    """Jansen's linkage example."""
    sys = SolverSystem()
    wp = sys.create_2d_base()
    p0 = sys.add_point_2d(0, 0, wp)
    sys.dragged(p0, wp)

    p1 = sys.add_point_2d(0, 20, wp)
    sys.distance(p0, p1, 15, wp)
    line0 = sys.add_line_2d(p0, p1, wp)

    p2 = sys.add_point_2d(-38, -7.8, wp)
    sys.dragged(p2, wp)
    p3 = sys.add_point_2d(-50, 30, wp)
    p4 = sys.add_point_2d(-70, -15, wp)
    sys.distance(p2, p3, 41.5, wp)
    sys.distance(p3, p4, 55.8, wp)
    sys.distance(p2, p4, 40.1, wp)

    p5 = sys.add_point_2d(-50, -50, wp)
    p6 = sys.add_point_2d(-10, -90, wp)
    p7 = sys.add_point_2d(-20, -40, wp)
    sys.distance(p5, p6, 65.7, wp)
    sys.distance(p6, p7, 49.0, wp)
    sys.distance(p5, p7, 36.7, wp)

    sys.distance(p1, p3, 50, wp)
    sys.distance(p1, p7, 61.9, wp)

    p8 = sys.add_point_2d(20, 0, wp)
    line_base = sys.add_line_2d(p0, p8, wp)
    sys.angle(line0, line_base, 45, wp)

    result_flag = sys.solve()
    self.assertEqual(result_flag, ResultFlag.OKAY)
    x, y = sys.params(p8.params)
    self.assertAlmostEqual(18.93036, x, 4)
    self.assertAlmostEqual(13.63778, y, 4)

</t>
<t tx="leo.20231205084742.2"></t>
<t tx="leo.20231205084742.20">def test_nut_cracker(self):
    """Nut cracker example."""
    h0 = 0.5
    b0 = 0.75
    r0 = 0.25
    n1 = 1.5
    n2 = 2.3
    l0 = 3.25

    sys = SolverSystem()
    wp = sys.create_2d_base()
    p0 = sys.add_point_2d(0, 0, wp)
    sys.dragged(p0, wp)

    p1 = sys.add_point_2d(2, 2, wp)
    p2 = sys.add_point_2d(2, 0, wp)
    line0 = sys.add_line_2d(p0, p2, wp)
    sys.horizontal(line0, wp)

    line1 = sys.add_line_2d(p1, p2, wp)
    p3 = sys.add_point_2d(b0 / 2, h0, wp)
    sys.dragged(p3, wp)
    sys.distance(p3, line1, r0, wp)
    sys.distance(p0, p1, n1, wp)
    sys.distance(p1, p2, n2, wp)

    result_flag = sys.solve()
    self.assertEqual(result_flag, ResultFlag.OKAY)
    x, _ = sys.params(p2.params)
    ans_min = x - b0 / 2
    ans_max = l0 - r0 - b0 / 2
    self.assertAlmostEqual(1.01576, ans_min, 4)
    self.assertAlmostEqual(2.625, ans_max, 4)

</t>
<t tx="leo.20231205084742.21">def test_pydemo(self):
    """Some sample code for slvs.dll.
    We draw some geometric entities, provide initial guesses for their positions,
    and then constrain them. The solver calculates their new positions,
    in order to satisfy the constraints.

    Copyright 2008-2013 Jonathan Westhues.
    Copyright 2016-2017 Yuan Chang [pyslvs@gmail.com] Python-Solvespace bundled.

    An example of a constraint in 2d. In our first group, we create a workplane
    along the reference frame's xy plane. In a second group, we create some
    entities in that group and dimension them.
    """
    sys = SolverSystem()
    sys.set_group(1)

    # First, we create our workplane. Its origin corresponds to the origin
    # of our base frame (x y z) = (0 0 0)
    p101 = sys.add_point_3d(0, 0, 0)
    # and it is parallel to the xy plane, so it has basis vectors (1 0 0)
    # and (0 1 0).
    qw, qx, qy, qz = make_quaternion(1, 0, 0, 0, 1, 0)
    n102 = sys.add_normal_3d(qw, qx, qy, qz)
    wp200 = sys.add_work_plane(p101, n102)

    # Now create a second group. We'll solve group 2, while leaving group 1
    # constant; so the workplane that we've created will be locked down,
    # and the solver can't move it.
    sys.set_group(2)
    p301 = sys.add_point_2d(10, 20, wp200)
    p302 = sys.add_point_2d(20, 10, wp200)

    # And we create a line segment with those endpoints.
    l400 = sys.add_line_2d(p301, p302, wp200)

    # Now three more points.
    p303 = sys.add_point_2d(100, 120, wp200)
    p304 = sys.add_point_2d(120, 110, wp200)
    p305 = sys.add_point_2d(115, 115, wp200)

    # And arc, centered at point 303, starting at point 304, ending at
    # point 305.
    a401 = sys.add_arc(n102, p303, p304, p305, wp200)

    # Now one more point, and a distance
    p306 = sys.add_point_2d(200, 200, wp200)
    d307 = sys.add_distance(30, wp200)

    # And a complete circle, centered at point 306 with radius equal to
    # distance 307. The normal is 102, the same as our workplane.
    c402 = sys.add_circle(n102, p306, d307, wp200)

    # The length of our line segment is 30.0 units.
    sys.distance(p301, p302, 30, wp200)

    # And the distance from our line segment to the origin is 10.0 units.
    sys.distance(p101, l400, 10, wp200)

    # And the line segment is vertical.
    sys.vertical(l400, wp200)

    # And the distance from one endpoint to the origin is 15.0 units.
    sys.distance(p301, p101, 15, wp200)

    # The arc and the circle have equal radius.
    sys.equal(a401, c402, wp200)

    # The arc has radius 17.0 units.
    sys.diameter(a401, 17 * 2)

    # If the solver fails, then ask it to report which constraints caused
    # the problem.

    # And solve.
    result_flag = sys.solve()
    self.assertEqual(result_flag, ResultFlag.OKAY)
    x, y = sys.params(p301.params)
    self.assertAlmostEqual(10, x, 4)
    self.assertAlmostEqual(11.18030, y, 4)
    x, y = sys.params(p302.params)
    self.assertAlmostEqual(10, x, 4)
    self.assertAlmostEqual(-18.81966, y, 4)
    x, y = sys.params(p303.params)
    self.assertAlmostEqual(101.11418, x, 4)
    self.assertAlmostEqual(119.04153, y, 4)
    x, y = sys.params(p304.params)
    self.assertAlmostEqual(116.47661, x, 4)
    self.assertAlmostEqual(111.76171, y, 4)
    x, y = sys.params(p305.params)
    self.assertAlmostEqual(117.40922, x, 4)
    self.assertAlmostEqual(114.19676, y, 4)
    x, y = sys.params(p306.params)
    self.assertAlmostEqual(200, x, 4)
    self.assertAlmostEqual(200, y, 4)
    x, = sys.params(d307.params)
    self.assertAlmostEqual(17, x, 4)
    self.assertEqual(6, sys.dof())
</t>
<t tx="leo.20231205084742.22">@path Y:/tmp/metapyslvs/solvespace/cython/test/
 
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084742.23">@path Y:/tmp/metapyslvs/solvespace/cython/test/
from unittest import defaultTestLoader, TextTestRunner

if __name__ == '__main__':
    TextTestRunner().run(defaultTestLoader.discover('test'))
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084742.26"></t>
<t tx="leo.20231205084742.29"></t>
<t tx="leo.20231205084742.31"></t>
<t tx="leo.20231205084742.33"></t>
<t tx="leo.20231205084742.34"></t>
<t tx="leo.20231205084742.36"></t>
<t tx="leo.20231205084742.39"></t>
<t tx="leo.20231205084742.4"></t>
<t tx="leo.20231205084742.5">@path Y:/tmp/metapyslvs/solvespace/cython/
# -*- coding: utf-8 -*-

"""Compile the Cython libraries of Python-Solvespace."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2019"
__license__ = "GPLv3+"
__email__ = "pyslvs@gmail.com"

import sys
from os import walk
from os.path import dirname, isdir, join
from setuptools import setup, Extension
from setuptools.command.build_ext import build_ext
from setuptools.command.sdist import sdist
from distutils import file_util, dir_util
from platform import system

m_path = 'python_solvespace'
include_path = join(m_path, 'include')
src_path = join(m_path, 'src')
platform_path = join(src_path, 'platform')
extlib_path = join(m_path, 'extlib')
mimalloc_path = join(extlib_path, 'mimalloc')
mimalloc_include_path = join(mimalloc_path, 'include')
mimalloc_src_path = join(mimalloc_path, 'src')
eigen_path = join(include_path, 'Eigen')
build_dir = 'build'
macros = [
    ('M_PI', 'PI'),
    ('_USE_MATH_DEFINES', None),
    ('ISOLATION_AWARE_ENABLED', None),
    ('LIBRARY', None),
    ('EXPORT_DLL', None),
    ('_CRT_SECURE_NO_WARNINGS', None),
]
compile_args = [
    '-O3',
    '-Wno-cpp',
    '-g',
    '-Wno-write-strings',
    '-fpermissive',
    '-fPIC',
    '-std=c++17',
]
compile_args_msvc = [
    '/O2',
    '/std:c++17',
]
link_args = ['-static-libgcc', '-static-libstdc++',
             '-Wl,-Bstatic,--whole-archive',
             '-lwinpthread',
             '-Wl,--no-whole-archive',
             '-lbcrypt',
             '-lpsapi',
             '-Wl,-Bdynamic']
sources = [
    join(m_path, 'slvs.pyx'),
    join(src_path, 'util.cpp'),
    join(src_path, 'entity.cpp'),
    join(src_path, 'expr.cpp'),
    join(src_path, 'constraint.cpp'),
    join(src_path, 'constrainteq.cpp'),
    join(src_path, 'system.cpp'),
    join(src_path, 'lib.cpp'),
    join(platform_path, 'platform.cpp'),
]
mimalloc_sources = [
    # MiMalloc
    join(mimalloc_src_path, 'stats.c'),
    join(mimalloc_src_path, 'random.c'),
    join(mimalloc_src_path, 'os.c'),
    join(mimalloc_src_path, 'bitmap.c'),
    join(mimalloc_src_path, 'arena.c'),
    join(mimalloc_src_path, 'segment-cache.c'),
    join(mimalloc_src_path, 'segment.c'),
    join(mimalloc_src_path, 'page.c'),
    join(mimalloc_src_path, 'alloc.c'),
    join(mimalloc_src_path, 'alloc-aligned.c'),
    join(mimalloc_src_path, 'alloc-posix.c'),
    join(mimalloc_src_path, 'heap.c'),
    join(mimalloc_src_path, 'options.c'),
    join(mimalloc_src_path, 'init.c'),
]
if {'sdist', 'bdist'} &amp; set(sys.argv):
    sources.append(join(platform_path, 'platform.cpp'))
elif system() == 'Windows':
    # Disable format warning
    compile_args.append('-Wno-format')
    # Solvespace arguments
    macros.append(('WIN32', None))
    if sys.version_info &lt; (3, 7):
        macros.append(('_hypot', 'hypot'))
else:
    macros.append(('UNIX_DATADIR', '"solvespace"'))
compiler_directives = {'binding': True, 'cdivision': True}


@others
setup(ext_modules=[Extension(
    "python_solvespace.slvs",
    sources,
    language="c++",
    include_dirs=[include_path, src_path, mimalloc_include_path,
                  mimalloc_src_path]
)], cmdclass={'build_ext': Build, 'sdist': PackSource})
@language python
@tabwidth -4
</t>
<t tx="leo.20231205084742.6">def copy_source(dry_run):
    dir_util.copy_tree(join('..', 'include'), include_path, dry_run=dry_run)
    dir_util.copy_tree(join('..', 'extlib', 'eigen', 'Eigen'), eigen_path, dry_run=dry_run)
    dir_util.copy_tree(join('..', 'extlib', 'mimalloc', 'include'),
                       mimalloc_include_path,
                       dry_run=dry_run)
    dir_util.mkpath(src_path)
    dir_util.mkpath(mimalloc_src_path)
    for path in (join('..', 'src'), join('..', 'extlib', 'mimalloc', 'src')):
        for root, _, files in walk(path):
            for f in files:
                if not (f.endswith('.h') or f.endswith('.c')):
                    continue
                f = join(root, f)
                f_new = f.replace('..', m_path)
                if not isdir(dirname(f_new)):
                    dir_util.mkpath(dirname(f_new))
                file_util.copy_file(f, f_new, dry_run=dry_run)
    for f in sources[1:] + mimalloc_sources:
        file_util.copy_file(f.replace(m_path, '..'), f, dry_run=dry_run)
    # Create an empty header
    open(join(platform_path, 'config.h'), 'a').close()


</t>
<t tx="leo.20231205084742.7">class Build(build_ext):

    @others
</t>
<t tx="leo.20231205084742.8">def build_extensions(self):
    compiler = self.compiler.compiler_type
    for e in self.extensions:
        e.cython_directives = compiler_directives
        e.libraries = ['mimalloc']
        e.library_dirs = [build_dir]
        if compiler in {'mingw32', 'unix'}:
            e.define_macros = macros
            e.extra_compile_args = compile_args
            if compiler == 'mingw32':
                e.extra_link_args = link_args
        elif compiler == 'msvc':
            e.define_macros = macros[1:]
            e.libraries.extend(['shell32', 'advapi32', 'Ws2_32'])
            e.extra_compile_args = compile_args_msvc
    has_src = isdir(include_path) and isdir(src_path) and isdir(extlib_path)
    if not has_src:
        copy_source(self.dry_run)
    # Pre-build MiMalloc
    if compiler in {'mingw32', 'unix'}:
        args = ['-fPIC']
    else:
        args = []
    objects = self.compiler.compile(
        mimalloc_sources,
        extra_postargs=args,
        include_dirs=[mimalloc_include_path, mimalloc_src_path]
    )
    dir_util.mkpath(build_dir)
    self.compiler.create_static_lib(objects, 'mimalloc', target_lang='c',
                                    output_dir=build_dir)
    super(Build, self).build_extensions()
    if not has_src:
        dir_util.remove_tree(include_path, dry_run=self.dry_run)
        dir_util.remove_tree(src_path, dry_run=self.dry_run)
        dir_util.remove_tree(extlib_path, dry_run=self.dry_run)


</t>
<t tx="leo.20231205084742.9">class PackSource(sdist):

    @others
</t>
<t tx="leo.20231205084743.10"></t>
<t tx="leo.20231205084743.12"></t>
<t tx="leo.20231205084743.4"></t>
<t tx="leo.20231205084743.5"></t>
<t tx="leo.20231205084743.9"></t>
<t tx="leo.20231205084744.13"></t>
<t tx="leo.20231205084744.17"></t>
<t tx="leo.20231205084744.9"></t>
<t tx="leo.20231205084803.1"></t>
<t tx="leo.20231205084803.2"></t>
<t tx="leo.20231205084804.100">cpdef object result(self, double[:] v):
    return self.target(v)
</t>
<t tx="leo.20231205084804.101">@path Y:/tmp/metapyslvs/metaheuristics/
# -*- coding: utf-8 -*-
# cython: language_level=3, cdivision=True, boundscheck=False, wraparound=False
# cython: initializedcheck=False, nonecheck=False

"""Teaching Learning Based Optimization

author: Yuan Chang
copyright: Copyright (C) 2016-2022
license: AGPL
email: pyslvs@gmail.com
"""

cimport cython
from libc.math cimport round
from numpy import zeros, float64 as f64
from .utility cimport uint, rand_v, rand_i, ObjFunc, Algorithm


@others
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084804.102">@cython.final
cdef class TLBO(Algorithm):
    """The implementation of Teaching Learning Based Optimization."""
    @others
</t>
<t tx="leo.20231205084804.103">cdef double[:] tmp

</t>
<t tx="leo.20231205084804.104">def __cinit__(
    self,
    ObjFunc func not None,
    dict settings not None,
    object progress_fun=None,
    object interrupt_fun=None
</t>
<t tx="leo.20231205084804.105">):
    self.tmp = zeros(self.dim, dtype=f64)

</t>
<t tx="leo.20231205084804.106">cdef inline void bounding(self, uint s) nogil:
    if self.tmp[s] &lt; self.func.lb[s]:
        self.tmp[s] = self.func.lb[s]
    elif self.tmp[s] &gt; self.func.ub[s]:
        self.tmp[s] = self.func.ub[s]

</t>
<t tx="leo.20231205084804.107">cdef inline void register(self, uint i) nogil:
    cdef double f_new = self.func.fitness(self.tmp)
    if f_new &lt; self.fitness[i]:
        self.pool[i, :] = self.tmp
        self.fitness[i] = f_new
    if f_new &lt; self.best_f:
        self.set_best(i)

</t>
<t tx="leo.20231205084804.108">cdef inline void teaching(self, uint i) nogil:
    """Teaching phase. The last best is the teacher."""
    @others
    for s in range(self.dim):
        mean = 0
        for j in range(self.pop_num):
            mean += self.pool[j, s]
        mean /= self.dim
        self.tmp[s] = self.pool[i, s] + rand_v(1, self.dim) * (self.best[s] - tf * mean)
        self.bounding(s)
    self.register(i)

</t>
<t tx="leo.20231205084804.109">cdef double tf = round(1 + rand_v())
</t>
<t tx="leo.20231205084804.110">cdef uint s, j
</t>
<t tx="leo.20231205084804.111">cdef double mean
</t>
<t tx="leo.20231205084804.112">cdef inline void learning(self, uint i) nogil:
    """Learning phase."""
    @others
    for s in range(self.dim):
        if self.fitness[j] &lt; self.fitness[i]:
            diff = self.pool[i, s] - self.pool[j, s]
        else:
            diff = self.pool[j, s] - self.pool[i, s]
        self.tmp[s] = self.pool[i, s] + diff * rand_v(1, self.dim)
        self.bounding(s)
    self.register(i)

</t>
<t tx="leo.20231205084804.113">cdef uint j = rand_i(self.pop_num - 1)
</t>
<t tx="leo.20231205084804.114">if j &gt;= i:
    j += 1
</t>
<t tx="leo.20231205084804.115">cdef uint s
</t>
<t tx="leo.20231205084804.116">cdef double diff
</t>
<t tx="leo.20231205084804.117">cdef inline void generation(self) nogil:
    """The process of each generation."""
    cdef uint i
    for i in range(self.pop_num):
        self.teaching(i)
        self.learning(i)
</t>
<t tx="leo.20231205084804.118">@path Y:/tmp/metapyslvs/metaheuristics/
# -*- coding: utf-8 -*-
# cython: language_level=3, cdivision=True, boundscheck=False, wraparound=False
# cython: initializedcheck=False, nonecheck=False

"""The callable class of the validation in algorithm.
The 'utility' module should be loaded when using sub-class of base classes.

author: Yuan Chang
copyright: Copyright (C) 2016-2022
license: AGPL
email: pyslvs@gmail.com
"""

from numpy import array, zeros, float64 as f64
from libc.math cimport HUGE_VAL
from libc.stdlib cimport rand, srand, RAND_MAX
from libc.time cimport time, difftime


@others
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084804.119">cdef inline double rand_v(double lower = 0., double upper = 1.) nogil:
    """Random real value between lower &lt;= r &lt;= upper."""
    return lower + &lt;double&gt;rand() / RAND_MAX * (upper - lower)


</t>
<t tx="leo.20231205084804.120">cdef inline uint rand_i(uint upper) nogil:
    """A random integer between 0 &lt;= r &lt; upper."""
    return rand() % upper


</t>
<t tx="leo.20231205084804.121">cdef class ObjFunc:
    """Objective function base class.

    It is used to build the objective function for Meta-heuristic Algorithms.
    """

    @others
</t>
<t tx="leo.20231205084804.122">cdef double fitness(self, double[:] v) nogil:
    with gil:
        raise NotImplementedError

</t>
<t tx="leo.20231205084804.123">cpdef object result(self, double[:] v):
    """The result function. Default is the best variable vector `v`."""
    return array(v)


</t>
<t tx="leo.20231205084804.124">cdef class Algorithm:
    """Algorithm base class.

    It is used to build the Meta-heuristic Algorithms.
    """

    @others
</t>
<t tx="leo.20231205084804.125">def __cinit__(
    self,
    ObjFunc func not None,
    dict settings not None,
    object progress_fun=None,
    object interrupt_fun=None
</t>
<t tx="leo.20231205084804.126">):
    """Generic settings."""
    srand(time(NULL))
    # object function
    self.func = func
    self.stop_at = 0
    if 'max_gen' in settings:
        self.task = MAX_GEN
        self.stop_at = settings['max_gen']
    elif 'min_fit' in settings:
        self.task = MIN_FIT
        self.stop_at = settings['min_fit']
    elif 'max_time' in settings:
        self.task = MAX_TIME
        self.stop_at = settings['max_time']
    elif 'slow_down' in settings:
        self.task = SLOW_DOWN
        self.stop_at = 1 - settings['slow_down']
    else:
        raise ValueError("please give 'max_gen', 'min_fit' or 'max_time' limit")
    self.pop_num = settings['pop_num']
    self.rpt = settings['report']
    if self.rpt &lt;= 0:
        self.rpt = 10
    self.progress_fun = progress_fun
    self.interrupt_fun = interrupt_fun
    self.dim = len(self.func.ub)
    if self.dim != len(self.func.lb):
        raise ValueError("length of upper and lower bounds must be equal")
    self.fitness = zeros(self.pop_num, dtype=f64)
    self.pool = zeros((self.pop_num, self.dim), dtype=f64)
    self.best_f = HUGE_VAL
    self.best = zeros(self.dim, dtype=f64)
    # setup benchmark
    self.func.gen = 0
    self.time_start = 0
    self.reports = clist[Report]()

</t>
<t tx="leo.20231205084804.127">cdef void assign(self, uint i, uint j) nogil:
    """Copy value from j to i."""
    self.fitness[i] = self.fitness[j]
    self.pool[i, :] = self.pool[j, :]

</t>
<t tx="leo.20231205084804.128">cdef void assign_from(self, uint i, double f, double[:] v) nogil:
    """Copy value from tmp."""
    self.fitness[i] = f
    self.pool[i, :] = v

</t>
<t tx="leo.20231205084804.129">cdef void set_best(self, uint i) nogil:
    """Set as best."""
    self.best_f = self.fitness[i]
    self.best[:] = self.pool[i, :]

</t>
<t tx="leo.20231205084804.130">cdef void find_best(self) nogil:
    """Find the best."""
    @others
    for i in range(0, self.pop_num):
        if self.fitness[i] &lt; self.fitness[best]:
            best = i
    if self.fitness[best] &lt; self.best_f:
        self.set_best(best)

</t>
<t tx="leo.20231205084804.131">cdef uint best = 0
</t>
<t tx="leo.20231205084804.132">cdef uint i
</t>
<t tx="leo.20231205084804.133">cdef void init_pop(self) nogil:
    """Initialize population."""
    @others
    for i in range(self.pop_num):
        for s in range(self.dim):
            self.pool[i, s] = rand_v(self.func.lb[s], self.func.ub[s])
        self.fitness[i] = self.func.fitness(self.pool[i, :])
        if self.fitness[i] &lt; self.fitness[best]:
            best = i
    if self.fitness[best] &lt; self.best_f:
        self.set_best(best)

</t>
<t tx="leo.20231205084804.134">cdef uint best = 0
</t>
<t tx="leo.20231205084804.135">cdef uint i, s
</t>
<t tx="leo.20231205084804.136">cdef void init(self) nogil:
    """Initialize function."""
    pass

</t>
<t tx="leo.20231205084804.137">cdef void generation(self) nogil:
    """The process of each generation."""
    with gil:
        raise NotImplementedError

</t>
<t tx="leo.20231205084804.138">cdef double check(self, int s, double v) nogil:
    """Check the bounds."""
    if v &gt; self.func.ub[s]:
        return self.func.ub[s]
    elif v &lt; self.func.lb[s]:
        return self.func.lb[s]
    else:
        return v

</t>
<t tx="leo.20231205084804.139">cdef inline void report(self) nogil:
    """Report generation, fitness and time."""
    self.reports.push_back(Report(
        self.func.gen,
        self.best_f,
        difftime(time(NULL), self.time_start),
    ))

</t>
<t tx="leo.20231205084804.140">cpdef double[:, :] history(self):
    """Return the history of the process.

    The first value is generation (iteration);
    the second value is fitness;
    the third value is time in second.
    """
    return array([
        (report.gen, report.fitness, report.time)
        for report in self.reports
    ], dtype=f64)

</t>
<t tx="leo.20231205084804.141">cpdef tuple result(self):
    """Return the best variable vector and its fitness."""
    return array(self.best), self.best_f

</t>
<t tx="leo.20231205084804.142">cpdef object run(self):
    """Run and return the result and convergence history.

    The first place of `return` is came from
    calling [`ObjFunc.result()`](#objfuncresult).

    The second place of `return` is a list of generation data,
    which type is `Tuple[int, float, float]]`.
    The first of them is generation,
    the second is fitness, and the last one is time in second.
    """
    # Swap upper and lower bound if reversed
    for i in range(len(self.func.ub)):
        if self.func.ub[i] &lt; self.func.lb[i]:
            self.func.ub[i], self.func.lb[i] = self.func.lb[i], self.func.ub[i]
    # Start
    self.time_start = time(NULL)
    self.init_pop()
    self.init()
    self.report()
    @others
    while True:
        best_f = self.best_f
        self.func.gen += 1
        self.generation()
        if self.func.gen % self.rpt == 0:
            self.report()
        if self.task == MAX_GEN:
            if self.func.gen &gt;= self.stop_at &gt; 0:
                break
        elif self.task == MIN_FIT:
            if self.best_f &lt; self.stop_at:
                break
        elif self.task == MAX_TIME:
            if difftime(time(NULL), self.time_start) &gt;= self.stop_at &gt; 0:
                break
        elif self.task == SLOW_DOWN:
            diff = best_f - self.best_f
            if last_diff &gt; 0 and diff / last_diff &gt;= self.stop_at:
                break
            last_diff = diff
        # progress
        if self.progress_fun is not None:
            self.progress_fun(self.func.gen, f"{self.best_f:.04f}")
        # interrupt
        if self.interrupt_fun is not None and self.interrupt_fun():
            break
    self.report()
    return self.func.result(self.best)
</t>
<t tx="leo.20231205084804.143"># Iterations
cdef double diff, best_f
</t>
<t tx="leo.20231205084804.144">cdef double last_diff = 0
</t>
<t tx="leo.20231205084804.145"></t>
<t tx="leo.20231205084804.147"></t>
<t tx="leo.20231205084804.148">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/
# -*- coding: utf-8 -*-
# cython: language_level=3, cdivision=True, boundscheck=False, wraparound=False
# cython: initializedcheck=False, nonecheck=False

"""Wrapper of BFGS algorithm.

author: Yuan Chang
copyright: Copyright (C) 2016-2022
license: AGPL
email: pyslvs@gmail.com
"""

from typing import Sequence, Set
cimport cython
from cpython.mem cimport PyMem_Malloc, PyMem_Free
from libc.math cimport M_PI, cos, sin
from libcpp.pair cimport pair
from .sketch_solve cimport (
    point_on_point,
    p2p_distance,
    internal_angle,
    point_on_line,
    line_internal_angle,
    solve,
)
from .expression cimport get_vlinks, VJoint, VPoint, Coord


@others
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084804.149">cdef inline double *de_refer_post_inc(clist[double].iterator &amp;it):
    """Implement &amp;(*it++) in C++."""
    return &amp;cython.operator.dereference(cython.operator.postincrement(it))


</t>
<t tx="leo.20231205084804.150">cdef inline void _sort_pairs(dict data_dict):
    """Sort the pairs in data_dict."""
    for k in data_dict:
        if isinstance(k, (Sequence, Set)) and len(k) == 2:
            data_dict[frozenset(k)] = data_dict.pop(k)


</t>
<t tx="leo.20231205084804.151">cdef inline double _radians(double degree):
    """Degrees to radians."""
    return degree / 180 * M_PI


</t>
<t tx="leo.20231205084804.152">cdef class SolverSystem:
    """Sketch Solve solver.

    !!! note
        The object attributes of such type are unable to access.
    """

    @others
</t>
<t tx="leo.20231205084804.153">def __cinit__(self, object vpoints_, dict inputs = None, dict data_dict = None):
    self.vpoints = list(vpoints_)
    self.vlinks = {vlink.name: vlink for vlink in get_vlinks(self.vpoints)}
    self.inputs = {} if inputs is None else inputs
    self.data_dict = {} if data_dict is None else data_dict
    _sort_pairs(self.data_dict)
    self.build_expression()

</t>
<t tx="leo.20231205084804.154">cpdef bint same_points(self, object vpoints_):
    """Return true if two expressions are same."""
    @others
    for i, p1 in enumerate(vpoints_):
        p2 = self.vpoints[i]
        if p1.links != p2.links:
            return False
    return True

</t>
<t tx="leo.20231205084804.155">cdef int i
</t>
<t tx="leo.20231205084804.156">cdef VPoint p1, p2
</t>
<t tx="leo.20231205084804.157">cpdef frozenset show_inputs(self):
    """Show the current input pairs keys from original constructor."""
    return frozenset(self.inputs)

</t>
<t tx="leo.20231205084804.158">cpdef frozenset show_data(self):
    """Show the current keys of `data_dict` parameter from original
    constructor.
    """
    return frozenset(self.data_dict)

</t>
<t tx="leo.20231205084804.159">cdef Point *point_ptr(self, int i, VLink vlink):
    """Pick Point pointers."""
    cdef VPoint vp = self.vpoints[i]
    if i not in self.data_dict and vp.is_slot_link(vlink.name):
        return &amp;self.slider_bases[self.sliders[i]]
    else:
        return &amp;self.points[i]

</t>
<t tx="leo.20231205084804.160">cdef void build_expression(self):
    """Build the expression for solver at first time."""
    @others
    for (b, d), angle in self.inputs.items():
        if b == d:
            continue
        self.handles.push_back([&amp;self.points[b], &amp;self.points[d]])
        self.inputs_angle.push_back(_radians(angle))
        self.cons_list.push_back(line_internal_angle(
            &amp;self.handles.back(),
            &amp;self.inputs_angle.back()
        ))

</t>
<t tx="leo.20231205084804.161"># Point parameters
cdef int i
</t>
<t tx="leo.20231205084804.162">cdef double x, y
</t>
<t tx="leo.20231205084804.163">cdef double *tmp_ptr
</t>
<t tx="leo.20231205084804.164">cdef VPoint vpoint
</t>
<t tx="leo.20231205084804.165">cdef Coord coord
</t>
<t tx="leo.20231205084804.166">for i, vpoint in enumerate(self.vpoints):
    if vpoint.no_link():
        x = vpoint.c[0, 0]
        y = vpoint.c[0, 1]
        self.constants.push_back(x)
        tmp_ptr = &amp;self.constants.back()
        self.constants.push_back(y)
        self.points.push_back([tmp_ptr, &amp;self.constants.back()])
        continue
    if vpoint.grounded():
        if self.check_known(i):
            continue
        x = vpoint.c[0, 0]
        y = vpoint.c[0, 1]
        self.constants.push_back(x)
        tmp_ptr = &amp;self.constants.back()
        self.constants.push_back(y)
        if vpoint.type in {VJoint.P, VJoint.RP}:
            self.sliders[i] = &lt;int&gt;self.slider_bases.size()
            # Base point (slot) is fixed
            self.slider_bases.push_back([tmp_ptr, &amp;self.constants.back()])
            # Slot point (slot) is movable
            self.params.push_back(x + cos(vpoint.angle))
            tmp_ptr = &amp;self.params.back()
            self.params.push_back(y + sin(vpoint.angle))
            self.slider_slots.push_back([tmp_ptr, &amp;self.params.back()])
            # Pin is movable
            x = vpoint.c[1, 0]
            y = vpoint.c[1, 1]
            if vpoint.has_offset() and vpoint.true_offset() &lt;= 0.1:
                if vpoint.offset() &gt; 0:
                    x += 0.1
                    y += 0.1
                else:
                    x -= 0.1
                    y -= 0.1
            self.params.push_back(x)
            tmp_ptr = &amp;self.params.back()
            self.params.push_back(y)
            self.points.push_back([tmp_ptr, &amp;self.params.back()])
        else:
            self.points.push_back([tmp_ptr, &amp;self.constants.back()])
        continue
    if self.check_known(i):
        continue
    x = vpoint.c[0, 0]
    y = vpoint.c[0, 1]
    self.params.push_back(x)
    tmp_ptr = &amp;self.params.back()
    self.params.push_back(y)
    if vpoint.type in {VJoint.P, VJoint.RP}:
        self.sliders[i] = &lt;int&gt;self.slider_bases.size()
        # Base point (slot) is movable
        self.slider_bases.push_back([tmp_ptr, &amp;self.params.back()])
        # Slot point (slot) is movable
        self.params.push_back(x + cos(vpoint.angle))
        tmp_ptr = &amp;self.params.back()
        self.params.push_back(y + sin(vpoint.angle))
        self.slider_slots.push_back([tmp_ptr, &amp;self.params.back()])
        if vpoint.pin_grounded():
            # Pin is fixed
            x = vpoint.c[1, 0]
            y = vpoint.c[1, 1]
            self.constants.push_back(x)
            tmp_ptr = &amp;self.constants.back()
            self.constants.push_back(y)
            self.points.push_back([tmp_ptr, &amp;self.constants.back()])
        else:
            # Pin is movable
            x = vpoint.c[1, 0]
            y = vpoint.c[1, 1]
            if vpoint.has_offset() and vpoint.true_offset() &lt;= 0.1:
                if vpoint.offset() &gt; 0:
                    x += 0.1
                    y += 0.1
                else:
                    x -= 0.1
                    y -= 0.1
            self.params.push_back(x)
            tmp_ptr = &amp;self.params.back()
            self.params.push_back(y)
            self.points.push_back([tmp_ptr, &amp;self.params.back()])
        continue
    # Point is movable
    self.points.push_back([tmp_ptr, &amp;self.params.back()])
</t>
<t tx="leo.20231205084804.167"># Link constraints
# (automatic fill up the link length options of data keys)
cdef int a, b, c, d
</t>
<t tx="leo.20231205084804.168">cdef VPoint vp1, vp2
</t>
<t tx="leo.20231205084804.169">cdef Point *p1
</t>
<t tx="leo.20231205084804.170">cdef Point *p2
</t>
<t tx="leo.20231205084804.171">cdef VLink vlink
</t>
<t tx="leo.20231205084804.172">for vlink in self.vlinks.values():
    if len(vlink.points) &lt; 2 or vlink.name == VLink.FRAME:
        continue
    a = vlink.points[0]
    b = vlink.points[1]
    if (a not in self.data_dict) or (b not in self.data_dict):
        vp1 = self.vpoints[a]
        vp2 = self.vpoints[b]
        p1 = self.point_ptr(a, vlink)
        p2 = self.point_ptr(b, vlink)
        frozen_pair = frozenset({a, b})
        if frozen_pair in self.data_dict:
            x = self.data_dict[frozen_pair]
        else:
            x = vp1.distance(vp2)
            self.data_dict[frozen_pair] = x
        self.data_values.push_back(x)
        self.cons_list.push_back(p2p_distance(p1, p2, &amp;self.data_values.back()))
    for c in vlink.points[2:]:
        if c in self.data_dict:
            # Known coordinate
            continue
        for d in (a, b):
            vp1 = self.vpoints[c]
            vp2 = self.vpoints[d]
            p1 = self.point_ptr(c, vlink)
            p2 = self.point_ptr(d, vlink)
            frozen_pair = frozenset({c, d})
            if frozen_pair in self.data_dict:
                x = self.data_dict[frozen_pair]
            else:
                x = vp1.distance(vp2)
                self.data_dict[frozen_pair] = x
            self.data_values.push_back(x)
            self.cons_list.push_back(p2p_distance(p1, p2, &amp;self.data_values.back()))
</t>
<t tx="leo.20231205084804.173"># Slider constraints
cdef Line *slider_slot
</t>
<t tx="leo.20231205084804.174">cdef pair[int, int] slider
</t>
<t tx="leo.20231205084804.175">for slider in self.sliders:
    a = slider.first
    b = slider.second
    # Base point
    vp1 = self.vpoints[a]
    p1 = &amp;self.points[a]
    # Base slot
    self.slider_lines.push_back([&amp;self.slider_bases[b], &amp;self.slider_slots[b]])
    slider_slot = &amp;self.slider_lines.back()
    if vp1.grounded():
        # Slot is grounded
        self.constants.push_back(_radians(vp1.angle))
        self.cons_list.push_back(line_internal_angle(slider_slot, &amp;self.constants.back()))
        self.cons_list.push_back(point_on_line(p1, slider_slot))
        if vp1.has_offset():
            p2 = &amp;self.slider_bases[b]
            if vp1.offset():
                self.constants.push_back(vp1.offset())
                self.cons_list.push_back(p2p_distance(p2, p1, &amp;self.constants.back()))
            else:
                self.cons_list.push_back(point_on_point(p2, p1))
    else:
        # Slider between links
        for name in vp1.links[:1]:
            vlink = self.vlinks[name]
            # A base link friend
            c = vlink.points[0]
            if c == a:
                if len(vlink.points) &lt; 2:
                    # If no any friend
                    continue
                c = vlink.points[1]
            vp2 = self.vpoints[c]
            if vp2.is_slot_link(vlink.name):
                # c is a slider, and it is be connected with slot link
                p2 = &amp;self.slider_bases[self.sliders[c]]
            else:
                # c is a R joint or it is not connected with slot link
                p2 = &amp;self.points[c]
            self.slider_lines.push_back([&amp;self.slider_bases[b], p2])
            self.constants.push_back(_radians(vp1.slope_angle(vp2) - vp1.angle))
            self.cons_list.push_back(internal_angle(
                slider_slot,
                &amp;self.slider_lines.back(),
                &amp;self.constants.back()
            ))
            self.cons_list.push_back(point_on_line(p1, slider_slot))
            if vp1.has_offset():
                p2 = &amp;self.slider_bases[b]
                if vp1.offset():
                    self.constants.push_back(vp1.offset())
                    self.cons_list.push_back(p2p_distance(p2, p1, &amp;self.constants.back()))
                else:
                    self.cons_list.push_back(point_on_point(p2, p1))
    if vp1.type != VJoint.P:
        continue
    for name in vp1.links[1:]:
        vlink = self.vlinks[name]
        # A base link friend
        c = vlink.points[0]
        if c == a:
            if len(vlink.points) &lt; 2:
                # If no any friend
                continue
            c = vlink.points[1]
        vp2 = self.vpoints[c]
        if vp2.is_slot_link(vlink.name):
            # c is a slider, and it is be connected with slot link
            p2 = &amp;self.slider_bases[self.sliders[c]]
        else:
            # c is a R joint or it is not connected with slot link
            p2 = &amp;self.points[c]
        self.slider_lines.push_back([p1, p2])
        self.constants.push_back(_radians(vp1.slope_angle(vp2) - vp1.angle))
        self.cons_list.push_back(internal_angle(
            slider_slot,
            &amp;self.slider_lines.back(),
            &amp;self.constants.back()
        ))
</t>
<t tx="leo.20231205084804.176"># Angle constraints
cdef double angle
</t>
<t tx="leo.20231205084804.177">cdef bint check_known(self, int i):
    """Check known coordinates."""
    if i not in self.data_dict:
        return False
    coord = self.data_dict[i]
    self.data_values.push_back(coord.x)
    tmp_ptr = &amp;self.data_values.back()
    self.data_values.push_back(coord.y)
    self.points.push_back([tmp_ptr, &amp;self.data_values.back()])
    return True

</t>
<t tx="leo.20231205084804.178">cpdef void set_inputs(self, dict inputs):
    """Set the values of `inputs` parameter from original constructor.
    Two groups of `dict` keys must be the same or subset.
    """
    if self.inputs is None or inputs is None:
        raise ValueError(f"do not accept modifications")
    if not self.show_inputs() &gt;= set(inputs):
        raise ValueError(f"format must be {set(self.inputs)}, not {set(inputs)}")
    self.inputs.update(inputs)
    @others
    for (b, d), angle in self.inputs.items():
        if b == d:
            continue
        handle = de_refer_post_inc(it)
        handle[0] = _radians(angle)

</t>
<t tx="leo.20231205084804.179"># Set values
cdef int b, d
</t>
<t tx="leo.20231205084804.180">cdef double angle
</t>
<t tx="leo.20231205084804.181">cdef double *handle
</t>
<t tx="leo.20231205084804.182">cdef clist[double].iterator it = self.inputs_angle.begin()
</t>
<t tx="leo.20231205084804.183">cpdef void set_data(self, dict data_dict):
    """Set the values of `data_dict` parameter from original constructor.
    Two groups of `dict` keys must be the same or subset.
    """
    if self.data_dict is None or data_dict is None:
        raise ValueError(f"do not accept modifications")
    _sort_pairs(data_dict)
    if not self.show_data() &gt;= set(data_dict):
        raise ValueError(f"format must be {set(self.data_dict)}, not {set(data_dict)}")
    self.data_dict.update(data_dict)
    @others
    for vlink in self.vlinks.values():
        if len(vlink.points) &lt; 2:
            continue
        if vlink.name == VLink.FRAME:
            continue
        a = vlink.points[0]
        b = vlink.points[1]
        if (a not in self.data_dict) or (b not in self.data_dict):
            handle = de_refer_post_inc(it)
            handle[0] = self.data_dict[frozenset({a, b})]
        for c in vlink.points[2:]:
            if c in self.data_dict:
                # Known coordinate
                continue
            for d in (a, b):
                handle = de_refer_post_inc(it)
                handle[0] = self.data_dict[frozenset({c, d})]

</t>
<t tx="leo.20231205084804.184">cdef size_t n = 0
</t>
<t tx="leo.20231205084804.185"># Set values
cdef int i
</t>
<t tx="leo.20231205084804.186">cdef double *handle
</t>
<t tx="leo.20231205084804.187">cdef VPoint vpoint
</t>
<t tx="leo.20231205084804.188">cdef Coord coord
</t>
<t tx="leo.20231205084804.189">cdef clist[double].iterator it = self.data_values.begin()
</t>
<t tx="leo.20231205084804.190">for i, vpoint in enumerate(self.vpoints):
    if vpoint.grounded():
        if i in self.data_dict:
            # Known coordinates
            coord = self.data_dict[i]
            handle = de_refer_post_inc(it)
            handle[0] = coord.x
            handle = de_refer_post_inc(it)
            handle[0] = coord.y
    if i in self.data_dict:
        # Known coordinates
        coord = self.data_dict[i]
        handle = de_refer_post_inc(it)
        handle[0] = coord.x
        handle = de_refer_post_inc(it)
        handle[0] = coord.y
</t>
<t tx="leo.20231205084804.191">cdef int a, b, c, d
</t>
<t tx="leo.20231205084804.192">cdef VLink vlink
</t>
<t tx="leo.20231205084804.193">cpdef list solve(self):
    """Solve the conditions and return the result, raise ValueError if
    not succeeded.
    The joint position will returned by its index correspondingly.

    + Revolute joints: Tuple[float, float]
    + Slider joints: Tuple[Tuple[float, float], Tuple[float, float]]
    """
    @others
    if flag:
        solved_points = []
        for i, vp in enumerate(self.vpoints):
            if i in self.data_dict or vp.no_link():
                if vp.no_link():
                    c = Coord.__new__(Coord, vp.c[0, 0], vp.c[0, 1])
                else:
                    c = self.data_dict[i]
                if vp.type == VJoint.R:
                    solved_points.append((c.x, c.y))
                else:
                    solved_points.append(((c.x, c.y), (c.x, c.y)))
                continue
            p1 = self.points[i]
            if vp.type == VJoint.R:
                solved_points.append((p1.x[0], p1.y[0]))
            else:
                p2 = self.slider_bases[self.sliders[i]]
                solved_points.append(((p2.x[0], p2.y[0]),
                                      (p1.x[0], p1.y[0])))
    PyMem_Free(params_ptr)
    PyMem_Free(cons)
    if flag:
        return solved_points
    else:
        raise ValueError("no valid solutions were found from initialed values")
</t>
<t tx="leo.20231205084804.194"># Pointer of parameters
cdef size_t params_count = &lt;int&gt;self.params.size()
</t>
<t tx="leo.20231205084804.195">cdef double **params_ptr = &lt;double **&gt;PyMem_Malloc(sizeof(double *) * params_count)
</t>
<t tx="leo.20231205084804.196">cdef clist[double].iterator it = self.params.begin()
</t>
<t tx="leo.20231205084804.197">cdef size_t i
</t>
<t tx="leo.20231205084804.198">for i in range(params_count):
    params_ptr[i] = de_refer_post_inc(it)
</t>
<t tx="leo.20231205084804.199"># Pointer of constraints
cdef size_t cons_count = &lt;int&gt;self.cons_list.size()
</t>
<t tx="leo.20231205084804.20"></t>
<t tx="leo.20231205084804.200">cdef Constraint *cons = &lt;Constraint *&gt;PyMem_Malloc(sizeof(Constraint) * cons_count)
</t>
<t tx="leo.20231205084804.201">i = 0
</t>
<t tx="leo.20231205084804.202">cdef Constraint con
</t>
<t tx="leo.20231205084804.203">for con in self.cons_list:
    cons[i] = con
    i += 1
</t>
<t tx="leo.20231205084804.204"># Solve
cdef bint flag = solve(params_ptr, params_count, cons, cons_count, False)
</t>
<t tx="leo.20231205084804.205">cdef VPoint vp
</t>
<t tx="leo.20231205084804.206">cdef Coord c
</t>
<t tx="leo.20231205084804.207">cdef Point p1, p2
</t>
<t tx="leo.20231205084804.21">@path Y:/tmp/metapyslvs/metaheuristics/
# -*- coding: utf-8 -*-
# cython: language_level=3, cdivision=True, boundscheck=False, wraparound=False
# cython: initializedcheck=False, nonecheck=False

"""Differential Evolution

author: Yuan Chang
copyright: Copyright (C) 2016-2022
license: AGPL
email: pyslvs@gmail.com
"""

cimport cython
from numpy import zeros, uint32 as usize, float64 as f64
from .utility cimport uint, rand_v, rand_i, ObjFunc, Algorithm


@others
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084804.22">cpdef enum Strategy:
    S1
    S2
    S3
    S4
    S5
    S6
    S7
    S8
    S9
    S10


</t>
<t tx="leo.20231205084804.23">@cython.final
cdef class DE(Algorithm):
    """The implementation of Differential Evolution."""
    @others
</t>
<t tx="leo.20231205084804.24">cdef Strategy strategy
</t>
<t tx="leo.20231205084804.25">cdef double f, cr
</t>
<t tx="leo.20231205084804.26">cdef uint[:] v
</t>
<t tx="leo.20231205084804.27">cdef double[:] tmp
</t>
<t tx="leo.20231205084804.28">cdef (double (*)(DE, uint) nogil) formula
cdef (void (*)(DE, uint) nogil) setter

</t>
<t tx="leo.20231205084804.29">def __cinit__(
    self,
    ObjFunc func not None,
    dict settings not None,
    object progress_fun=None,
    object interrupt_fun=None
</t>
<t tx="leo.20231205084804.30">):
    # strategy 0~9, choice what strategy to generate new member in temporary
    self.strategy = Strategy(settings['strategy'])
    # weight factor f is usually between 0.5 and 1 (in rare cases &gt; 1)
    self.f = settings['f']
    if 0.5 &gt; self.f or self.f &gt; 1:
        raise ValueError('cr should be [0.5,1]')
    # crossover possible cr in [0,1]
    self.cr = settings['cr']
    if 0 &gt; self.cr or self.cr &gt; 1:
        raise ValueError('cr should be [0,1]')
</t>
<t tx="leo.20231205084804.31">    # the vector
    cdef uint num
</t>
<t tx="leo.20231205084804.32">    if self.strategy in {S1, S3, S6, S8}:
        num = 2
    elif self.strategy in {S2, S7}:
        num = 3
    elif self.strategy in {S4, S9}:
        num = 4
    else:
        num = 5
    self.v = zeros(num, dtype=usize)
    self.tmp = zeros(self.dim, dtype=f64)
    if self.strategy in {S1, S6}:
        self.formula = DE.f1
    elif self.strategy in {S2, S7}:
        self.formula = DE.f2
    elif self.strategy in {S3, S8}:
        self.formula = DE.f3
    elif self.strategy in {S4, S9}:
        self.formula = DE.f4
    else:
        self.formula = DE.f5
    if self.strategy in {S1, S2, S3, S4, S5}:
        self.setter = DE.s1
    else:
        self.setter = DE.s2

</t>
<t tx="leo.20231205084804.33">cdef inline void init(self) nogil:
    """Initial population."""
    self.init_pop()
    self.find_best()

</t>
<t tx="leo.20231205084804.34">cdef inline void vector(self, uint i) nogil:
    """Generate new vectors."""
    @others
    for j in range(len(self.v)):
        self.v[j] = i
        while True:
            if self.v[j] != i:
                for k in range(j):
                    if self.v[j] == self.v[k]:
                        break
                else:
                    break
            self.v[j] = rand_i(self.pop_num)

</t>
<t tx="leo.20231205084804.35">cdef uint j
</t>
<t tx="leo.20231205084804.36">cdef double f1(self, uint n) nogil:
    return self.best[n] + self.f * (
        self.pool[self.v[0], n] - self.pool[self.v[1], n])

</t>
<t tx="leo.20231205084804.37">cdef double f2(self, uint n) nogil:
    return self.pool[self.v[0], n] + self.f * (
        self.pool[self.v[1], n] - self.pool[self.v[2], n])

</t>
<t tx="leo.20231205084804.38">cdef double f3(self, uint n) nogil:
    return self.tmp[n] + self.f * (self.best[n] - self.tmp[n]
        + self.pool[self.v[0], n] - self.pool[self.v[1], n])

</t>
<t tx="leo.20231205084804.39">cdef double f4(self, uint n) nogil:
    return self.best[n] + self.f * (
        self.pool[self.v[0], n] + self.pool[self.v[1], n]
        - self.pool[self.v[2], n] - self.pool[self.v[3], n])

</t>
<t tx="leo.20231205084804.40">cdef double f5(self, uint n) nogil:
    return self.pool[self.v[4], n] + self.f * (
        self.pool[self.v[0], n] + self.pool[self.v[1], n]
        - self.pool[self.v[2], n] - self.pool[self.v[3], n])

</t>
<t tx="leo.20231205084804.41">cdef void s1(self, uint n) nogil:
    for _ in range(self.dim):
        self.tmp[n] = self.formula(self, n)
        n = (n + 1) % self.dim
        if rand_v() &gt;= self.cr:
            break

</t>
<t tx="leo.20231205084804.42">cdef void s2(self, uint n) nogil:
    cdef uint l_v
    for l_v in range(self.dim):
        if rand_v() &lt; self.cr or l_v == self.dim - 1:
            self.tmp[n] = self.formula(self, n)
        n = (n + 1) % self.dim

</t>
<t tx="leo.20231205084804.43">cdef inline void recombination(self, int i) nogil:
    """use new vector, recombination the new one member to tmp."""
    self.tmp[:] = self.pool[i, :]
    self.setter(self, rand_i(self.dim))

</t>
<t tx="leo.20231205084804.44">cdef inline void generation(self) nogil:
    @others
    for i in range(self.pop_num):
        # Generate a new vector
        self.vector(i)
        # Use the vector recombine the member to temporary
        self.recombination(i)
        # Check the one is out of bound
        for s in range(self.dim):
            if not self.func.ub[s] &gt;= self.tmp[s] &gt;= self.func.lb[s]:
                break
        else:
            # Test
            tmp_f = self.func.fitness(self.tmp)
            # Self evolution
            if tmp_f &lt; self.fitness[i]:
                self.assign_from(i, tmp_f, self.tmp)
    self.find_best()
</t>
<t tx="leo.20231205084804.45">cdef uint i, s
</t>
<t tx="leo.20231205084804.46">cdef double tmp_f
</t>
<t tx="leo.20231205084804.47">@path Y:/tmp/metapyslvs/metaheuristics/
# -*- coding: utf-8 -*-
# cython: language_level=3, cdivision=True, boundscheck=False, wraparound=False
# cython: initializedcheck=False, nonecheck=False

"""Firefly Algorithm

author: Yuan Chang
copyright: Copyright (C) 2016-2022
license: AGPL
email: pyslvs@gmail.com
"""

cimport cython
from libc.math cimport exp
from numpy import zeros, float64 as f64
from .utility cimport uint, rand_v, ObjFunc, Algorithm


@others
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084804.48">cdef double _distance(double[:] me, double[:] she, uint dim) nogil:
    """Distance of two fireflies."""
    @others
    for i in range(dim):
        diff = me[i] - she[i]
        dist += diff * diff
    return dist


</t>
<t tx="leo.20231205084804.49">cdef double dist = 0
</t>
<t tx="leo.20231205084804.50">cdef uint i
</t>
<t tx="leo.20231205084804.51">cdef double diff
</t>
<t tx="leo.20231205084804.52">@cython.final
cdef class FA(Algorithm):
    """The implementation of Firefly Algorithm."""
    @others
</t>
<t tx="leo.20231205084804.53">cdef double alpha, beta_min, gamma

</t>
<t tx="leo.20231205084804.54">def __cinit__(
    self,
    ObjFunc func not None,
    dict settings not None,
    object progress_fun=None,
    object interrupt_fun=None
</t>
<t tx="leo.20231205084804.55">):
    # alpha, the step size
    self.alpha = settings['alpha']
    # beta_min, the minimal attraction, must not less than this
    self.beta_min = settings['beta_min']
    # gamma
    self.gamma = settings['gamma']

</t>
<t tx="leo.20231205084804.56">cdef inline void move_fireflies(self) nogil:
    """Move fireflies."""
    cdef uint i, j
    for i in range(self.pop_num - 1):
        for j in range(i + 1, self.pop_num):
            self.move_firefly(i, j)

</t>
<t tx="leo.20231205084804.57">cdef inline void move_firefly(self, uint i, uint j) nogil:
    """Move single firefly."""
    if self.fitness[i] &lt;= self.fitness[j]:
        i, j = j, i
    @others
    if f &lt; self.fitness[i]:
        self.assign_from(i, f, v)

</t>
<t tx="leo.20231205084804.58">cdef double[:] v
</t>
<t tx="leo.20231205084804.59">with gil:
    v = zeros(self.dim, dtype=f64)
</t>
<t tx="leo.20231205084804.60">cdef double r = _distance(self.pool[i, :], self.pool[j, :], self.dim)
</t>
<t tx="leo.20231205084804.61">cdef double beta = self.beta_min * exp(-self.gamma * r)
</t>
<t tx="leo.20231205084804.62">cdef uint s
</t>
<t tx="leo.20231205084804.63">cdef double step, surround
</t>
<t tx="leo.20231205084804.64">for s in range(self.dim):
    step = self.alpha * (self.func.ub[s] - self.func.lb[s]) * rand_v(-0.5, 0.5)
    surround = self.pool[i, s] + beta * (self.pool[j, s] - self.pool[i, s])
    v[s] = self.check(s, surround + step)
</t>
<t tx="leo.20231205084804.65">cdef double f = self.func.fitness(v)
</t>
<t tx="leo.20231205084804.66">cdef inline void generation(self) nogil:
    self.move_fireflies()
    self.alpha *= 0.95
    self.find_best()
</t>
<t tx="leo.20231205084804.67">@path Y:/tmp/metapyslvs/metaheuristics/
# -*- coding: utf-8 -*-
# cython: language_level=3, cdivision=True, boundscheck=False, wraparound=False
# cython: initializedcheck=False, nonecheck=False

"""Particle Swarm Optimization

author: Yuan Chang
copyright: Copyright (C) 2016-2022
license: AGPL
email: pyslvs@gmail.com
"""

cimport cython
from numpy import zeros, float64 as f64
from .utility cimport uint, rand_v, ObjFunc, Algorithm


@others
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084804.68">@cython.final
cdef class PSO(Algorithm):
    @others
</t>
<t tx="leo.20231205084804.69">cdef double cognition, social, velocity
</t>
<t tx="leo.20231205084804.70">cdef double[:] best_f_past
</t>
<t tx="leo.20231205084804.71">cdef double[:, :] best_past

</t>
<t tx="leo.20231205084804.72">def __cinit__(
    self,
    ObjFunc func not None,
    dict settings not None,
    object progress_fun=None,
    object interrupt_fun=None
</t>
<t tx="leo.20231205084804.73">):
    self.cognition = settings['cognition']
    self.social = settings['social']
    self.velocity = settings['velocity']
    self.best_past = zeros((self.pop_num, self.dim), dtype=f64)
    self.best_f_past = zeros(self.pop_num, dtype=f64)

</t>
<t tx="leo.20231205084804.74">cdef inline void init(self) nogil:
    """Initial population."""
    self.best_past[:, :] = self.pool
    self.best_f_past[:] = self.fitness

</t>
<t tx="leo.20231205084804.75">cdef inline void generation(self) nogil:
    @others
    for i in range(self.pop_num):
        alpha = self.cognition * rand_v()
        beta = self.social * rand_v()
        for s in range(self.dim):
            self.pool[i, s] = self.check(s, self.velocity * self.pool[i, s]
                + alpha * (self.best_past[i, s] - self.pool[i, s])
                + beta * (self.best[s] - self.pool[i, s]))
        self.fitness[i] = self.func.fitness(self.pool[i, :])
        if self.fitness[i] &lt; self.best_f_past[i]:
            self.best_past[i, :] = self.pool[i, :]
            self.best_f_past[i] = self.fitness[i]
        if self.fitness[i] &lt; self.best_f:
            self.set_best(i)
</t>
<t tx="leo.20231205084804.76">cdef double alpha
</t>
<t tx="leo.20231205084804.77">cdef double beta
</t>
<t tx="leo.20231205084804.78">cdef uint i, s
</t>
<t tx="leo.20231205084804.79">@path Y:/tmp/metapyslvs/metaheuristics/
# -*- coding: utf-8 -*-
# cython: language_level=3, cdivision=True, boundscheck=False, wraparound=False
# cython: initializedcheck=False, nonecheck=False

"""Real-coded Genetic Algorithm

author: Yuan Chang
copyright: Copyright (C) 2016-2022
license: AGPL
email: pyslvs@gmail.com
"""

cimport cython
from libc.math cimport pow
from numpy import zeros, float64 as f64
from .utility cimport uint, MAX_GEN, rand_v, rand_i, ObjFunc, Algorithm


@others
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084804.80">@cython.final
cdef class RGA(Algorithm):
    """The implementation of Real-coded Genetic Algorithm."""
    @others
</t>
<t tx="leo.20231205084804.81">cdef double cross, mutate_f, win, delta
</t>
<t tx="leo.20231205084804.82">cdef double[:] new_fitness, f_tmp
</t>
<t tx="leo.20231205084804.83">cdef double[:, :] new_pool, tmp

</t>
<t tx="leo.20231205084804.84">def __cinit__(
    self,
    ObjFunc func not None,
    dict settings not None,
    object progress_fun=None,
    object interrupt_fun=None
</t>
<t tx="leo.20231205084804.85">):
    self.cross = settings['cross']
    self.mutate_f = settings['mutate']
    self.win = settings['win']
    self.delta = settings['delta']
    self.new_fitness = zeros(self.pop_num, dtype=f64)
    self.new_pool = zeros((self.pop_num, self.dim), dtype=f64)
    self.tmp = zeros((3, self.dim), dtype=f64)
    self.f_tmp = zeros(3, dtype=f64)

</t>
<t tx="leo.20231205084804.86">cdef inline double bound(self, int i, double v) nogil:
    """If a variable is out of bound, replace it with a random value."""
    if not self.func.ub[i] &gt;= v &gt;= self.func.lb[i]:
        return rand_v(self.func.lb[i], self.func.ub[i])
    return v

</t>
<t tx="leo.20231205084804.87">cdef inline void crossover(self) nogil:
    @others
    for i in range(0, self.pop_num - 1, 2):
        if not rand_v() &lt; self.cross:
            continue
        for s in range(self.dim):
            # first baby, half father half mother
            self.tmp[0, s] = 0.5 * (self.pool[i, s] + self.pool[i + 1, s])
            # second baby, three quarters of father and quarter of mother
            self.tmp[1, s] = self.bound(s, 1.5 * self.pool[i, s]
                                        - 0.5 * self.pool[i + 1, s])
            # third baby, quarter of father and three quarters of mother
            self.tmp[2, s] = self.bound(s, -0.5 * self.pool[i, s]
                                        + 1.5 * self.pool[i + 1, s])
        # evaluate new baby
        self.f_tmp[0] = self.func.fitness(self.tmp[0, :])
        self.f_tmp[1] = self.func.fitness(self.tmp[1, :])
        self.f_tmp[2] = self.func.fitness(self.tmp[2, :])
        # bubble sort: smaller -&gt; larger
        if self.f_tmp[0] &gt; self.f_tmp[1]:
            self.f_tmp[0], self.f_tmp[1] = self.f_tmp[1], self.f_tmp[0]
            self.tmp[0], self.tmp[1] = self.tmp[1], self.tmp[0]
        if self.f_tmp[0] &gt; self.f_tmp[2]:
            self.f_tmp[0], self.f_tmp[2] = self.f_tmp[2], self.f_tmp[0]
            self.tmp[0], self.tmp[2] = self.tmp[2], self.tmp[0]
        if self.f_tmp[1] &gt; self.f_tmp[2]:
            self.f_tmp[1], self.f_tmp[2] = self.f_tmp[2], self.f_tmp[1]
            self.tmp[1], self.tmp[2] = self.tmp[2], self.tmp[1]
        # replace first two baby to parent, another one will be
        self.assign_from(i, self.f_tmp[0], self.tmp[0])
        self.assign_from(i + 1, self.f_tmp[1], self.tmp[1])

</t>
<t tx="leo.20231205084804.88">cdef uint i, s
</t>
<t tx="leo.20231205084804.89">cdef inline double get_delta(self, double y) nogil:
    cdef double r
    if self.task == MAX_GEN and self.stop_at &gt; 0:
        r = &lt;double&gt;self.func.gen / self.stop_at
    else:
        r = 1
    return y * rand_v() * pow(1.0 - r, self.delta)

</t>
<t tx="leo.20231205084804.90">cdef inline void mutate(self) nogil:
    @others
    for i in range(self.pop_num):
        if not rand_v() &lt; self.mutate_f:
            continue
        s = rand_i(self.dim)
        if rand_v() &lt; 0.5:
            self.pool[i, s] += self.get_delta(self.func.ub[s]
                                              - self.pool[i, s])
        else:
            self.pool[i, s] -= self.get_delta(self.pool[i, s]
                                              - self.func.lb[s])
        # Get fitness
        self.fitness[i] = self.func.fitness(self.pool[i, :])
    self.find_best()

</t>
<t tx="leo.20231205084804.91">cdef uint i, s
</t>
<t tx="leo.20231205084804.92">cdef inline void select(self) nogil:
    """roulette wheel selection"""
    @others
    for i in range(self.pop_num):
        j = rand_i(self.pop_num)
        k = rand_i(self.pop_num)
        if self.fitness[j] &gt; self.fitness[k] and rand_v() &lt; self.win:
            self.new_fitness[i] = self.fitness[k]
            self.new_pool[i, :] = self.pool[k, :]
        else:
            self.new_fitness[i] = self.fitness[j]
            self.new_pool[i, :] = self.pool[j, :]
    # in this stage, new_chromosome is select finish
    # now replace origin chromosome
    self.fitness[:] = self.new_fitness
    self.pool[:] = self.new_pool
    # select random one chromosome to be best chromosome,
    # make best chromosome still exist
    self.assign_from(rand_i(self.pop_num), self.best_f, self.best)

</t>
<t tx="leo.20231205084804.93">cdef uint i, j, k
</t>
<t tx="leo.20231205084804.94">cdef inline void generation(self) nogil:
    self.select()
    self.crossover()
    self.mutate()
</t>
<t tx="leo.20231205084804.95">@path Y:/tmp/metapyslvs/metaheuristics/
# -*- coding: utf-8 -*-
# cython: language_level=3, cdivision=True, boundscheck=False, wraparound=False
# cython: initializedcheck=False, nonecheck=False

"""Test objective function for algorithms.

author: Yuan Chang
copyright: Copyright (C) 2016-2022
license: AGPL
email: pyslvs@gmail.com
"""

cimport cython
from numpy import array, float64 as f64
from .utility cimport ObjFunc


@others
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084804.96">@cython.final
cdef class TestObj(ObjFunc):
    """Test objective function.

    f(x) = x1^2 + 8*x2
    """

    @others
</t>
<t tx="leo.20231205084804.97">def __cinit__(self):
    self.ub = array([50] * 4, dtype=f64)
    self.lb = array([-50] * 4, dtype=f64)

</t>
<t tx="leo.20231205084804.98">cdef double target(self, double[:] v) nogil:
    return v[0] * v[0] + 8 * v[1] * v[1] + v[2] * v[2] + v[3] * v[3]

</t>
<t tx="leo.20231205084804.99">cdef double fitness(self, double[:] v) nogil:
    return self.target(v)

</t>
<t tx="leo.20231205084805.1">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/
# -*- coding: utf-8 -*-
# cython: language_level=3, cdivision=True, boundscheck=False, wraparound=False
# cython: initializedcheck=False, nonecheck=False

"""PMKS symbolics.

author: Yuan Chang
copyright: Copyright (C) 2016-2022
license: AGPL
email: pyslvs@gmail.com
"""

cimport cython
from libc.math cimport M_PI, atan2, hypot
from cpython.object cimport Py_EQ, Py_NE
from numpy import array, zeros, float64 as f64


@others
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084805.10">cpdef double slope_angle(self, Coord p):
    """Slope angle of two coordinates."""
    return slope_angle(self.x, self.y, p.x, p.y)

</t>
<t tx="leo.20231205084805.100">    vpoints = list(vpoints)
</t>
<t tx="leo.20231205084805.101">    cdef int vp_dof = vpoint_dof(vpoints)
</t>
<t tx="leo.20231205084805.102">    # First, we create a "VLinks" that can help us to
    # find a relationship just like adjacency matrix
    cdef int node, base
</t>
<t tx="leo.20231205084805.103">    cdef VPoint vp, vp2
</t>
<t tx="leo.20231205084805.104">    vlinks = {}
    for node, vp in enumerate(vpoints):
        for link in vp.links:
            # Add as vlink.
            if link not in vlinks:
                vlinks[link] = [node]
            else:
                vlinks[link].append(node)
</t>
<t tx="leo.20231205084805.105">    # Replace the P joints and their friends with RP joint
    # DOF must be same after properties changed
    cdef double x, y, angle
</t>
<t tx="leo.20231205084805.106">    for base in range(len(vpoints)):
        vp = vpoints[base]
        if vp.type != VJoint.P:
            continue
        for link in vp.links[1:]:
            for node in vlinks[link]:
                vp2 = vpoints[node]
                if node == base or vp2.is_slider():
                    continue
                x = vp2.c[0, 0]
                y = vp2.c[0, 1]
                vpoints[node] = VPoint.c_slider_joint([vp.links[0]] + [
                    link_ for link_ in vp2.links
                    if link_ not in vp.links
                ], VJoint.RP, vp.angle, x, y)
    # Assign joint positions
    for node, vp in enumerate(vpoints):
        base = 1 if vp.is_slider() else 0
        joint_pos[Sym(P_LABEL, node)] = CCoord(vp.c[base, 0], vp.c[base, 1])
    # Add slider slot virtual coordinates
    for node, vp in enumerate(vpoints):
        # PLPP dependencies
        if vp.type != VJoint.RP:
            continue
        base = base_friend(node, vpoints)
        angle = (vp.angle
                 - vp.slope_angle(vpoints[base], 1, 0)
                 + vp.slope_angle(vpoints[base], 0, 0)) / 180 * M_PI
        joint_pos[Sym(S_LABEL, node)] = CCoord(vp.c[1, 0] + cos(angle),
                                               vp.c[1, 1] + sin(angle))
</t>
<t tx="leo.20231205084805.107">    # Scan again to check if the parameter exists
    # Especially link lengths and angles
    cdef int dof = 0
</t>
<t tx="leo.20231205084805.108">    cdef Expr e
</t>
<t tx="leo.20231205084805.109">    cdef SwappablePair pair1, pair2
</t>
<t tx="leo.20231205084805.11">cpdef bint is_nan(self):
    """Return true if the coordinate value is not a number."""
    return self.x != self.x

</t>
<t tx="leo.20231205084805.110">    for e in exprs.stack:
        pair1 = SwappablePair(e.c1.second, e.target.second)
        pair2 = SwappablePair(e.c2.second, e.target.second)
        if e.func == PXY:
            param[e.v1] = joint_pos[e.target].x - joint_pos[e.c1].x
            param[e.v2] = joint_pos[e.target].y - joint_pos[e.c1].y
            continue
        if e.func in {PLLP, PALP}:
            param[e.v2] = (link_len[pair2]
                           if link_len.find(pair2) != link_len.end() else
                           distance(joint_pos[e.c2].x,
                                    joint_pos[e.c2].y,
                                    joint_pos[e.target].x,
                                    joint_pos[e.target].y))
        if e.func in {PLLP, PLA, PLAP, PLPP}:
            param[e.v1] = (link_len[pair1]
                           if link_len.find(pair1) != link_len.end() else
                           distance(joint_pos[e.c1].x,
                                    joint_pos[e.c1].y,
                                    joint_pos[e.target].x,
                                    joint_pos[e.target].y))
            if e.func in {PLA, PLAP}:
                if e.v2.first == I_LABEL:
                    # Input angles
                    angle = inputs[pair1.first, pair1.second]
                    param[e.v2] = angle / 180 * M_PI
                    dof += 1
                else:
                    # A_LABEL
                    param[e.v2] = slope_angle(joint_pos[e.c1].x,
                                              joint_pos[e.c1].y,
                                              joint_pos[e.target].x,
                                              joint_pos[e.target].y)
                    if e.func == PLAP:
                        param[e.v2] -= slope_angle(joint_pos[e.c1].x,
                                                   joint_pos[e.c1].y,
                                                   joint_pos[e.c2].x,
                                                   joint_pos[e.c2].y)
                if (
                    (&lt;VPoint&gt;vpoints[e.c1.second]).grounded()
                    and (&lt;VPoint&gt;vpoints[e.target.second]).grounded()
                ):
                    raise ValueError("wrong driver definition")
    return dof &lt;= len(inputs) &lt;= vp_dof


</t>
<t tx="leo.20231205084805.111">cpdef list expr_solving(
    EStack exprs,
    object vpoints,
    object inputs = None
</t>
<t tx="leo.20231205084805.112">):
    """Solver function of Triangular method and BFGS method, for mechanism
    expression `vpoints`.

    The triangle expression stack `expr` is generated from
    [`t_config`](#t_config).

    Solver function will not handle slider input pairs in argument `angles`,
    which is only support revolute joints. In another way, the slider input
    pairs can be set by [`VPoint.disable_offset()`](#vpointdisable_offset)
    method.
    """
    # Blank sequences
    if inputs is None:
        inputs = {}
</t>
<t tx="leo.20231205084805.113">    cdef map[Sym, CCoord] joint_pos
</t>
<t tx="leo.20231205084805.114">    cdef map[SwappablePair, double] link_len
</t>
<t tx="leo.20231205084805.115">    cdef map[Sym, double] param
</t>
<t tx="leo.20231205084805.116">    if not preprocessing(exprs, vpoints, inputs, joint_pos, link_len, param):
        raise ValueError("wrong number of input parameters")
    # Check coverage
    status = {i: False for i in range(len(vpoints))}
</t>
<t tx="leo.20231205084805.117">    cdef Expr e
</t>
<t tx="leo.20231205084805.118">    for e in exprs.stack:
        status[e.c1.second] = status[e.target.second] = True
        if e.func in {PLAP, PLLP, PLPP, PALP}:
            status[e.c2.second] = True
            if e.func == PLPP:
                status[e.c3.second] = True
</t>
<t tx="leo.20231205084805.119">    cdef bint bfgs_mode = not all(status.values())
</t>
<t tx="leo.20231205084805.12">def __repr__(self):
    return f"Coord({self.x:.02f}, {self.y:.02f})"


</t>
<t tx="leo.20231205084805.120">    # Solve
    cdef ExprSolver solver = ExprSolver(exprs.stack, joint_pos, param)
</t>
<t tx="leo.20231205084805.121">    if not solver.solve():
        raise ValueError("solve failed")
</t>
<t tx="leo.20231205084805.122">    # Use BFGS mode
    cdef pair[Sym, CCoord] jp
</t>
<t tx="leo.20231205084805.123">    if bfgs_mode:
        data_dict = {}
        for jp in solver.joint_pos:
            if (
                jp.first.first == P_LABEL
                and status[jp.first.second]
            ):
                data_dict[jp.first.second] = Coord.__new__(Coord, jp.second.x,
                                                           jp.second.y)
        return SolverSystem(vpoints, inputs, data_dict).solve()
    rt = []
</t>
<t tx="leo.20231205084805.124">    cdef int i
</t>
<t tx="leo.20231205084805.125">    cdef CCoord c
</t>
<t tx="leo.20231205084805.126">    cdef VPoint vp
</t>
<t tx="leo.20231205084805.127">    for i, vp in enumerate(vpoints):
        c = solver.joint_pos[Sym(P_LABEL, i)]
        if vp.is_slider():
            rt.append(((vp.c[0, 0], vp.c[0, 1]), (c.x, c.y)))
        else:
            rt.append((c.x, c.y))
    return rt


cdef (bint, map[Sym, CCoord]) quick_solve(
    vector[Expr] stack,
    map[Sym, CCoord] joint_pos,
    map[Sym, double] param
) nogil:
    """Quick solving function.

    !! Cython can not expose C external function to another pyx.
    """
</t>
<t tx="leo.20231205084805.128">    cdef ExprSolver s = ExprSolver(stack, joint_pos, param)
</t>
<t tx="leo.20231205084805.129">    cdef bint ok = s.solve()
</t>
<t tx="leo.20231205084805.13">@cython.final
cdef class VPoint:
    """Mechanism expression class."""
    HOLDER = VPoint([], VJoint.R, 0., "", 0., 0.)

    @others
</t>
<t tx="leo.20231205084805.130">    return ok, s.joint_pos


</t>
<t tx="leo.20231205084805.131">def uniform_four_bar(double ml, int n):
    """Generate n four bar mechanisms from maximum lengths.

    These mechanisms have coupling points.
    Normalized parameters are $[L_0, L_2, L_3, L_4, \\alpha]$.

    ![pxy](img/uniform_four_bar.png)
    """
    return array(_uniform_four_bar(ml, n))


</t>
<t tx="leo.20231205084805.132">cdef double[:, :] _uniform_four_bar(double ml, int n):
    """Uniform four-bar implementation."""
    @others
    for i in range(n):
        while not d[i, 0] + d[i, 2] &gt; 1 + d[i, 1]:
            for j in range(4):
                d[i, j] = uniform(1., ml)
        d[i, 4] = uniform(1., 2 * M_PI)
    return d


</t>
<t tx="leo.20231205084805.133">cdef double[:, :] d = uniform(1., ml, (n, 5))
</t>
<t tx="leo.20231205084805.134">cdef int i
</t>
<t tx="leo.20231205084805.135">def uniform_path(double[:, :] v, int n):
    """Generate path with four-bar dimensions.

    Normalized parameters are $[L_0, L_2, L_3, L_4, \\alpha]$.
    """
    return array(c_uniform_path(v, n))


</t>
<t tx="leo.20231205084805.136">cdef (vector[Expr], map[Sym, CCoord], map[Sym, double]) ueb(double[:] v) nogil:
    """Uniform expression builder."""
</t>
<t tx="leo.20231205084805.137">    cdef vector[Expr] stack
</t>
<t tx="leo.20231205084805.138">    stack.push_back(Expr(False, PLA, Sym(L_LABEL, 1), Sym(I_LABEL, 0),
                         Sym(P_LABEL, 0), Sym(), Sym(), Sym(P_LABEL, 2)))
    stack.push_back(Expr(False, PLLP, Sym(L_LABEL, 2), Sym(L_LABEL, 3),
                         Sym(P_LABEL, 2), Sym(P_LABEL, 1), Sym(),
                         Sym(P_LABEL, 3)))
    stack.push_back(Expr(False, PLAP, Sym(L_LABEL, 4), Sym(A_LABEL, 0),
                         Sym(P_LABEL, 2), Sym(P_LABEL, 3), Sym(),
                         Sym(P_LABEL, 4)))
</t>
<t tx="leo.20231205084805.139">    cdef map[Sym, CCoord] joint_pos
</t>
<t tx="leo.20231205084805.14">def __cinit__(
    self,
    object links,
    VJoint j_type,
    double angle,
    str color_str,
    double x,
    double y,
    object color_func=None
</t>
<t tx="leo.20231205084805.140">    joint_pos[Sym(P_LABEL, 0)] = CCoord(0, 0)
</t>
<t tx="leo.20231205084805.141">    cdef map[Sym, double] param
</t>
<t tx="leo.20231205084805.142">    param[Sym(L_LABEL, 1)] = 1.
    joint_pos[Sym(P_LABEL, 1)] = CCoord(v[0], 0)
</t>
<t tx="leo.20231205084805.143">    cdef int i
</t>
<t tx="leo.20231205084805.144">    for i in range(1, 4):
        param[Sym(L_LABEL, i + 1)] = v[i]
    param[Sym(A_LABEL, 0)] = v[4]
    # Assign driver angle
    # param[Sym(I_LABEL, 0)] = a
    return stack, joint_pos, param


</t>
<t tx="leo.20231205084805.145">cdef double[:, :, :] c_uniform_path(double[:, :] v, int n) nogil:
    """Uniform path implementation."""
    @others
    for i in range(len(v)):
        stack, joint_pos, param = ueb(v[i])
        j = 0
        a = 0
        while a &lt; 2 * M_PI:
            param[Sym(I_LABEL, 0)] = a
            ok, ans = quick_solve(stack, joint_pos, param)
            if ok:
                c = ans[Sym(P_LABEL, 4)]
                p[i, j, 0] = c.x
                p[i, j, 1] = c.y
            else:
                p[i, j, 0] = NAN
                p[i, j, 1] = NAN
            a += 2 * M_PI / n
            j += 1
    return p


</t>
<t tx="leo.20231205084805.146">cdef double[:, :, :] p
</t>
<t tx="leo.20231205084805.147">with gil:
    p = zeros((v.shape[0], n, 2))
</t>
<t tx="leo.20231205084805.148">cdef vector[Expr] stack
</t>
<t tx="leo.20231205084805.149">cdef map[Sym, CCoord] joint_pos
</t>
<t tx="leo.20231205084805.15">):
    self.set_links(links)
    self.type = j_type
    self.type_str = ('R', 'P', 'RP')[j_type]
    self.angle = angle
    self.color_str = color_str
    if color_func is None:
        self.color = None
    else:
        self.color = color_func(color_str)
    self.x = x
    self.y = y
    self.c = zeros((2, 2), dtype=f64)
    if self.type in {VJoint.P, VJoint.RP}:
        # Slider current coordinates
        # [0]: Current node on slot
        # [1]: Pin
        self.c[0, 0] = self.c[1, 0] = self.x
        self.c[0, 1] = self.c[1, 1] = self.y
    else:
        self.c[0, 0] = self.x
        self.c[0, 1] = self.y
    self.__has_offset = False
    self.__offset = 0

</t>
<t tx="leo.20231205084805.150">cdef map[Sym, double] param
</t>
<t tx="leo.20231205084805.151">cdef bint ok
</t>
<t tx="leo.20231205084805.152">cdef int i, j
</t>
<t tx="leo.20231205084805.153">cdef double a
</t>
<t tx="leo.20231205084805.154">cdef CCoord c
</t>
<t tx="leo.20231205084805.155">cdef map[Sym, CCoord] ans
</t>
<t tx="leo.20231205084805.156">cpdef object uniform_expr(double[:] v):
    """Turn the uniform link length into expression."""
    @others
    while a &lt; 2 * M_PI:
        param[Sym(I_LABEL, 0)] = a
        ok, ans = quick_solve(stack, joint_pos, param)
        for i in range(2, 5):
            coords[i - 2] = ans[Sym(P_LABEL, i)]
        if ok:
            break
        a += 2 * M_PI / 30
    return [
        VPoint.c_r_joint([VLink.FRAME, 'L1'], 0., 0.),
        VPoint.c_r_joint([VLink.FRAME, 'L3'], v[0], 0.),
        VPoint.c_r_joint(['L1', 'L2'], coords[0].x, coords[0].y),
        VPoint.c_r_joint(['L2', 'L3'], coords[1].x, coords[1].y),
        VPoint.c_r_joint(['L2'], coords[2].x, coords[2].y),
    ]
</t>
<t tx="leo.20231205084805.157">cdef vector[Expr] stack
</t>
<t tx="leo.20231205084805.158">cdef map[Sym, CCoord] joint_pos
</t>
<t tx="leo.20231205084805.159">cdef map[Sym, double] param
</t>
<t tx="leo.20231205084805.16">@staticmethod
def r_joint(links, x, y):
    """A fast constructor of revolute joints."""
    return VPoint.c_r_joint(links, x, y)

</t>
<t tx="leo.20231205084805.160">stack, joint_pos, param = ueb(v)
</t>
<t tx="leo.20231205084805.161">cdef vector[CCoord] coords = vector[CCoord](3, CCoord(0., 0.))
</t>
<t tx="leo.20231205084805.162">cdef bint ok = False
</t>
<t tx="leo.20231205084805.163">cdef double a = 0
</t>
<t tx="leo.20231205084805.164">cdef map[Sym, CCoord] ans
</t>
<t tx="leo.20231205084805.165">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/
# -*- coding: utf-8 -*-
# cython: language_level=3, cdivision=True, boundscheck=False, wraparound=False
# cython: initializedcheck=False, nonecheck=False

"""Triangular expressions.

author: Yuan Chang
copyright: Copyright (C) 2016-2022
license: AGPL
email: pyslvs@gmail.com
"""

from libc.math cimport sin, cos, M_PI
from libcpp.map cimport map
from numpy import zeros, float64 as f64
from .expression cimport VJoint, VPoint, VLink
from .tinycadlib cimport (
    PXY, PPP, PLA, PLAP, PLLP, PLPP, PALP, P_LABEL, L_LABEL, I_LABEL,
    A_LABEL, S_LABEL
)

ctypedef vector[Sym] Inputs
ctypedef map[int, bint] Status


@others
    # Friend iterator
    while not _is_all_lock(status):
        if status.find(node) == status.end():
            node = 0
            continue
        # Check and break the loop if it's re-scan again
        if skip_times &gt;= around:
            break
        if status[node]:
            node += 1
            skip_times += 1
            continue
        vp1 = vpoints[node]
        if vp1.type == VJoint.R:
            # R joint
            # + Is input node?
            # + Normal revolute joint
            if node in input_targets:
                base = _get_input_base(node, inputs)
                if status[base]:
                    exprs.add_pla(
                        Sym(P_LABEL, base),
                        Sym(L_LABEL, link_symbol),
                        Sym(I_LABEL, input_symbol),
                        Sym(P_LABEL, node)
                    )
                    status[node] = True
                    link_symbol += 1
                    input_symbol += 1
                else:
                    skip_times += 1
            else:
                ok, fa, fb = _get_reliable_friends(node, vp1, vlinks, status)
                if not ok:
                    skip_times += 1
                else:
                    if not _clockwise(pos[fa], pos[node], pos[fb]):
                        fa, fb = fb, fa
                    vp2 = vpoints[fa]
                    vp3 = vpoints[fb]
                    if vp2.same_link(vp3) and not (vp2.grounded() and vp3.grounded()):
                        exprs.add_plap(
                            Sym(P_LABEL, fa),
                            Sym(L_LABEL, link_symbol),
                            Sym(A_LABEL, angle_symbol),
                            Sym(P_LABEL, fb),
                            Sym(P_LABEL, node)
                        )
                        link_symbol += 1
                        angle_symbol += 1
                    else:
                        # Decide when to solve parallel linkage
                        fc = _get_intersection(fa, fb, vpoints, vlinks, status)
                        if (fc != -1 and _is_parallel(
                            vpoints[fa], vpoints[fb], vpoints[fc], vpoints[node]
                        )):
                            exprs.add_ppp(
                                Sym(P_LABEL, fc),
                                Sym(P_LABEL, fa),
                                Sym(P_LABEL, fb),
                                Sym(P_LABEL, node)
                            )
                        else:
                            exprs.add_pllp(
                                Sym(P_LABEL, fa),
                                Sym(L_LABEL, link_symbol),
                                Sym(L_LABEL, link_symbol + 1),
                                Sym(P_LABEL, fb),
                                Sym(P_LABEL, node)
                            )
                            link_symbol += 2
                    status[node] = True
                    skip_times = 0
        elif vp1.type == VJoint.P:
            # Need to solve P joint itself here (only grounded)
            fa = _get_not_base_friend(vp1, vlinks, status)
            if fa == -1:
                skip_times += 1
            else:
                exprs.add_pxy(
                    Sym(P_LABEL, fa),
                    Sym(L_LABEL, link_symbol),
                    Sym(L_LABEL, link_symbol + 1),
                    Sym(P_LABEL, node)
                )
                status[node] = True
                link_symbol += 2
                # Solution for all friends
                for link in vp1.links[1:]:
                    for fb in vlinks[link]:
                        if status[fb]:
                            continue
                        exprs.add_pxy(
                            Sym(P_LABEL, node),
                            Sym(L_LABEL, link_symbol),
                            Sym(L_LABEL, link_symbol + 1),
                            Sym(P_LABEL, fb)
                        )
                        status[fb] = True
                        link_symbol += 2
                skip_times = 0
        elif vp1.type == VJoint.RP:
            # Copy as 'fc'
            fc = node
            # 'S' point
            tmp[:] = pos[node, :]
            angle = vp1.angle / 180 * M_PI
            tmp[0] += cos(angle)
            tmp[1] += sin(angle)
            fa = _get_not_base_friend(vp1, vlinks, status)
            ok, fb, fd = _get_base_friend(vp1, vlinks)
            if fa == -1 or not ok:
                skip_times += 1
            else:
                # Slot is not grounded
                if not vp1.grounded():
                    if not _clockwise(pos[fb], tmp, pos[fd]):
                        fb, fd = fd, fb
                    exprs.add_pllp(
                        Sym(P_LABEL, fb),
                        Sym(L_LABEL, link_symbol),
                        Sym(L_LABEL, link_symbol + 1),
                        Sym(P_LABEL, fd),
                        Sym(P_LABEL, node)
                    )
                    link_symbol += 2
                # PLPP
                # [PLLP]
                # Set 'S' (slider) point to define second point of slider
                # + A 'friend' from base link
                # + Get distance from me and friend
                # [PLPP]
                # Re-define coordinate of target point by self and 'S' point
                # + A 'friend' from other link
                # + Solve
                if not _clockwise(pos[fb], tmp, pos[fc]):
                    fb, fc = fc, fb
                exprs.add_pllp(
                    Sym(P_LABEL, fb),
                    Sym(L_LABEL, link_symbol),
                    Sym(L_LABEL, link_symbol + 1),
                    Sym(P_LABEL, fc),
                    Sym(S_LABEL, node)
                )
                # Two conditions
                exprs.add_plpp(
                    Sym(P_LABEL, fa),
                    Sym(L_LABEL, link_symbol + 2),
                    Sym(P_LABEL, node),
                    Sym(S_LABEL, node),
                    Sym(P_LABEL, node),
                    (pos[fa, 0] - pos[node, 0] &gt; 0) != (vp1.angle &gt; 90)
                )
                status[node] = True
                link_symbol += 3
                skip_times = 0
        node += 1
    if has_status:
        for node, ok in status:
            status_[node] = ok
    return exprs
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084805.166">cdef str symbol_str(Sym p):
    """The match pattern of the symbols."""
    if p.first == P_LABEL:
        return f"P{p.second}"
    elif p.first == L_LABEL:
        return f"L{p.second}"
    elif p.first == I_LABEL:
        return f"I{p.second}"
    elif p.first == A_LABEL:
        return f"A{p.second}"
    elif p.first == S_LABEL:
        return f"S{p.second}"
    else:
        return ""


</t>
<t tx="leo.20231205084805.167">cdef class EStack:
    """Triangle solution stack, generated from [`t_config`](#t_config).
    It is pointless to call the constructor.
    """

    @others
</t>
<t tx="leo.20231205084805.168">cdef void add_pxy(self, Sym c1, Sym v1, Sym v2, Sym t) nogil:
    @others
    e.func = PXY
    e.c1 = c1
    e.v1 = v1
    e.v2 = v2
    e.target = t
    e.op = False
    self.stack.push_back(e)

</t>
<t tx="leo.20231205084805.169">cdef Expr e
</t>
<t tx="leo.20231205084805.17">@staticmethod
cdef VPoint c_r_joint(object links, double x, double y):
    return VPoint.__new__(VPoint, links, VJoint.R, 0., '', x, y)

</t>
<t tx="leo.20231205084805.170">cdef void add_ppp(self, Sym c1, Sym c2, Sym c3, Sym t) nogil:
    cdef Expr e
    e.func = PPP
    e.c1 = c1
    e.c2 = c2
    e.c3 = c3
    e.target = t
    self.stack.push_back(e)

</t>
<t tx="leo.20231205084805.171">cdef void add_pla(self, Sym c1, Sym v1, Sym v2, Sym t) nogil:
    @others
    e.func = PLA
    e.c1 = c1
    e.v1 = v1
    e.v2 = v2
    e.target = t
    e.op = False
    self.stack.push_back(e)

</t>
<t tx="leo.20231205084805.172">cdef Expr e
</t>
<t tx="leo.20231205084805.173">cdef void add_plap(self, Sym c1, Sym v1, Sym v2, Sym c2, Sym t) nogil:
    @others
    e.func = PLAP
    e.c1 = c1
    e.v1 = v1
    e.v2 = v2
    e.c2 = c2
    e.target = t
    e.op = False
    self.stack.push_back(e)

</t>
<t tx="leo.20231205084805.174">cdef Expr e
</t>
<t tx="leo.20231205084805.175">cdef void add_pllp(self, Sym c1, Sym v1, Sym v2, Sym c2, Sym t) nogil:
    @others
    e.func = PLLP
    e.c1 = c1
    e.v1 = v1
    e.v2 = v2
    e.c2 = c2
    e.target = t
    e.op = False
    self.stack.push_back(e)

</t>
<t tx="leo.20231205084805.176">cdef Expr e
</t>
<t tx="leo.20231205084805.177">cdef void add_plpp(self, Sym c1, Sym v1, Sym c2, Sym c3, Sym t, bint op) nogil:
    @others
    e.func = PLPP
    e.c1 = c1
    e.v1 = v1
    e.c2 = c2
    e.c3 = c3
    e.target = t
    e.op = op
    self.stack.push_back(e)

</t>
<t tx="leo.20231205084805.178">cdef Expr e
</t>
<t tx="leo.20231205084805.179">cdef void add_palp(self, Sym c1, Sym v1, Sym v2, Sym c2, Sym t, bint op) nogil:
    @others
    e.func = PALP
    e.c1 = c1
    e.v1 = v1
    e.v2 = v2
    e.c2 = c2
    e.target = t
    e.op = op
    self.stack.push_back(e)

</t>
<t tx="leo.20231205084805.18">@staticmethod
def slider_joint(links, type_int, angle, x, y):
    """A fast constructor of slider joints."""
    return VPoint.c_slider_joint(links, type_int, angle, x, y)

</t>
<t tx="leo.20231205084805.180">cdef Expr e
</t>
<t tx="leo.20231205084805.181">cpdef list as_list(self):
    """Copy the dataset as list object."""
    stack = []
    @others
    for expr in self.stack:
        if expr.func == PXY:
            stack.append((
                "PXY",
                symbol_str(expr.c1),
                symbol_str(expr.v1),
                symbol_str(expr.v2),
                symbol_str(expr.target),
            ))
        elif expr.func == PPP:
            stack.append((
                "PPP",
                symbol_str(expr.c1),
                symbol_str(expr.c2),
                symbol_str(expr.c3),
                symbol_str(expr.target),
            ))
        elif expr.func == PLA:
            stack.append((
                "PLA",
                symbol_str(expr.c1),
                symbol_str(expr.v1),
                symbol_str(expr.v2),
                symbol_str(expr.target),
            ))
        elif expr.func == PLAP:
            stack.append((
                "PLAP",
                symbol_str(expr.c1),
                symbol_str(expr.v1),
                symbol_str(expr.v2),
                symbol_str(expr.c2),
                symbol_str(expr.target),
            ))
        elif expr.func == PLLP:
            stack.append((
                "PLLP",
                symbol_str(expr.c1),
                symbol_str(expr.v1),
                symbol_str(expr.v2),
                symbol_str(expr.c2),
                symbol_str(expr.target),
            ))
        elif expr.func == PLPP:
            stack.append((
                "PLPP",
                symbol_str(expr.c1),
                symbol_str(expr.v1),
                symbol_str(expr.c2),
                symbol_str(expr.c3),
                symbol_str(expr.target),
            ))
        elif expr.func == PALP:
            stack.append((
                "PALP",
                symbol_str(expr.c1),
                symbol_str(expr.v1),
                symbol_str(expr.v2),
                symbol_str(expr.c2),
                symbol_str(expr.target),
            ))
    return stack

</t>
<t tx="leo.20231205084805.182">cdef Expr expr
</t>
<t tx="leo.20231205084805.183">def __repr__(self):
    return f"{type(self).__name__}({self.as_list()})"


</t>
<t tx="leo.20231205084805.184">cdef bint _is_all_lock(Status &amp;status):
    """Test is all status done."""
    cdef bint n_status
    for _, n_status in status:
        if not n_status:
            return False
    return True


</t>
<t tx="leo.20231205084805.185">cdef bint _is_parallel(VPoint p1, VPoint p2, VPoint p3, VPoint p4):
    """Check parallel four bar loop."""
    return (abs(p1.distance(p3) - p2.distance(p4)) &lt; 1e-12
            and abs(p2.distance(p3) - p1.distance(p4)) &lt; 1e-12)


</t>
<t tx="leo.20231205084805.186">cdef bint _clockwise(double[:] c1, double[:] c2, double[:] c3):
    """Check the orientation of three points."""
    cdef double val = (c2[1] - c1[1]) * (c3[0] - c2[0]) - (c2[0] - c1[0]) * (c3[1] - c2[1])
    return val == 0 or val &gt; 0


</t>
<t tx="leo.20231205084805.187">cdef (bint, int, int) _get_reliable_friends(
    int node,
    VPoint vpoint,
    object vlinks,
    Status &amp;status
):
    """Return two "has been solved" nodes on the same link."""
</t>
<t tx="leo.20231205084805.188">    cdef int fa = -1
</t>
<t tx="leo.20231205084805.189">    cdef int fb = -1
</t>
<t tx="leo.20231205084805.19">@staticmethod
cdef VPoint c_slider_joint(object links, VJoint type_int, double angle, double x, double y):
    return VPoint.__new__(VPoint, links, type_int, angle, '', x, y)

</t>
<t tx="leo.20231205084805.190">    cdef int f
</t>
<t tx="leo.20231205084805.191">    for link in vpoint.links:
        if len(vlinks[link]) &lt; 2:
            continue
        for f in vlinks[link]:
            if status[f] and f != node:
                if fa == -1:
                    fa = f
                elif fb == -1:
                    fb = f
                    return True, fa, fb
    return False, -1, -1


</t>
<t tx="leo.20231205084805.192">cdef int _get_intersection(
    int node1,
    int node2,
    object vpoints,
    object vlinks,
    Status &amp;status
</t>
<t tx="leo.20231205084805.193">):
    """Get a configured node between two nodes."""
</t>
<t tx="leo.20231205084805.194">    cdef int node
</t>
<t tx="leo.20231205084805.195">    cdef VPoint vp
</t>
<t tx="leo.20231205084805.196">    for node, vp in enumerate(vpoints):
        if (set(vp.links) &amp; set((&lt;VPoint&gt;vpoints[node1]).links)
            and set(vp.links) &amp; set((&lt;VPoint&gt; vpoints[node2]).links)
            and status[node]
        ):
            return node
    return -1


</t>
<t tx="leo.20231205084805.197">cdef int _get_not_base_friend(VPoint vpoint, object vlinks, Status &amp;status):
    """Get a configured node from other links."""
    if (vpoint.pin_grounded()
        or not vpoint.grounded()
        or vpoint.has_offset()
        or len(vpoint.links) &lt; 2
    ):
        return -1
    @others
    for f in vlinks[vpoint.links[1]]:
        if status[f]:
            return f
    return -1


</t>
<t tx="leo.20231205084805.198">cdef int f
</t>
<t tx="leo.20231205084805.199">cdef (bint, int, int) _get_base_friend(VPoint vpoint, object vlinks):
    """Get two configured nodes on the same links."""
    if len(vpoint.links) &lt; 1:
        return False, -1, -1
</t>
<t tx="leo.20231205084805.2">cdef double distance(double x1, double y1, double x2, double y2) nogil:
    """Distance of two coordinates."""
    return hypot(x2 - x1, y2 - y1)


</t>
<t tx="leo.20231205084805.20">cpdef VPoint copy(self):
    """The copy method of the VPoint object."""
    return self.__copy__()

</t>
<t tx="leo.20231205084805.200">    cdef int fa = -1
</t>
<t tx="leo.20231205084805.201">    cdef int f
</t>
<t tx="leo.20231205084805.202">    for f in vlinks[vpoint.links[0]]:
        if fa == -1:
            fa = f
        else:
            return True, fa, f
    return False, -1, -1


</t>
<t tx="leo.20231205084805.203">cdef int _get_input_base(int node, Inputs &amp;inputs):
    """Get the base node for input pairs."""
    cdef int base, node_
    for base, node_ in inputs:
        if node == node_:
            return base
    return -1


</t>
<t tx="leo.20231205084805.204">cpdef EStack t_config(
    object vpoints_,
    object inputs_,
    object status_ = None
</t>
<t tx="leo.20231205084805.205">):
    """Generate the Triangle solution stack by mechanism expression `vpoints_`.

    The argument `inputs` is a list of input pairs.
    The argument `status` will track the configuration of each point,
    which is optional.
    """
</t>
<t tx="leo.20231205084805.206">    # For VPoint list:
    # + vpoints_: [vpoint0, vpoint1, ...]
    # + inputs: [(p0, p1), (p0, p2), ...]
    # + status: Dict[int, bint]
    # vpoints will make a copy that we don't want to modified itself
    cdef bint has_input = True
</t>
<t tx="leo.20231205084805.207">    cdef bint has_status = True
</t>
<t tx="leo.20231205084805.208">    if inputs_ is None or not inputs_:
        has_input = False
    if status_ is None:
        has_status = False
</t>
<t tx="leo.20231205084805.209">    cdef EStack exprs = EStack.__new__(EStack)
</t>
<t tx="leo.20231205084805.21">@property
def sx(self):
    """X value of slot coordinate."""
    return self.c[0, 0]

</t>
<t tx="leo.20231205084805.210">    if not vpoints_ or not has_input:
        return exprs

    vpoints = list(vpoints_)
</t>
<t tx="leo.20231205084805.211">    cdef Inputs inputs
</t>
<t tx="leo.20231205084805.212">    cdef Status status

</t>
<t tx="leo.20231205084805.213">    cdef bint ok
</t>
<t tx="leo.20231205084805.214">    cdef int node, base
</t>
<t tx="leo.20231205084805.215">    if has_input:
        for node, base in inputs_:
            inputs.push_back(Sym(node, base))
    if has_status:
        for node, ok in status_.items():
            status[node] = ok
</t>
<t tx="leo.20231205084805.216">    # First, we create a "VLinks" that can help us to
    # find a relationship just like adjacency matrix
    cdef VPoint vp1, vp2, vp3
</t>
<t tx="leo.20231205084805.217">    vlinks = {}
    for node, vp1 in enumerate(vpoints):
        status[node] = False
        if vp1.links:
            for link in vp1.links:
                # Connect on the ground and it is not a slider
                if link == VLink.FRAME and vp1.type == VJoint.R:
                    status[node] = True
                # Add as vlink
                if link not in vlinks:
                    vlinks[link] = {node}
                else:
                    vlinks[link].add(node)
        else:
            status[node] = True
    # Replace the P joints and their friends with RP joint
    # DOF must be same after properties changed
    for base, vp1 in enumerate(vpoints):
        if vp1.type != VJoint.P or not vp1.grounded():
            continue
        for link in vp1.links[1:]:
            for node in vlinks[link]:
                vp2 = vpoints[node]
                if node == base or vp2.type != VJoint.R:
                    continue
                vpoints[node] = VPoint.c_slider_joint([vp1.links[0]] + [
                    link_ for link_ in vp2.links
                    if link_ not in vp1.links
                ], VJoint.RP, vp1.angle, vp2.x, vp2.y)
</t>
<t tx="leo.20231205084805.218">    # Add positions parameters
    cdef double[:, :] pos = zeros((len(vpoints), 2), dtype=f64)
</t>
<t tx="leo.20231205084805.219">    for base, vp1 in enumerate(vpoints):
        node = 0 if vp1.type == VJoint.R else 1
        pos[base, 0] = vp1.c[node, 0]
        pos[base, 1] = vp1.c[node, 1]
</t>
<t tx="leo.20231205084805.22">@property
def sy(self):
    """Y value of slot coordinate."""
    return self.c[0, 1]

</t>
<t tx="leo.20231205084805.220">    cdef int link_symbol = 0
</t>
<t tx="leo.20231205084805.221">    cdef int input_symbol = 0
</t>
<t tx="leo.20231205084805.222">    cdef int angle_symbol = 0
</t>
<t tx="leo.20231205084805.223">    # Input joints (R) that was connect with ground
    for base, node in inputs:
        if status[base]:
            exprs.add_pla(
                [P_LABEL, base],
                [L_LABEL, link_symbol],
                [I_LABEL, input_symbol],
                [P_LABEL, node]
            )
            status[node] = True
            link_symbol += 1
            input_symbol += 1
    # Now let we search around all the points, until we find the solutions
    # that we could
    input_targets = {node for _, node in inputs}
    node = 0
</t>
<t tx="leo.20231205084805.224">    cdef int skip_times = 0
</t>
<t tx="leo.20231205084805.225">    cdef int around = len(status)
</t>
<t tx="leo.20231205084805.226">    cdef int fa, fb, fc, fd
</t>
<t tx="leo.20231205084805.227">    cdef double angle
</t>
<t tx="leo.20231205084805.228">    cdef double[:] tmp = zeros(2, dtype=f64)
</t>
<t tx="leo.20231205084805.23">@property
def cx(self):
    """X value of current coordinate.
    If it's slider, the pin coordinate will be returned.
    """
    if self.type == VJoint.R:
        return self.c[0, 0]
    else:
        return self.c[1, 0]

</t>
<t tx="leo.20231205084805.230"></t>
<t tx="leo.20231205084805.231">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/graph/
# -*- coding: utf-8 -*-
# cython: language_level=3, cdivision=True, boundscheck=False, wraparound=False
# cython: initializedcheck=False, nonecheck=False

"""Graph class.

The algorithm reference:
+ NetworkX

author: Yuan Chang
copyright: Copyright (C) 2016-2022
license: AGPL
email: pyslvs@gmail.com
"""

cimport cython
from libcpp.pair cimport pair
import sys
from typing import Tuple, Dict, Iterator
from itertools import permutations, groupby
from numpy import zeros, uint8 as np_uint

ctypedef pair[int, int] ipair


@others
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084805.232">cpdef list link_assortment(Graph g):
    """Return link assortment of the graph."""
    assortment = [0]
    if not g.edges:
        return assortment
    @others
    for n in g.degrees().values():
        if n &lt; 2:
            continue
        d = n - 2
        while d &gt;= len(assortment):
            assortment.append(0)
        assortment[d] += 1
    return assortment


</t>
<t tx="leo.20231205084805.233">cdef int d, n
</t>
<t tx="leo.20231205084805.234">cpdef list contracted_link_assortment(Graph g):
    """Return contracted link assortment of the graph."""
    if not g.edges:
        return [0]
    assortment = [0] * link_assortment(g)[0]
    counted = set()
    for mcl in _multi_contracted_links(g, False):
        counted.update(mcl)
        assortment[len(mcl) - 1] += 1
    @others
    for n, d in g.degrees().items():
        if d != 2:
            continue
        if n not in counted:
            assortment[0] += 1
    return assortment


</t>
<t tx="leo.20231205084805.235"># For single contracted links
cdef int n, d
</t>
<t tx="leo.20231205084805.236">cdef list _multi_contracted_links(Graph g, bint only_one):
    """Return a list of multiple contracted links."""
    @others
    contracted_links = []
    counted = set()
    for n1 in g.vertices:
        # Only for binary link.
        if len(g.adj[n1]) != 2:
            continue
        # n1 is not collected yet.
        if n1 in counted:
            continue
        index = 0
        c_links = [n1]
        while index &lt; len(c_links):
            for neighbor in g.adj[c_links[index]]:
                if len(g.adj[neighbor]) == 2 and neighbor not in c_links:
                    c_links.append(neighbor)
            index += 1
        if len(c_links) &gt; 1:
            if only_one:
                return c_links
            counted.update(c_links)
            contracted_links.append(tuple(c_links))
    if only_one:
        return []
    else:
        return contracted_links


</t>
<t tx="leo.20231205084805.237">cdef int n1, n2, index, neighbor
</t>
<t tx="leo.20231205084805.238">cpdef list labeled_enumerate(Graph g):
    """Enumerate each node with labeled except isomorphism."""
    result = []
    @others
    for n1 in g.vertices:
        g1 = Graph.__new__(Graph, [e for e in g.edges if n1 not in e])
        for n2, g2 in result:
            if g1.is_isomorphic(g2):
                break
        else:
            result.append((n1, g1))
    return result


</t>
<t tx="leo.20231205084805.239">cdef int n1, n2
</t>
<t tx="leo.20231205084805.24">@property
def cy(self):
    """Y value of current coordinate.
    If it's slider, the pin coordinate will be returned.
    """
    if self.type == VJoint.R:
        return self.c[0, 1]
    else:
        return self.c[1, 1]

</t>
<t tx="leo.20231205084805.240">cdef Graph g1, g2
</t>
<t tx="leo.20231205084805.241">@cython.final
cdef class Graph:
    """The undirected graph class, support multigraph."""

    @others
</t>
<t tx="leo.20231205084805.242">def __cinit__(self, object edges):
    self.edges = tuple(edges)
    @others
    vertices = []
    for p1, p2 in self.edges:
        if p1 not in vertices:
            vertices.append(p1)
        if p2 not in vertices:
            vertices.append(p2)
    self.vertices = tuple(vertices)
    # adj
    self.adj = {n: self.neighbors(n) for n in self.vertices}

</t>
<t tx="leo.20231205084805.243"># vertices
cdef int p1, p2
</t>
<t tx="leo.20231205084805.244">cpdef void add_vertices(self, object vertices):
    """Add vertices from iterable object `vertices`."""
    self.vertices = tuple(set(self.vertices) | set(vertices))

</t>
<t tx="leo.20231205084805.245">cpdef void add_edge(self, int n1, int n2):
    """Add edge `n1` to `n2`."""
    self.edges += ((n1, n2),)
    self.vertices = tuple(set(self.vertices) | {n1, n2})
    cdef int n
    for n in (n1, n2):
        self.adj[n] = self.neighbors(n)

</t>
<t tx="leo.20231205084805.246">cpdef void add_path(self, object new_nodes):
    edges = list(self.edges)
    vertices = set(self.vertices)
    @others
    for n2 in new_nodes:
        if n1 != -1:
            edges.append((n1, n2))
            vertices.update((n1, n2))
        n1 = n2
    self.edges = tuple(edges)
    self.vertices = tuple(vertices)
    for n1 in vertices:
        self.adj[n1] = self.neighbors(n1)

</t>
<t tx="leo.20231205084805.247">cdef int n1 = -1
</t>
<t tx="leo.20231205084805.248">cdef int n2
</t>
<t tx="leo.20231205084805.249">cpdef void remove_edge(self, int n1, int n2):
    """Remove edge(s) {n1, n2} once if exist, otherwise do nothing."""
    vertices = set()
    edges = []
    @others
    for n in self.vertices:
        edge = self.neighbors(n)
        if edge:
            self.adj[n] = edge
        else:
            self.adj.pop(n, None)

</t>
<t tx="leo.20231205084805.25">cpdef void set_links(self, object links) except *:
    """The update function of links attribute."""
    self.links = tuple([s for s in links if s])

</t>
<t tx="leo.20231205084805.250">cdef bint once = False
</t>
<t tx="leo.20231205084805.251">for edge in self.edges:
    if {n1, n2} != set(edge) or once:
        vertices.update(edge)
        edges.append(edge)
    else:
        once = True
self.edges = tuple(edges)
self.vertices = tuple(vertices)
</t>
<t tx="leo.20231205084805.252">cdef int n
</t>
<t tx="leo.20231205084805.253">cpdef int dof(self):
    """Return DOF of the graph.

    !!! note
        DOF is the Degree of Freedoms to a mechanism.

        In the [Graph] objects, all vertices will assumed as revolute
        joints (1 DOF).

        $$
        F = 3(N_L - 1) - 2N_J
        $$
    """
    return 3 * (len(self.vertices) - 1) - (2 * len(self.edges))

</t>
<t tx="leo.20231205084805.254">cpdef inline tuple neighbors(self, int n):
    """Return the neighbors of the vertex `n`."""
    neighbors = []
    @others
    for l1, l2 in self.edges:
        if n == l1:
            neighbors.append(l2)
        if n == l2:
            neighbors.append(l1)
    return tuple(neighbors)

</t>
<t tx="leo.20231205084805.255">cdef int l1, l2
</t>
<t tx="leo.20231205084805.256">cpdef dict degrees(self):
    """Return the degrees of each vertex."""
    return {n: len(neighbors) for n, neighbors in self.adj.items()}

</t>
<t tx="leo.20231205084805.257">cpdef ullong degree_code(self):
    """Generate a degree code.

    With a sorted vertices mapping by the degrees of each vertex,
    regenerate a new adjacency matrix.
    A binary code can be found by concatenating the upper right elements.
    The degree code is the maximum value of the permutation.
    """
    if len(self.vertices) &lt; 2:
        return 0
    # Create a new mapping
    degrees = self.degrees()
    # Permute the group to find the max degree code
    # "per1" is the mapping of the graph
    # "prefix" is the last choose of the candidate (can be multiple)
    per1 = []
    prefix = []
    @others
    for _, g in groupby(
        sorted(degrees, key=degrees.__getitem__, reverse=True),
        key=degrees.__getitem__
    ):
        code = 0
        order = None
        g = tuple(g)
        for pre in iter(prefix if len(prefix) &gt; 1 else [()]):
            for per2 in permutations(g):
                if len(per2) == 1:
                    order = pre + per2
                    prefix = [order]
                    break
                sub_code = 0
                # Calculate sub code
                per3 = tuple(per1) + pre + per2
                for i, n1 in enumerate(per3):
                    for n2 in per3[i + 1:]:
                        sub_code &lt;&lt;= 1
                        sub_code += n2 in self.adj[n1]
                # Compare sub code
                if sub_code &gt; code or order is None:
                    code = sub_code
                    order = pre + per2
                    prefix = [order]
                elif sub_code == code:
                    # Will affect the subsequent arrangement
                    prefix.append(pre + per2)
        if len(prefix) == 1:
            per1.extend(order)
    # Check the last one prefix candidate
    if not set(order) &lt;= set(per1):
        per1.extend(order)
    # Calculate the degree code
    code = 0
    for i, n1 in enumerate(per1):
        for n2 in per1[i + 1:]:
            code &lt;&lt;= 1
            code += n2 in self.adj[n1]
    return code

</t>
<t tx="leo.20231205084805.258">cdef int i, n1, n2
</t>
<t tx="leo.20231205084805.259">cdef ullong code, sub_code
</t>
<t tx="leo.20231205084805.26">cpdef void replace_link(self, str link1, str link2) except *:
    """Replace the value in links attribute."""
    self.set_links([link2 if link == link1 else link for link in self.links])

</t>
<t tx="leo.20231205084805.260">cpdef double[:, :] adjacency_matrix(self):
    """Generate a adjacency matrix.

    Assume the matrix $A[i, j] = A[j, i]$.
    Where $A[i, j] = 1$ if edge `(i, j)` exist.
    """
    @others
    for n1, n2 in self.edges:
        am[n1, n2] += 1
        am[n2, n1] += 1
    return am

</t>
<t tx="leo.20231205084805.261">cdef int n = len(self.vertices)
</t>
<t tx="leo.20231205084805.262">cdef double[:, :] am = zeros((n, n), dtype=np_uint)
</t>
<t tx="leo.20231205084805.263">cdef int n1, n2
</t>
<t tx="leo.20231205084805.264">cpdef bint is_connected(self, int without = -1):
    """Return `True` if the graph is connected.
    Set the argument `without` to ignore one vertex.
    """
    if not self.vertices:
        return True
    @others
    vertices = []
    # Change start node if index zero has been excluded.
    if without == self.vertices[0]:
        vertices.append(self.vertices[1])
    else:
        vertices.append(self.vertices[0])
    # Search node by node.
    while index &lt; len(vertices):
        for neighbors in self.adj[vertices[index]]:
            if (neighbors not in vertices) and neighbors != without:
                vertices.append(neighbors)
        index += 1
    if without != -1:
        vertices.append(without)
    return len(vertices) == len(self.vertices)

</t>
<t tx="leo.20231205084805.265">cdef int neighbors
</t>
<t tx="leo.20231205084805.266">cdef int index = 0
</t>
<t tx="leo.20231205084805.267">cpdef bint has_cut_link(self):
    """Return true if the graph has any cut links."""
    @others
    for n, d in self.degrees().items():
        # Only for multiple links.
        if d &gt; 2:
            # Remove a multiple link should be keep connected.
            if not self.is_connected(n):
                return True
    return False

</t>
<t tx="leo.20231205084805.268">cdef int n, d
</t>
<t tx="leo.20231205084805.269">cpdef bint is_degenerate(self):
    """Return true if this kinematic chain is degenerate.

    + Prue all multiple contracted links recursively.
    + Check the DOF of sub-graph if it is lower then zero.
    """
    if self.has_triangle():
        return True
    @others
    mcl = set()
    while True:
        mcl.update(_multi_contracted_links(g, True))
        if not mcl:
            break
        c_l = []
        for n1, n2 in g.edges:
            if not {n1, n2} &amp; mcl:
                c_l.append((n1, n2))
        mcl.clear()
        # Pruned graph
        g = Graph.__new__(Graph, c_l)
        if {n2 for n2 in g.degrees().values()} == {2}:
            # The graph is a basic loop.
            break
    # Check the DOF
    return g.dof() &lt; 1

</t>
<t tx="leo.20231205084805.27">cpdef void move(self, object c1, object c2 = None) except *:
    """The update function of current coordinate(s).
    The 2nd placement is the pin coordinate of slider joints.

    If there is only one argument for a slider joint,
    the slot and pin coordinates will be set to the same position.
    """
    @others
    x, y = c1
    self.c[0, 0] = x
    self.c[0, 1] = y
    if self.type in {VJoint.P, VJoint.RP}:
        if c2 is not None:
            x, y = c2
        self.c[1, 0] = x
        self.c[1, 1] = y

</t>
<t tx="leo.20231205084805.270">cdef int n1, n2
</t>
<t tx="leo.20231205084805.271">cdef Graph g = self.copy()
</t>
<t tx="leo.20231205084805.272">cpdef bint has_triangle(self):
    """Return true if the graph has triangle."""
    @others
    for neighbors in self.adj.values():
        for n1 in neighbors:
            for n2 in neighbors:
                if n1 == n2:
                    continue
                if n1 in self.adj[n2]:
                    return True
    return False

</t>
<t tx="leo.20231205084805.273">cdef int n1, n2
</t>
<t tx="leo.20231205084805.274">cpdef bint is_isomorphic(self, Graph g):
    """Return true if two graphs is isomorphic.

    Default is using VF2 algorithm.
    """
    return self.is_isomorphic_vf2(g)

</t>
<t tx="leo.20231205084805.275">cpdef bint is_isomorphic_vf2(self, Graph g):
    """Compare isomorphism by VF2 algorithm,
    one of the high performance isomorphic algorithms.
    """
    cdef GraphMatcher gm_gh = GraphMatcher.__new__(GraphMatcher, self, g)
    return gm_gh.is_isomorphic()

</t>
<t tx="leo.20231205084805.276">cpdef bint is_isomorphic_degree_code(self, Graph g):
    """Compare isomorphism by degree code algorithm.

    + &lt;https://doi.org/10.1115/1.2919236&gt;
    """
    return self.degree_code() == g.degree_code()

</t>
<t tx="leo.20231205084805.277">cpdef Graph duplicate(self, object vertices, int times):
    """Make graph duplicate by specific `vertices`. Return a new graph."""
    if times &lt; 1:
        raise ValueError("please input a number larger than 1.")
    @others
    edges = set(self.edges)
    for i in range(times):
        for n1 in sorted(set(vertices)):
            mapping[n1] = max_num
            max_num += 1
        for n1, n2 in self.edges:
            if n1 in mapping:
                n1 = mapping[n1]
            if n2 in mapping:
                n2 = mapping[n2]
            if n1 &gt; n2:
                n1, n2 = n2, n1
            edges.add((n1, n2))
    return Graph.__new__(Graph, edges)

</t>
<t tx="leo.20231205084805.278">cdef int max_num = max(self.vertices) + 1
</t>
<t tx="leo.20231205084805.279">mapping = {}
</t>
<t tx="leo.20231205084805.28">cdef double x, y
</t>
<t tx="leo.20231205084805.280">cdef int i, n1, n2
</t>
<t tx="leo.20231205084805.281">cpdef Graph copy(self):
    """The copy method of the Graph object."""
    return Graph.__new__(Graph, self.edges)

</t>
<t tx="leo.20231205084805.282">def __repr__(self) -&gt; str:
    return f"{type(self).__name__}({list(self.edges)})"


</t>
<t tx="leo.20231205084805.283">cdef bint _is_adjacent(Graph g, int u, int v):
    """Find the distance between u and v."""
    if v in g.adj[u]:
        return True
    return False


</t>
<t tx="leo.20231205084805.284">@cython.final
cdef class GraphMatcher:
    """GraphMatcher and GMState class from NetworkX.

    Copyright (C) 2007-2009 by the NetworkX maintainers
    All rights reserved.
    BSD license.

    This work was originally coded by Christopher Ellison
    as part of the Computational Mechanics Python (CMPy) project.
    James P. Crutchfield, principal investigator.
    Complexity Sciences Center and Physics Department, UC Davis.
    """
    @others
</t>
<t tx="leo.20231205084805.285">cdef Graph g1, g2
</t>
<t tx="leo.20231205084805.286">cdef set g1_nodes, g2_nodes
</t>
<t tx="leo.20231205084805.287">cdef dict core_1, core_2, inout_1, inout_2, mapping
</t>
<t tx="leo.20231205084805.288">cdef GMState state

</t>
<t tx="leo.20231205084805.289">def __cinit__(self, Graph g1, Graph g2):
    self.g1 = g1
    self.g2 = g2
    self.g1_nodes = set(g1.vertices)
    self.g2_nodes = set(g2.vertices)
    @others
    if old_recursion_limit &lt; 1.5 * expected_max_recursion_level:
        # Give some breathing room
        sys.setrecursionlimit(int(1.5 * expected_max_recursion_level))
    # Initialize state
    self.initialize()

</t>
<t tx="leo.20231205084805.29">cpdef void locate(self, double x, double y) except *:
    """The update function of original coordinate."""
    self.x = x
    self.y = y
    self.c[0, 0] = x
    self.c[0, 1] = y

</t>
<t tx="leo.20231205084805.290"># Set recursion limit
cdef int old_recursion_limit = sys.getrecursionlimit()
</t>
<t tx="leo.20231205084805.291">cdef int expected_max_recursion_level = len(self.g2.vertices)
</t>
<t tx="leo.20231205084805.292">cdef inline void initialize(self):
    """Re-initializes the state of the algorithm."""
    # core_1[n] contains the index of the node paired with n, which is m,
    #            provided n is in the mapping.
    # core_2[m] contains the index of the node paired with m, which is n,
    #            provided m is in the mapping.
    self.core_1 = {}
    self.core_2 = {}
    # See the paper for definitions of M_x and T_x^{y}
    # inout_1[n]  is non-zero if n is in M_1 or in T_1^{inout}
    # inout_2[m]  is non-zero if m is in M_2 or in T_2^{inout}
    #
    # The value stored is the depth of the SSR tree when the node became
    # part of the corresponding set.
    self.inout_1 = {}
    self.inout_2 = {}
    # Practically, these sets simply store the nodes in the subgraph.
    self.state = GMState.__new__(GMState, self)
    # Provide a convenient way to access the isomorphism mapping.
    self.mapping = self.core_1.copy()

</t>
<t tx="leo.20231205084805.293">def candidate_pairs_iter(self) -&gt; Iterator[Tuple[int, int]]:
    """Iterator over candidate pairs of nodes in g1 and g2."""
    # First we compute the inout-terminal sets.
    s1 = set(self.inout_1) - set(self.core_1)
    s2 = set(self.inout_2) - set(self.core_2)
    t1_inout = [node for node in self.g1_nodes if node in s1]
    t2_inout = [node for node in self.g2_nodes if node in s2]
    @others
    if t1_inout and t2_inout:
        for node in t1_inout:
            yield node, min(t2_inout)
    else:
        # If t1_inout and t2_inout were both empty....
        # P(s) = (N_1 - M_1) x {min (N_2 - M_2)}
        # # if not (t1_inout or t2_inout):
        # as suggested by  [2], incorrect
        # as inferred from [1], correct
        # First we determine the candidate node for g2
        for node in self.g1.vertices:
            if node not in self.core_1:
                yield node, min(self.g2_nodes - set(self.core_2))
    # For all other cases, we don't have any candidate pairs.

</t>
<t tx="leo.20231205084805.294"># If t1_inout and t2_inout are both nonempty.
# P(s) = t1_inout x {min t2_inout}
cdef int node
</t>
<t tx="leo.20231205084805.295">cdef bint is_isomorphic(self):
    """Returns True if g1 and g2 are isomorphic graphs."""
    # Let's do two very quick checks!
    # QUESTION: Should we call faster_graph_could_be_isomorphic(g1,g2)?
    # For now, graph3 just copy the code.
    # Check global properties
    if len(self.g1.vertices) != len(self.g2.vertices):
        return False
    # Check local properties
    if (
        sorted([len(neighbor) for neighbor in self.g1.adj.values()])
        != sorted([len(neighbor) for neighbor in self.g2.adj.values()])
    ):
        return False
    self.initialize()
    try:
        next(self.match())
        return True
    except StopIteration:
        return False

</t>
<t tx="leo.20231205084805.296">def match(self) -&gt; Iterator[Dict[int, Tuple[int]]]:
    """Extends the isomorphism mapping."""
    @others
    if len(self.core_1) == len(self.g2.vertices):
        # Save the final mapping, otherwise garbage collection deletes it.
        self.mapping = self.core_1.copy()
        # The mapping is complete.
        yield self.mapping
    else:
        for g1_node, g2_node in self.candidate_pairs_iter():
            if self.syntactic_feasibility(g1_node, g2_node):
                # Recursive call, adding the feasible state.
                new_state = type(self.state)(self, g1_node, g2_node)
                yield from self.match()
                # restore data structures
                new_state.restore()

</t>
<t tx="leo.20231205084805.297">cdef int g1_node, g2_node
</t>
<t tx="leo.20231205084805.298">cdef GMState new_state
</t>
<t tx="leo.20231205084805.299">cdef inline bint syntactic_feasibility(self, int g1_node, int g2_node):
    """Returns True if adding (g1_node, g2_node) is syntactically feasible.

    The VF2 algorithm was designed to work with graphs having, at most,
    one edge connecting any two nodes.  This is not the case when
    dealing with an MultiGraphs.

    Basically, when we test the look-ahead rules R_neighbor, we will
    make sure that the number of edges are checked. We also add
    a R_self check to verify that the number of self loops is acceptable.

    Users might be comparing Graph instances with MultiGraph instances.
    So the generic GraphMatcher class must work with MultiGraphs.
    Care must be taken since the value in the innermost dictionary is a
    singlet for Graph instances.  For MultiGraphs, the value in the
    innermost dictionary is a list.
    """

    # ## Test at each step to get a return value as soon as possible.

    # ## Look ahead 0
    # R_self
    # The number of self loops for g1_node must equal the number of
    # self-loops for g2_node. Without this check, we would fail on
    # R_neighbor at the next recursion level. But it is good to prune the
    # search tree now.
    if (
        _is_adjacent(self.g1, g1_node, g1_node)
        != _is_adjacent(self.g2, g2_node, g2_node)
    ):
        return False
    @others
    for neighbor in self.g2.adj[g2_node]:
        if (neighbor in self.inout_2) and (neighbor not in self.core_2):
            num2 += 1
    if num1 != num2:
        return False

    # ## Look ahead 2
    # R_new
    # The number of neighbors of n that are neither in the core_1 nor
    # T_1^{inout} is equal to the number of neighbors of m
    # that are neither in core_2 nor T_2^{inout}.
    num1 = 0
    for neighbor in self.g1.adj[g1_node]:
        if neighbor not in self.inout_1:
            num1 += 1
    num2 = 0
    for neighbor in self.g2.adj[g2_node]:
        if neighbor not in self.inout_2:
            num2 += 1
    return num1 == num2


</t>
<t tx="leo.20231205084805.3">cdef double slope_angle(double x1, double y1, double x2, double y2) nogil:
    """Slope angle of two coordinates."""
    return atan2(y1 - y2, x1 - x2)


</t>
<t tx="leo.20231205084805.30">cpdef void rotate(self, double angle):
    """The update function of angle attribute."""
    self.angle = angle % 180

</t>
<t tx="leo.20231205084805.300"># R_neighbor
# For each neighbor n' of n in the partial mapping, the corresponding
# node m' is a neighbor of m, and vice versa. Also, the number of
# edges must be equal.
cdef int neighbor
</t>
<t tx="leo.20231205084805.301">for neighbor in self.g1.adj[g1_node]:
    if neighbor in self.core_1:
        if self.core_1[neighbor] not in self.g2.adj[g2_node]:
            return False
        elif (
                _is_adjacent(self.g1, neighbor, g1_node)
                != _is_adjacent(self.g2, self.core_1[neighbor], g2_node)
        ):
            return False
for neighbor in self.g2.adj[g2_node]:
    if neighbor in self.core_2:
        if self.core_2[neighbor] not in self.g1.adj[g1_node]:
            return False
        elif (
                _is_adjacent(self.g1, self.core_2[neighbor], g1_node)
                != _is_adjacent(self.g2, neighbor, g2_node)
        ):
            return False

</t>
<t tx="leo.20231205084805.302"># ## Look ahead 1
# R_term_inout
# The number of neighbors of n that are in T_1^{inout} is equal to the
# number of neighbors of m that are in T_2^{inout}, and vice versa.
cdef int num1 = 0
</t>
<t tx="leo.20231205084805.303">for neighbor in self.g1.adj[g1_node]:
    if (neighbor in self.inout_1) and (neighbor not in self.core_1):
        num1 += 1
</t>
<t tx="leo.20231205084805.304">cdef int num2 = 0
</t>
<t tx="leo.20231205084805.305">@cython.final
cdef class GMState:
    """Graph matcher state."""
    @others
</t>
<t tx="leo.20231205084805.306">cdef GraphMatcher gm
</t>
<t tx="leo.20231205084805.307">cdef int g1_node, g2_node, depth

</t>
<t tx="leo.20231205084805.308">def __cinit__(
    self,
    GraphMatcher gm,
    int g1_node=-1,
    int g2_node=-1
</t>
<t tx="leo.20231205084805.309">):
    """Initializes GMState object.

    Pass in the GraphMatcher to which this GMState belongs and the
    new node pair that will be added to the GraphMatcher's current
    isomorphism mapping.
    """
    self.gm = gm

    # Initialize the last stored node pair.
    self.g1_node = -1
    self.g2_node = -1
    self.depth = len(gm.core_1)

    if g1_node == -1 or g2_node == -1:
        # Then we reset the class variables
        gm.core_1 = {}
        gm.core_2 = {}
        gm.inout_1 = {}
        gm.inout_2 = {}

</t>
<t tx="leo.20231205084805.31">cpdef void set_offset(self, double offset):
    """The update function of slider offset.
    It will also enable offset value after called.
    """
    self.__has_offset = True
    self.__offset = offset

</t>
<t tx="leo.20231205084805.310">    cdef int node
</t>
<t tx="leo.20231205084805.311">    # Watch out! g1_node == 0 should evaluate to True.
    if g1_node != -1 and g2_node != -1:
        # Add the node pair to the isomorphism mapping.
        gm.core_1[g1_node] = g2_node
        gm.core_2[g2_node] = g1_node

        # Store the node that was added last.
        self.g1_node = g1_node
        self.g2_node = g2_node

        # Now we must update the other two vectors.
        # We will add only if it is not in there already!
        self.depth = len(gm.core_1)

        # First we add the new nodes...
        if g1_node not in gm.inout_1:
            gm.inout_1[g1_node] = self.depth
        if g2_node not in gm.inout_2:
                gm.inout_2[g2_node] = self.depth

        # Now we add every other node...

        # Updates for T_1^{inout}
        new_nodes = set()
        for node in gm.core_1:
            new_nodes.update([
                neighbor for neighbor in gm.g1.adj[node]
                if neighbor not in gm.core_1
            ])
        for node in new_nodes:
            if node not in gm.inout_1:
                gm.inout_1[node] = self.depth

        # Updates for T_2^{inout}
        new_nodes = set()
        for node in gm.core_2:
            new_nodes.update([
                neighbor for neighbor in gm.g2.adj[node]
                if neighbor not in gm.core_2
            ])
        for node in new_nodes:
            if node not in gm.inout_2:
                gm.inout_2[node] = self.depth

</t>
<t tx="leo.20231205084805.312">cdef void restore(self):
    """Deletes the GMState object and restores the class variables."""
    # First we remove the node that was added from the core vectors.
    # Watch out! g1_node == 0 should evaluate to True.
    if self.g1_node != -1 and self.g2_node != -1:
        self.gm.core_1.pop(self.g1_node)
        self.gm.core_2.pop(self.g2_node)

    @others
    for vector in (self.gm.inout_1, self.gm.inout_2):
        for node in tuple(vector):
            if vector[node] == self.depth:
                vector.pop(node)
</t>
<t tx="leo.20231205084805.313"># Now we revert the other two vectors.
# Thus, we delete all entries which have this depth level.
cdef int node
</t>
<t tx="leo.20231205084805.314">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/graph/
# -*- coding: utf-8 -*-
# cython: language_level=3

"""Layout functions for graph object.

The algorithms references:
+ NetworkX

author: Yuan Chang
copyright: Copyright (C) 2016-2022
license: AGPL
email: pyslvs@gmail.com
"""

from typing import Set, Iterable, Any
cimport cython
from cpython cimport PyDict_Contains, PyIndex_Check
from cpython.slice cimport PySlice_GetIndicesEx
from libc.math cimport hypot, M_PI, sin, cos, atan2
from libcpp.map cimport map
from .graph cimport Graph


@others
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084805.315">cpdef dict external_loop_layout(Graph g, bint node_mode, double scale = 1.):
    """Layout position decided by outer loop (max cycle).

    Return the layout position decided by external loop.
    Argument `node_mode` will transform edges into vertices.
    Argument `scale` will resize the position by scale factor.
    """
    pos = _line_polygon_layout(g, scale)
    @others
    if not node_mode:
        n_pos = {}
        edges_view = sorted([((n2, n1) if n2 &lt; n1 else (n1, n2)) for (n1, n2) in g.edges])
        for i, (n1, n2) in enumerate(edges_view):
            x1, y1 = pos[n1]
            x2, y2 = pos[n2]
            n_pos[i] = _middle_point(x1, y1, x2, y2)
        pos = n_pos

    return pos


</t>
<t tx="leo.20231205084805.316"># Node mode
cdef int i, n1, n2
</t>
<t tx="leo.20231205084805.317">cdef double x1, y1, x2, y2
</t>
<t tx="leo.20231205084805.318">cdef inline dict _line_polygon_layout(Graph g, double scale):
    """Generate position of external loop and inner lines."""
    @others
    for line, start, end in lines:
        x1, y1 = pos[start]
        x2, y2 = pos[end]
        # Conditions of linear or bezier curve
        limit = line_limit[start][end]
        if limit == 1:
            _linear_layout(x1, y1, x2, y2, line, pos)
        else:
            line_counter[start][end] += 1
            p = &lt;double&gt;line_counter[start][end] / (limit + 1)
            _bezier_layout(p, x1, y1, x2, y2, line, pos)
        used_nodes.update(line)

    # Last check for debug
    if set(g.vertices) != set(pos):
        raise ValueError(
            f"the algorithm is error with {g.edges}\n"
            f"external loop: {o_loop}\n"
            f"inner layout: {set(pos) - o_loop}\n"
            f"node {set(g.vertices) - set(pos)} are not included"
        )

    return pos


</t>
<t tx="leo.20231205084805.319">cdef OrderedSet o_loop = _external_loop(g)
</t>
<t tx="leo.20231205084805.32">cpdef void disable_offset(self):
    """Disable offset setting of the joint."""
    self.__has_offset = False

</t>
<t tx="leo.20231205084805.320">lines = None
while lines is None:
    # Patch function of external cycle
    lines = _inner_lines(g, o_loop)

o_loop.roll(min(o_loop), 0)
pos = {}
_regular_polygon_layout(o_loop, scale, pos)
</t>
<t tx="leo.20231205084805.321">cdef OrderedSet used_nodes = o_loop.copy()

</t>
<t tx="leo.20231205084805.322">cdef int start, end
</t>
<t tx="leo.20231205084805.323">cdef OrderedSet line
</t>
<t tx="leo.20231205084805.324">cdef map[int, map[int, int]] line_limit, line_counter
</t>
<t tx="leo.20231205084805.325">for line, start, end in lines:
    line_limit[start][end] += 1

</t>
<t tx="leo.20231205084805.326">cdef int limit
</t>
<t tx="leo.20231205084805.327">cdef double p, x1, y1, x2, y2
</t>
<t tx="leo.20231205084805.328">cdef inline void _regular_polygon_layout(OrderedSet vertices, double scale, dict pos):
    """Return position of a regular polygon with radius 5.
    Start from bottom with clockwise.
    """
    @others
    for i in range(edge_count):
        pos[vertices[i]] = (scale * cos(angle), scale * sin(angle))
        angle -= angle_step


</t>
<t tx="leo.20231205084805.329">cdef int edge_count = len(vertices)
</t>
<t tx="leo.20231205084805.33">cpdef bint is_slider(self):
    """Return true for slider type."""
    return self.type in {VJoint.P, VJoint.RP}

</t>
<t tx="leo.20231205084805.330">scale *= 5
</t>
<t tx="leo.20231205084805.331">cdef int i
</t>
<t tx="leo.20231205084805.332">cdef double angle = M_PI * 1.5
</t>
<t tx="leo.20231205084805.333">cdef double angle_step = M_PI * 2 / edge_count
</t>
<t tx="leo.20231205084805.334">cdef inline void _linear_layout(
    double x1,
    double y1,
    double x2,
    double y2,
    OrderedSet vertices,
    dict pos
</t>
<t tx="leo.20231205084805.335">):
    """Layout position decided by equal division between two points."""
</t>
<t tx="leo.20231205084805.336">    cdef int count = len(vertices)
</t>
<t tx="leo.20231205084805.337">    if count &lt; 1:
        raise ValueError(f"Invalid point number {count}")

    count += 1
</t>
<t tx="leo.20231205084805.338">    cdef double sx = (x2 - x1) / count
</t>
<t tx="leo.20231205084805.339">    cdef double sy = (y2 - y1) / count

</t>
<t tx="leo.20231205084805.34">cpdef double distance(self, VPoint p):
    """Return the distance between two VPoint objects."""
    on_links = tuple(set(self.links) &amp; set(p.links))
    @others
    if on_links:
        if self.type == VJoint.R or self.links[0] == on_links[0]:
            # self is R joint or at base link
            m_x = self.c[0, 0]
            m_y = self.c[0, 1]
        else:
            # At pin joint
            m_x = self.c[1, 0]
            m_y = self.c[1, 1]
        if p.type == VJoint.R or p.links[0] == on_links[0]:
            # p is R joint or at base link
            p_x = p.c[0, 0]
            p_y = p.c[0, 1]
        else:
            # At pin joint
            p_x = p.c[1, 0]
            p_y = p.c[1, 1]
    else:
        m_x = self.c[0, 0]
        m_y = self.c[0, 1]
        p_x = p.c[0, 0]
        p_y = p.c[0, 1]
    return hypot(p_x - m_x, p_y - m_y)

</t>
<t tx="leo.20231205084805.340">    cdef int i
</t>
<t tx="leo.20231205084805.341">    for i in range(1, count):
        pos[vertices[i - 1]] = (x1 + i * sx, y1 + i * sy)


</t>
<t tx="leo.20231205084805.342">cdef inline void _bezier_layout(
    double p,
    double x1,
    double y1,
    double x2,
    double y2,
    OrderedSet vertices,
    dict pos
</t>
<t tx="leo.20231205084805.343">):
    """Layout position decided by four points bezier curve."""
</t>
<t tx="leo.20231205084805.344">    cdef int count = len(vertices)
</t>
<t tx="leo.20231205084805.345">    if count &lt; 1:
        raise ValueError(f"Invalid point number {count}")
    count += 1

</t>
<t tx="leo.20231205084805.346">    # Make direction from start and end nodes
    cdef double sx = x2 - x1
</t>
<t tx="leo.20231205084805.347">    cdef double sy = y2 - y1
</t>
<t tx="leo.20231205084805.348">    cdef double r = hypot(sx, sy) * 0.45
</t>
<t tx="leo.20231205084805.349">    cdef double direction = (p + 0.5) * M_PI + atan2(sy, sx)
</t>
<t tx="leo.20231205084805.35">cdef double m_x = 0
</t>
<t tx="leo.20231205084805.350">    cdef double cx1 = x1 + r * cos(direction)
</t>
<t tx="leo.20231205084805.351">    cdef double cy1 = y1 + r * sin(direction)
</t>
<t tx="leo.20231205084805.352">    cdef double cx2 = x2 + r * cos(-direction)
</t>
<t tx="leo.20231205084805.353">    cdef double cy2 = y2 + r * sin(-direction)

</t>
<t tx="leo.20231205084805.354">    cdef int i
</t>
<t tx="leo.20231205084805.355">    cdef double u
</t>
<t tx="leo.20231205084805.356">    for i in range(1, count):
        u = &lt;double&gt;i / count
        pos[vertices[i - 1]] = _bezier_curve(u, x1, y1, cx1, cy1, cx2, cy2, x2, y2)


</t>
<t tx="leo.20231205084805.357">cdef inline tuple _bezier_curve(
    double u,
    double x1,
    double y1,
    double x2,
    double y2,
    double x3,
    double y3,
    double x4,
    double y4
</t>
<t tx="leo.20231205084805.358">):
    """A coordinate on bezier curve."""
</t>
<t tx="leo.20231205084805.359">    cdef double mx = _uv(u, x2, x3)
</t>
<t tx="leo.20231205084805.36">cdef double m_y = 0
</t>
<t tx="leo.20231205084805.360">    cdef double my = _uv(u, y2, y3)
</t>
<t tx="leo.20231205084805.361">    return (
        _uv(u, _uv(u, _uv(u, x1, x2), mx), _uv(u, mx, _uv(u, x3, x4))),
        _uv(u, _uv(u, _uv(u, y1, y2), my), _uv(u, my, _uv(u, y3, y4)))
    )


</t>
<t tx="leo.20231205084805.362">cdef inline double _uv(double u, double v1, double v2) nogil:
    """Return v1 + u * (v2 - v1)"""
    return v1 + u * (v2 - v1)


</t>
<t tx="leo.20231205084805.363">cdef inline tuple _middle_point(double x1, double y1, double x2, double y2):
    """Return middle point of two coordinates."""
    return ((x1 + x2) / 2), ((y1 + y2) / 2)


</t>
<t tx="leo.20231205084805.364">cdef list _inner_lines(Graph g, OrderedSet o_loop):
    """Layout for inner vertices of graph block."""
    @others
    while vertices:
        n = vertices.pop(0)
        if not (used_nodes &amp; g.adj[n]):
            # Not contacted yet
            vertices.add(n)
            continue

        line = OrderedSet.__new__(OrderedSet)
        line.add(n)
        inter = OrderedSet(g.adj[n]) - used_nodes
        while inter:
            # New vertices to add
            n = inter.pop()
            line.add(n)
            vertices.remove(n)
            inter = vertices &amp; g.adj[n]
            if used_nodes &amp; g.adj[n]:
                # Connected with any used node
                break

        # Find the intersections of the line
        if line[0] == line[-1]:
            inter = used_nodes &amp; g.adj[line[0]]
            start = inter.pop()
            end = inter.pop()
        else:
            inter = used_nodes &amp; g.adj[line[0]]
            start = inter.pop()
            inter = used_nodes &amp; g.adj[line[-1]]
            end = inter.pop()

        if _split_loop(o_loop, line, start, end):
            # 'o_loop' has been changed
            return None

        # A unified format of start node and end node
        if end &lt; start:
            end, start = start, end
            line.reverse()

        # Line is ended
        used_nodes.update(line)
        lines.append((line, start, end))

    return lines


</t>
<t tx="leo.20231205084805.365">cdef OrderedSet vertices = OrderedSet(g.vertices) - o_loop
</t>
<t tx="leo.20231205084805.366">if not vertices:
    return []
lines = []
</t>
<t tx="leo.20231205084805.367">cdef OrderedSet used_nodes = o_loop.copy()
</t>
<t tx="leo.20231205084805.368">cdef int n
</t>
<t tx="leo.20231205084805.369">cdef OrderedSet line, inter
</t>
<t tx="leo.20231205084805.37">cdef double p_x = 0
</t>
<t tx="leo.20231205084805.370">cdef inline bint _split_loop(OrderedSet o_loop, OrderedSet line, int n1, int n2):
    """Return false if the line is a chord.
    Or it is an arc of external cycle.
    """
    if n1 == n2:
        return False
    loop_list = list(o_loop) * 2
    @others
    if len(line) &gt; s1 - (s0 + 1):
        anchor = s0 + 1
        del loop_list[anchor:s1]
        if loop_list[s0] == n2:
            # reverse
            loop_list[anchor:anchor] = reversed(line)
        else:
            loop_list[anchor:anchor] = line
    elif len(line) &gt; s2 - (s1 + 1):
        anchor = s1 + 1
        del loop_list[anchor:s2]
        if loop_list[s1] == n2:
            # reverse
            loop_list[anchor:anchor] = reversed(line)
        else:
            loop_list[anchor:anchor] = line
    else:
        # Is a normal chord
        return False

    o_loop.clear()
    # Remove the first repeated part
    o_loop.update(loop_list[s0:])
    return True


</t>
<t tx="leo.20231205084805.371">cdef int i, n
</t>
<t tx="leo.20231205084805.372">cdef int s0 = -1
</t>
<t tx="leo.20231205084805.373">cdef int s1 = -1
</t>
<t tx="leo.20231205084805.374">cdef int s2 = -1
</t>
<t tx="leo.20231205084805.375">for i, n in enumerate(loop_list):
    if n not in {n1, n2}:
        continue
    if s0 == -1:
        s0 = i
    elif s1 == -1:
        s1 = i
    else:
        s2 = i
        break
else:
    # Split failed
    return False

# Remove the last repeated part
loop_list = loop_list[:s2 + 1]

</t>
<t tx="leo.20231205084805.376">cdef int anchor
</t>
<t tx="leo.20231205084805.377">cdef inline OrderedSet _external_loop(Graph g):
    """Return vertices of external loop."""
    cycles = _cycle_basis(g)
    if not cycles:
        raise ValueError(f"invalid graph has no any cycle: {g.edges}")

    @others
    while len(cycles) &gt; 1:
        c1 = cycles.pop()
        for c2 in cycles:
            if _merge_inter(c1, c2, cycles, g):
                break
        else:
            # Cycles have no contacted
            # Find connection from edges
            for c2 in cycles:
                if _merge_no_inter(c1, c2, cycles, g):
                    break
            else:
                raise ValueError(
                    f"invalid graph: {g.edges}\n"
                    f"last one: {c1}\n"
                    f"with cycle(s): {cycles}"
                )
    return cycles.pop()


</t>
<t tx="leo.20231205084805.378">cdef OrderedSet c1, c2
</t>
<t tx="leo.20231205084805.379">cdef inline bint _merge_inter(
    OrderedSet c1,
    OrderedSet c2,
    list cycles,
    Graph g
</t>
<t tx="leo.20231205084805.38">cdef double p_y = 0
</t>
<t tx="leo.20231205084805.380">):
    """Merge function for intersection strategy."""
    # Find the intersection
    if not len(c1 &amp; c2) &gt;= 2:
        return False

    # Ignore subsets
    if c1 &gt;= c2:
        cycles.remove(c2)
        cycles.append(c1)
        return True
    inter_over = c1.ordered_intersections(c2, is_loop=True)
    # Find the intersection with reversed cycle
    c2.reverse()
    inter_tmp = c1.ordered_intersections(c2, is_loop=True)
    if len(inter_tmp) &lt; len(inter_over):
        # Choose the longest continuous intersection
        inter_over = inter_tmp
    inter_tmp = None

</t>
<t tx="leo.20231205084805.381">    cdef int start = -1
</t>
<t tx="leo.20231205084805.382">    cdef int end = -1

</t>
<t tx="leo.20231205084805.383">    cdef int i
</t>
<t tx="leo.20231205084805.384">    cdef OrderedSet inter
</t>
<t tx="leo.20231205084805.385">    for i, inter in enumerate(inter_over):
        if not inter.is_ordered_subset(c1, is_loop=True):
            # Intersection and cycle 1 has wrong direction
            inter.reverse()
        if inter.is_ordered_subset(c2, is_loop=True) and i == 0:
            # Cycle 1 and cycle 2 should has different direction
            c2.reverse()

        # Prune cycle 2 by intersection
        c2 -= inter[1:-1]

        # Interface nodes
        if i == 0:
            start = inter[0]
        end = inter[-1]

    # Roll to interface
    c1.roll(end, -1)
    c2.roll(start, 0)

    # Insert points
    _compare_insert(
        c1,
        c2,
        c1.index(start),
        c1.index(end),
        c2.index(start),
        c2.index(end),
        g
    )

    # The cycle 2 has been merged into cycle 1
    cycles.remove(c2)
    cycles.append(c1)
    return True


</t>
<t tx="leo.20231205084805.386">cdef inline bint _merge_no_inter(
    OrderedSet c1,
    OrderedSet c2,
    list cycles,
    Graph g
</t>
<t tx="leo.20231205084805.387">):
    """Merge function for the strategy without intersection."""
</t>
<t tx="leo.20231205084805.388">    cdef OrderedSet inter = OrderedSet.__new__(OrderedSet)
</t>
<t tx="leo.20231205084805.389">    cdef map[int, int] inter_map

</t>
<t tx="leo.20231205084805.39">cpdef bint has_offset(self):
    """Return true if the offset setting is enabled."""
    return self.__has_offset

</t>
<t tx="leo.20231205084805.390">    cdef int n1, n2
</t>
<t tx="leo.20231205084805.391">    for n1, n2 in g.edges:
        if (n1 in c1) and (n2 in c2):
            inter.add(n1)
            inter_map[n1] = n2
        elif (n2 in c1) and (n1 in c2):
            inter.add(n2)
            inter_map[n2] = n1

    if not inter:
        return False

    # Resort intersection
    if not inter.is_ordered_subset(c1, is_loop=True):
        inter = c1 &amp; inter
</t>
<t tx="leo.20231205084805.392">    cdef int start = inter[0]
</t>
<t tx="leo.20231205084805.393">    cdef int end = inter[-1]
</t>
<t tx="leo.20231205084805.394">    cdef int replace_start = c2.index(inter_map[start])
</t>
<t tx="leo.20231205084805.395">    cdef int replace_end = c2.index(inter_map[end])
</t>
<t tx="leo.20231205084805.396">    if replace_start &gt; replace_end:
        c2.reverse()

    # Roll to interface
    c1.roll(end, -1)
    c2.roll(inter_map[start], 0)

    # Merge them
    _compare_insert(
        c1,
        c2,
        c1.index(start),
        c1.index(end),
        replace_start,
        replace_end,
        g
    )

    # The cycle 2 has been merged into cycle 1
    cycles.remove(c2)
    cycles.append(c1)
    return True


</t>
<t tx="leo.20231205084805.397">cdef inline void _compare_insert(
    OrderedSet c1,
    OrderedSet c2,
    int insert_start,
    int insert_end,
    int replace_start,
    int replace_end,
    Graph g
</t>
<t tx="leo.20231205084805.398">):
    """Compare and insert cycle 2 to cycle 1."""
</t>
<t tx="leo.20231205084805.399">    cdef int c1_degrees = 0
</t>
<t tx="leo.20231205084805.4">cpdef list get_vlinks(object vpoints):
    """Get VLinks from a list of VPoint `vpoints`."""
    links = {}
    @others
    for i, vpoint in enumerate(vpoints):
        for name in vpoint.links:
            if name not in links:
                links[name] = {i}
            else:
                links[name].add(i)
    vlinks = []
    for name, points in links.items():
        vlinks.append(VLink(name, "", points))
    return vlinks


</t>
<t tx="leo.20231205084805.40">cpdef double offset(self):
    """Return the offset constraint value of the joint."""
    return self.__offset

</t>
<t tx="leo.20231205084805.400">    cdef int c2_degrees = 0
</t>
<t tx="leo.20231205084805.401">    cdef OrderedSet c1_slice = c1[insert_start:insert_end]
</t>
<t tx="leo.20231205084805.402">    cdef OrderedSet c2_slice = c2[replace_start:replace_end]

</t>
<t tx="leo.20231205084805.403">    cdef int i
</t>
<t tx="leo.20231205084805.404">    other_nodes = set(c1_slice | c2_slice)
    for i in c1_slice:
        c1_degrees += len(set(g.adj[i]) - other_nodes)
    for i in c2_slice:
        c2_degrees += len(set(g.adj[i]) - other_nodes)

    if not (c2_degrees &gt; c1_degrees):
        return

    # Cycle 2 should longer then intersection
    del c1[insert_start:insert_end]
    c1.insert_from(insert_start, c2_slice)


</t>
<t tx="leo.20231205084805.405">cdef inline list _cycle_basis(Graph g):
    """Returns a list of cycles which form a basis for cycles of G.
    Reference from NetworkX.
    """
    g_nodes = set(g.vertices)
    cycles = []
    @others
    while g_nodes:
        # loop over connected components
        if root == -1:
            root = g_nodes.pop()
        stack = [root]
        pred = {root: root}
        used = {root: set()}
        # walk the spanning tree finding cycles
        while stack:
            # use last-in so cycles easier to find
            z = stack.pop()
            zused = used[z]
            for nbr in g.adj[z]:
                if nbr not in used:
                    # new node
                    pred[nbr] = z
                    stack.append(nbr)
                    used[nbr] = {z}
                elif nbr == z:
                    # self loops
                    cycles.append(OrderedSet([z]))
                elif nbr not in zused:
                    # found a cycle
                    pn = used[nbr]
                    cycle = OrderedSet([nbr, z])
                    p = pred[z]
                    while p not in pn:
                        cycle.add(p)
                        p = pred[p]
                    cycle.add(p)
                    cycles.append(cycle)
                    used[nbr].add(z)
        g_nodes -= set(pred)
        root = -1
    return cycles


</t>
<t tx="leo.20231205084805.406">cdef int root = -1
</t>
<t tx="leo.20231205084805.407">cdef int z, nbr, p
</t>
<t tx="leo.20231205084805.408">cdef OrderedSet cycle
</t>
<t tx="leo.20231205084805.409">cdef class _Entry:
    cdef object key
    cdef _Entry prev
    cdef _Entry next


</t>
<t tx="leo.20231205084805.41">cpdef double true_offset(self):
    """Return the current offset value of the joint."""
    return hypot(self.c[1, 0] - self.c[0, 0], self.c[1, 1] - self.c[0, 1])

</t>
<t tx="leo.20231205084805.410">    cdef _Entry next


@others
</t>
<t tx="leo.20231205084805.411">cdef inline void _add(OrderedSet oset, object key):
    if PyDict_Contains(oset.map, key):
        return
    @others
    next_entry.key = key
    next_entry.prev = oset.end.prev
    next_entry.next = oset.end
    oset.end.prev.next = oset.end.prev = oset.map[key] = next_entry
    oset.os_used += 1


</t>
<t tx="leo.20231205084805.412">cdef _Entry next_entry = _Entry()
</t>
<t tx="leo.20231205084805.413">cdef void _discard(OrderedSet oset, object key):
    if not PyDict_Contains(oset.map, key):
        return
    cdef _Entry entry = oset.map.pop(key)
    entry.prev.next = entry.next
    entry.next.prev = entry.prev
    oset.os_used -= 1


</t>
<t tx="leo.20231205084805.414">cdef inline bint _isorderedsubset(seq1, seq2, bint is_loop):
    """Return true if 'seq1' is ordered subset of 'seq2'."""
    @others
    for self_elem in seq2_list:
        if self_elem == seq1_list[matched]:
            matched += 1
            if matched == seq1_len:
                return True
        else:
            matched = 0

    return matched == seq1_len


</t>
<t tx="leo.20231205084805.415">cdef int seq1_len = len(seq1)
</t>
<t tx="leo.20231205084805.416">if not seq1_len &lt;= len(seq2):
    # 'seq1' is obviously not a subset.
    return False
seq1_list = list(seq1)
seq2_list = list(seq2)
if is_loop:
    seq2_list *= 2
</t>
<t tx="leo.20231205084805.417">cdef int matched = 0
</t>
<t tx="leo.20231205084805.418">cdef inline bint _not_subset(OrderedSet o_set, list members):
    """Return true if 'o_set' is not any subset of members."""
    @others
    for member in members:
        if member &lt; o_set:
            # Is superset
            members.remove(member)
            return True
        if member &gt;= o_set:
            return False
    # No subset
    return True


</t>
<t tx="leo.20231205084805.419">cdef OrderedSet member
</t>
<t tx="leo.20231205084805.42">cpdef double slope_angle(self, VPoint p, int num1 = 2, int num2 = 2):
    """Return the value `hypot(p_x - m_x, p_y - m_y)`,
    where `m_x`, `m_y` is the value of the joint,
    and `p_x`, `p_y` is the value of `p`.

    The option `num1` and `num2` is the position of current coordinate
    attribute.
    """
    @others
    if num1 &gt; 1:
        x2, y2 = self.x, self.y
    else:
        x2 = self.c[num2, 0]
        y2 = self.c[num2, 1]
    if num2 &gt; 1:
        x1, y1 = p.x, p.y
    else:
        x1 = p.c[num2, 0]
        y1 = p.c[num2, 1]
    return slope_angle(x1, y1, x2, y2) / M_PI * 180

</t>
<t tx="leo.20231205084805.420">cdef class _OrderedSetIterator:
    """Ordered set iterator."""
    @others
</t>
<t tx="leo.20231205084805.421">cdef OrderedSet oset
</t>
<t tx="leo.20231205084805.422">cdef _Entry curr
</t>
<t tx="leo.20231205084805.423">cdef ssize_t si_used

</t>
<t tx="leo.20231205084805.424">def __cinit__(self, OrderedSet oset):
    self.oset = oset
    self.curr = oset.end
    self.si_used = oset.os_used

</t>
<t tx="leo.20231205084805.425">def __iter__(self):
    return self

</t>
<t tx="leo.20231205084805.426">def __next__(self):
    @others
    if self.si_used != self.oset.os_used:
        # make this state sticky
        self.si_used = -1
        raise RuntimeError(f'{type(self.oset).__name__} changed size during iteration')

    item = self.curr.next
    if item == self.oset.end:
        raise StopIteration
    self.curr = item
    return item.key


</t>
<t tx="leo.20231205084805.427">cdef _Entry item

</t>
<t tx="leo.20231205084805.428">cdef class _OrderedSetReverseIterator:
    """Ordered set iterator with reversed order."""
    @others
</t>
<t tx="leo.20231205084805.429">cdef OrderedSet oset
</t>
<t tx="leo.20231205084805.43">cdef double x1, y1, x2, y2
</t>
<t tx="leo.20231205084805.430">cdef _Entry curr
</t>
<t tx="leo.20231205084805.431">cdef ssize_t si_used

</t>
<t tx="leo.20231205084805.432">def __cinit__(self, OrderedSet oset):
    self.oset = oset
    self.curr = oset.end
    self.si_used = oset.os_used

</t>
<t tx="leo.20231205084805.433">def __iter__(self):
    return self

</t>
<t tx="leo.20231205084805.434">def __next__(self):
    if self.si_used != self.oset.os_used:
        # make this state sticky
        self.si_used = -1
        raise RuntimeError(f'{type(self.oset).__name__} changed size during iteration')

    @others
    if item is self.oset.end:
        raise StopIteration
    self.curr = item
    return item.key


</t>
<t tx="leo.20231205084805.435">cdef _Entry item = self.curr.prev
</t>
<t tx="leo.20231205084805.436">@cython.final
cdef class OrderedSet:
    """Ordered set container."""
    @others
</t>
<t tx="leo.20231205084805.437">cdef dict map
</t>
<t tx="leo.20231205084805.438">cdef _Entry end
</t>
<t tx="leo.20231205084805.439">cdef ssize_t os_used

</t>
<t tx="leo.20231205084805.44">cpdef Coord link_pos(self, str link):
    """Return the position for the vlink."""
    cdef size_t ind
    if self.type == VJoint.R or self.is_slot_link(link):
        ind = 0
    else:
        ind = 1
    return self.to_coord(ind)

</t>
<t tx="leo.20231205084805.440">def __cinit__(self):
    self.map = {}
    self.os_used = 0
    self.end = end = _Entry()
    end.prev = end.next = end

</t>
<t tx="leo.20231205084805.441">def __init__(self, iterable: Iterable[Any] = None):
    if iterable is None:
        return
    map_d = self.map
    @others
    for elem in iterable:
        if not PyDict_Contains(map_d, elem):
            next_e = _Entry()
            next_e.key, next_e.prev, next_e.next = elem, end.prev, end
            end.prev.next = end.prev = map_d[elem] = next_e
            self.os_used += 1

</t>
<t tx="leo.20231205084805.442">cdef _Entry next_e
</t>
<t tx="leo.20231205084805.443">cdef _Entry end = self.end
</t>
<t tx="leo.20231205084805.444">@classmethod
def _from_iterable(cls, it: Iterable[Any]) -&gt; OrderedSet:
    if isinstance(it, OrderedSet):
        return it
    else:
        return cls(it)

</t>
<t tx="leo.20231205084805.445">##
# set methods
##
cpdef void add(self, elem):
    """Add 'elem' to the set."""
    _add(self, elem)

</t>
<t tx="leo.20231205084805.446">cpdef void insert(self, int index, elem):
    """Insert 'elem' to 'index'."""
    self.insert_from(index, (elem,))

</t>
<t tx="leo.20231205084805.447">cpdef void insert_from(self, int index, elem):
    """Insert iterable 'elem' to 'index'."""
    if not isinstance(elem, Iterable):
        raise ValueError("extend iterable only")
    cdef OrderedSet tail = self[index:]
    del self[index:]
    self.update(elem)
    self.update(tail)

</t>
<t tx="leo.20231205084805.448">cpdef void discard(self, elem):
    """Remove element 'elem' from the 'OrderedSet' if it is present."""
    _discard(self, elem)

</t>
<t tx="leo.20231205084805.449">cpdef void roll(self, elem, int index):
    """Roll the list to 'elem' as 'index' item."""
    if elem not in self:
        raise ValueError(f"{elem} is not in {self}")

    while elem != self[index]:
        # Rolling the list
        self.add(self.pop(0))

</t>
<t tx="leo.20231205084805.45">cpdef bint grounded(self):
    """Return true if the joint pin is connected to ground link."""
    if self.type == VJoint.R:
        return VLink.FRAME in self.links
    elif self.type in {VJoint.P, VJoint.RP}:
        if self.links:
            return self.is_slot_link(VLink.FRAME)
        else:
            return False

</t>
<t tx="leo.20231205084805.450">cpdef object pop(self, int index = -1):
    """Remove and return the last element or an arbitrary set element.
    Raises 'KeyError' if the 'OrderedSet' is empty.
    """
    if not self:
        raise KeyError(f'{self} is empty')
    key = self[index]
    _discard(self, key)
    return key

</t>
<t tx="leo.20231205084805.451">cpdef void remove(self, elem):
    """Remove element 'elem' from the 'set'.
    Raises KeyError if 'elem' is not contained in the set.
    """
    if elem not in self:
        raise KeyError(elem)
    _discard(self, elem)

</t>
<t tx="leo.20231205084805.452">cpdef void clear(self):
    """Remove all elements from the 'set'."""
    @others
    end.next.prev = end.next = None

    # reinitialize
    self.map.clear()
    self.os_used = 0
    self.end = end = _Entry()
    end.prev = end.next = end

</t>
<t tx="leo.20231205084805.453">cdef _Entry end = self.end
</t>
<t tx="leo.20231205084805.454">cpdef OrderedSet copy(self):
    """Copy the instance."""
    return OrderedSet(self)

</t>
<t tx="leo.20231205084805.455">def __sub__(self, other: Iterable[Any]) -&gt; OrderedSet:
    """Implement for '-' operator."""
    if not isinstance(other, Set):
        if not isinstance(other, Iterable):
            return NotImplemented
        other = OrderedSet._from_iterable(other)

    return OrderedSet._from_iterable(value for value in self if value not in other)

</t>
<t tx="leo.20231205084805.456">def __isub__(self, other: Iterable[Any]) -&gt; OrderedSet:
    """Implement for '-=' operator."""
    if other is self:
        self.clear()
    else:
        for value in other:
            self.discard(value)
    return self

</t>
<t tx="leo.20231205084805.457">cpdef OrderedSet intersection(self, other):
    """Implement of '&amp;' operator."""
    return self &amp; other

</t>
<t tx="leo.20231205084805.458">def __and__(self, other: Iterable[Any]) -&gt; OrderedSet:
    """Implement for '&amp;' operator."""
    if not isinstance(other, Set):
        if not isinstance(other, Iterable):
            return NotImplemented
        other = OrderedSet._from_iterable(other)

    return OrderedSet._from_iterable(value for value in self if value in other)

</t>
<t tx="leo.20231205084805.459">def __iand__(self, it: Iterable[Any]):
    """Implement for '&amp;=' operator."""
    for value in (self - it):
        self.discard(value)
    return self

</t>
<t tx="leo.20231205084805.46">cpdef bint pin_grounded(self):
    """Return true if the point is at the same link."""
    return VLink.FRAME in self.links[1:]

</t>
<t tx="leo.20231205084805.460">cpdef list ordered_intersections(self, other, bint is_loop = False):
    """Find the max length intersection with ordered detection."""
    if not isinstance(other, Iterable):
        raise TypeError("object must be iterable")

    self_list = list(self)
    other_list = list(other)
    if is_loop:
        self_list *= 2
    # Result list
    subsets = []
    @others
    for matched_self, self_elem in enumerate(self_list):
        try:
            matched_other = other_list.index(self_elem)
        except ValueError:
            # Not found
            continue

        match_set = {matched_other_old + 1}
        if is_loop:
            match_set.add(matched_other_old + 1 - len(other_list))

        if subset and not (matched_self == matched_self_old + 1 or matched_other in match_set):
            # Add to results
            if _not_subset(subset, subsets):
                subsets.append(subset)
            # Start new record
            subset = OrderedSet.__new__(OrderedSet)
        subset.add(self_elem)
        matched_other_old = matched_other
        matched_self_old = matched_self

    if _not_subset(subset, subsets):
        subsets.append(subset)
    return subsets

</t>
<t tx="leo.20231205084805.461">cdef int matched_self
</t>
<t tx="leo.20231205084805.462">cdef int matched_self_old = -2
</t>
<t tx="leo.20231205084805.463">cdef int matched_other = -2
</t>
<t tx="leo.20231205084805.464">cdef int matched_other_old = -2
</t>
<t tx="leo.20231205084805.465">cdef OrderedSet subset = OrderedSet.__new__(OrderedSet)
</t>
<t tx="leo.20231205084805.466">cpdef bint isdisjoint(self, other):
    """Return true if the set has no elements in common with other.
    Sets are disjoint if and only if their intersection is the empty set.
    """
    for value in other:
        if value in self:
            return False
    return True

</t>
<t tx="leo.20231205084805.467">cpdef bint issubset(self, other):
    """Method of '&lt;=' operator."""
    return self &lt;= other

</t>
<t tx="leo.20231205084805.468">cpdef bint issuperset(self, other):
    """Method of '&gt;=' operator."""
    return other &lt;= self

</t>
<t tx="leo.20231205084805.469">cpdef bint is_ordered_subset(self, other, bint is_loop = False):
    """Method of '&lt;=' operator with ordered detection."""
    return _isorderedsubset(self, other, is_loop)

</t>
<t tx="leo.20231205084805.47">cpdef bint same_link(self, VPoint p):
    """Return true if the point is at the same link."""
    return bool(set(self.links) &amp; set(p.links))

</t>
<t tx="leo.20231205084805.470">cpdef bint is_ordered_superset(self, other, bint is_loop = False):
    """Method of '&gt;=' operator with ordered detection."""
    return _isorderedsubset(other, self, is_loop)

</t>
<t tx="leo.20231205084805.471">def __xor__(self, other: Iterable[Any]) -&gt; OrderedSet:
    """Implement for '^' operator."""
    if not isinstance(other, Iterable):
        return NotImplemented

    cdef OrderedSet o_other = OrderedSet._from_iterable(other)
    return (self - o_other) | (o_other - self)

</t>
<t tx="leo.20231205084805.472">def __ixor__(self, other: Iterable[Any]):
    """Implement for '^=' operator."""
    if other is self:
        self.clear()
    else:
        if not isinstance(other, Set):
            other = self._from_iterable(other)
        for value in other:
            if value in self:
                self.discard(value)
            else:
                self.add(value)
    return self

</t>
<t tx="leo.20231205084805.473">cpdef OrderedSet union(self, other):
    """Method of '|' operator."""
    return self | other

</t>
<t tx="leo.20231205084805.474">cpdef void update(self, other):
    """Method of '|=' operator."""
    self |= other

</t>
<t tx="leo.20231205084805.475">def __or__(self, other: Iterable[Any]) -&gt; OrderedSet:
    """Implement for '|' operator."""
    if not isinstance(other, Iterable):
        return NotImplemented
    chain = (e for s in (self, other) for e in s)
    return OrderedSet._from_iterable(chain)

</t>
<t tx="leo.20231205084805.476">def __ior__(self, other: Iterable[Any]) -&gt; OrderedSet:
    """Implement for '|=' operator."""
    for elem in other:
        _add(self, elem)
    return self

</t>
<t tx="leo.20231205084805.477">##
# list methods
##
cpdef int index(self, elem):
    """Return the index of 'elem'. Rases :class:'ValueError' if not in the OrderedSet."""
    if elem not in self:
        raise ValueError(f"{elem} is not in {type(self).__name__}")
    @others
    while curr.key != elem:
        curr = curr.next
        index += 1
    return index

</t>
<t tx="leo.20231205084805.478">cdef _Entry curr = self.end.next
</t>
<t tx="leo.20231205084805.479">cdef ssize_t index = 0
</t>
<t tx="leo.20231205084805.48">cpdef bint no_link(self):
    """Return true if there is no any link in links attribute."""
    return not self.links

</t>
<t tx="leo.20231205084805.480">cdef list _get_slice_entry(self, slice item):
    @others
    if slicelength &lt;= 0:
        pass
    elif step &gt; 0:
        # normal forward slice
        i = 0
        while slicelength &gt; 0:
            while i &lt;= place:
                curr = curr.next
                i += 1
            result.append(curr)
            place += step
            slicelength -= 1
    else:
        # we're going backwards
        i = len(self)
        while slicelength &gt; 0:
            while i &gt; place:
                curr = curr.prev
                i -= 1
            result.append(curr)
            place += step
            slicelength -= 1
    return result

</t>
<t tx="leo.20231205084805.481">cdef ssize_t start, stop, step, slicelength
</t>
<t tx="leo.20231205084805.482">PySlice_GetIndicesEx(item, len(self), &amp;start, &amp;stop, &amp;step, &amp;slicelength)
result = []
</t>
<t tx="leo.20231205084805.483">cdef ssize_t place = start
</t>
<t tx="leo.20231205084805.484">cdef _Entry curr = self.end

</t>
<t tx="leo.20231205084805.485">cdef ssize_t i
</t>
<t tx="leo.20231205084805.486">cdef _Entry _get_index_entry(self, ssize_t index):
    @others
    if index &gt;= 0:
        curr = self.end.next
        while index:
            curr = curr.next
            index -= 1
    else:
        index = abs(index) - 1
        curr = self.end.prev
        while index:
            curr = curr.prev
            index -= 1
    return curr

</t>
<t tx="leo.20231205084805.487">cdef ssize_t _len = len(self)
</t>
<t tx="leo.20231205084805.488">if index &gt;= _len or (index &lt; 0 and abs(index) &gt; _len):
    raise IndexError("list index out of range")

</t>
<t tx="leo.20231205084805.489">cdef _Entry curr
</t>
<t tx="leo.20231205084805.49">cpdef bint is_slot_link(self, str link):
    """Return true if the slot is on the link `link_name`."""
    if self.type == VJoint.R:
        return False
    if self.links:
        return link == self.links[0]
    else:
        return False

</t>
<t tx="leo.20231205084805.490">def __getitem__(self, index):
    """Implement of 'self[index]' operator."""
    if isinstance(index, slice):
        return OrderedSet([curr.key for curr in self._get_slice_entry(index)])
    if not PyIndex_Check(index):
        raise TypeError(f"{type(self).__name__} indices must be integers, not {type(index)}")

    @others
    return curr.key

</t>
<t tx="leo.20231205084805.491">cdef _Entry curr = self._get_index_entry(index)
</t>
<t tx="leo.20231205084805.492">def __setitem__(self, index, value):
    """Implement of 'self[index] = value' operator."""
    @others
    if isinstance(index, slice):
        if not isinstance(value, Iterable):
            raise TypeError("must assign iterable to extended slice")
        value_list = list(value)
        for i, curr in enumerate(self._get_slice_entry(index)):
            curr.key = value_list[i]
        return

    if not PyIndex_Check(index):
        raise TypeError(f"{type(self).__name__} indices must be integers, not {type(index)}")
    curr = self._get_index_entry(index)
    curr.key = value

</t>
<t tx="leo.20231205084805.493">cdef int i
</t>
<t tx="leo.20231205084805.494">cdef _Entry curr
</t>
<t tx="leo.20231205084805.495">def __delitem__(self, index):
    """Implement of 'del self[index]' operator."""
    @others
    if isinstance(index, slice):
        for curr in self._get_slice_entry(index):
            self.discard(curr.key)
        return

    if not PyIndex_Check(index):
        raise TypeError(f"{type(self).__name__} indices must be integers, not {type(index)}")
    curr = self._get_index_entry(index)
    self.discard(curr.key)

</t>
<t tx="leo.20231205084805.496">cdef _Entry curr
</t>
<t tx="leo.20231205084805.497">cpdef void reverse(self):
    """Reverse all elements."""
    my_iter = list(_OrderedSetReverseIterator(self))
    self.clear()
    self.update(my_iter)

</t>
<t tx="leo.20231205084805.498">##
# sequence methods
##
def __len__(self) -&gt; int:
    """Implement of 'len(self)' operator."""
    return len(self.map)

</t>
<t tx="leo.20231205084805.499">def __contains__(self, elem: Any) -&gt; bool:
    """Implement of 'elem in self' operator."""
    return elem in self.map

</t>
<t tx="leo.20231205084805.5">cdef int i
</t>
<t tx="leo.20231205084805.50">cpdef str expr(self):
    """Return the literal mechanism expression of the joint."""
    if self.type != VJoint.R:
        type_text = f"{self.type_str}, A[{self.angle}]"
    else:
        type_text = 'R'
    if self.color_str:
        color = f", color[{self.color_str}]"
    else:
        color = ""
    links_text = ", ".join([name for name in self.links])
    x_text = f"{self.x:.4f}".rstrip('0').rstrip('.')
    y_text = f"{self.y:.4f}".rstrip('0').rstrip('.')
    return f"J[{type_text}{color}, P[{x_text}, {y_text}], L[{links_text}]]"

</t>
<t tx="leo.20231205084805.500">def __iter__(self) -&gt; _OrderedSetIterator:
    """Return iterator without copy."""
    return _OrderedSetIterator.__new__(_OrderedSetIterator, self)

</t>
<t tx="leo.20231205084805.501">def __reversed__(self) -&gt; _OrderedSetReverseIterator:
    """Return reversed iterator without copy."""
    return _OrderedSetReverseIterator.__new__(_OrderedSetReverseIterator, self)

</t>
<t tx="leo.20231205084805.502">def __reduce__(self):
    items = list(self)
    inst_dict = vars(self).copy()
    return type(self), (items, ), inst_dict

</t>
<t tx="leo.20231205084805.503">def __repr__(self) -&gt; str:
    """Implement of '!r' operator in string."""
    if not self:
        return f'{type(self).__name__}()'
    return f'{type(self).__name__}({list(self)!r})'

</t>
<t tx="leo.20231205084805.504">def __eq__(self, other: Iterable[Any]) -&gt; bool:
    """Implement of '==' operator."""
    if isinstance(other, Set):
        # Set is no ordered
        return set(self) == set(other)
    if isinstance(other, Iterable):
        return len(self) == len(other) and list(self) == list(other)
    return NotImplemented

</t>
<t tx="leo.20231205084805.505">def __le__(self, other: Iterable[Any]) -&gt; bool:
    """Implement of '&lt;=' operator."""
    if isinstance(other, (Set, OrderedSet)):
        return len(self) &lt;= len(other) and set(self) &lt;= set(other)
    elif isinstance(other, list):
        return len(self) &lt;= len(other) and list(self) &lt;= list(other)
    return NotImplemented

</t>
<t tx="leo.20231205084805.506">def __lt__(self, other: Iterable[Any]) -&gt; bool:
    """Implement of '&lt;' operator."""
    if isinstance(other, (Set, OrderedSet)):
        return len(self) &lt; len(other) and set(self) &lt; set(other)
    elif isinstance(other, list):
        return len(self) &lt; len(other) and list(self) &lt; list(other)
    return NotImplemented

</t>
<t tx="leo.20231205084805.507">def __ge__(self, other: Iterable[Any]) -&gt; bool:
    """Implement of '&gt;=' operator."""
    if isinstance(other, (Set, OrderedSet)):
        return len(self) &gt;= len(other) and set(self) &gt;= set(other)
    elif isinstance(other, list):
        return len(self) &gt;= len(other) and list(self) &gt;= list(other)
    return NotImplemented

</t>
<t tx="leo.20231205084805.508">def __gt__(self, other: Iterable[Any]) -&gt; bool:
    """Implement of '&gt;' operator."""
    if isinstance(other, (Set, OrderedSet)):
        return len(self) &gt; len(other) and set(self) &gt; set(other)
    elif isinstance(other, list):
        return len(self) &gt; len(other) and list(self) &gt; list(other)
    return NotImplemented
</t>
<t tx="leo.20231205084805.509">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/graph/
# -*- coding: utf-8 -*-
# cython: language_level=3

"""Planarity check function for Graph class.

The algorithms references:
+ NetworkX

author: Yuan Chang
copyright: Copyright (C) 2016-2022
license: AGPL
email: pyslvs@gmail.com
"""

from collections import defaultdict
from libcpp.pair cimport pair
from libcpp.list cimport list as clist
from libcpp.map cimport map

ctypedef pair[int, int] ipair


@others
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084805.51">cpdef Coord to_coord(self, size_t ind):
    """Obtain coordinate by Coord object."""
    return Coord.__new__(Coord, self.c[ind, 0], self.c[ind, 1])

</t>
<t tx="leo.20231205084805.510">cpdef bint is_planar(Graph g):
    """Return true if the graph is a planar graph."""
    cdef _LRPlanarity planarity_state = _LRPlanarity.__new__(_LRPlanarity, g)
    return planarity_state.lr_planarity() is not None


</t>
<t tx="leo.20231205084805.511">cdef inline _ConflictPair _stack_top(list l):
    """Returns the conflict pair element on top of the stack."""
    if not l:
        return None
    return l[-1]


</t>
<t tx="leo.20231205084805.512">cdef class _LRPlanarity:
    """A class to maintain the state during planarity check."""
    @others
</t>
<t tx="leo.20231205084805.513">cdef Graph g, DG
</t>
<t tx="leo.20231205084805.514">cdef _PlanarEmbedding embedding
</t>
<t tx="leo.20231205084805.515">cdef list s
</t>
<t tx="leo.20231205084805.516">cdef dict lowpt, lowpt2, nesting_depth, adjs
</t>
<t tx="leo.20231205084805.517">cdef dict ordered_adjs, stack_bottom, lowpt_edge, left_ref, right_ref
</t>
<t tx="leo.20231205084805.518"># default dict
cdef object height, parent_edge, ref, side

</t>
<t tx="leo.20231205084805.519">def __cinit__(self, Graph g):
    # copy G without adding self-loops
    self.g = Graph.__new__(Graph, set(g.edges))
    # distance from tree root
    self.height = defaultdict(lambda: None)
    self.lowpt = {}  # height of lowest return point of an edge
    self.lowpt2 = {}  # height of second lowest return point
    self.nesting_depth = {}  # for nesting order
    # None -&gt; missing edge
    self.parent_edge = defaultdict(lambda: None)
    # oriented DFS graph
    self.DG = Graph.__new__(Graph, [])
    self.DG.add_vertices(g.vertices)
    self.adjs = {}
    self.ordered_adjs = {}
    self.ref = defaultdict(lambda: None)
    self.side = defaultdict(lambda: 1)
    # stack of conflict pairs
    self.s = []
    self.stack_bottom = {}
    self.lowpt_edge = {}
    self.left_ref = {}
    self.right_ref = {}
    self.embedding = _PlanarEmbedding.__new__(_PlanarEmbedding, [])

</t>
<t tx="leo.20231205084805.52">def __copy__(self):
    @others
    )
    vpoint.c[:] = self.c[:]
    return vpoint

</t>
<t tx="leo.20231205084805.520">cdef _PlanarEmbedding lr_planarity(self):
    """Execute the LR planarity test."""
    if len(self.g.vertices) &gt; 2 and len(self.g.edges) &gt; 3 * len(self.g.vertices) - 6:
        # graph is not planar
        return None
    @others
    for v in self.DG.vertices:
        # sort the adjacency lists again
        self.ordered_adjs[v] = sorted(
            [n2 for n1, n2 in self.DG.edges if n1 == v],
            key=lambda x: self.nesting_depth[v, x]
        )
        # initialize the embedding
        previous_node = -1
        for w in self.ordered_adjs[v]:
            self.embedding.add_half_edge_cw(v, w, previous_node)
            previous_node = w
    # Free no longer used variables
    self.DG = None
    self.nesting_depth = None
    self.ref = None
    # compute the complete embedding
    for v in roots:
        self.dfs_embedding(v)
    return self.embedding

</t>
<t tx="leo.20231205084805.521"># make adjacency lists for dfs
cdef int v
</t>
<t tx="leo.20231205084805.522">for v in self.g.vertices:
    self.adjs[v] = list(self.g.adj[v])
</t>
<t tx="leo.20231205084805.523"># orientation of the graph by depth first search traversal
cdef clist[int] roots
</t>
<t tx="leo.20231205084805.524">for v in self.g.vertices:
    if self.height[v] is None:
        self.height[v] = 0
        roots.push_back(v)
        self.dfs_orientation(v)
# Free no longer used variables
self.g = None
self.lowpt2 = None
self.adjs = None
# testing
for v in self.DG.vertices:  # sort the adjacency lists by nesting depth
    # note: this sorting leads to non linear time
    self.ordered_adjs[v] = sorted(
        [n2 for n1, n2 in self.DG.edges if n1 == v],
        key=lambda x: self.nesting_depth[v, x]
    )
for v in roots:
    if not self.dfs_testing(v):
        return None
# Free no longer used variables
self.height = None
self.lowpt = None
self.s = None
self.stack_bottom = None
self.lowpt_edge = None
for e in self.DG.edges:
    self.nesting_depth[e] = self.sign(e) * self.nesting_depth[e]
self.embedding.add_vertices(self.DG.vertices)
</t>
<t tx="leo.20231205084805.525">cdef int previous_node, w
</t>
<t tx="leo.20231205084805.526">cdef bint dfs_testing(self, int v):
    """Test for LR partition."""
    @others
    while not dfs_stack.empty():
        v = dfs_stack.back()
        dfs_stack.pop_back()
        e = self.parent_edge[v]
        # to indicate whether to skip the final block after the for loop
        skip_final = False
        for w in self.ordered_adjs[v][ind[v]:]:
            ei = (v, w)
            if not skip_init[ei]:
                self.stack_bottom[ei] = _stack_top(self.s)
                if ei == self.parent_edge[w]:  # tree edge
                    dfs_stack.push_back(v)  # revisit v after finishing w
                    dfs_stack.push_back(w)  # visit w next
                    skip_init[ei] = True  # don't redo this block
                    skip_final = True  # skip final work after breaking
                    break  # handle next node in dfs_stack (i.e. w)
                else:  # back edge
                    self.lowpt_edge[ei] = ei
                    self.s.append(_ConflictPair.__new__(_ConflictPair, None,
                        _Interval.__new__(_Interval, ei, ei)))
            # integrate new return edges
            if self.lowpt[ei] &lt; self.height[v]:
                if w == self.ordered_adjs[v][0]:  # e_i has return edge
                    self.lowpt_edge[e] = self.lowpt_edge[ei]
                else:  # add constraints of e_i
                    if not self.add_constraints(ei, e):
                        # graph is not planar
                        return False
            ind[v] += 1
        if not skip_final:
            # remove back edges returning to parent
            if e is not None:  # v isn't root
                self.remove_back_edges(e)
    return True

</t>
<t tx="leo.20231205084805.527"># the recursion stack
cdef clist[int] dfs_stack = [v]
</t>
<t tx="leo.20231205084805.528"># index of next edge to handle in adjacency list of each node
cdef map[int, int] ind
</t>
<t tx="leo.20231205084805.529"># bintean to indicate whether to skip the initial work for an edge
skip_init = defaultdict(lambda: False)
</t>
<t tx="leo.20231205084805.53">cdef VPoint vpoint = VPoint.__new__(
    VPoint,
    self.links,
    self.type,
    self.angle,
    self.color_str,
    self.x,
    self.y
</t>
<t tx="leo.20231205084805.530">cdef bint skip_final
</t>
<t tx="leo.20231205084805.531">cdef int w
</t>
<t tx="leo.20231205084805.532">cdef void dfs_embedding(self, int v):
    """Completes the embedding."""
    @others
    while not dfs_stack.empty():
        v = dfs_stack.back()
        dfs_stack.pop_back()
        for w in self.ordered_adjs[v][ind[v]:]:
            ind[v] += 1
            ei = (v, w)
            if ei == self.parent_edge[w]:  # tree edge
                self.embedding.add_half_edge_first(w, v)
                self.left_ref[v] = w
                self.right_ref[v] = w
                dfs_stack.push_back(v)  # revisit v after finishing w
                dfs_stack.push_back(w)  # visit w next
                break  # handle next node in dfs_stack (i.e. w)
            else:  # back edge
                if self.side[ei] == 1:
                    self.embedding.add_half_edge_cw(w, v, self.right_ref[w])
                else:
                    self.embedding.add_half_edge_ccw(w, v, self.left_ref[w])
                    self.left_ref[w] = v

</t>
<t tx="leo.20231205084805.533"># the recursion stack
cdef clist[int] dfs_stack = [v]
</t>
<t tx="leo.20231205084805.534"># index of next edge to handle in adjacency list of each node
cdef map[int, int] ind
</t>
<t tx="leo.20231205084805.535">cdef int w
</t>
<t tx="leo.20231205084805.536">cdef void dfs_orientation(self, int v):
    """Orient the graph by DFS, compute lowpoints and nesting order."""
    @others
    while not dfs_stack.empty():
        v = dfs_stack.back()
        dfs_stack.pop_back()
        e = self.parent_edge[v]
        for w in self.adjs[v][ind[v]:]:
            vw = (v, w)
            if not skip_init[vw]:
                if (v, w) in self.DG.edges or (w, v) in self.DG.edges:
                    ind[v] += 1
                    continue  # the edge was already oriented
                self.DG.add_edge(v, w)  # orient the edge
                self.lowpt[vw] = self.height[v]
                self.lowpt2[vw] = self.height[v]
                if self.height[w] is None:  # (v, w) is a tree edge
                    self.parent_edge[w] = vw
                    self.height[w] = self.height[v] + 1
                    dfs_stack.push_back(v)  # revisit v after finishing w
                    dfs_stack.push_back(w)  # visit w next
                    skip_init[vw] = True  # don't redo this block
                    break  # handle next node in dfs_stack (i.e. w)
                else:  # (v, w) is a back edge
                    self.lowpt[vw] = self.height[w]
            # determine nesting graph
            self.nesting_depth[vw] = 2 * self.lowpt[vw]
            if self.lowpt2[vw] &lt; self.height[v]:  # chordal
                self.nesting_depth[vw] += 1
            # update lowpoints of parent edge e
            if e is not None:
                if self.lowpt[vw] &lt; self.lowpt[e]:
                    self.lowpt2[e] = min(self.lowpt[e], self.lowpt2[vw])
                    self.lowpt[e] = self.lowpt[vw]
                elif self.lowpt[vw] &gt; self.lowpt[e]:
                    self.lowpt2[e] = min(self.lowpt2[e], self.lowpt[vw])
                else:
                    self.lowpt2[e] = min(self.lowpt2[e], self.lowpt2[vw])
            ind[v] += 1

</t>
<t tx="leo.20231205084805.537"># the recursion stack
cdef clist[int] dfs_stack = [v]
</t>
<t tx="leo.20231205084805.538"># index of next edge to handle in adjacency list of each node
cdef map[int, int] ind
</t>
<t tx="leo.20231205084805.539"># bintean to indicate whether to skip the initial work for an edge
skip_init = defaultdict(lambda: False)
</t>
<t tx="leo.20231205084805.54">def __richcmp__(self, rhs, int op):
    @others
    )
    if op == Py_EQ:
        return not different
    elif op == Py_NE:
        return different
    else:
        raise TypeError(
            f"'{op}' not support between instances of "
            f"{type(self)} and {type(other)}"
        )

</t>
<t tx="leo.20231205084805.540">cdef int w
</t>
<t tx="leo.20231205084805.541">cdef bint add_constraints(self, tuple ei, tuple e):
    @others
    while True:
        q = self.s.pop()
        if not q.left.empty():
            q.swap()
        if not q.left.empty():  # not planar
            return False
        if self.lowpt[q.right.low] &gt; self.lowpt[e]:
            # merge intervals
            if p.right.empty():  # topmost interval
                p.right = q.right.copy()
            else:
                self.ref[p.right.low] = q.right.high
            p.right.low = q.right.low
        else:  # align
            self.ref[q.right.low] = self.lowpt_edge[e]
        if _stack_top(self.s) == self.stack_bottom[ei]:
            break
    # merge conflicting return edges of e_1,...,e_i-1 into P.L
    while (
        _stack_top(self.s).left.conflicting(ei, self) or
        _stack_top(self.s).right.conflicting(ei, self)
    ):
        q = self.s.pop()
        if q.right.conflicting(ei, self):
            q.swap()
        if q.right.conflicting(ei, self):  # not planar
            return False
        # merge interval below lowpt(e_i) into P.R
        self.ref[p.right.low] = q.right.high
        if q.right.low is not None:
            p.right.low = q.right.low
        if p.left.empty():  # topmost interval
            p.left = q.left.copy()
        else:
            self.ref[p.left.low] = q.left.high
        p.left.low = q.left.low
    if not (p.left.empty() and p.right.empty()):
        self.s.append(p)
    return True

</t>
<t tx="leo.20231205084805.542">cdef _ConflictPair p = _ConflictPair.__new__(_ConflictPair, None, None)
</t>
<t tx="leo.20231205084805.543"># merge return edges of e_i into P.right
cdef _ConflictPair q
</t>
<t tx="leo.20231205084805.544">cdef void _trim_interval(self, _Interval inter1, _Interval inter2, int u):
    """Trim left or right interval."""
    while inter1.high is not None and inter1.high[1] == u:
        inter1.high = self.ref[inter1.high]
    if inter1.high is None and inter1.low is not None:
        # just emptied
        self.ref[inter1.low] = inter2.low
        self.side[inter1.low] = -1
        inter1.low = None

</t>
<t tx="leo.20231205084805.545">cdef void remove_back_edges(self, tuple e):
    @others
    while self.s and _stack_top(self.s).lowest(self) == self.height[u]:
        p = self.s.pop()
        if p.left.low is not None:
            self.side[p.left.low] = -1
    if self.s:  # one more conflict pair to consider
        p = self.s.pop()
        # trim left interval
        self._trim_interval(p.left, p.right, u)
        # trim right interval
        self._trim_interval(p.right, p.left, u)
        self.s.append(p)
    # side of e is side of a highest return edge
    if self.lowpt[e] &lt; self.height[u]:  # e has return edge
        p = _stack_top(self.s)
        hl = p.left.high
        hr = p.right.high
        if (hl is not None) and (hr is None or self.lowpt[hl] &gt; self.lowpt[hr]):
            self.ref[e] = hl
        else:
            self.ref[e] = hr

</t>
<t tx="leo.20231205084805.546">cdef int u = e[0]
</t>
<t tx="leo.20231205084805.547"># trim back edges ending at parent u
# drop entire conflict pairs
cdef _ConflictPair p
</t>
<t tx="leo.20231205084805.548">cdef int sign(self, tuple e):
    """Resolve the relative side of an edge to the absolute side."""
    # the recursion stack
    dfs_stack = [e]
    # dict to remember reference edges
    old_ref = defaultdict(lambda: None)
    while dfs_stack:
        e = dfs_stack.pop()
        if self.ref[e] is not None:
            dfs_stack.append(e)  # revisit e after finishing self.ref[e]
            dfs_stack.append(self.ref[e])  # visit self.ref[e] next
            old_ref[e] = self.ref[e]  # remember value of self.ref[e]
            self.ref[e] = None
        else:
            self.side[e] *= self.side[old_ref[e]]
    return self.side[e]


</t>
<t tx="leo.20231205084805.549">cdef class _ConflictPair:
    """Represents a different constraint between two intervals.

    The edges in the left interval must have a different orientation than
    the one in the right interval.
    """
    @others
</t>
<t tx="leo.20231205084805.55">cdef VPoint other = rhs
</t>
<t tx="leo.20231205084805.550">cdef _Interval left, right

</t>
<t tx="leo.20231205084805.551">def __cinit__(self, _Interval left, _Interval right):
    if left is None:
        self.left = _Interval.__new__(_Interval, None, None)
    else:
        self.left = left
    if right is None:
        self.right = _Interval.__new__(_Interval, None, None)
    else:
        self.right = right

</t>
<t tx="leo.20231205084805.552">cdef void swap(self):
    """Swap left and right intervals"""
    self.left, self.right = self.right, self.left

</t>
<t tx="leo.20231205084805.553">cdef int lowest(self, _LRPlanarity planarity_state):
    """Return the lowest low point of a conflict pair"""
    if self.left.empty():
        return planarity_state.lowpt[self.right.low]
    if self.right.empty():
        return planarity_state.lowpt[self.left.low]
    return min(
        planarity_state.lowpt[self.left.low],
        planarity_state.lowpt[self.right.low]
    )


</t>
<t tx="leo.20231205084805.554">cdef class _Interval:
    """Represents a set of return edges.

    All return edges in an interval induce a same constraint on the contained
    edges, which means that all edges must either have a left orientation or
    all edges must have a right orientation.
    """
    @others
</t>
<t tx="leo.20231205084805.555">cdef tuple low, high

</t>
<t tx="leo.20231205084805.556">def __cinit__(self, tuple low, tuple high):
    self.low = low
    self.high = high

</t>
<t tx="leo.20231205084805.557">cdef bint empty(self):
    """Check if the interval is empty"""
    return self.low is self.high is None

</t>
<t tx="leo.20231205084805.558">cdef _Interval copy(self):
    """Return a copy of this interval"""
    return _Interval.__new__(_Interval, self.low, self.high)

</t>
<t tx="leo.20231205084805.559">cdef bint conflicting(self, tuple b, _LRPlanarity state):
    """Return true if interval I conflicts with edge b"""
    return not self.empty() and state.lowpt[self.high] &gt; state.lowpt[b]


</t>
<t tx="leo.20231205084805.56">cdef bint different = (
    self.links != other.links or
    self.c[0, 0] != other.c[0, 0] or
    self.c[0, 1] != other.c[0, 1] or
    self.c[1, 1] != other.c[1, 1] or
    self.c[1, 1] != other.c[1, 1] or
    self.type != other.type or
    self.x != other.x or
    self.y != other.y or
    self.angle != other.angle
</t>
<t tx="leo.20231205084805.560">cdef class _PlanarEmbedding(Graph):
    """Represents a planar graph with its planar embedding."""
    @others
</t>
<t tx="leo.20231205084805.561">cdef map[int, int] node_label
</t>
<t tx="leo.20231205084805.562">cdef map[ipair, ipair] edge_label

</t>
<t tx="leo.20231205084805.563">cdef void add_half_edge_cw(self, int start_node, int end_node, int reference_neighbor):
    """Adds a half-edge from start_node to end_node.

    edge_label[:, :, :] 0: cw
    edge_label[:, :, :] 1: ccw
    node_label[:]: first_nbr
    """
    self.add_edge(start_node, end_node)  # Add edge to graph
    if reference_neighbor == -1:
        # The start node has no neighbors
        self.edge_label[ipair(start_node, end_node)].first = end_node
        self.edge_label[ipair(start_node, end_node)].second = end_node
        self.node_label[start_node] = end_node
        return
    @others
    # Alter half-edge data structures
    self.edge_label[ipair(start_node, reference_neighbor)].first = end_node
    self.edge_label[ipair(start_node, end_node)].first = cw_reference
    self.edge_label[ipair(start_node, cw_reference)].second = end_node
    self.edge_label[ipair(start_node, end_node)].second = reference_neighbor

</t>
<t tx="leo.20231205084805.564"># Get half-edge at the other side
cdef int cw_reference = self.edge_label[ipair(start_node, reference_neighbor)].first
</t>
<t tx="leo.20231205084805.565">cdef void add_half_edge_ccw(self, int start_node, int end_node, int reference_neighbor):
    """Adds a half-edge from start_node to end_node."""
    self.add_half_edge_cw(
        start_node,
        end_node,
        self.edge_label[ipair(start_node, reference_neighbor)].second
    )
    @others
    if self.node_label.find(start_node) != self.node_label.end():
        s_f_label = self.node_label[start_node]
    else:
        s_f_label = -1
    if reference_neighbor == s_f_label:
        # Update first neighbor
        self.node_label[start_node] = end_node

</t>
<t tx="leo.20231205084805.566">cdef int s_f_label
</t>
<t tx="leo.20231205084805.567">cdef void add_half_edge_first(self, int start_node, int end_node):
    """The added half-edge is inserted at the first position in the order."""
    self.add_half_edge_ccw(start_node, end_node, self.node_label[start_node])
</t>
<t tx="leo.20231205084805.568">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/graph/
# -*- coding: utf-8 -*-
# cython: language_level=3

"""Structural synthesis.

The algorithm reference:
+ On the Number Synthesis of Kinematic Chains
    + author: Hong-Sen Yan, Yu-Ting Chiu
    + Mechanism and Machine Theory, Volume 89, 2015, Pages 128-144, ISSN 0094-114X
    + https://doi.org/10.1016/j.mechmachtheory.2014.08.012

author: Yuan Chang
copyright: Copyright (C) 2016-2022
license: AGPL
email: pyslvs@gmail.com
"""

from time import process_time
from logging import getLogger
from collections import Counter
cimport cython
from libcpp.pair cimport pair
from libcpp.vector cimport vector
from libcpp.map cimport map
from numpy import (
    int16 as i16,
    array as np_array,
    zeros as np_zeros,
    ones as np_ones,
    sum as np_sum,
    subtract as np_sub,
    multiply as np_mul,
    floor_divide as np_div,
    any as np_any,
    prod as np_prod,
    repeat as np_repeat,
    arange,
)
from .graph cimport Graph, link_assortment
from .planar cimport is_planar

ctypedef unsigned int uint
ctypedef unsigned long long ullong
ctypedef pair[int, int] ipair
ctypedef map[int, int] imap

logger = getLogger()


@others
    m_link = _labels(m_link, 3, 1)

    # Synthesis of multiple links
    _graph_atlas(result, cg_list, _labels(c_j, 1, 0), no_degenerate, stop_func)

    # Return graph list and time
    logger.debug(f"Count: {len(result)}, time: {process_time() - t0}")
    return result
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084805.569">@cython.boundscheck(False)
@cython.wraparound(False)
cdef short[:, :] _product(tuple pool, object stop_func):
    """Product function as same as iteration tools.

    The pool is created by range(n).
    """
    if not pool:
        return np_array([], dtype=i16)
    @others
    if pool[1:]:
        tmp2 = _product(pool[1:], stop_func)
        out[0:m, 1:] = tmp2
        for j in range(1, array0_size):
            if stop_func is not None and stop_func():
                return out
            out[j * m:(j + 1) * m, 1:] = out[0:m, 1:]
    return out


</t>
<t tx="leo.20231205084805.57">def __getitem__(self, ind):
    cdef int i = ind
    if self.type == VJoint.R:
        return self.c[0, i]
    else:
        return self.c[1, i]

</t>
<t tx="leo.20231205084805.570">cdef short[:] tmp1
</t>
<t tx="leo.20231205084805.571">cdef short[:, :] tmp2
</t>
<t tx="leo.20231205084805.572">cdef short[:] array0 = arange(pool[0], dtype=i16)
</t>
<t tx="leo.20231205084805.573">cdef int n = np_prod(pool)
</t>
<t tx="leo.20231205084805.574">cdef short[:, :] out = np_zeros((n, len(pool)), dtype=i16)
</t>
<t tx="leo.20231205084805.575">cdef int array0_size = len(array0)
</t>
<t tx="leo.20231205084805.576">cdef int m = n / array0_size
</t>
<t tx="leo.20231205084805.577">tmp1 = np_repeat(array0, m)
out[:, 0] = tmp1
</t>
<t tx="leo.20231205084805.578">cdef int j
</t>
<t tx="leo.20231205084805.579">cdef short[:, :] _simple_product(int pool_size, int repeat, object stop_func):
    return _product((pool_size,) * repeat + (1,), stop_func)


</t>
<t tx="leo.20231205084805.58">def __repr__(self):
    return f"VPoint({self.links}, {int(self.type)}, {self.angle}, {array(self.c).tolist()})"


</t>
<t tx="leo.20231205084805.580">cdef inline int _m_max(int nl, int nj) nogil:
    """Find max number of joint on each link.

    + nl &lt;= nj and nj &lt;= (2 * nl - 3)
    + (2 * nl - 3) &lt;= nj and nj &lt;= (nl * (nl - 1) / 2)
    + other exceptions (return -1).
    """
    if nl &lt;= nj &lt;= (2 * nl - 3):
        return nj - nl + 2
    if nl == nj == 0:
        return -1
    if 2 * nl - 3 &lt;= nj &lt;= &lt;double&gt;(nl * (nl - 1)) / 2:
        return nl - 1
    return -1


</t>
<t tx="leo.20231205084805.581">cdef inline int _sum_factors(short[:] factors):
    """F0*N2 + F1*N3 + F2*N4 + ... + Fn*N(n+2)"""
    cdef int factor = 0
    cdef int i
    for i in range(len(factors)):
        factor += factors[i] * (i + 2)
    return factor


</t>
<t tx="leo.20231205084805.582">cpdef list link_synthesis(int nl, int nj, object stop_func = None):
    """Return link assortment by number of links `nl` and number of joints `nj`.

    The check stop function `stop_func` object for GUI or subprocess,
    return `True` to terminate this function.
    """
    result = []
    @others
    for symbols in _simple_product(nl + 1, m_max_v - 2, stop_func):
        nl_m_max = nl - np_sum(symbols)
        if nl_m_max &lt; 0:
            continue
        symbols[-1] = nl_m_max
        if _sum_factors(symbols) == nj * 2:
            result.append(tuple(symbols))
    return result


</t>
<t tx="leo.20231205084805.583">cdef int m_max_v = _m_max(nl, nj)
</t>
<t tx="leo.20231205084805.584">if m_max_v == -1:
    raise ValueError("incorrect mechanism.")

</t>
<t tx="leo.20231205084805.585">cdef int i, p
</t>
<t tx="leo.20231205084805.586">cdef short[:] symbols
</t>
<t tx="leo.20231205084805.587">cdef inline int _j_m(short[:] link_num):
    """Return value of JM."""
    @others
    for num in link_num[1:]:
        c += &lt;double&gt;i / 2 * num
        i += 1
    return &lt;int&gt;c


</t>
<t tx="leo.20231205084805.588">cdef int num
</t>
<t tx="leo.20231205084805.589">cdef int i = 3
</t>
<t tx="leo.20231205084805.59">@cython.final
cdef class VLink:
    """Mechanism expression class in link's view."""
    HOLDER = VLink("", "", [])
    FRAME = 'ground'

    @others
</t>
<t tx="leo.20231205084805.590">cdef float c = 0
</t>
<t tx="leo.20231205084805.591">cdef inline int _j_m_p(int n_m) nogil:
    """Return value of J'M. This is improved function.

    + Origin equation:
    if n_m % 2 == 0:
        return &lt;int&gt;((3 * (n_m - 1) - 1) / 2)
    else:
        return &lt;int&gt;((3 * (n_m - 1) - 2) / 2)
    """
    # Number of multiple links.
    if n_m &lt;= 1:
        return 0
    elif n_m == 2:
        return 1
    else:
        return 3 * (n_m - 2)


</t>
<t tx="leo.20231205084805.592">cpdef list contracted_link_synthesis(object link_num_list, object stop_func = None):
    """Return contracted link assortment by link assortment `link_num_list`.

    The check stop function `stop_func` object for GUI or subprocess,
    return `True` to terminate this function.
    """
    @others
    cj_list = []
    for m in _simple_product(link_num[0] + 1, i_max - 1, stop_func):
        count = 0
        index = 1
        for factor in m[:-1]:
            count +=  factor * index
            index += 1

        # Check if the last factor is a natural number.
        last_factor = &lt;double&gt;(link_num[0] - count) / index
        factor = &lt;int&gt;last_factor
        if last_factor &lt; 0 or last_factor != factor:
            continue

        m[-1] = factor
        if n_c_min &lt;= np_sum(m) &lt;= n_c_max:
            cj_list.append(tuple(m))

    return cj_list


</t>
<t tx="leo.20231205084805.593">cdef short[:] link_num
</t>
<t tx="leo.20231205084805.594">if len(link_num_list) == 1:
    link_num = np_zeros(link_num_list[0], dtype=i16)
    link_num[-1] = 1
    return [tuple(link_num)]

link_num = np_array(link_num_list, dtype=i16)

</t>
<t tx="leo.20231205084805.595"># Contracted link
cdef int j_m_v = _j_m(link_num)
</t>
<t tx="leo.20231205084805.596">cdef int n_c_min = max(1, j_m_v - _j_m_p(sum(link_num[1:])))
</t>
<t tx="leo.20231205084805.597">cdef int n_c_max = min(link_num[0], j_m_v)

</t>
<t tx="leo.20231205084805.598"># i = NL2 - NC + 2
cdef int i_max = min(link_num[0], link_num[0] - n_c_min + 2)

</t>
<t tx="leo.20231205084805.599"># Matching formula
cdef int count, factor, index
</t>
<t tx="leo.20231205084805.6">cdef VPoint vpoint
</t>
<t tx="leo.20231205084805.60">def __cinit__(
    self,
    str name,
    str color_str,
    object points,
    object color_func=None
</t>
<t tx="leo.20231205084805.600">cdef float last_factor
</t>
<t tx="leo.20231205084805.601">cdef short[:] m
</t>
<t tx="leo.20231205084805.602">cdef inline short[:] _nonzero_index(short[:] array):
    """Return the number of nonzero numbers."""
    counter = []
    @others
    for i, n in enumerate(array):
        if n != 0:
            counter.append(i)
    return np_array(counter, dtype=i16)


</t>
<t tx="leo.20231205084805.603">cdef int i, n
</t>
<t tx="leo.20231205084805.604">cdef inline ullong _factorial(int n):
    """Return (n!)."""
    cdef ullong ret = 1
    cdef int i
    for i in range(2, n + 1):
        ret *= i
    return ret


</t>
<t tx="leo.20231205084805.605">cdef inline int _gcd(int a, int b) nogil:
    """Return Greatest Common Divisor of a and b.

    Only for positive numbers.
    """
    @others
    while b &gt; 0:
        r = a % b
        a = b
        b = r
    return a


</t>
<t tx="leo.20231205084805.606">cdef int r
</t>
<t tx="leo.20231205084805.607">cdef inline short[:] _labels(short[:] numbers, int index, int offset):
    """Generate labels from numbers."""
    @others
    labels = []
    for num in numbers[offset:]:
        for i in range(num):
            labels.append(index)
        index += 1
    return np_array(labels, dtype=i16)


</t>
<t tx="leo.20231205084805.608">cdef int i, num
</t>
<t tx="leo.20231205084805.609">cdef inline Graph _multigraph(short[:] counter, int n):
    """Get multigraph from n x n matrix."""
    edges = {}
    @others
    for i in range(n):
        for j in range(n):
            if i &gt;= j:
                continue
            edges[i, j] = counter[c]
            c += 1
    return Graph(Counter(edges).elements())


</t>
<t tx="leo.20231205084805.61">):
    self.name = name
    self.color_str = color_str
    if color_func is None:
        self.color = None
    else:
        self.color = color_func(color_str)
    self.points = array(list(points), dtype=int)

</t>
<t tx="leo.20231205084805.610">cdef int c = 0
</t>
<t tx="leo.20231205084805.611">cdef int i, j
</t>
<t tx="leo.20231205084805.612">@cython.boundscheck(False)
cdef inline void _gauss_elimination(
    list result,
    short[:] limit,
    short[:, :] f_matrix,
    int n,
    int var_count
</t>
<t tx="leo.20231205084805.613">):
    """Gauss elimination for (n, n + 1) matrix."""
</t>
<t tx="leo.20231205084805.614">    cdef int i, j, d
</t>
<t tx="leo.20231205084805.615">    cdef short[:] tmp1, tmp2
</t>
<t tx="leo.20231205084805.616">    for j in range(var_count):
        # Remove all coefficients of index [i] to zero
        for i in range(n):
            if f_matrix[i, j] != 0 and not np_any(f_matrix[i, :j]):
                d = i
                tmp2 = np_div(f_matrix[i, :], f_matrix[i, j])
                break
        else:
            continue

        for i in range(n):
            if i == d or f_matrix[i, j] == 0:
                continue
            tmp1 = np_sub(f_matrix[i, :], np_mul(tmp2, f_matrix[i, j]))
            f_matrix[i, :] = tmp1

</t>
<t tx="leo.20231205084805.617">    # Answer
    cdef short[:] answer = -np_ones(var_count, dtype=i16)

</t>
<t tx="leo.20231205084805.618">    # Determined solution
    cdef int c, k
</t>
<t tx="leo.20231205084805.619">    for i in range(n):
        c = 0
        for j in range(var_count):
            # Derivation (has answer)
            if answer[j] != -1 and f_matrix[i, j] != 0:
                f_matrix[i, -1] -= f_matrix[i, j] * answer[j]
                f_matrix[i, j] = 0

            # Nonzero coefficient
            if f_matrix[i, j] != 0:
                d = j
                c += 1

        if c != 1:
            continue

        j = d
        k = f_matrix[i, j]
        c = f_matrix[i, -1]
        if k != 1:
            if k &lt; 0:
                k = -k
                c = -c
            if c &lt; 0:
                return
            d = _gcd(k, c)
            k /= d
            c /= d
        if c &lt; 0:
            return
        answer[j] = c

    # Result
    _test_contracted_graph(_multigraph(answer, n), result)


</t>
<t tx="leo.20231205084805.62">cpdef void set_points(self, object points) except *:
    """The update function of points attribute."""
    self.points = array(list(points), dtype=int)

</t>
<t tx="leo.20231205084805.620">@cython.boundscheck(False)
cdef void _nest_do(
    list result,
    short[:] answer,
    short[:, :] f_matrix,
    int i,
    int n,
    object stop_func
</t>
<t tx="leo.20231205084805.621">):
    """Nest do loop."""
    if i &gt;= n:
        # Result
        if &lt;int&gt;np_sum(answer) == &lt;int&gt;np_sum(f_matrix[:, -1]) / 2:
            _test_contracted_graph(_multigraph(answer, n), result)
        return

</t>
<t tx="leo.20231205084805.622">    cdef short[:] coefficients = _nonzero_index(f_matrix[i, :-1])
</t>
<t tx="leo.20231205084805.623">    cdef int c = 0
</t>
<t tx="leo.20231205084805.624">    cdef int j = -1
</t>
<t tx="leo.20231205084805.625">    cdef int d
</t>
<t tx="leo.20231205084805.626">    for d in coefficients:
        if answer[d] == -1:
            c += 1
            j = d

    if c == 0:
        if &lt;int&gt;np_sum(np_mul(answer, f_matrix[i, :-1])) == f_matrix[i, -1]:
            _nest_do(result, answer, f_matrix, i + 1, n, stop_func)
        return
    elif c == 1:
        c = 0
        for d in coefficients:
            if answer[d] != -1:
                c += answer[d] * f_matrix[i, d]
        answer[j] = (f_matrix[i, -1] - c) / f_matrix[i, j]
        _nest_do(result, answer, f_matrix, i + 1, n, stop_func)
        return

</t>
<t tx="leo.20231205084805.627">    cdef short[:] combine, answer_copy
</t>
<t tx="leo.20231205084805.628">    for combine in _product((f_matrix[i, -1],) * c, stop_func):
        if stop_func is not None and stop_func():
            return

        c = 0
        d = 0
        for j in coefficients:
            if answer[j] == -1:
                c += combine[d] * f_matrix[i, j]
                d += 1
            else:
                c += answer[j] * f_matrix[i, j]
        if c != f_matrix[i, -1]:
            continue

        answer_copy = answer.copy()
        d = 0
        for j in coefficients:
            # Pass to answer
            if answer_copy[j] == -1:
                answer_copy[j] = combine[d]
                d += 1
        _nest_do(result, answer_copy, f_matrix, i + 1, n, stop_func)


</t>
<t tx="leo.20231205084805.629">cdef inline bint _is_isomorphic(Graph g, list result):
    """Return true if graph is isomorphic with result list."""
    cdef Graph h
    for h in result:
        if g.is_isomorphic(h):
            return True
    return False


</t>
<t tx="leo.20231205084805.63">cpdef Coord[:] points_pos(self, object vpoints) except *:
    """Get link positions from a VPoint list."""
    coords = []
    @others
    for i in self.points:
        vpoint = vpoints[i]
        coords.append(vpoint.link_pos(self.name))
    return array(coords, dtype=object)

</t>
<t tx="leo.20231205084805.630">cdef inline void _test_contracted_graph(Graph g, list result):
    """Test the contracted graph."""
    if not g.edges:
        return
    # All connected
    if not g.is_connected():
        return
    # Cut link
    if g.has_cut_link():
        return
    # Planar graph
    if not is_planar(g):
        return
    # Isomorphism
    if _is_isomorphic(g, result):
        return

    result.append(g)


</t>
<t tx="leo.20231205084805.631">cdef inline void _test_graph(
    Graph g,
    list result,
    uint no_degenerate
</t>
<t tx="leo.20231205084805.632">):
    """Test result graph."""
    # Graph filter depending on degenerate option
    if no_degenerate == 0 and not g.is_degenerate():
        return
    elif no_degenerate == 1 and g.is_degenerate():
        return
    # Isomorphism
    if _is_isomorphic(g, result):
        return
    result.append(g)


</t>
<t tx="leo.20231205084805.633">@cython.boundscheck(False)
cdef inline void _contracted_graph(
    list result,
    short[:] limit,
    object stop_func
</t>
<t tx="leo.20231205084805.634">):
    """Synthesis of contracted graphs."""
</t>
<t tx="leo.20231205084805.635">    cdef int n = len(limit)
</t>
<t tx="leo.20231205084805.636">    cdef int var_count = n * (n - 1) / 2
</t>
<t tx="leo.20231205084805.637">    cdef short[:, :] f_matrix = np_zeros((n, var_count + 1), dtype=i16)
</t>
<t tx="leo.20231205084805.638">    f_matrix[:, -1] = limit

</t>
<t tx="leo.20231205084805.639">    # Equations
    cdef int i, j, k, c
</t>
<t tx="leo.20231205084805.64">cdef int i
</t>
<t tx="leo.20231205084805.640">    for i in range(n):
        c = 0
        for j in range(n):
            for k in range(n):
                if j &gt;= k:
                    continue
                if i in {j, k}:
                    f_matrix[i, c] = 1
                c += 1

    if n &gt;= var_count:
        # Fast solution by Gauss elimination.
        _gauss_elimination(result, limit, f_matrix, n, var_count)
    else:
        # Nest do loop method.
        _nest_do(result, -np_ones(var_count, dtype=i16), f_matrix, 0, n, stop_func)


</t>
<t tx="leo.20231205084805.641">cdef inline void _dyad_insert(Graph g, frozenset edge, int amount):
    """Insert dyad to the graph."""
    if amount &lt; 1:
        return

    @others
    n1, n2 = edge

    path = [n1]
    path.extend(range(last_num, last_num + amount))
    path.append(n2)

    g.remove_edge(n1, n2)
    g.add_path(path)


</t>
<t tx="leo.20231205084805.642">cdef int last_num = max(g.vertices) + 1
</t>
<t tx="leo.20231205084805.643">cdef int n1, n2
</t>
<t tx="leo.20231205084805.644">cdef inline void _permute_combine(
    short[:] limit,
    list combine_list,
    tuple pick_list,
    object stop_func
</t>
<t tx="leo.20231205084805.645">):
    """Permutation of combined list."""
</t>
<t tx="leo.20231205084805.646">    cdef int n = len(limit)
</t>
<t tx="leo.20231205084805.647">    if n &lt; 1:
        return

</t>
<t tx="leo.20231205084805.648">    cdef vector[int] indices = range(n)
</t>
<t tx="leo.20231205084805.649">    cdef short[:] cycles = np_zeros(n, dtype=i16)
</t>
<t tx="leo.20231205084805.65">cdef Coord c
</t>
<t tx="leo.20231205084805.650">    cdef short[:] pool = limit
</t>
<t tx="leo.20231205084805.651">    permute_list = set()
</t>
<t tx="leo.20231205084805.652">    cdef int i, j
</t>
<t tx="leo.20231205084805.653">    for i, j in enumerate(range(n, 0, -1)):
        cycles[i] = j
    permute_list.add(tuple(pool[indices[i]] for i in range(n)))
</t>
<t tx="leo.20231205084805.654">    cdef vector[int].iterator it2 = indices.begin()

</t>
<t tx="leo.20231205084805.655">    cdef int tmp
</t>
<t tx="leo.20231205084805.656">    while True:
        if stop_func is not None and stop_func():
            break

        for i in reversed(range(n)):
            cycles[i] -= 1
            if cycles[i] == 0:
                tmp = indices[i]
                indices.erase(it2 + i)
                indices.push_back(tmp)
                cycles[i] = n - i
            else:
                j = cycles[i]
                tmp = indices[i]
                indices[i] = indices[n - j]
                indices[n - j] = tmp
                permute_list.add(tuple(pool[indices[i]] for i in range(n)))
                break
        else:
            break
    for tmp_array in permute_list:
        combine_list.append(tuple(zip(pick_list, tmp_array)))


</t>
<t tx="leo.20231205084805.657">cdef inline list _contracted_links(tuple edges, short[:] limit, object stop_func):
    """Combination of contracted links.

    pool: edges
    pick: contracted links

    If the edge is not picked, it represent the joint is connected directly.
    """
    @others
    while True:
        if stop_func is not None and stop_func():
            break

        # Combine
        for i in range(pick_count):
            pick_list[pool_list[indices[i]]] += 1

        # Collecting
        combine_set.add(tuple(pick_list.elements()))
        # Initialize
        pick_list.clear()
        # Check combination is over.
        for n1 in reversed(range(pick_count)):
            if indices[n1] != n1 + pool_size - pick_count:
                break
        else:
            break
        # Next indicator
        indices[n1] += 1
        for n2 in range(n1 + 1, pick_count):
            indices[n2] = indices[n2 - 1] + 1
    combine_list = []
    pool_list = tuple(confirm_list.elements())
    for picked in combine_set:
        _permute_combine(limit, combine_list, pool_list + picked, stop_func)
    return combine_list


</t>
<t tx="leo.20231205084805.658"># Number of contracted links
cdef int pick_count = len(limit)
</t>
<t tx="leo.20231205084805.659">if pick_count &lt; 1:
    return []

# Check over picked
pool_list = tuple([frozenset(edge) for edge in edges])
pool = Counter(pool_list)
# The list including required edge(s).
confirm_list = pool - Counter(set(pool_list))
# Simplified the pool
pool_list = tuple((pool - confirm_list).elements())
</t>
<t tx="leo.20231205084805.66">cdef VPoint vpoint
</t>
<t tx="leo.20231205084805.660">cdef int confirm_size = sum(confirm_list.values())
</t>
<t tx="leo.20231205084805.661">if confirm_size &gt; pick_count or pick_count &gt; len(edges):
    return []

pick_count -= confirm_size
</t>
<t tx="leo.20231205084805.662">cdef int pool_size = len(pool_list)
</t>
<t tx="leo.20231205084805.663">cdef short[:] indices = np_zeros(pick_count, dtype=i16)
</t>
<t tx="leo.20231205084805.664">cdef int i
</t>
<t tx="leo.20231205084805.665">for i in range(pick_count):
    indices[i] = i
pick_list = Counter()
combine_set = set()
</t>
<t tx="leo.20231205084805.666"># Combinations loop with number checking.
cdef int n1, n2
</t>
<t tx="leo.20231205084805.667">cdef inline void _graph_atlas(
    list result,
    list contracted_graph,
    short[:] limit,
    uint no_degenerate,
    object stop_func
</t>
<t tx="leo.20231205084805.668">):
    """Synthesis of atlas."""
</t>
<t tx="leo.20231205084805.669">    cdef int n
</t>
<t tx="leo.20231205084805.67">def __contains__(self, point: int):
    return point in self.points

</t>
<t tx="leo.20231205084805.670">    cdef Graph cg, g
</t>
<t tx="leo.20231205084805.671">    for cg in contracted_graph:
        for combine in _contracted_links(cg.edges, limit, stop_func):
            g = Graph.__new__(Graph, cg.edges)
            for edge, n in combine:
                _dyad_insert(g, edge, n)
            _test_graph(g, result, no_degenerate)


</t>
<t tx="leo.20231205084805.672">cdef inline list _loop_chain(int num):
    """Loop chain of num."""
    @others
    chain = []
    for i in range(1, num):
        chain.append((b, i))
        b = i
    chain.append((0, b))
    return chain


</t>
<t tx="leo.20231205084805.673">cdef int i
</t>
<t tx="leo.20231205084805.674">cdef int b = 0
</t>
<t tx="leo.20231205084805.675">cpdef list contracted_graph(object link_num_list, object stop_func = None):
    """Generate contracted graphs by link assortment `link_num`.

    The check stop function `stop_func` object for GUI or subprocess,
    return `True` to terminate this function.
    """
    if not link_num_list:
        return []

    @others
    for num in m_link:
        m_limit[i] = num
        count[i] = 0
        i += 1

    # Synthesis of contracted graphs
    cg_list = []
    _contracted_graph(cg_list, m_link, stop_func)
    logger.debug(f"Contracted graph(s): {len(cg_list)}, time: {process_time() - t0}")
    return cg_list


</t>
<t tx="leo.20231205084805.676"># Initial time
cdef double t0 = process_time()
</t>
<t tx="leo.20231205084805.677">cdef short[:] link_num = np_array(link_num_list, ndmin=1, dtype=i16)
</t>
<t tx="leo.20231205084805.678">logger.debug(f"Link assortment: {list(link_num)}")

</t>
<t tx="leo.20231205084805.679"># Multiple links
cdef short[:] m_link = _labels(link_num, 3, 1)

</t>
<t tx="leo.20231205084805.68">def __repr__(self):
    return f"VLink('{self.name}', {tuple(self.points)}, color_qt)"
</t>
<t tx="leo.20231205084805.680">cdef imap m_limit, count
</t>
<t tx="leo.20231205084805.681">cdef int num
</t>
<t tx="leo.20231205084805.682">cdef int i = 0
</t>
<t tx="leo.20231205084805.683">cpdef list conventional_graph(
    list cg_list,
    object c_j_list,
    uint no_degenerate = 1,
    object stop_func = None
</t>
<t tx="leo.20231205084805.684">):
    """Generate conventional graphs by contracted graphs `cg_list` and
    contracted link assortment `c_j_list`.

    The degenerate setting `no_degenerate` has following option:

    + `0`: No degenerate.
    + `1`: Only degenerate.
    + Else: All graphs.

    The check stop function `stop_func` object for GUI or subprocess,
    return `True` to terminate this function.
    """
</t>
<t tx="leo.20231205084805.685">    # Initial time
    cdef double t0 = process_time()
</t>
<t tx="leo.20231205084805.686">    logger.debug(f"Contracted link assortment: {list(c_j_list)}")

</t>
<t tx="leo.20231205084805.687">    # Synthesis of contracted link and multiple link combination.
    cdef short[:] c_j = np_array(c_j_list, ndmin=1, dtype=i16)
</t>
<t tx="leo.20231205084805.688">    result = []
</t>
<t tx="leo.20231205084805.689">    cdef int i, num
</t>
<t tx="leo.20231205084805.69">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/
# -*- coding: utf-8 -*-
# cython: language_level=3, cdivision=True, boundscheck=False, wraparound=False
# cython: initializedcheck=False, nonecheck=False

"""Tiny CAD library of PMKS symbolic and position analysis.

author: Yuan Chang
copyright: Copyright (C) 2016-2022
license: AGPL
email: pyslvs@gmail.com
"""

from libc.math cimport M_PI, NAN, sin, cos
from .expression cimport Coord, VJoint, VPoint, VLink, distance, slope_angle
from .bfgs cimport SolverSystem
from numpy import zeros, array
from numpy.random import uniform


@others
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084805.690">    if not cg_list:
        if 1 not in c_j_list:
            return []
        # Single loop - ring graph (special case)
        i = 1
        for num in c_j:
            if num == 1:
                break
            i += 1
        else:
            raise ValueError("Invalid assortment!")
        result.append(Graph.__new__(Graph, _loop_chain(i)))
        logger.debug(f"Count: {len(result)}")
        return result

</t>
<t tx="leo.20231205084805.691">    # Multiple links
    cdef short[:] m_link = np_array(link_assortment(cg_list[0]), ndmin=1, dtype=i16)
</t>
<t tx="leo.20231205084805.692"></t>
<t tx="leo.20231205084805.693">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/optimization/
# -*- coding: utf-8 -*-
# cython: language_level=3, cdivision=True, boundscheck=False, wraparound=False
# cython: initializedcheck=False, nonecheck=False

"""Fast planar linkage synthesis. (defect allowable)

author: Yuan Chang
copyright: Copyright (C) 2016-2022
license: AGPL
email: pyslvs@gmail.com
"""

cimport cython
from collections import OrderedDict
from logging import getLogger
from numpy import (
    zeros, array, arange, interp, argmax, concatenate, float64 as f64,
)
from numpy.core.multiarray import correlate
from libc.math cimport (
    cos, sin, atan2, isnan, log, INFINITY as INF, HUGE_VAL, M_PI,
)
from libcpp.pair cimport pair
from libcpp.map cimport map
from libcpp.vector cimport vector
from libcpp.set cimport set as cset
from pyslvs.expression cimport Coord, VPoint, distance
from pyslvs.metaheuristics.utility cimport ObjFunc
from pyslvs.tinycadlib cimport (
    quick_solve, I_LABEL, A_LABEL, P_LABEL, PLA, PLAP, PLLP, preprocessing,
    CCoord, Sym, SwappablePair,
)
from pyslvs.topo_config cimport t_config, EStack, Expr
from pyslvs.bfgs cimport SolverSystem

try:
    from scipy.signal import fftconvolve
except ImportError:
    fftconvolve = None

logger = getLogger()


@others
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084805.694">def norm_path(path, scale=1):
    """Normalization function."""
    cdef double[:, :] path_m = array(path, dtype=f64)
    _norm(path_m, scale)
    return array(path_m)


</t>
<t tx="leo.20231205084805.695">cdef void _norm(double[:, :] path, double scale) nogil:
    """Normalization implementation."""
    @others
    for i in range(len(path)):
        a = angle[i] - angle[end]
        path[i, 0] = length[i] * cos(a)
        path[i, 1] = length[i] * sin(a)
        if path[i, 0] &lt; bound.x:
            bound.x = path[i, 0]
        if path[i, 0] &gt; bound.y:
            bound.y = path[i, 0]
    scale /= (bound.y - bound.x)
    _mul1d(path[:, 0], scale)
    _mul1d(path[:, 1], scale)


</t>
<t tx="leo.20231205084805.696">cdef CCoord centre = CCoord(0, 0)
</t>
<t tx="leo.20231205084805.697">cdef double x, y
</t>
<t tx="leo.20231205084805.698">cdef int i
</t>
<t tx="leo.20231205084805.699">for i in range(len(path)):
    centre.x += path[i, 0]
    centre.y += path[i, 1]
</t>
<t tx="leo.20231205084805.7">@cython.final
cdef class Coord:
    """A data class used to store coordinates."""

    @others
</t>
<t tx="leo.20231205084805.70">def pxy(Coord c1, double x, double y):
    """The PXY function requires one point and offset values, get the
    position of second point.

    In the following picture, `c1` correspond to "A", `d0` correspond to "X",
    `d1` correspond to "Y", `return` correspond to "B", the sign of value are
    correspond to coordinate system.

    ![pxy](img/pxy.png)
    """
    @others
    return Coord.__new__(Coord, c.x, c.y)


</t>
<t tx="leo.20231205084805.700">cdef int end = len(path)
</t>
<t tx="leo.20231205084805.701">centre.x /= end
centre.y /= end
</t>
<t tx="leo.20231205084805.702">cdef vector[double] angle = vector[double](end + 1)
</t>
<t tx="leo.20231205084805.703">cdef vector[double] length = vector[double](end + 1)
</t>
<t tx="leo.20231205084805.704">cdef int sp = 0
</t>
<t tx="leo.20231205084805.705">for i in range(len(path)):
    x = path[i, 0]
    y = path[i, 1]
    angle[i] = atan2(y - centre.y, x - centre.x)
    length[i] = distance(centre.x, centre.y, x, y)
    if length[i] &gt; length[end]:
        length[end] = length[i]
        angle[end] = angle[i]
        sp = end
roll(path, sp)
</t>
<t tx="leo.20231205084805.706">cdef CCoord bound = CCoord(INF, -INF)
</t>
<t tx="leo.20231205084805.707">cdef double a
</t>
<t tx="leo.20231205084805.708">cdef void roll(double[:, :] path, int ind) nogil:
    """Split 1D path from sp, concatenate to end."""
    if ind == 0:
        return
    @others
    with gil:
        tmp = zeros((ind, 2), dtype=f64)
    tmp[:] = path[:ind]
    path[:len(path) - ind] = path[ind:]
    path[len(path) - ind:] = tmp[:]


</t>
<t tx="leo.20231205084805.709">cdef double[:, :] tmp
</t>
<t tx="leo.20231205084805.71">cdef CCoord c = cpxy(CCoord(c1.x, c1.y), x, y)
</t>
<t tx="leo.20231205084805.710">def curvature(path):
    r"""Calculate the signed curvature and return as an array.

    $$
    \kappa(t) = \frac{x'y'' - x''y'}{(x'^2 + y'^2)^\frac{3}{2}}
    $$
    """
    @others
    return array(_curvature(path_m))


</t>
<t tx="leo.20231205084805.711">cdef double[:, :] path_m = array(path, dtype=f64)
</t>
<t tx="leo.20231205084805.712">cdef double[:] _curvature(double[:, :] path) nogil:
    """Calculate the signed curvature."""
    @others
    for i in range(len(path) - 2):
        k[i] = ((p1d[i, 0] * p2d[i, 1] - p2d[i, 0] * p1d[i, 1])
                / (p1d[i, 0] * p1d[i, 0] + p1d[i, 1] * p1d[i, 1]) ** 1.5)
    return k


</t>
<t tx="leo.20231205084805.713">cdef double[:, :] p1d = _derivative(path)
</t>
<t tx="leo.20231205084805.714">cdef double[:, :] p2d = _derivative(p1d)
</t>
<t tx="leo.20231205084805.715">cdef double[:] k
</t>
<t tx="leo.20231205084805.716">with gil:
    k = zeros(len(path) - 2, dtype=f64)
</t>
<t tx="leo.20231205084805.717">cdef int i
</t>
<t tx="leo.20231205084805.718">def derivative(double[:, :] p):
    """Differential function. Return $p'$."""
    return array(_derivative(p))


</t>
<t tx="leo.20231205084805.719">cdef double[:, :] _derivative(double[:, :] p) nogil:
    """Differential function backend."""
    @others
    for i in range(len(p)):
        j = i + 1
        if j &gt;= len(p):
            j = 0
        pd[i, 0] = p[j, 0] - p[i, 0]
        pd[i, 1] = p[j, 1] - p[i, 1]
        if pd[i, 0] &gt; max0:
            max0 = pd[i, 0]
        if pd[i, 1] &gt; max1:
            max1 = pd[i, 1]
    i = len(p) - 1
    if max0 == pd[i, 0] or max1 == pd[i, 1]:
        return pd[:i]
    else:
        return pd


</t>
<t tx="leo.20231205084805.72">def ppp(Coord c1, Coord c2, Coord c3):
    """The PPP function is used to solve parallel linkage.

    In the following picture, `c1` correspond to "A", `c2` correspond to "B",
    `c3` correspond to "C", `return` correspond to "D".

    ![ppp](img/ppp.png)
    """
    @others
    return Coord.__new__(Coord, c.x, c.y)


</t>
<t tx="leo.20231205084805.720">cdef double[:, :] pd
</t>
<t tx="leo.20231205084805.721">with gil:
    pd = zeros((len(p), 2), dtype=f64)
</t>
<t tx="leo.20231205084805.722">cdef double max0 = 0
</t>
<t tx="leo.20231205084805.723">cdef double max1 = 0
</t>
<t tx="leo.20231205084805.724">cdef int i, j
</t>
<t tx="leo.20231205084805.725">def path_signature(double[:] k, double maximum = 100):
    r"""Require a curvature, return path signature.
    It's composed by curvature $\kappa$ and a $K$ value.

    $$
    K = \int^t_0 |\kappa(t)| dt
    $$

    &gt;&gt;&gt; from pyslvs.optimization import curvature, path_signature
    &gt;&gt;&gt; path_signature(curvature(...))
    """
    return array(_path_signature(k, maximum))


</t>
<t tx="leo.20231205084805.726">cdef double[:, :] _path_signature(double[:] k, double maximum) nogil:
    """Require a curvature, return path signature."""
    @others
    for i in range(len(k)):
        s[i] = v
        v += interval
    s[:, 1] = k
    return s


</t>
<t tx="leo.20231205084805.727">cdef double[:, :] s
</t>
<t tx="leo.20231205084805.728">with gil:
    s = zeros((len(k), 2), dtype=f64)
</t>
<t tx="leo.20231205084805.729">cdef double interval = maximum / len(k)
</t>
<t tx="leo.20231205084805.73">cdef CCoord c = cppp(CCoord(c1.x, c1.y), CCoord(c2.x, c2.y),
                     CCoord(c3.x, c3.y))
</t>
<t tx="leo.20231205084805.730">cdef double v = 0
</t>
<t tx="leo.20231205084805.731">cdef int i
</t>
<t tx="leo.20231205084805.732">def cross_correlation(double[:, :] p1, double[:, :] p2, double t = 0.1):
    r"""Compare signature and return as an 1d array.

    $$
    \begin{aligned}
    C_n(j, W, P) &amp;= \left|\sum_i^{l_P} \frac{(W_{i + j}
    - \overline{W}_{j\rightarrow j + l_P})(P_i-\overline{P})}{
    \sqrt{\sum_i^{l_P}(W_{i + j} - \overline{W}_{j\rightarrow j + l_P})^2
    \sum_i^{l_P}(P_i - \overline{P})^2}}\right|
    \\
    S &amp;= \arg\max\{C_n(j)\} t
    \end{aligned}
    $$

    &gt;&gt;&gt; from pyslvs.optimization import curvature, path_signature
    &gt;&gt;&gt; ps1 = path_signature(curvature(...))
    &gt;&gt;&gt; ps2 = path_signature(curvature(...))
    &gt;&gt;&gt; from pyslvs.optimization import cross_correlation
    &gt;&gt;&gt; cc = cross_correlation(ps1, ps2)
    """
    return array(_cross_correlation(p1, p2, t), dtype=f64)


</t>
<t tx="leo.20231205084805.733">cdef double[:] _cross_correlation(double[:, :] ps1, double[:, :] ps2, double t):
    """Compare path signature."""
    @others
    if s2 &gt;= s1:
        s1, s2 = s2, s1
    if (fftconvolve is not None and 1.89095737e-9 * 3 * n * log(n)
        &lt; 2.1364985e-10 * (s1 - s2 + 1) * s2 - 1e-3
    ):
        return fftconvolve(p1, p2[::-1], mode='valid')
    else:
        return correlate(p1, p2)


</t>
<t tx="leo.20231205084805.734">cdef double[:] p1 = interp(arange(0, _extr1d(ps1[:, 0], 1), t),
                           ps1[:, 0], ps1[:, 1])
</t>
<t tx="leo.20231205084805.735">cdef double[:] p2 = interp(arange(0, _extr1d(ps2[:, 0], 1), t),
                           ps2[:, 0], ps2[:, 1])
</t>
<t tx="leo.20231205084805.736">p1 = concatenate((p1, p1))
</t>
<t tx="leo.20231205084805.737">cdef int s1 = len(p1)
</t>
<t tx="leo.20231205084805.738">cdef int s2 = len(p2)
</t>
<t tx="leo.20231205084805.739">cdef int n = s1 + s2 - 1
</t>
<t tx="leo.20231205084805.74">def plap(
    Coord c1,
    double d0,
    double a0,
    Coord c2 = None,
    bint inverse = False
</t>
<t tx="leo.20231205084805.740">cdef double _extr1d(double[:] s, bint op) nogil:
    """Max value of 1D slice."""
    @others
    for v in s:
        if op:
            if v &gt; m:
                m = v
        elif v &lt; m:
            m = v
    return m


</t>
<t tx="leo.20231205084805.741">cdef double m = -INF if op else INF
</t>
<t tx="leo.20231205084805.742">cdef void _mul1d(double[:] s, double v) nogil:
    """Inplace multiplication assignment of 1D slice."""
    cdef int i
    for i in range(len(s)):
        s[i] *= v


</t>
<t tx="leo.20231205084805.743">cdef double[:, :] _slice_nan2d(double[:, :] s) nogil:
    """Slice continuous view without NaN."""
    @others
    for i in range(len(s)):
        v = s[i, 1]
        if i == first + 1 and isnan(v):
            # The first of slice
            first = i
        elif isnan(v):
            # The end of slice
            second = i
            break
    if first == -1:
        first = 0
    if second == -1:
        second = len(s) - 1
    return s[first:second]


</t>
<t tx="leo.20231205084805.744">cdef int first = -1
</t>
<t tx="leo.20231205084805.745">cdef int second = -1
</t>
<t tx="leo.20231205084805.746">cdef int i
</t>
<t tx="leo.20231205084805.747">cdef double v
</t>
<t tx="leo.20231205084805.748">@cython.final
cdef class FPlanar(ObjFunc):
    """A fast matching method that adds mapping angles to variables.

    Allowing defects.
    """
    @others
</t>
<t tx="leo.20231205084805.749">cdef bint bfgs_mode, shape_only, use_curvature, full_path, ordered
</t>
<t tx="leo.20231205084805.75">):
    """The PLAP function requires two points, one distance and one angle,
    obtained the position of third point. The unit of `a0` is degree.

    In the following picture, `c1` correspond to "A", `c2` correspond to "B",
    `d0` correspond to "L0", `a0` correspond to "beta", `return` correspond
    to "C".
    If `c2` is not given, "alpha" will be set to zero.

    ![plap](img/plap.png)

    Set `inverse` option to `True` can make `a0` value as negative.
    """
    if c2 is None:
        c2 = c1
</t>
<t tx="leo.20231205084805.750">cdef int target_count, target_len, input_count, l_base
</t>
<t tx="leo.20231205084805.751">cdef public unsigned long callback
</t>
<t tx="leo.20231205084805.752">cdef list vpoints
</t>
<t tx="leo.20231205084805.753">cdef long[:] target_nodes, pivots
</t>
<t tx="leo.20231205084805.754">cdef double[:, :, :] target
</t>
<t tx="leo.20231205084805.755">cdef EStack exprs
</t>
<t tx="leo.20231205084805.756">cdef cset[int] slider
</t>
<t tx="leo.20231205084805.757">cdef map[Sym, CCoord] joint_pos
</t>
<t tx="leo.20231205084805.758">cdef map[Sym, double] param

</t>
<t tx="leo.20231205084805.759">def __cinit__(self, dict mech):
    # mech = {
    #     'expression': List[VPoint],
    #     'input': OrderedDict([((b0, d0), [start, end]), ...]),
    #     'placement': {pt: (x, y, r)},
    #     'target': {pt: [(x0, y0), (x1, y1), ...]},
    #     'same': {pt: match_to_pt},
    #     # Bounds of base link length
    #     'upper': float,
    #     'lower': float,
    #     'shape_only': bool,
    #     'use_curvature': bool,
    #     'full_path': bool,
    # }
    placement = mech.get('placement', {})
    if len(placement) == 0:
        raise ValueError("no grounded joint")
    target = mech.get('target', {})
    if len(target) == 0:
        raise ValueError("no target joint")
    check_set = {len(t) for t in target.values()}
    if len(check_set) != 1:
        raise ValueError("target paths should be in the same size")
    self.target_len = check_set.pop()
    # Change the target paths into memory view
    self.target_count = len(target)
    self.target_nodes = zeros(self.target_count, dtype=int)
    self.target = zeros((self.target_count, self.target_len, 2), dtype=f64)
    same = mech.get('same', {})
    self.shape_only = mech.get('shape_only', False)
    self.use_curvature = mech.get('use_curvature', False)
    self.full_path = mech.get('full_path', False)
    if self.use_curvature:
        self.shape_only = False
    @others
    for expr in self.exprs.stack:
        ub.append(link_upper)
        lb.append(link_lower)
        if expr.func in {PLA, PLAP} and expr.v2.first == A_LABEL:
            # The included angle of the link
            ub.append(2 * M_PI)
            lb.append(0)
        elif expr.func == PLLP:
            ub.append(link_upper)
            lb.append(link_lower)
    # The start of the angle parameters
    self.l_base = len(ub)
    if self.use_curvature and self.full_path:
        # Scale factor
        ub.append(1)
        lb.append(1e-12)
    else:
        # Input nodes
        for start, end in inputs.values():
            ub.append(start / 180 * M_PI)
            lb.append(end / 180 * M_PI)
        # Angle rage (input count * target count)
        ub[self.l_base:] *= self.target_len
        lb[self.l_base:] *= self.target_len
    self.ub = array(ub, dtype=f64)
    self.lb = array(lb, dtype=f64)
    # Swap upper and lower bound if reversed
    for i in range(len(self.ub)):
        if self.ub[i] &lt; self.lb[i]:
            self.ub[i], self.lb[i] = self.lb[i], self.ub[i]
    self.callback = 0

</t>
<t tx="leo.20231205084805.76">    cdef CCoord c = cplap(CCoord(c1.x, c1.y), d0, a0, CCoord(c2.x, c2.y), inverse)
</t>
<t tx="leo.20231205084805.760">cdef int i, j
</t>
<t tx="leo.20231205084805.761">cdef double[:, :] path
</t>
<t tx="leo.20231205084805.762">for i, j in enumerate(target):
    self.target_nodes[i] = j
    path = array(target[j], dtype=f64)
    if self.shape_only:
        _norm(path, 1)
    if self.use_curvature:
        path = _path_signature(_curvature(path), 100)
    self.target[i, :, :] = path
# Expressions (must be readonly)
self.vpoints = list(mech.get('expression', []))
self.pivots = array([i for i, vp in enumerate(self.vpoints)
                     if (&lt;VPoint&gt;vp).grounded()], dtype=int)
self.slider = {i for i, vp in enumerate(self.vpoints)
               if (&lt;VPoint&gt;vp).is_slider()}
inputs = OrderedDict(mech.get('input', {}))
self.input_count = len(inputs)
status = {}
self.exprs = t_config(self.vpoints, tuple(inputs.keys()), status)
self.bfgs_mode = not all(status.values())
if not preprocessing(self.exprs, self.vpoints, {p: 0. for p in inputs},
                     self.joint_pos, map[SwappablePair, double](),
                     self.param):
    raise ValueError("wrong number of input parameters")
# Bounds
ub = []
lb = []
</t>
<t tx="leo.20231205084805.763"># Position
cdef double x, y, r
</t>
<t tx="leo.20231205084805.764">for i in self.pivots:
    x, y, r = placement[i]
    ub.append(x + r)
    ub.append(y + r)
    lb.append(x - r)
    lb.append(y - r)
# Length of links
link_upper = float(mech.get('upper', 100))
link_lower = float(mech.get('lower', 0))
</t>
<t tx="leo.20231205084805.765">cdef Expr expr
</t>
<t tx="leo.20231205084805.766">cpdef bint is_two_kernel(self):
    """Input a generic data (variable array), return the mechanism
    expression.
    """
    return self.bfgs_mode

</t>
<t tx="leo.20231205084805.767">cdef double fitness(self, double[:] v) nogil:
    """Return the difference of the path signature.

    + Position of fix joints.
    + Link lengths.
    + Angle corresponding to the target points.
    """
    self.callback += 1
    @others
    for vi, node in enumerate(self.target_nodes):
        if self.use_curvature:
            with gil:
                path1 = zeros((self.target_len, 2), dtype=f64)
                path2 = array(self.target[vi], dtype=f64)
            for i in range(self.target_len):
                c = target[node][i]
                path1[i, 0] = c.x
                path1[i, 1] = c.y
            path1 = _slice_nan2d(path1)
            if len(path1) == 0:
                return HUGE_VAL
            path1 = _path_signature(_curvature(path1), 100)
            scale = 1 / v[len(v) - 1]
            if not self.full_path:
                scale *= _extr1d(path1[:, 0], 1) / _extr1d(path2[:, 0], 1)
            _mul1d(path2[:, 0], scale)
            with gil:
                j = argmax(_cross_correlation(path2, path1, 0.1))
            for i in range(len(path2)):
                path2[i, 0] += j
            for i in range(self.target_len):
                fitness += path1[i, 0] - path2[i, 0]
        else:
            if self.shape_only:
                with gil:
                    path1 = zeros((self.target_len, 2), dtype=f64)
                for i in range(self.target_len):
                    c = target[node][i]
                    path1[i, 0] = c.x
                    path1[i, 1] = c.y
                _norm(path1, 1)
                for i in range(self.target_len):
                    target[node][i].x = path1[i, 0]
                    target[node][i].y = path1[i, 1]
            for i in range(self.target_len):
                c = target[node][i]
                fitness += distance(c.x, c.y,
                                    self.target[vi, i, 0],
                                    self.target[vi, i, 1])
    return fitness

</t>
<t tx="leo.20231205084805.768">cdef map[int, vector[CCoord]] target
</t>
<t tx="leo.20231205084805.769">cdef map[Sym, double] param = map[Sym, double](self.param)
</t>
<t tx="leo.20231205084805.77">    return Coord.__new__(Coord, c.x, c.y)


</t>
<t tx="leo.20231205084805.770">cdef map[Sym, CCoord] joint_pos = map[Sym, CCoord](self.joint_pos)
</t>
<t tx="leo.20231205084805.771">cdef bint ok
</t>
<t tx="leo.20231205084805.772">cdef int i, j, node, vi
</t>
<t tx="leo.20231205084805.773">cdef double x, y
</t>
<t tx="leo.20231205084805.774">cdef Expr expr
</t>
<t tx="leo.20231205084805.775">cdef CCoord c
</t>
<t tx="leo.20231205084805.776">cdef pair[Sym, CCoord] jp
</t>
<t tx="leo.20231205084805.777">for i in range(self.target_len):
    vi = 0
    for node in self.pivots:
        joint_pos[Sym(P_LABEL, node)] = CCoord(v[vi], v[vi + 1])
        vi += 2
    # Input parameters (length)
    for expr in self.exprs.stack:
        param[expr.v1] = v[vi]
        vi += 1
        if expr.v2.first == I_LABEL:
            continue
        param[expr.v2] = v[vi]
        vi += 1
    # Input parameters (angles)
    for vi in range(self.input_count):
        param[Sym(I_LABEL, vi)] = v[self.l_base + vi
                                    + i * self.target_count]
    # Solve
    ok, joint_pos = quick_solve(self.exprs.stack, joint_pos, param)
    if not ok:
        return HUGE_VAL
    if self.bfgs_mode:
        with gil:
            data_dict = {}
            for jp in joint_pos:
                data_dict[jp.first.second] = Coord.__new__(Coord,
                                                           jp.second.x,
                                                           jp.second.y)
            # Solve
            try:
                solved_bfgs = SolverSystem(self.vpoints, {}, data_dict).solve()
            except ValueError:
                return HUGE_VAL
    # Collecting
    for node in self.target_nodes:
        if self.bfgs_mode:
            with gil:
                x, y = solved_bfgs[node][0]
            target[node].push_back(CCoord(x, y))
        else:
            c = joint_pos[Sym(P_LABEL, node)]
            target[node].push_back(c)
</t>
<t tx="leo.20231205084805.778"># Compare
cdef double fitness = 0
</t>
<t tx="leo.20231205084805.779">cdef double scale
</t>
<t tx="leo.20231205084805.78">def pllp(
    Coord c1,
    double d0,
    double d1,
    Coord c2,
    bint inverse = False
</t>
<t tx="leo.20231205084805.780">cdef double[:, :] path1, path2
</t>
<t tx="leo.20231205084805.781">cpdef object result(self, double[:] v):
    """Input a generic data (variable array), return the mechanism
    expression.
    """
    @others
    for node in range(len(self.vpoints)):
        vp = self.vpoints[node]
        if self.bfgs_mode:
            x, y = solved_bfgs[node][0]
            vp.locate(x, y)
            if vp.is_slider():
                vp.move(solved_bfgs[node][0], solved_bfgs[node][1])
        else:
            c = joint_pos[Sym(P_LABEL, node)]
            if vp.is_slider():
                vp.locate(vp.c[0, 0], vp.c[0, 1])
                vp.move((vp.c[0, 0], vp.c[0, 1]), (c.x, c.y))
            else:
                vp.locate(c.x, c.y)
    expr_str = "M[" + ", ".join([(&lt;VPoint&gt; vp).expr()
                                 for vp in self.vpoints]) + "]"
    logger.debug(f"Result: {expr_str}")
    return expr_str
</t>
<t tx="leo.20231205084805.782">cdef map[Sym, double] param = map[Sym, double](self.param)
</t>
<t tx="leo.20231205084805.783">cdef map[Sym, CCoord] joint_pos = map[Sym, CCoord](self.joint_pos)
</t>
<t tx="leo.20231205084805.784">cdef int vi = 0
</t>
<t tx="leo.20231205084805.785">cdef int node
</t>
<t tx="leo.20231205084805.786">for node in self.pivots:
    joint_pos[Sym(P_LABEL, node)] = CCoord(v[vi], v[vi + 1])
    vi += 2
</t>
<t tx="leo.20231205084805.787">cdef Expr expr
</t>
<t tx="leo.20231205084805.788">for expr in self.exprs.stack:
    param[expr.v1] = v[vi]
    vi += 1
    if expr.v2.first == I_LABEL:
        continue
    param[expr.v2] = v[vi]
    vi += 1
# Input parameters (angles)
for vi in range(self.input_count):
    param[Sym(I_LABEL, vi)] = v[self.l_base + vi]
# Solve
_, joint_pos = quick_solve(self.exprs.stack, joint_pos, param)
</t>
<t tx="leo.20231205084805.789">cdef pair[Sym, CCoord] jp
</t>
<t tx="leo.20231205084805.79">):
    """The PLLP function requires two points and two distances, obtained the
    position of third point.

    In the following picture, `c1` correspond to "A", `c2` correspond to "B",
    `d0` correspond to "L0", `d1` correspond to "L1", `return` correspond to
    "C".

    ![pllp](img/pllp.png)

    Set `inverse` option to `True` can make the result upside down.
    """
</t>
<t tx="leo.20231205084805.790">if self.bfgs_mode:
    data_dict = {}
    for jp in joint_pos:
        data_dict[jp.first.second] = Coord.__new__(Coord,
                                                   jp.second.x,
                                                   jp.second.y)
    # Solve
    solved_bfgs = SolverSystem(self.vpoints, {}, data_dict).solve()
</t>
<t tx="leo.20231205084805.791"># Collecting
cdef CCoord c
</t>
<t tx="leo.20231205084805.792">cdef VPoint vp
</t>
<t tx="leo.20231205084805.793">cdef double x, y
</t>
<t tx="leo.20231205084805.794">@path Y:/tmp/metapyslvs/pyslvs/pyslvs/optimization/
# -*- coding: utf-8 -*-
# cython: language_level=3, cdivision=True, boundscheck=False, wraparound=False
# cython: initializedcheck=False, nonecheck=False

"""Normalized planar four-bar linkage synthesis.

author: Yuan Chang
copyright: Copyright (C) 2016-2022
license: AGPL
email: pyslvs@gmail.com
"""

cimport cython
from libc.math cimport (
    M_PI, INFINITY as INF, HUGE_VAL, isnan, hypot, atan2, cos, sin, sqrt,
)
from numpy import array, float64 as f64, hstack
from numpy.linalg import eig
from numpy.fft import fft
from pyslvs.expression cimport VPoint
from pyslvs.tinycadlib cimport c_uniform_path, uniform_expr
from pyslvs.metaheuristics.utility cimport ObjFunc
from .f_planar cimport roll


cdef (double, double) axes_v(double[:] v1, double[:] v2, double[:, :] p1,
                             double x_mean, double y_mean) nogil:
    """Calculate the orientation vector of the axes."""
@others
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084805.795">    cdef double a = v1[1] / v1[0]
</t>
<t tx="leo.20231205084805.796">    cdef double b = y_mean - a * x_mean
</t>
<t tx="leo.20231205084805.797">    cdef double neg_x = 0
</t>
<t tx="leo.20231205084805.798">    cdef double neg_y = 0
</t>
<t tx="leo.20231205084805.799">    cdef double pos_x = 0
</t>
<t tx="leo.20231205084805.8">def __cinit__(self, double x, double y):
    self.x = x
    self.y = y

</t>
<t tx="leo.20231205084805.80">    cdef CCoord c = cpllp(CCoord(c1.x, c1.y), d0, d1, CCoord(c2.x, c2.y), inverse)
</t>
<t tx="leo.20231205084805.800">    cdef double pos_y = 0
</t>
<t tx="leo.20231205084805.801">    cdef int i
</t>
<t tx="leo.20231205084805.802">    cdef double val, x, y
</t>
<t tx="leo.20231205084805.803">    for i in range(len(p1)):
        val = p1[i, 1] - a * p1[i, 0] - b
        x = p1[i, 0] - x_mean
        y = p1[i, 1] - y_mean
        if val &lt; 0:
            neg_x += x * x
            neg_y += y * y
        elif val &gt; 0:
            pos_x += x * x
            pos_y += y * y
</t>
<t tx="leo.20231205084805.804">    cdef double neg_dist = sqrt(neg_x) + sqrt(neg_y)
</t>
<t tx="leo.20231205084805.805">    cdef double pos_dist = sqrt(pos_x) + sqrt(pos_y)
</t>
<t tx="leo.20231205084805.806">    x = abs(v2[0])
    y = abs(v2[1])
    if a &lt; 0:
        if neg_dist &gt; pos_dist:
            return -x, -y
        else:
            return x, y
    else:
        if neg_dist &gt; pos_dist:
            return x, -y
        else:
            return -x, y


</t>
<t tx="leo.20231205084805.807">cdef double rotation_angle(double[:, :] p1, double x_mean, double y_mean) nogil:
    """Calculate rotation angle."""
    @others
    # Calculate the rotation matrix
    if a1 * a2 &gt; 0:
        return min(a1, a2)
    elif a1 * a2 &lt; 0:
        if abs(a1) &lt; M_PI / 2:
            return min(a1, a2)
        else:
            return max(a1, a2)
    else:
        return -M_PI / 2 if -M_PI / 2 in {a1, a2} else 0


</t>
<t tx="leo.20231205084805.808"># Calculate the principal component axes (eigenvectors)
cdef double cxx = 0
</t>
<t tx="leo.20231205084805.809">cdef double cyy = 0
</t>
<t tx="leo.20231205084805.81">    return Coord.__new__(Coord, c.x, c.y)


</t>
<t tx="leo.20231205084805.810">cdef double cxy = 0
</t>
<t tx="leo.20231205084805.811">cdef int i
</t>
<t tx="leo.20231205084805.812">cdef double x, y
</t>
<t tx="leo.20231205084805.813">for i in range(len(p1)):
    x = p1[i, 0] - x_mean
    y = p1[i, 1] - y_mean
    cxx += x * x
    cyy += y * y
    cxy += x * y
cxx /= len(p1)
cyy /= len(p1)
cxy /= len(p1)
</t>
<t tx="leo.20231205084805.814">cdef double[:, :] v
</t>
<t tx="leo.20231205084805.815">with gil:
    _, v = eig(array([[cxx, cxy], [cxy, cyy]], dtype=f64))
# Calculate the orientation of the axes
x, y = axes_v(v[:, 1], v[:, 0], p1, x_mean, y_mean)
</t>
<t tx="leo.20231205084805.816">cdef double a1 = atan2(y, x)
</t>
<t tx="leo.20231205084805.817">x, y = axes_v(v[:, 0], v[:, 1], p1, x_mean, y_mean)
</t>
<t tx="leo.20231205084805.818">cdef double a2 = atan2(y, x)
</t>
<t tx="leo.20231205084805.819">cdef double[:, :] rotate(double[:, :] p1, double a) nogil:
    cdef double c = cos(a)
    cdef double s = sin(a)
    with gil:
        return array(p1) @ array([[c, -s], [s, c]], dtype=f64)


</t>
<t tx="leo.20231205084805.82">def plpp(
    Coord c1,
    double d0,
    Coord c2,
    Coord c3,
    bint inverse = False
</t>
<t tx="leo.20231205084805.820">def norm_pca(path):
    """Normalization function by PCA."""
    cdef double[:, :] path_m = array(path, dtype=f64)
    _norm_pca(path_m)
    return array(path_m)


</t>
<t tx="leo.20231205084805.821">cdef void _norm_pca(double[:, :] p1) nogil:
    """Normalization implementation."""
    @others
    for i in range(len(p1)):
        d = hypot(p1[i, 0], p1[i, 1])
        if d &lt; d_min:
            d_min = d
        if p1[i, 0] &gt; p1_max:
            p1_max = p1[i, 0]
            if p1[i, 1] &gt; 0:
                ind = i
        if p1[i, 0] &lt; p1_min:
            p1_min = p1[i, 0]
    d_min = p1_max - p1_min
    for i in range(len(p1)):
        p1[i, 0] /= d_min
        p1[i, 1] /= d_min
    # Swap to the starting point of the path
    roll(p1, ind)


</t>
<t tx="leo.20231205084805.822">cdef double x_mean = 0
</t>
<t tx="leo.20231205084805.823">cdef double y_mean = 0
</t>
<t tx="leo.20231205084805.824">cdef int i
</t>
<t tx="leo.20231205084805.825">for i in range(len(p1)):
    x_mean += p1[i, 0]
    y_mean += p1[i, 1]
x_mean /= len(p1)
y_mean /= len(p1)
</t>
<t tx="leo.20231205084805.826">cdef double alpha = rotation_angle(p1, x_mean, y_mean)
</t>
<t tx="leo.20231205084805.827"># Normalized the path points
for i in range(len(p1)):
    p1[i, 0] -= x_mean
    p1[i, 1] -= y_mean
p1[:] = rotate(p1, alpha)
</t>
<t tx="leo.20231205084805.828">cdef int ind = 0
</t>
<t tx="leo.20231205084805.829">cdef double p1_max = -INF
</t>
<t tx="leo.20231205084805.83">):
    """The PLPP function requires three points and one distance, obtained the
    position of fourth point.

    In the following picture, `c1` correspond to "A", `c2` correspond to "B",
    `c3` correspond to "C", `d0` correspond to "L0", `return` correspond to "D".

    ![plpp](img/plpp.png)

    Set `inverse` option to `True` can make the result to the another side
    between `c1` and line `c2` `c3`.
    """
</t>
<t tx="leo.20231205084805.830">cdef double p1_min = INF
</t>
<t tx="leo.20231205084805.831">cdef double d_min = INF
</t>
<t tx="leo.20231205084805.832">cdef double d
</t>
<t tx="leo.20231205084805.833">cdef void transform(double[:, :] target) nogil:
    """Apply normalization and FFT to target."""
    _norm_pca(target)
    @others
    with gil:
        c = array(target, dtype=f64)
        c = c[:, 0] + c[:, 1] * 1j
        v = fft(hstack([c, c, c]))[len(target):len(target) * 2]
        real = v.real
        imag = v.imag
    target[:, 0] = real
    target[:, 1] = imag


</t>
<t tx="leo.20231205084805.834">cdef double[:] real, imag
</t>
<t tx="leo.20231205084805.835">cdef double trapezoidal_camp(double[:] a, double[:] b) nogil:
    """Error comparison by trapezoidal rule."""
    @others
    for i in range(1, len(a)):
        right = a[i] - b[i]
        left = a[i - 1] - b[i - 1]
        total = abs(right) + abs(left)
        if right * left &lt; 0:
            area += (right * right + left * left) / total * 0.5
        else:
            area += total * 0.5
    return area


</t>
<t tx="leo.20231205084805.836">cdef double area = 0
</t>
<t tx="leo.20231205084805.837">cdef int i
</t>
<t tx="leo.20231205084805.838">cdef double right, left, total
</t>
<t tx="leo.20231205084805.839">@cython.final
cdef class NPlanar(ObjFunc):
    """A normalized matching method.

    Defects free. Normalized parameters are $[L_0, L_2, L_3, L_4, \\alpha]$.

    ![pxy](img/uniform_four_bar.png)
    """
    @others
</t>
<t tx="leo.20231205084805.84">    cdef CCoord c = cplpp(CCoord(c1.x, c1.y), d0, CCoord(c2.x, c2.y),
                          CCoord(c3.x, c3.y), inverse)
</t>
<t tx="leo.20231205084805.840">cdef int len
</t>
<t tx="leo.20231205084805.841">cdef double[:, :] target

</t>
<t tx="leo.20231205084805.842">def __cinit__(self, dict mech):
    self.target = array(mech['target'], dtype=f64)
    transform(self.target)
    self.len = len(self.target)
    self.lb = array([1e-5] * 4 + [0.], dtype=f64)
    self.ub = array([5.] * 4 + [2. * M_PI], dtype=f64)

</t>
<t tx="leo.20231205084805.843">cdef double fitness(self, double[:] v) nogil:
    """Generate linkage with 5 parameters."""
    @others
    for i in range(len(p)):
        if isnan(p[i, 0]) or isnan(p[i, 1]):
            return HUGE_VAL
    transform(p)
    return (trapezoidal_camp(self.target[:, 0], p[:, 0]) +
            trapezoidal_camp(self.target[:, 1], p[:, 1]))

</t>
<t tx="leo.20231205084805.844">cdef double[:, :] p = c_uniform_path(v[None, :], self.len)[0]
</t>
<t tx="leo.20231205084805.845"># NAN check
cdef int i
</t>
<t tx="leo.20231205084805.846">cpdef object path(self, double[:] v):
    return array(c_uniform_path(v[None, :], self.len)[0])

</t>
<t tx="leo.20231205084805.847">cpdef object result(self, double[:] v):
    return "M[" + ", ".join([(&lt;VPoint&gt; vp).expr()
                             for vp in uniform_expr(v)]) + "]"
</t>
<t tx="leo.20231205084805.85">    return Coord.__new__(Coord, c.x, c.y)


</t>
<t tx="leo.20231205084805.850"></t>
<t tx="leo.20231205084805.86">def palp(
    Coord c1,
    double a0,
    double d0,
    Coord c2,
    bint inverse = False
</t>
<t tx="leo.20231205084805.87">):
    """The PALP function requires two points, one angle and one distance,
    obtained the position of fourth point.

    In the following picture, `c1` correspond to "A", `c2` correspond to "B",
    `d0` correspond to "L0", `a0` correspond to "alpha", `return` correspond
    to "C".

    ![palp](img/palp.png)

    Set `inverse` option to `True` can make the result upside down.
    """
</t>
<t tx="leo.20231205084805.88">    cdef CCoord c = cpalp(CCoord(c1.x, c1.y), a0, d0, CCoord(c2.x, c2.y), inverse)
</t>
<t tx="leo.20231205084805.89">    return Coord.__new__(Coord, c.x, c.y)


</t>
<t tx="leo.20231205084805.9">cpdef double distance(self, Coord p):
    """Return the distance between two coordinates."""
    return distance(self.x, self.y, p.x, p.y)

</t>
<t tx="leo.20231205084805.90">cpdef int vpoint_dof(object vpoints):
    """Return the DOF of the mechanism expression `vpoints`."""
    @others
    for vp in vpoints:
        link_count = len(vp.links)
        if link_count &lt; 2:
            # If a point doesn't have two more links, it can not be call a 'joint'.
            continue
        vlinks.update(vp.links)
        if vp.type in {VJoint.R, VJoint.P}:
            j1 += link_count - 1
        elif vp.type == VJoint.RP:
            j1 += link_count - 2
            j2 += 1
    return 3 * (len(vlinks) - 1) - 2 * j1 - j2


</t>
<t tx="leo.20231205084805.91"># Joint with DOF 1
cdef int j1 = 0
</t>
<t tx="leo.20231205084805.92"># Joint with DOF 2
cdef int j2 = 0
</t>
<t tx="leo.20231205084805.93"># First link is frame
vlinks = {VLink.FRAME}
</t>
<t tx="leo.20231205084805.94">cdef int link_count
</t>
<t tx="leo.20231205084805.95">cdef VPoint vp
</t>
<t tx="leo.20231205084805.96">cdef inline int base_friend(int node, object vpoints):
    @others
    for i, vpoint in enumerate(vpoints):
        if not vpoints[node].links:
            continue
        if vpoints[node].links[0] in vpoint.links:
            return i


</t>
<t tx="leo.20231205084805.97">cdef int i
</t>
<t tx="leo.20231205084805.98">cdef VPoint vpoint
</t>
<t tx="leo.20231205084805.99">cdef bint preprocessing(EStack exprs, object vpoints, object inputs,
                        map[Sym, CCoord] &amp;joint_pos,
                        map[SwappablePair, double] &amp;link_len,
                        map[Sym, double] &amp;param):
    """Data extraction. Return true if input angle is matched DOF.

    Use "exprs", "vpoints", "angles" and "link_len" to generate solver
    required data. Please pre-allocate the "joint_pos" and "param".

    C++ objects
    + "exprs.stack" used for the position solution.
    + "joint_pos" used for joint position.
    + "link_len" used for custom link length except from calculation.
      (The link pairs must be exist in the solution.)
    + "param" used for store angles and link length.
    """
</t>
<t tx="leo.20231205084806.1"></t>
<t tx="leo.20231205084806.10">cdef double x, y, z
</t>
<t tx="leo.20231205084806.100">cpdef void add_constraint(
    self,
    int c_type,
    Entity wp,
    double v,
    Entity p1,
    Entity p2,
    Entity e1,
    Entity e2,
    Entity e3 = _E_NONE,
    Entity e4 = _E_NONE,
    int other = 0,
    int other2 = 0
</t>
<t tx="leo.20231205084806.101">):
    """Add a constraint by type code `c_type`.
    This is an origin function mapping to different constraint methods.

    Where `wp` represents work plane; `v` represents constraint value;
    `p1` and `p2` represent point entities; `e1` to `e4` represent other
    types of entity;
    `other` and `other2` are control options of the constraint.
    """
    if wp is None or not wp.is_work_plane():
        raise TypeError(f"{wp} is not a work plane")

</t>
<t tx="leo.20231205084806.102">    cdef Entity e
</t>
<t tx="leo.20231205084806.103">    for e in (p1, p2):
        if e is None or not (e.is_none() or e.is_point()):
            raise TypeError(f"{e} is not a point")
    for e in (e1, e2, e3, e4):
        if e is None:
            raise TypeError(f"{e} is not a entity")

</t>
<t tx="leo.20231205084806.104">    cdef Slvs_Constraint c
</t>
<t tx="leo.20231205084806.105">    c.h = &lt;Slvs_hConstraint&gt;self.cons_list.size() + 1
    c.group = self.g
    c.type = c_type
    c.wrkpl = wp.h
    c.valA = v
    c.ptA = p1.h
    c.ptB = p2.h
    c.entityA = e1.h
    c.entityB = e2.h
    c.entityC = e3.h
    c.entityD = e4.h
    c.other = other
    c.other2 = other2
    self.cons_list.push_back(c)

</t>
<t tx="leo.20231205084806.106">#####
# Constraint methods.
#####

cpdef void coincident(self, Entity e1, Entity e2, Entity wp = _E_FREE_IN_3D):
    """Coincident two entities.

    | Entity 1 (`e1`) | Entity 2 (`e2`) | Work plane (`wp`) |
    |:---------------:|:---------------:|:-----------------:|
    | [is_point] | [is_point] | Optional |
    | [is_point] | [is_work_plane] | [Entity.FREE_IN_3D] |
    | [is_point] | [is_line] | Optional |
    | [is_point] | [is_circle] | Optional |
    """
    if e1.is_point() and e2.is_point():
        self.add_constraint(SLVS_C_POINTS_COINCIDENT, wp, 0., e1, e2, _E_NONE, _E_NONE)
    elif e1.is_point() and e2.is_work_plane():
        self.add_constraint(SLVS_C_PT_IN_PLANE, _E_FREE_IN_3D, 0., e1, _E_NONE, e2, _E_NONE)
    elif e1.is_point() and e2.is_line():
        self.add_constraint(SLVS_C_PT_ON_LINE, wp, 0., e1, _E_NONE, e2, _E_NONE)
    elif e1.is_point() and e2.is_circle():
        self.add_constraint(SLVS_C_PT_ON_CIRCLE, _E_FREE_IN_3D, 0., e1, _E_NONE, e2, _E_NONE)
    else:
        raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

</t>
<t tx="leo.20231205084806.107">cpdef void distance(
    self,
    Entity e1,
    Entity e2,
    double value,
    Entity wp = _E_FREE_IN_3D
</t>
<t tx="leo.20231205084806.108">):
    """Distance constraint between two entities.

    If `value` is equal to zero, then turn into
    [coincident](#solversystemcoincident)

    | Entity 1 (`e1`) | Entity 2 (`e2`) | Work plane (`wp`) |
    |:---------------:|:---------------:|:-----------------:|
    | [is_point] | [is_point] | Optional |
    | [is_point] | [is_work_plane] | [Entity.FREE_IN_3D] |
    | [is_point] | [is_line] | Optional |
    """
    if value == 0.:
        self.coincident(e1, e2, wp)
        return
    if e1.is_point() and e2.is_point():
        self.add_constraint(SLVS_C_PT_PT_DISTANCE, wp, value, e1, e2, _E_NONE, _E_NONE)
    elif e1.is_point() and e2.is_work_plane() and wp is _E_FREE_IN_3D:
        self.add_constraint(SLVS_C_PT_PLANE_DISTANCE, e2, value, e1, _E_NONE, e2, _E_NONE)
    elif e1.is_point() and e2.is_line():
        self.add_constraint(SLVS_C_PT_LINE_DISTANCE, wp, value, e1, _E_NONE, e2, _E_NONE)
    else:
        raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

</t>
<t tx="leo.20231205084806.109">cpdef void equal(self, Entity e1, Entity e2, Entity wp = _E_FREE_IN_3D):
    """Equal constraint between two entities.

   | Entity 1 (`e1`) | Entity 2 (`e2`) | Work plane (`wp`) |
   |:---------------:|:---------------:|:-----------------:|
   | [is_line] | [is_line] | Optional |
   | [is_line] | [is_arc] | Optional |
   | [is_line] | [is_circle] | Optional |
   | [is_arc] | [is_arc] | Optional |
   | [is_arc] | [is_circle] | Optional |
   | [is_circle] | [is_circle] | Optional |
   | [is_circle] | [is_arc] | Optional |
   """
    if e1.is_line() and e2.is_line():
        self.add_constraint(SLVS_C_EQUAL_LENGTH_LINES, wp, 0., _E_NONE,
                            _E_NONE, e1, e2)
    elif e1.is_line() and (e2.is_arc() or e2.is_circle()):
        self.add_constraint(SLVS_C_EQUAL_LINE_ARC_LEN, wp, 0., _E_NONE,
                            _E_NONE, e1, e2)
    elif (e1.is_arc() or e1.is_circle()) and (e2.is_arc() or e2.is_circle()):
        self.add_constraint(SLVS_C_EQUAL_RADIUS, wp, 0., _E_NONE, _E_NONE, e1, e2)
    else:
        raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

</t>
<t tx="leo.20231205084806.11">cpdef tuple quaternion_n(double qw, double qx, double qy, double qz):
    """Input quaternion, return unit vector of normal.

    Signature is same as [quaternion_u](#quaternion_u).
    """
    @others
    Slvs_QuaternionN(qw, qx, qy, qz, &amp;x, &amp;y, &amp;z)
    return x, y, z


</t>
<t tx="leo.20231205084806.110">cpdef void equal_angle(
    self,
    Entity e1,
    Entity e2,
    Entity e3,
    Entity e4,
    Entity wp = _E_FREE_IN_3D
</t>
<t tx="leo.20231205084806.111">):
    """Constraint that 2D line 1 (`e1`) and line 2 (`e2`),
    line 3 (`e3`) and line 4 (`e4`) must have same included angle on work
    plane `wp`.
    """
    if e1.is_line_2d() and e2.is_line_2d() and e3.is_line_2d() and e4.is_line_2d():
        self.add_constraint(SLVS_C_EQUAL_ANGLE, wp, 0., _E_NONE, _E_NONE,
                            e1, e2, e3, e4)
    else:
        raise TypeError(f"unsupported entities: {e1}, {e2}, {e3}, {e4}, {wp}")

</t>
<t tx="leo.20231205084806.112">cpdef void equal_point_to_line(
    self,
    Entity e1,
    Entity e2,
    Entity e3,
    Entity e4,
    Entity wp = _E_FREE_IN_3D
</t>
<t tx="leo.20231205084806.113">):
    """Constraint that point 1 (`e1`) and line 1 (`e2`),
    point 2 (`e3`) and line 2  (`e4`) must have same distance on work plane `wp`.
    """
    if e1.is_point_2d() and e2.is_line_2d() and e3.is_point_2d() and e4.is_line_2d():
        self.add_constraint(SLVS_C_EQ_PT_LN_DISTANCES, wp, 0., e1, e3, e2, e4)
    else:
        raise TypeError(f"unsupported entities: {e1}, {e2}, {e3}, {e4}, {wp}")

</t>
<t tx="leo.20231205084806.114">cpdef void ratio(self, Entity e1, Entity e2, double value, Entity wp = _E_FREE_IN_3D):
    """The ratio (`value`) constraint between two 2D lines (`e1` and `e2`)."""
    if e1.is_line_2d() and e2.is_line_2d():
        self.add_constraint(SLVS_C_LENGTH_RATIO, wp, value, _E_NONE, _E_NONE, e1, e2)
    else:
        raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

</t>
<t tx="leo.20231205084806.115">cpdef void symmetric(
    self,
    Entity e1,
    Entity e2,
    Entity e3 = _E_NONE,
    Entity wp = _E_FREE_IN_3D
</t>
<t tx="leo.20231205084806.116">):
    """Symmetric constraint between two points.

    | Entity 1 (`e1`) | Entity 2 (`e2`) | Entity 3 (`e3`) | Work plane (`wp`) |
    |:---------------:|:---------------:|:---------------:|:-----------------:|
    | [is_point_3d] | [is_point_3d] | [is_work_plane] | [Entity.FREE_IN_3D] |
    | [is_point_2d] | [is_point_2d] | [is_work_plane] | [Entity.FREE_IN_3D] |
    | [is_point_2d] | [is_point_2d] | [is_line_2d] | not [Entity.FREE_IN_3D] |
    """
    if e1.is_point_3d() and e2.is_point_3d() and e3.is_work_plane() and wp is _E_FREE_IN_3D:
        self.add_constraint(SLVS_C_SYMMETRIC, wp, 0., e1, e2, e3, _E_NONE)
    elif e1.is_point_2d() and e2.is_point_2d() and e3.is_work_plane() and wp is _E_FREE_IN_3D:
        self.add_constraint(SLVS_C_SYMMETRIC, e3, 0., e1, e2, e3, _E_NONE)
    elif e1.is_point_2d() and e2.is_point_2d() and e3.is_line_2d():
        if wp is _E_FREE_IN_3D:
            raise ValueError("this is a 2d constraint")
        self.add_constraint(SLVS_C_SYMMETRIC_LINE, wp, 0., e1, e2, e3, _E_NONE)
    else:
        raise TypeError(f"unsupported entities: {e1}, {e2}, {e3}, {wp}")

</t>
<t tx="leo.20231205084806.117">cpdef void symmetric_h(self, Entity e1, Entity e2, Entity wp):
    """Symmetric constraint between two 2D points (`e1` and `e2`)
    with horizontal line on the work plane (`wp` can not be [Entity.FREE_IN_3D]).
    """
    if wp is _E_FREE_IN_3D:
        raise ValueError("this is a 2d constraint")
    if e1.is_point_2d() and e2.is_point_2d():
        self.add_constraint(SLVS_C_SYMMETRIC_HORIZ, wp, 0., e1, e2, _E_NONE, _E_NONE)
    else:
        raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

</t>
<t tx="leo.20231205084806.118">cpdef void symmetric_v(self, Entity e1, Entity e2, Entity wp):
    """Symmetric constraint between two 2D points (`e1` and `e2`)
    with vertical line on the work plane (`wp` can not be [Entity.FREE_IN_3D]).
    """
    if wp is _E_FREE_IN_3D:
        raise ValueError("this is a 2d constraint")
    if e1.is_point_2d() and e2.is_point_2d():
        self.add_constraint(SLVS_C_SYMMETRIC_VERT, wp, 0., e1, e2, _E_NONE, _E_NONE)
    else:
        raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

</t>
<t tx="leo.20231205084806.119">cpdef void midpoint(
    self,
    Entity e1,
    Entity e2,
    Entity wp = _E_FREE_IN_3D
</t>
<t tx="leo.20231205084806.12">cdef double x, y, z
</t>
<t tx="leo.20231205084806.120">):
    """Midpoint constraint between a point (`e1`) and
    a line (`e2`) on work plane (`wp`).
    """
    if e1.is_point() and e2.is_line():
        self.add_constraint(SLVS_C_AT_MIDPOINT, wp, 0., e1, _E_NONE, e2, _E_NONE)
    else:
        raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

</t>
<t tx="leo.20231205084806.121">cpdef void horizontal(self, Entity e1, Entity wp):
    """Vertical constraint of a 2d point (`e1`) on
    work plane (`wp` can not be [Entity.FREE_IN_3D]).
    """
    if wp is _E_FREE_IN_3D:
        raise ValueError("this is a 2d constraint")
    if e1.is_line_2d():
        self.add_constraint(SLVS_C_HORIZONTAL, wp, 0., _E_NONE, _E_NONE, e1, _E_NONE)
    else:
        raise TypeError(f"unsupported entities: {e1}, {wp}")

</t>
<t tx="leo.20231205084806.122">cpdef void vertical(self, Entity e1, Entity wp):
    """Vertical constraint of a 2d point (`e1`) on
    work plane (`wp` can not be [Entity.FREE_IN_3D]).
    """
    if wp is _E_FREE_IN_3D:
        raise ValueError("this is a 2d constraint")
    if e1.is_line_2d():
        self.add_constraint(SLVS_C_VERTICAL, wp, 0., _E_NONE, _E_NONE, e1, _E_NONE)
    else:
        raise TypeError(f"unsupported entities: {e1}, {wp}")

</t>
<t tx="leo.20231205084806.123">cpdef void diameter(self, Entity e1, double value):
    """Diameter (`value`) constraint of a circular entities.

    | Entity 1 (`e1`) | Work plane (`wp`) |
    |:---------------:|:-----------------:|
    | [is_arc] | Optional |
    | [is_circle] | Optional |
    """
    if e1.is_arc() or e1.is_circle():
        self.add_constraint(SLVS_C_DIAMETER, _E_FREE_IN_3D, value, _E_NONE, _E_NONE,
                            e1, _E_NONE)
    else:
        raise TypeError(f"unsupported entities: {e1}")

</t>
<t tx="leo.20231205084806.124">cpdef void same_orientation(self, Entity e1, Entity e2):
    """Equal orientation constraint between two 3d normals (`e1` and `e2`)."""
    if e1.is_normal_3d() and e2.is_normal_3d():
        self.add_constraint(SLVS_C_SAME_ORIENTATION, _E_FREE_IN_3D, 0.,
                            _E_NONE, _E_NONE, e1, e2)
    else:
        raise TypeError(f"unsupported entities: {e1}, {e2}")

</t>
<t tx="leo.20231205084806.125">cpdef void angle(self, Entity e1, Entity e2, double value, Entity wp = _E_FREE_IN_3D, bint inverse = False):
    """Degrees angle (`value`) constraint between two 2d lines (`e1` and
    `e2`) on the work plane (`wp` can not be [Entity.FREE_IN_3D]).
    """
    if e1.is_line_2d() and e2.is_line_2d():
        self.add_constraint(SLVS_C_ANGLE, wp, value, _E_NONE, _E_NONE,
                            e1, e2, _E_NONE, _E_NONE, inverse)
    else:
        raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

</t>
<t tx="leo.20231205084806.126">cpdef void perpendicular(self, Entity e1, Entity e2, Entity wp = _E_FREE_IN_3D, bint inverse = False):
    """Perpendicular constraint between two 2d lines (`e1` and `e2`)
    on the work plane (`wp`) with `inverse` option.
    """
    if e1.is_line_2d() and e2.is_line_2d():
        self.add_constraint(SLVS_C_PERPENDICULAR, wp, 0., _E_NONE, _E_NONE,
                            e1, e2, _E_NONE, _E_NONE, inverse)
    else:
        raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

</t>
<t tx="leo.20231205084806.127">cpdef void parallel(self, Entity e1, Entity e2, Entity wp = _E_FREE_IN_3D):
    """Parallel constraint between two lines (`e1` and `e2`) on
    the work plane (`wp`).
    """
    if e1.is_line() and e2.is_line():
        self.add_constraint(SLVS_C_PARALLEL, wp, 0., _E_NONE, _E_NONE, e1, e2)
    else:
        raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

</t>
<t tx="leo.20231205084806.128">cpdef void tangent(self, Entity e1, Entity e2, Entity wp = _E_FREE_IN_3D):
    """Parallel constraint between two entities (`e1` and `e2`) on the
    work plane (`wp`).

    | Entity 1 (`e1`) | Entity 2 (`e2`) | Work plane (`wp`) |
    |:---------------:|:---------------:|:-----------------:|
    | [is_arc] | [is_line_2d] | not [Entity.FREE_IN_3D] |
    | [is_cubic] | [is_line_3d] | [Entity.FREE_IN_3D] |
    | [is_arc]/[is_cubic] | [is_arc]/[is_cubic] | not [Entity.FREE_IN_3D] |
    """
    if e1.is_arc() and e2.is_line_2d():
        if wp is _E_FREE_IN_3D:
            raise ValueError("this is a 2d constraint")
        self.add_constraint(SLVS_C_ARC_LINE_TANGENT, wp, 0., _E_NONE, _E_NONE, e1, e2)
    elif e1.is_cubic() and e2.is_line_3d() and wp is _E_FREE_IN_3D:
        self.add_constraint(SLVS_C_CUBIC_LINE_TANGENT, wp, 0., _E_NONE, _E_NONE, e1, e2)
    elif (e1.is_arc() or e1.is_cubic()) and (e2.is_arc() or e2.is_cubic()):
        if wp is _E_FREE_IN_3D:
            raise ValueError("this is a 2d constraint")
        self.add_constraint(SLVS_C_CURVE_CURVE_TANGENT, wp, 0., _E_NONE, _E_NONE, e1, e2)
    else:
        raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

</t>
<t tx="leo.20231205084806.129">cpdef void distance_proj(self, Entity e1, Entity e2, double value):
    """Projected distance (`value`) constraint between
    two 2D/3D points (`e1` and `e2`).
    """
    if e1.is_point() and e2.is_point():
        self.add_constraint(SLVS_C_PROJ_PT_DISTANCE, _E_FREE_IN_3D,
                            value, e1, e2, _E_NONE, _E_NONE)
    else:
        raise TypeError(f"unsupported entities: {e1}, {e2}")

</t>
<t tx="leo.20231205084806.13">cpdef tuple make_quaternion(double ux, double uy, double uz, double vx, double vy, double vz):
    """Input two unit vector, return quaternion.

    Where `ux`, `uy`, `uz` are corresponded to the value of U vector;
    `vx`, `vy`, `vz` are corresponded to the value of V vector.
    """
    @others
    Slvs_MakeQuaternion(ux, uy, uz, vx, vy, vz, &amp;qw, &amp;qx, &amp;qy, &amp;qz)
    return qw, qx, qy, qz


</t>
<t tx="leo.20231205084806.130">cpdef void dragged(self, Entity e1, Entity wp = _E_FREE_IN_3D):
    """Dragged constraint of a point (`e1`) on the work plane (`wp`)."""
    if e1.is_point():
        self.add_constraint(SLVS_C_WHERE_DRAGGED, wp, 0., e1, _E_NONE, _E_NONE, _E_NONE)
    else:
        raise TypeError(f"unsupported entities: {e1}, {wp}")

</t>
<t tx="leo.20231205084806.131">cpdef void length_diff(self, Entity e1, Entity e2, double value, Entity wp = _E_FREE_IN_3D):
    """The length difference between two lines (`e1` and `e2`)."""
    if e1.is_line() and e2.is_line():
        self.add_constraint(SLVS_C_LENGTH_DIFFERENCE, wp, value, _E_NONE, _E_NONE, e1, e2)
    else:
        raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")
</t>
<t tx="leo.20231205084806.14">cdef double qw, qx, qy, qz
</t>
<t tx="leo.20231205084806.15">class Constraint(IntEnum):
    """Symbol of the constraint types."""
    # Expose macro of constraint types
    POINTS_COINCIDENT = 100000
    PT_PT_DISTANCE = auto()
    PT_PLANE_DISTANCE = auto()
    PT_LINE_DISTANCE = auto()
    PT_FACE_DISTANCE = auto()
    PT_IN_PLANE = auto()
    PT_ON_LINE = auto()
    PT_ON_FACE = auto()
    EQUAL_LENGTH_LINES = auto()
    LENGTH_RATIO = auto()
    EQ_LEN_PT_LINE_D = auto()
    EQ_PT_LN_DISTANCES = auto()
    EQUAL_ANGLE = auto()
    EQUAL_LINE_ARC_LEN = auto()
    SYMMETRIC = auto()
    SYMMETRIC_HORIZ = auto()
    SYMMETRIC_VERT = auto()
    SYMMETRIC_LINE = auto()
    AT_MIDPOINT = auto()
    HORIZONTAL = auto()
    VERTICAL = auto()
    DIAMETER = auto()
    PT_ON_CIRCLE = auto()
    SAME_ORIENTATION = auto()
    ANGLE = auto()
    PARALLEL = auto()
    PERPENDICULAR = auto()
    ARC_LINE_TANGENT = auto()
    CUBIC_LINE_TANGENT = auto()
    EQUAL_RADIUS = auto()
    PROJ_PT_DISTANCE = auto()
    WHERE_DRAGGED = auto()
    CURVE_CURVE_TANGENT = auto()
    LENGTH_DIFFERENCE = auto()


</t>
<t tx="leo.20231205084806.16">class ResultFlag(IntEnum):
    """Symbol of the result flags."""
    # Expose macro of result flags
    OKAY = 0
    INCONSISTENT = auto()
    DIDNT_CONVERGE = auto()
    TOO_MANY_UNKNOWNS = auto()


</t>
<t tx="leo.20231205084806.17">cdef class Params:

    """Python object to handle multiple parameter handles."""

    @others
</t>
<t tx="leo.20231205084806.18">@staticmethod
cdef Params create(Slvs_hParam *p, size_t count):
    """Constructor."""
    cdef Params params = Params.__new__(Params)
    cdef size_t i
    for i in range(count):
        params.param_list.push_back(p[i])
    return params

</t>
<t tx="leo.20231205084806.19">def __richcmp__(self, Params other, int op) -&gt; bint:
    """Compare the parameters."""
    if op == Py_EQ:
        return self.param_list == other.param_list
    elif op == Py_NE:
        return self.param_list != other.param_list
    else:
        raise TypeError(
            f"'{op}' not support between instances of "
            f"{type(self)} and {type(other)}"
        )

</t>
<t tx="leo.20231205084806.20">def __repr__(self) -&gt; str:
    m = f"{type(self).__name__}(["
    @others
    for i in range(s):
        m += str(&lt;int&gt;self.param_list[i])
        if i != s - 1:
            m += ", "
    m += "])"
    return m

</t>
<t tx="leo.20231205084806.21">cdef size_t i
</t>
<t tx="leo.20231205084806.22">cdef size_t s = self.param_list.size()
</t>
<t tx="leo.20231205084806.23"># A virtual work plane that present 3D entity or constraint.
cdef Entity _E_FREE_IN_3D = Entity.__new__(Entity)
</t>
<t tx="leo.20231205084806.24">_E_FREE_IN_3D.t = SLVS_E_WORKPLANE
_E_FREE_IN_3D.h = SLVS_FREE_IN_3D
_E_FREE_IN_3D.g = 0
_E_FREE_IN_3D.params = Params.create(NULL, 0)

</t>
<t tx="leo.20231205084806.25"># A "None" entity used to fill in constraint option.
cdef Entity _E_NONE = Entity.__new__(Entity)
</t>
<t tx="leo.20231205084806.26">_E_NONE.t = 0
_E_NONE.h = 0
_E_NONE.g = 0
_E_NONE.params = Params.create(NULL, 0)

# Entity names
_NAME_OF_ENTITIES = {
    SLVS_E_POINT_IN_3D: "point 3d",
    SLVS_E_POINT_IN_2D: "point 2d",
    SLVS_E_NORMAL_IN_2D: "normal 2d",
    SLVS_E_NORMAL_IN_3D: "normal 3d",
    SLVS_E_DISTANCE: "distance",
    SLVS_E_WORKPLANE: "work plane",
    SLVS_E_LINE_SEGMENT: "line segment",
    SLVS_E_CUBIC: "cubic",
    SLVS_E_CIRCLE: "circle",
    SLVS_E_ARC_OF_CIRCLE: "arc",
}

# Constraint names
_NAME_OF_CONSTRAINTS = {
    SLVS_C_POINTS_COINCIDENT: "points coincident",
    SLVS_C_PT_PT_DISTANCE: "point point distance",
    SLVS_C_PT_PLANE_DISTANCE: "point plane distance",
    SLVS_C_PT_LINE_DISTANCE: "point line distance",
    SLVS_C_PT_FACE_DISTANCE: "point face distance",
    SLVS_C_PT_IN_PLANE: "point in plane",
    SLVS_C_PT_ON_LINE: "point on line",
    SLVS_C_PT_ON_FACE: "point on face",
    SLVS_C_EQUAL_LENGTH_LINES: "equal length lines",
    SLVS_C_LENGTH_RATIO: "length ratio",
    SLVS_C_EQ_LEN_PT_LINE_D: "equal length point line distance",
    SLVS_C_EQ_PT_LN_DISTANCES: "equal point line distance",
    SLVS_C_EQUAL_ANGLE: "equal angle",
    SLVS_C_EQUAL_LINE_ARC_LEN: "equal line arc length",
    SLVS_C_SYMMETRIC: "symmetric",
    SLVS_C_SYMMETRIC_HORIZ: "symmetric horizontal",
    SLVS_C_SYMMETRIC_VERT: "symmetric vertical",
    SLVS_C_SYMMETRIC_LINE: "symmetric line",
    SLVS_C_AT_MIDPOINT: "at midpoint",
    SLVS_C_HORIZONTAL: "horizontal",
    SLVS_C_VERTICAL: "vertical",
    SLVS_C_DIAMETER: "diameter",
    SLVS_C_PT_ON_CIRCLE: "point on circle",
    SLVS_C_SAME_ORIENTATION: "same orientation",
    SLVS_C_ANGLE: "angle",
    SLVS_C_PARALLEL: "parallel",
    SLVS_C_PERPENDICULAR: "perpendicular",
    SLVS_C_ARC_LINE_TANGENT: "arc line tangent",
    SLVS_C_CUBIC_LINE_TANGENT: "cubic line tangent",
    SLVS_C_EQUAL_RADIUS: "equal radius",
    SLVS_C_PROJ_PT_DISTANCE: "project point distance",
    SLVS_C_WHERE_DRAGGED: "where dragged",
    SLVS_C_CURVE_CURVE_TANGENT: "curve curve tangent",
    SLVS_C_LENGTH_DIFFERENCE: "length difference",
}


</t>
<t tx="leo.20231205084806.27">cdef class Entity:

    """The handles of entities.

    This handle **should** be dropped after system removed.
    """

    FREE_IN_3D = _E_FREE_IN_3D
    NONE = _E_NONE

    @others
</t>
<t tx="leo.20231205084806.28">@staticmethod
cdef Entity create(Slvs_Entity *e):
    """Constructor."""
    @others
    if e.type == SLVS_E_DISTANCE:
        p_size = 1
    elif e.type == SLVS_E_POINT_IN_2D:
        p_size = 2
    elif e.type == SLVS_E_POINT_IN_3D:
        p_size = 3
    elif e.type == SLVS_E_NORMAL_IN_3D:
        p_size = 4
    else:
        p_size = 0
    entity.params = Params.create(e.param, p_size)
    return entity

</t>
<t tx="leo.20231205084806.29">cdef Entity entity = Entity.__new__(Entity)
</t>
<t tx="leo.20231205084806.3"></t>
<t tx="leo.20231205084806.30">with nogil:
    entity.t = e.type
    entity.h = e.h
    entity.wp = e.wrkpl
    entity.g = e.group
</t>
<t tx="leo.20231205084806.31">cdef size_t p_size
</t>
<t tx="leo.20231205084806.32">def __richcmp__(self, Entity other, int op) -&gt; bint:
    """Compare the entities."""
    if op == Py_EQ:
        return (
            self.t == other.t and
            self.h == other.h and
            self.wp == other.wp and
            self.g == other.g and
            self.params == other.params
        )
    elif op == Py_NE:
        return not (self == other)
    else:
        raise TypeError(
            f"'{op}' not support between instances of "
            f"{type(self)} and {type(other)}"
        )

</t>
<t tx="leo.20231205084806.33">cpdef bint is_3d(self):
    """Return True if this is a 3D entity."""
    return self.wp == SLVS_FREE_IN_3D

</t>
<t tx="leo.20231205084806.34">cpdef bint is_none(self):
    """Return True if this is a empty entity."""
    return self.h == 0

</t>
<t tx="leo.20231205084806.35">cpdef bint is_point_2d(self):
    """Return True if this is a 2D point."""
    return self.t == SLVS_E_POINT_IN_2D

</t>
<t tx="leo.20231205084806.36">cpdef bint is_point_3d(self):
    """Return True if this is a 3D point."""
    return self.t == SLVS_E_POINT_IN_3D

</t>
<t tx="leo.20231205084806.37">cpdef bint is_point(self):
    """Return True if this is a point."""
    return self.is_point_2d() or self.is_point_3d()

</t>
<t tx="leo.20231205084806.38">cpdef bint is_normal_2d(self):
    """Return True if this is a 2D normal."""
    return self.t == SLVS_E_NORMAL_IN_2D

</t>
<t tx="leo.20231205084806.39">cpdef bint is_normal_3d(self):
    """Return True if this is a 3D normal."""
    return self.t == SLVS_E_NORMAL_IN_3D

</t>
<t tx="leo.20231205084806.4">@path Y:/tmp/metapyslvs/solvespace/cython/python_solvespace/
# -*- coding: utf-8 -*-
# cython: language_level=3

"""Wrapper source code of Solvespace.

author: Yuan Chang
copyright: Copyright (C) 2016-2019
license: GPLv3+
email: pyslvs@gmail.com
"""

from cpython.object cimport Py_EQ, Py_NE
from enum import IntEnum, auto
from collections import Counter


@others
@language cython
@tabwidth -4
</t>
<t tx="leo.20231205084806.40">cpdef bint is_normal(self):
    """Return True if this is a normal."""
    return self.is_normal_2d() or self.is_normal_3d()

</t>
<t tx="leo.20231205084806.41">cpdef bint is_distance(self):
    """Return True if this is a distance."""
    return self.t == SLVS_E_DISTANCE

</t>
<t tx="leo.20231205084806.42">cpdef bint is_work_plane(self):
    """Return True if this is a work plane."""
    return self.t == SLVS_E_WORKPLANE

</t>
<t tx="leo.20231205084806.43">cpdef bint is_line_2d(self):
    """Return True if this is a 2D line."""
    return self.is_line() and not self.is_3d()

</t>
<t tx="leo.20231205084806.44">cpdef bint is_line_3d(self):
    """Return True if this is a 3D line."""
    return self.is_line() and self.is_3d()

</t>
<t tx="leo.20231205084806.45">cpdef bint is_line(self):
    """Return True if this is a line."""
    return self.t == SLVS_E_LINE_SEGMENT

</t>
<t tx="leo.20231205084806.46">cpdef bint is_cubic(self):
    """Return True if this is a cubic."""
    return self.t == SLVS_E_CUBIC

</t>
<t tx="leo.20231205084806.47">cpdef bint is_circle(self):
    """Return True if this is a circle."""
    return self.t == SLVS_E_CIRCLE

</t>
<t tx="leo.20231205084806.48">cpdef bint is_arc(self):
    """Return True if this is a arc."""
    return self.t == SLVS_E_ARC_OF_CIRCLE

</t>
<t tx="leo.20231205084806.49">def __repr__(self) -&gt; str:
    @others
    return (
        f"{type(self).__name__}"
        f"(handle={h}, group={g}, type=&lt;{t}&gt;, is_3d={self.is_3d()}, params={self.params})"
    )


</t>
<t tx="leo.20231205084806.5">def _create_sys(dof_v, g, param_list, entity_list, cons_list):
    @others
    s.dof_v = dof_v
    s.g = g
    s.param_list = param_list
    s.entity_list = entity_list
    s.cons_list = cons_list
    return s


</t>
<t tx="leo.20231205084806.50">cdef int h = &lt;int&gt;self.h
</t>
<t tx="leo.20231205084806.51">cdef int g = &lt;int&gt;self.g
</t>
<t tx="leo.20231205084806.52">cdef str t = _NAME_OF_ENTITIES[&lt;int&gt;self.t]
</t>
<t tx="leo.20231205084806.53">cdef class SolverSystem:

    """A solver system of Python-Solvespace.

    The operation of entities and constraints are using the methods of this class.
    """

    @others
</t>
<t tx="leo.20231205084806.54">def __cinit__(self):
    self.g = 0

</t>
<t tx="leo.20231205084806.55">def __reduce__(self):
    return (_create_sys, (self.dof_v, self.g, self.param_list, self.entity_list, self.cons_list))

</t>
<t tx="leo.20231205084806.56">def entity(self, int i) -&gt; Entity:
    """Generate entity handle, it can only be used with this system.

    Negative index is allowed.
    """
    if i &lt; 0:
        return Entity.create(&amp;self.entity_list[self.entity_list.size() + i])
    elif i &gt;= self.entity_list.size():
        raise IndexError(f"index {i} is out of bound {self.entity_list.size()}")
    else:
        return Entity.create(&amp;self.entity_list[i])

</t>
<t tx="leo.20231205084806.57">cpdef SolverSystem copy(self):
    """Copy the solver."""
    return _create_sys(self.dof_v, self.g, self.param_list, self.entity_list, self.cons_list)

</t>
<t tx="leo.20231205084806.58">cpdef void clear(self):
    """Clear the system."""
    self.dof_v = 0
    self.g = 0
    self.param_list.clear()
    self.entity_list.clear()
    self.cons_list.clear()
    self.failed_list.clear()

</t>
<t tx="leo.20231205084806.59">cpdef void set_group(self, size_t g):
    """Set the current group (`g`)."""
    self.g = g

</t>
<t tx="leo.20231205084806.6">cdef SolverSystem s = SolverSystem.__new__(SolverSystem)
</t>
<t tx="leo.20231205084806.60">cpdef int group(self):
    """Return the current group."""
    return self.g

</t>
<t tx="leo.20231205084806.61">cpdef void set_params(self, Params p, object params):
    """Set the parameters from a [Params] handle (`p`) belong to this system.
    The values is come from `params`, length must be equal to the handle.
    """
    params = list(params)
    if p.param_list.size() != len(params):
        raise ValueError(f"number of parameters {len(params)} are not match {p.param_list.size()}")

    @others
    for h in p.param_list:
        self.param_list[h - 1].val = params[i]
        i += 1

</t>
<t tx="leo.20231205084806.62">cdef int i = 0
</t>
<t tx="leo.20231205084806.63">cdef Slvs_hParam h
</t>
<t tx="leo.20231205084806.64">cpdef list params(self, Params p):
    """Get the parameters from a [Params] handle (`p`) belong to this
    system.
    The length of tuple is decided by handle.
    """
    param_list = []
    @others
    for h in p.param_list:
        param_list.append(self.param_list[h - 1].val)
    return param_list

</t>
<t tx="leo.20231205084806.65">cdef Slvs_hParam h
</t>
<t tx="leo.20231205084806.66">cpdef int dof(self):
    """Return the degrees of freedom of current group.
    Only can be called after solved.
    """
    return self.dof_v

</t>
<t tx="leo.20231205084806.67">cpdef object constraints(self):
    """Return the number of each constraint type.
    The name of constraints is represented by string.
    """
    cons_list = []
    @others
    for con in self.cons_list:
        cons_list.append(_NAME_OF_CONSTRAINTS[con.type])
    return Counter(cons_list)

</t>
<t tx="leo.20231205084806.68">cdef Slvs_Constraint con
</t>
<t tx="leo.20231205084806.69">cpdef list failures(self):
    """Return a list of failed constraint numbers."""
    return self.failed_list

</t>
<t tx="leo.20231205084806.7">cpdef tuple quaternion_u(double qw, double qx, double qy, double qz):
    """Input quaternion, return unit vector of U axis.

    Where `qw`, `qx`, `qy`, `qz` are corresponded to the W, X, Y, Z value of
    quaternion.
    """
    @others
    Slvs_QuaternionU(qw, qx, qy, qz, &amp;x, &amp;y, &amp;z)
    return x, y, z


</t>
<t tx="leo.20231205084806.70">cdef int solve_c(self) nogil:
    """Start the solving, return the result flag."""
    @others
    # Parameters
    sys.param = self.param_list.data()
    sys.params = self.param_list.size()
    # Entities
    sys.entity = self.entity_list.data()
    sys.entities = self.entity_list.size()
    # Constraints
    sys.constraint = self.cons_list.data()
    sys.constraints = self.cons_list.size()
    # Faileds
    self.failed_list = vector[Slvs_hConstraint](self.cons_list.size(), 0)
    sys.failed = self.failed_list.data()
    sys.faileds = self.failed_list.size()
    # Solve
    Slvs_Solve(&amp;sys, self.g)
    self.failed_list.resize(sys.faileds)
    self.dof_v = sys.dof
    return sys.result

</t>
<t tx="leo.20231205084806.71">cdef Slvs_System sys
</t>
<t tx="leo.20231205084806.72">def solve(self):
    return ResultFlag(self.solve_c())

</t>
<t tx="leo.20231205084806.73">cpdef size_t param_len(self):
    """The length of parameter list."""
    return self.param_list.size()

</t>
<t tx="leo.20231205084806.74">cpdef size_t entity_len(self):
    """The length of parameter list."""
    return self.entity_list.size()

</t>
<t tx="leo.20231205084806.75">cpdef size_t cons_len(self):
    """The length of parameter list."""
    return self.cons_list.size()

</t>
<t tx="leo.20231205084806.76">cpdef Entity create_2d_base(self):
    """Create a 2D system on current group,
    return the handle of work plane.
    """
    cdef double qw, qx, qy, qz
    qw, qx, qy, qz = make_quaternion(1, 0, 0, 0, 1, 0)
    cdef Entity nm = self.add_normal_3d(qw, qx, qy, qz)
    return self.add_work_plane(self.add_point_3d(0, 0, 0), nm)

</t>
<t tx="leo.20231205084806.77">cdef inline Slvs_hParam new_param(self, double val) nogil:
    """Add a parameter."""
    cdef Slvs_hParam h = &lt;Slvs_hParam&gt;self.param_list.size() + 1
    self.param_list.push_back(Slvs_MakeParam(h, self.g, val))
    return h

</t>
<t tx="leo.20231205084806.78">cdef inline Slvs_hEntity eh(self) nogil:
    """Return new entity handle."""
    return &lt;Slvs_hEntity&gt;self.entity_list.size() + 1

</t>
<t tx="leo.20231205084806.79">cpdef Entity add_point_2d(self, double u, double v, Entity wp):
    """Add a 2D point to specific work plane (`wp`) then return the handle.

    Where `u`, `v` are corresponded to the value of U, V axis on the work
    plane.
    """
    if wp is None or not wp.is_work_plane():
        raise TypeError(f"{wp} is not a work plane")

    @others
    self.entity_list.push_back(Slvs_MakePoint2d(self.eh(), self.g, wp.h, u_p, v_p))
    return Entity.create(&amp;self.entity_list.back())

</t>
<t tx="leo.20231205084806.8">cdef double x, y, z
</t>
<t tx="leo.20231205084806.80">cdef Slvs_hParam u_p = self.new_param(u)
</t>
<t tx="leo.20231205084806.81">cdef Slvs_hParam v_p = self.new_param(v)
</t>
<t tx="leo.20231205084806.82">cpdef Entity add_point_3d(self, double x, double y, double z):
    """Add a 3D point then return the handle.

    Where `x`, `y`, `z` are corresponded to the value of X, Y, Z axis.
    """
    @others
    self.entity_list.push_back(Slvs_MakePoint3d(self.eh(), self.g, x_p, y_p, z_p))
    return Entity.create(&amp;self.entity_list.back())

</t>
<t tx="leo.20231205084806.83">cdef Slvs_hParam x_p = self.new_param(x)
</t>
<t tx="leo.20231205084806.84">cdef Slvs_hParam y_p = self.new_param(y)
</t>
<t tx="leo.20231205084806.85">cdef Slvs_hParam z_p = self.new_param(z)
</t>
<t tx="leo.20231205084806.86">cpdef Entity add_normal_2d(self, Entity wp):
    """Add a 2D normal orthogonal to specific work plane (`wp`)
    then return the handle.
    """
    if wp is None or not wp.is_work_plane():
        raise TypeError(f"{wp} is not a work plane")

    self.entity_list.push_back(Slvs_MakeNormal2d(self.eh(), self.g, wp.h))
    return Entity.create(&amp;self.entity_list.back())

</t>
<t tx="leo.20231205084806.87">cpdef Entity add_normal_3d(self, double qw, double qx, double qy, double qz):
    """Add a 3D normal from quaternion then return the handle.

    Where `qw`, `qx`, `qy`, `qz` are corresponded to
    the W, X, Y, Z value of quaternion.
    """
    @others
    self.entity_list.push_back(Slvs_MakeNormal3d(
        self.eh(), self.g, w_p, x_p, y_p, z_p))
    return Entity.create(&amp;self.entity_list.back())

</t>
<t tx="leo.20231205084806.88">cdef Slvs_hParam w_p = self.new_param(qw)
</t>
<t tx="leo.20231205084806.89">cdef Slvs_hParam x_p = self.new_param(qx)
</t>
<t tx="leo.20231205084806.9">cpdef tuple quaternion_v(double qw, double qx, double qy, double qz):
    """Input quaternion, return unit vector of V axis.

    Signature is same as [quaternion_u](#quaternion_u).
    """
    @others
    Slvs_QuaternionV(qw, qx, qy, qz, &amp;x, &amp;y, &amp;z)
    return x, y, z


</t>
<t tx="leo.20231205084806.90">cdef Slvs_hParam y_p = self.new_param(qy)
</t>
<t tx="leo.20231205084806.91">cdef Slvs_hParam z_p = self.new_param(qz)
</t>
<t tx="leo.20231205084806.92">cpdef Entity add_distance(self, double d, Entity wp):
    """Add a distance to specific work plane (`wp`) then return the handle.

    Where `d` is distance value.
    """
    if wp is None or not wp.is_work_plane():
        raise TypeError(f"{wp} is not a work plane")

    @others
    self.entity_list.push_back(Slvs_MakeDistance(
        self.eh(), self.g, wp.h, d_p))
    return Entity.create(&amp;self.entity_list.back())

</t>
<t tx="leo.20231205084806.93">cdef Slvs_hParam d_p = self.new_param(d)
</t>
<t tx="leo.20231205084806.94">cpdef Entity add_line_2d(self, Entity p1, Entity p2, Entity wp):
    """Add a 2D line to specific work plane (`wp`) then return the handle.

    Where `p1` is the start point; `p2` is the end point.
    """
    if wp is None or not wp.is_work_plane():
        raise TypeError(f"{wp} is not a work plane")
    if p1 is None or not p1.is_point_2d():
        raise TypeError(f"{p1} is not a 2d point")
    if p2 is None or not p2.is_point_2d():
        raise TypeError(f"{p2} is not a 2d point")

    self.entity_list.push_back(Slvs_MakeLineSegment(
        self.eh(), self.g, wp.h, p1.h, p2.h))
    return Entity.create(&amp;self.entity_list.back())

</t>
<t tx="leo.20231205084806.95">cpdef Entity add_line_3d(self, Entity p1, Entity p2):
    """Add a 3D line then return the handle.

    Where `p1` is the start point; `p2` is the end point.
    """
    if p1 is None or not p1.is_point_3d():
        raise TypeError(f"{p1} is not a 3d point")
    if p2 is None or not p2.is_point_3d():
        raise TypeError(f"{p2} is not a 3d point")

    self.entity_list.push_back(Slvs_MakeLineSegment(
        self.eh(), self.g, SLVS_FREE_IN_3D, p1.h, p2.h))
    return Entity.create(&amp;self.entity_list.back())

</t>
<t tx="leo.20231205084806.96">cpdef Entity add_cubic(self, Entity p1, Entity p2, Entity p3, Entity p4, Entity wp):
    """Add a cubic curve to specific work plane (`wp`) then return the
    handle.

    Where `p1` to `p4` is the control points.
    """
    if wp is None or not wp.is_work_plane():
        raise TypeError(f"{wp} is not a work plane")
    if p1 is None or not p1.is_point_2d():
        raise TypeError(f"{p1} is not a 2d point")
    if p2 is None or not p2.is_point_2d():
        raise TypeError(f"{p2} is not a 2d point")
    if p3 is None or not p3.is_point_2d():
        raise TypeError(f"{p3} is not a 2d point")
    if p4 is None or not p4.is_point_2d():
        raise TypeError(f"{p4} is not a 2d point")

    self.entity_list.push_back(Slvs_MakeCubic(
        self.eh(), self.g, wp.h, p1.h, p2.h, p3.h, p4.h))
    return Entity.create(&amp;self.entity_list.back())

</t>
<t tx="leo.20231205084806.97">cpdef Entity add_arc(self, Entity nm, Entity ct, Entity start, Entity end, Entity wp):
    """Add an arc to specific work plane (`wp`) then return the handle.

    Where `nm` is the orthogonal normal; `ct` is the center point;
    `start` is the start point; `end` is the end point.
    """
    if wp is None or not wp.is_work_plane():
        raise TypeError(f"{wp} is not a work plane")
    if nm is None or not nm.is_normal_3d():
        raise TypeError(f"{nm} is not a 3d normal")
    if ct is None or not ct.is_point_2d():
        raise TypeError(f"{ct} is not a 2d point")
    if start is None or not start.is_point_2d():
        raise TypeError(f"{start} is not a 2d point")
    if end is None or not end.is_point_2d():
        raise TypeError(f"{end} is not a 2d point")
    self.entity_list.push_back(Slvs_MakeArcOfCircle(
        self.eh(), self.g, wp.h, nm.h, ct.h, start.h, end.h))
    return Entity.create(&amp;self.entity_list.back())

</t>
<t tx="leo.20231205084806.98">cpdef Entity add_circle(self, Entity nm, Entity ct, Entity radius, Entity wp):
    """Add an circle to specific work plane (`wp`) then return the handle.

    Where `nm` is the orthogonal normal;
    `ct` is the center point;
    `radius` is the distance value represent radius.
    """
    if wp is None or not wp.is_work_plane():
        raise TypeError(f"{wp} is not a work plane")
    if nm is None or not nm.is_normal_3d():
        raise TypeError(f"{nm} is not a 3d normal")
    if ct is None or not ct.is_point_2d():
        raise TypeError(f"{ct} is not a 2d point")
    if radius is None or not radius.is_distance():
        raise TypeError(f"{radius} is not a distance")

    self.entity_list.push_back(Slvs_MakeCircle(self.eh(), self.g, wp.h,
                                               ct.h, nm.h, radius.h))
    return Entity.create(&amp;self.entity_list.back())

</t>
<t tx="leo.20231205084806.99">cpdef Entity add_work_plane(self, Entity origin, Entity nm):
    """Add a work plane then return the handle.

    Where `origin` is the origin point of the plane;
    `nm` is the orthogonal normal.
    """
    if origin is None or origin.t != SLVS_E_POINT_IN_3D:
        raise TypeError(f"{origin} is not a 3d point")
    if nm is None or nm.t != SLVS_E_NORMAL_IN_3D:
        raise TypeError(f"{nm} is not a 3d normal")

    self.entity_list.push_back(Slvs_MakeWorkplane(self.eh(), self.g, origin.h, nm.h))
    return Entity.create(&amp;self.entity_list.back())

</t>
<t tx="leo.20231205091145.1">https://github.com/spyder-ide/qtpy

https://blog.csdn.net/weixin_42887343/article/details/123863894</t>
<t tx="leo.20231205092018.1">https://github.com/pyslvs/PMKS
https://designengrlab.github.io/PMKS/

PMKS plus: 
    https://app.pmksplus.com/
    https://digital.wpi.edu/concern/file_sets/5712m911h
    https://core.ac.uk/download/pdf/213005393.pdf

MotionGen: 
    https://motiongen.io/
    https://deshpandeshrinath.github.io/assets/papers/motiongen.pdf
</t>
<t tx="leo.20231205092846.1">MeKin2D:
    in https://www.freepascal.org/
    https://sourceforge.net/projects/mekin2d/
    https://www.researchgate.net/publication/304782762_MeKin2D_Suite_for_Planar_Mechanism_Kinematics</t>
</tnodes>
</leo_file>
